{
  "api/app/runner.html": {
    "href": "api/app/runner.html",
    "title": "Class app::Runner | qiotoolkit",
    "keywords": "Class app::Runner Inheritance app::Runner Constructors Runner() Declaration app::Runner::Runner() Runner() Declaration app::Runner::Runner(const Runner&)=delete Methods operator=() Declaration Runner&app::Runner::operator=(const Runner&)=delete ~Runner() Declaration virtual app::Runner::~Runner() set_output_benchmark() Declaration void app::Runner::set_output_benchmark(bool value) set_input_file() Declaration void app::Runner::set_input_file(std::string file_path) set_parameter_file() Declaration void app::Runner::set_parameter_file(std::string file_path) set_solver() Declaration virtual void app::Runner::set_solver(std::string target) get_target() Declaration std::string app::Runner::get_target() configure() Declaration void app::Runner::configure() configure() Configure the solver and model to run. This parses the string being passed as json and selects the solver and model according to the target and input_data.type attributes defined therein. In particular, it calls Solver::configure() and Model::configure() with a Json config, meaning that any work performed as part of reading the input arguments will happen here (this includes setting up the graph for GraphModels). Note Response.benchmark.end2end_runtime_ms in the benchmark output will reflect the time / spent in this function PLUS the time spent in Runner::run(). Declaration void app::Runner::configure(const std::string&json) run() Run the simulation. This calls Solver::init() followed by Solver::run(). Note Response.benchmark.execution_time_ms will reflect the time spent in this method (excluding Structure::to_string() converting the response to string, because that happens after the time measurement is written into the response) Declaration std::string app::Runner::run() get_run_output() Declaration utils::Structure app::Runner::get_run_output() get_solver() Declaration ::solver::Solver* app::Runner::get_solver() const copy_if_present() Declaration void app::Runner::copy_if_present(const std::string&key, const utils::Structure&src, utils::Structure&target) add_common_metrics() Declaration void app::Runner::add_common_metrics(utils::Structure&benchmarks, utils::Structure&metrics) configure() Configure using streaming. Declaration void app::Runner::configure(const std::string&input, const utils::Json&parameters, const std::string&solver_name) configure() Handle dimacs input for max-sat. Handling of parsed dimacs. Declaration void app::Runner::configure(const utils::Dimacs&dimacs, const utils::Json&parameters, const std::string&solver_name) select_max_sat_implementation() Select a suitable implementation (i.e., Counter_T size) for the max sat model. Declaration void app::Runner::select_max_sat_implementation(::model::MaxSat32 *maxsat, const utils::Json&params, const std::string&target) check_solver() Check that a solver has been created successfully. Otherwise, throw an exception indicating whether model selection or solver selection failed. Declaration void app::Runner::check_solver(const std::string&model_type, const std::string&selected_model, const std::string&target) metric_to_console() Declaration void app::Runner::metric_to_console(utils::Structure&metrics) memory_saving_enabled() Declaration bool app::Runner::memory_saving_enabled() const memory_saving_retry() Declaration bool app::Runner::memory_saving_retry() const reset_for_memory_saving() Declaration void app::Runner::reset_for_memory_saving() target_support_memory_saving() Declaration bool app::Runner::target_support_memory_saving() const model_support_memory_saving() Declaration bool app::Runner::model_support_memory_saving() const"
  },
  "api/archiver.html": {
    "href": "api/archiver.html",
    "title": "Class Archiver | qiotoolkit",
    "keywords": "Class Archiver Archiver concept. Archiver can be a reader or writer for serialization or deserialization respectively. class Archiver { public: / true if the archiver is in normal state. false if it has errors. operator bool() const; / Starts an object Archiver& StartObject(); / After calling StartObject(), assign a member with a name Archiver& Member(const char* name); / After calling StartObject(), check if a member presents bool HasMember(const char* name) const; / Ends an object Archiver& EndObject(); / Starts an array / size If Archiver::IsReader is true, the size of array is written. Archiver& StartArray(size_t* size = 0); / Ends an array Archiver& EndArray(); / Read/Write primitive types. Archiver& operator&(bool& b); Archiver& operator&(unsigned& u); Archiver& operator&(int& i); Archiver& operator&(double& d); Archiver& operator&(std::string& s); / Write primitive types. Archiver& SetNull(); ! Whether it is a reader. static const bool IsReader; ! Whether it is a writer. static const bool IsWriter; }; Inheritance Archiver"
  },
  "api/argp.html": {
    "href": "api/argp.html",
    "title": "Struct argp | qiotoolkit",
    "keywords": "Struct argp"
  },
  "api/argp/option.html": {
    "href": "api/argp/option.html",
    "title": "Struct argp_option | qiotoolkit",
    "keywords": "Struct argp_option"
  },
  "api/argp/state.html": {
    "href": "api/argp/state.html",
    "title": "Struct argp_state | qiotoolkit",
    "keywords": "Struct argp_state"
  },
  "api/ascii.html": {
    "href": "api/ascii.html",
    "title": "Struct ASCII | qiotoolkit",
    "keywords": "Struct ASCII ASCII encoding. http://en.wikipedia.org/wiki/ASCII CharType Code unit for storing 7-bit ASCII data. Default is char. implements Encoding concept Methods Encode() Declaration static void ASCII<CharType>::Encode(OutputStream&os, unsigned codepoint) EncodeUnsafe() Declaration static void ASCII<CharType>::EncodeUnsafe(OutputStream&os, unsigned codepoint) Decode() Declaration static bool ASCII<CharType>::Decode(InputStream&is, unsigned *codepoint) Validate() Declaration static bool ASCII<CharType>::Validate(InputStream&is, OutputStream&os) TakeBOM() Declaration static CharType ASCII<CharType>::TakeBOM(InputByteStream&is) Take() Declaration static Ch ASCII<CharType>::Take(InputByteStream&is) PutBOM() Declaration static void ASCII<CharType>::PutBOM(OutputByteStream&os) Put() Declaration static void ASCII<CharType>::Put(OutputByteStream&os, Ch c)"
  },
  "api/auto-utf.html": {
    "href": "api/auto-utf.html",
    "title": "Struct AutoUTF | qiotoolkit",
    "keywords": "Struct AutoUTF Dynamically select encoding according to stream's runtime-specified UTF encoding type. This class can be used with AutoUTFInputtStream and AutoUTFOutputStream, which provides GetType(). Methods Encode() Declaration static RAPIDJSON_FORCEINLINE void AutoUTF<CharType>::Encode(OutputStream&os, unsigned codepoint) EncodeUnsafe() Declaration static RAPIDJSON_FORCEINLINE void AutoUTF<CharType>::EncodeUnsafe(OutputStream&os, unsigned codepoint) Decode() Declaration static RAPIDJSON_FORCEINLINE bool AutoUTF<CharType>::Decode(InputStream&is, unsigned *codepoint) Validate() Declaration static RAPIDJSON_FORCEINLINE bool AutoUTF<CharType>::Validate(InputStream&is, OutputStream&os)"
  },
  "api/auto-utfinput-stream.html": {
    "href": "api/auto-utfinput-stream.html",
    "title": "Class AutoUTFInputStream | qiotoolkit",
    "keywords": "Class AutoUTFInputStream Input stream wrapper with dynamically bound encoding and automatic encoding detection. CharType Type of character for reading. InputByteStream type of input byte stream to be wrapped. Inheritance AutoUTFInputStream Constructors AutoUTFInputStream() Declaration AutoUTFInputStream<CharType, InputByteStream>::AutoUTFInputStream(const AutoUTFInputStream&) AutoUTFInputStream() Constructor. is input stream to be wrapped. type UTF encoding type if it is not detected from the stream. Declaration AutoUTFInputStream<CharType, InputByteStream>::AutoUTFInputStream(InputByteStream&is, UTFType type=kUTF8) Methods RAPIDJSON_STATIC_ASSERT() Declaration AutoUTFInputStream<CharType, InputByteStream>::RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch)==1) operator=() Declaration AutoUTFInputStream&AutoUTFInputStream<CharType, InputByteStream>::operator=(const AutoUTFInputStream&) DetectType() Declaration void AutoUTFInputStream<CharType, InputByteStream>::DetectType() GetType() Declaration UTFType AutoUTFInputStream<CharType, InputByteStream>::GetType() const HasBOM() Declaration bool AutoUTFInputStream<CharType, InputByteStream>::HasBOM() const Peek() Declaration Ch AutoUTFInputStream<CharType, InputByteStream>::Peek() const Take() Declaration Ch AutoUTFInputStream<CharType, InputByteStream>::Take() Tell() Declaration size_t AutoUTFInputStream<CharType, InputByteStream>::Tell() const Put() Declaration void AutoUTFInputStream<CharType, InputByteStream>::Put(Ch) Flush() Declaration void AutoUTFInputStream<CharType, InputByteStream>::Flush() PutBegin() Declaration Ch* AutoUTFInputStream<CharType, InputByteStream>::PutBegin() PutEnd() Declaration size_t AutoUTFInputStream<CharType, InputByteStream>::PutEnd(Ch *)"
  },
  "api/auto-utfoutput-stream.html": {
    "href": "api/auto-utfoutput-stream.html",
    "title": "Class AutoUTFOutputStream | qiotoolkit",
    "keywords": "Class AutoUTFOutputStream Output stream wrapper with dynamically bound encoding and automatic encoding detection. CharType Type of character for writing. OutputByteStream type of output byte stream to be wrapped. Inheritance AutoUTFOutputStream Constructors AutoUTFOutputStream() Declaration AutoUTFOutputStream<CharType, OutputByteStream>::AutoUTFOutputStream(const AutoUTFOutputStream&) AutoUTFOutputStream() Constructor. os output stream to be wrapped. type UTF encoding type. putBOM Whether to write BOM at the beginning of the stream. Declaration AutoUTFOutputStream<CharType, OutputByteStream>::AutoUTFOutputStream(OutputByteStream&os, UTFType type, bool putBOM) Methods RAPIDJSON_STATIC_ASSERT() Declaration AutoUTFOutputStream<CharType, OutputByteStream>::RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch)==1) operator=() Declaration AutoUTFOutputStream&AutoUTFOutputStream<CharType, OutputByteStream>::operator=(const AutoUTFOutputStream&) PutBOM() Declaration void AutoUTFOutputStream<CharType, OutputByteStream>::PutBOM() GetType() Declaration UTFType AutoUTFOutputStream<CharType, OutputByteStream>::GetType() const Put() Declaration void AutoUTFOutputStream<CharType, OutputByteStream>::Put(Ch c) Flush() Declaration void AutoUTFOutputStream<CharType, OutputByteStream>::Flush() Peek() Declaration Ch AutoUTFOutputStream<CharType, OutputByteStream>::Peek() const Take() Declaration Ch AutoUTFOutputStream<CharType, OutputByteStream>::Take() Tell() Declaration size_t AutoUTFOutputStream<CharType, OutputByteStream>::Tell() const PutBegin() Declaration Ch* AutoUTFOutputStream<CharType, OutputByteStream>::PutBegin() PutEnd() Declaration size_t AutoUTFOutputStream<CharType, OutputByteStream>::PutEnd(Ch *)"
  },
  "api/base-reader-handler.html": {
    "href": "api/base-reader-handler.html",
    "title": "Struct BaseReaderHandler | qiotoolkit",
    "keywords": "Struct BaseReaderHandler Default implementation of Handler. This can be used as base class of any reader handler. implements Handler concept Methods Default() Declaration bool BaseReaderHandler<Encoding, Derived>::Default() Null() Declaration bool BaseReaderHandler<Encoding, Derived>::Null() Bool() Declaration bool BaseReaderHandler<Encoding, Derived>::Bool(bool) Int() Declaration bool BaseReaderHandler<Encoding, Derived>::Int(int) Uint() Declaration bool BaseReaderHandler<Encoding, Derived>::Uint(unsigned) Int64() Declaration bool BaseReaderHandler<Encoding, Derived>::Int64(int64_t) Uint64() Declaration bool BaseReaderHandler<Encoding, Derived>::Uint64(uint64_t) Double() Declaration bool BaseReaderHandler<Encoding, Derived>::Double(double) RawNumber() enabled via kParseNumbersAsStringsFlag, string is not null-terminated (use length) Declaration bool BaseReaderHandler<Encoding, Derived>::RawNumber(const Ch *str, SizeType len, bool copy) String() Declaration bool BaseReaderHandler<Encoding, Derived>::String(const Ch *, SizeType, bool) StartObject() Declaration bool BaseReaderHandler<Encoding, Derived>::StartObject() Key() Declaration bool BaseReaderHandler<Encoding, Derived>::Key(const Ch *str, SizeType len, bool copy) EndObject() Declaration bool BaseReaderHandler<Encoding, Derived>::EndObject(SizeType) StartArray() Declaration bool BaseReaderHandler<Encoding, Derived>::StartArray() EndArray() Declaration bool BaseReaderHandler<Encoding, Derived>::EndArray(SizeType)"
  },
  "api/basic-istream-wrapper.html": {
    "href": "api/basic-istream-wrapper.html",
    "title": "Class BasicIStreamWrapper | qiotoolkit",
    "keywords": "Class BasicIStreamWrapper Wrapper of std::basic_istream into RapidJSON's Stream concept. The classes can be wrapped including but not limited to: std::istringstream std::stringstream std::wistringstream std::wstringstream std::ifstream std::fstream std::wifstream std::wfstream StreamType Class derived from std::basic_istream. Inheritance BasicIStreamWrapper Constructors BasicIStreamWrapper() Constructor. stream stream opened for read. Declaration BasicIStreamWrapper<StreamType>::BasicIStreamWrapper(StreamType&stream) BasicIStreamWrapper() Constructor. stream stream opened for read. buffer user-supplied buffer. bufferSize size of buffer in bytes. Must >=4 bytes. Declaration BasicIStreamWrapper<StreamType>::BasicIStreamWrapper(StreamType&stream, char *buffer, size_t bufferSize) BasicIStreamWrapper() Declaration BasicIStreamWrapper<StreamType>::BasicIStreamWrapper() BasicIStreamWrapper() Declaration BasicIStreamWrapper<StreamType>::BasicIStreamWrapper(const BasicIStreamWrapper&) Methods Peek() Declaration Ch BasicIStreamWrapper<StreamType>::Peek() const Take() Declaration Ch BasicIStreamWrapper<StreamType>::Take() Tell() Declaration size_t BasicIStreamWrapper<StreamType>::Tell() const Put() Declaration void BasicIStreamWrapper<StreamType>::Put(Ch) Flush() Declaration void BasicIStreamWrapper<StreamType>::Flush() PutBegin() Declaration Ch* BasicIStreamWrapper<StreamType>::PutBegin() PutEnd() Declaration size_t BasicIStreamWrapper<StreamType>::PutEnd(Ch *) Peek4() Declaration const Ch* BasicIStreamWrapper<StreamType>::Peek4() const operator=() Declaration BasicIStreamWrapper&BasicIStreamWrapper<StreamType>::operator=(const BasicIStreamWrapper&) Read() Declaration void BasicIStreamWrapper<StreamType>::Read()"
  },
  "api/basic-ostream-wrapper.html": {
    "href": "api/basic-ostream-wrapper.html",
    "title": "Class BasicOStreamWrapper | qiotoolkit",
    "keywords": "Class BasicOStreamWrapper Wrapper of std::basic_ostream into RapidJSON's Stream concept. The classes can be wrapped including but not limited to: std::ostringstream std::stringstream std::wpstringstream std::wstringstream std::ifstream std::fstream std::wofstream std::wfstream StreamType Class derived from std::basic_ostream. Inheritance BasicOStreamWrapper Constructors BasicOStreamWrapper() Declaration BasicOStreamWrapper<StreamType>::BasicOStreamWrapper(StreamType&stream) BasicOStreamWrapper() Declaration BasicOStreamWrapper<StreamType>::BasicOStreamWrapper(const BasicOStreamWrapper&) Methods Put() Declaration void BasicOStreamWrapper<StreamType>::Put(Ch c) Flush() Declaration void BasicOStreamWrapper<StreamType>::Flush() Peek() Declaration char BasicOStreamWrapper<StreamType>::Peek() const Take() Declaration char BasicOStreamWrapper<StreamType>::Take() Tell() Declaration size_t BasicOStreamWrapper<StreamType>::Tell() const PutBegin() Declaration char* BasicOStreamWrapper<StreamType>::PutBegin() PutEnd() Declaration size_t BasicOStreamWrapper<StreamType>::PutEnd(char *) operator=() Declaration BasicOStreamWrapper&BasicOStreamWrapper<StreamType>::operator=(const BasicOStreamWrapper&)"
  },
  "api/boost/uniform/real.html": {
    "href": "api/boost/uniform/real.html",
    "title": "Class boost::uniform_real | qiotoolkit",
    "keywords": "Class boost::uniform_real Inheritance boost::uniform_real"
  },
  "api/box.html": {
    "href": "api/box.html",
    "title": "Class Box | qiotoolkit",
    "keywords": "Class Box Inheritance Shape Box Inherited Members Shape ~Shape Shape Constructors Box() Declaration Box::Box() Box() Declaration Box::Box(double x, double y, double width, double height) Methods ~Box() Declaration Box::~Box() GetType() Declaration const char* Box::GetType() const Print() Declaration void Box::Print(std::ostream&os) const"
  },
  "api/canvas.html": {
    "href": "api/canvas.html",
    "title": "Class Canvas | qiotoolkit",
    "keywords": "Class Canvas Inheritance Canvas Constructors Canvas() Declaration Canvas::Canvas() Methods ~Canvas() Declaration Canvas::~Canvas() Clear() Declaration void Canvas::Clear() AddShape() Declaration void Canvas::AddShape(Shape *shape) Print() Declaration void Canvas::Print(std::ostream&os)"
  },
  "api/capitalize-filter.html": {
    "href": "api/capitalize-filter.html",
    "title": "Struct CapitalizeFilter | qiotoolkit",
    "keywords": "Struct CapitalizeFilter Constructors CapitalizeFilter() Declaration CapitalizeFilter<OutputHandler>::CapitalizeFilter(OutputHandler&out) CapitalizeFilter() Declaration CapitalizeFilter<OutputHandler>::CapitalizeFilter(const CapitalizeFilter&) Methods Null() Declaration bool CapitalizeFilter<OutputHandler>::Null() Bool() Declaration bool CapitalizeFilter<OutputHandler>::Bool(bool b) Int() Declaration bool CapitalizeFilter<OutputHandler>::Int(int i) Uint() Declaration bool CapitalizeFilter<OutputHandler>::Uint(unsigned u) Int64() Declaration bool CapitalizeFilter<OutputHandler>::Int64(int64_t i) Uint64() Declaration bool CapitalizeFilter<OutputHandler>::Uint64(uint64_t u) Double() Declaration bool CapitalizeFilter<OutputHandler>::Double(double d) RawNumber() Declaration bool CapitalizeFilter<OutputHandler>::RawNumber(const char *str, SizeType length, bool copy) String() Declaration bool CapitalizeFilter<OutputHandler>::String(const char *str, SizeType length, bool) StartObject() Declaration bool CapitalizeFilter<OutputHandler>::StartObject() Key() Declaration bool CapitalizeFilter<OutputHandler>::Key(const char *str, SizeType length, bool copy) EndObject() Declaration bool CapitalizeFilter<OutputHandler>::EndObject(SizeType memberCount) StartArray() Declaration bool CapitalizeFilter<OutputHandler>::StartArray() EndArray() Declaration bool CapitalizeFilter<OutputHandler>::EndArray(SizeType elementCount) operator=() Declaration CapitalizeFilter&CapitalizeFilter<OutputHandler>::operator=(const CapitalizeFilter&)"
  },
  "api/circle.html": {
    "href": "api/circle.html",
    "title": "Class Circle | qiotoolkit",
    "keywords": "Class Circle Inheritance Shape Circle Inherited Members Shape ~Shape Shape Constructors Circle() Declaration Circle::Circle() Circle() Declaration Circle::Circle(double x, double y, double radius) Methods ~Circle() Declaration Circle::~Circle() GetType() Declaration const char* Circle::GetType() const Print() Declaration void Circle::Print(std::ostream&os) const"
  },
  "api/config.html": {
    "href": "api/config.html",
    "title": "Struct Config | qiotoolkit",
    "keywords": "Struct Config"
  },
  "api/counter.html": {
    "href": "api/counter.html",
    "title": "Class Counter | qiotoolkit",
    "keywords": "Class Counter Inheritance Counter Constructors Counter() Declaration Counter::Counter() Counter() Declaration Counter::Counter() Methods Increment() Declaration int Counter::Increment() Decrement() Declaration int Counter::Decrement() Print() Declaration void Counter::Print() const Increment() Declaration int Counter::Increment() Print() Declaration void Counter::Print() const"
  },
  "api/cpp/ast/ast-builder.html": {
    "href": "api/cpp/ast/ast-builder.html",
    "title": "Class cpp::ast::AstBuilder | qiotoolkit",
    "keywords": "Class cpp::ast::AstBuilder Inheritance cpp::ast::AstBuilder Methods __init__() Declaration def cpp.ast.AstBuilder.__init__(self, token_stream, filename, in_class='', visibility=None, namespace_stack=[]) HandleError() Declaration def cpp.ast.AstBuilder.HandleError(self, msg, token) Generate() Declaration def cpp.ast.AstBuilder.Generate(self) GetScope() Declaration def cpp.ast.AstBuilder.GetScope(self) GetName() Returns ([tokens], next_token_info). Declaration def cpp.ast.AstBuilder.GetName(self, seq=None) GetMethod() Declaration def cpp.ast.AstBuilder.GetMethod(self, modifiers, templated_types) handle_bool() Declaration def cpp.ast.AstBuilder.handle_bool(self) handle_char() Declaration def cpp.ast.AstBuilder.handle_char(self) handle_int() Declaration def cpp.ast.AstBuilder.handle_int(self) handle_long() Declaration def cpp.ast.AstBuilder.handle_long(self) handle_short() Declaration def cpp.ast.AstBuilder.handle_short(self) handle_double() Declaration def cpp.ast.AstBuilder.handle_double(self) handle_float() Declaration def cpp.ast.AstBuilder.handle_float(self) handle_void() Declaration def cpp.ast.AstBuilder.handle_void(self) handle_wchar_t() Declaration def cpp.ast.AstBuilder.handle_wchar_t(self) handle_unsigned() Declaration def cpp.ast.AstBuilder.handle_unsigned(self) handle_signed() Declaration def cpp.ast.AstBuilder.handle_signed(self) handle_struct() Declaration def cpp.ast.AstBuilder.handle_struct(self) handle_union() Declaration def cpp.ast.AstBuilder.handle_union(self) handle_enum() Declaration def cpp.ast.AstBuilder.handle_enum(self) handle_auto() Declaration def cpp.ast.AstBuilder.handle_auto(self) handle_register() Declaration def cpp.ast.AstBuilder.handle_register(self) handle_const() Declaration def cpp.ast.AstBuilder.handle_const(self) handle_inline() Declaration def cpp.ast.AstBuilder.handle_inline(self) handle_extern() Declaration def cpp.ast.AstBuilder.handle_extern(self) handle_static() Declaration def cpp.ast.AstBuilder.handle_static(self) handle_virtual() Declaration def cpp.ast.AstBuilder.handle_virtual(self) handle_volatile() Declaration def cpp.ast.AstBuilder.handle_volatile(self) handle_mutable() Declaration def cpp.ast.AstBuilder.handle_mutable(self) handle_public() Declaration def cpp.ast.AstBuilder.handle_public(self) handle_protected() Declaration def cpp.ast.AstBuilder.handle_protected(self) handle_private() Declaration def cpp.ast.AstBuilder.handle_private(self) handle_friend() Declaration def cpp.ast.AstBuilder.handle_friend(self) handle_static_cast() Declaration def cpp.ast.AstBuilder.handle_static_cast(self) handle_const_cast() Declaration def cpp.ast.AstBuilder.handle_const_cast(self) handle_dynamic_cast() Declaration def cpp.ast.AstBuilder.handle_dynamic_cast(self) handle_reinterpret_cast() Declaration def cpp.ast.AstBuilder.handle_reinterpret_cast(self) handle_new() Declaration def cpp.ast.AstBuilder.handle_new(self) handle_delete() Declaration def cpp.ast.AstBuilder.handle_delete(self) handle_typedef() Declaration def cpp.ast.AstBuilder.handle_typedef(self) handle_typeid() Declaration def cpp.ast.AstBuilder.handle_typeid(self) handle_typename() Declaration def cpp.ast.AstBuilder.handle_typename(self) handle_template() Declaration def cpp.ast.AstBuilder.handle_template(self) handle_true() Declaration def cpp.ast.AstBuilder.handle_true(self) handle_false() Declaration def cpp.ast.AstBuilder.handle_false(self) handle_asm() Declaration def cpp.ast.AstBuilder.handle_asm(self) handle_class() Declaration def cpp.ast.AstBuilder.handle_class(self) handle_namespace() Declaration def cpp.ast.AstBuilder.handle_namespace(self) handle_using() Declaration def cpp.ast.AstBuilder.handle_using(self) handle_explicit() Declaration def cpp.ast.AstBuilder.handle_explicit(self) handle_this() Declaration def cpp.ast.AstBuilder.handle_this(self) handle_operator() Declaration def cpp.ast.AstBuilder.handle_operator(self) handle_sizeof() Declaration def cpp.ast.AstBuilder.handle_sizeof(self) handle_case() Declaration def cpp.ast.AstBuilder.handle_case(self) handle_switch() Declaration def cpp.ast.AstBuilder.handle_switch(self) handle_default() Declaration def cpp.ast.AstBuilder.handle_default(self) handle_if() Declaration def cpp.ast.AstBuilder.handle_if(self) handle_else() Declaration def cpp.ast.AstBuilder.handle_else(self) handle_return() Declaration def cpp.ast.AstBuilder.handle_return(self) handle_goto() Declaration def cpp.ast.AstBuilder.handle_goto(self) handle_try() Declaration def cpp.ast.AstBuilder.handle_try(self) handle_catch() Declaration def cpp.ast.AstBuilder.handle_catch(self) handle_throw() Declaration def cpp.ast.AstBuilder.handle_throw(self) handle_while() Declaration def cpp.ast.AstBuilder.handle_while(self) handle_do() Declaration def cpp.ast.AstBuilder.handle_do(self) handle_for() Declaration def cpp.ast.AstBuilder.handle_for(self) handle_break() Declaration def cpp.ast.AstBuilder.handle_break(self) handle_continue() Declaration def cpp.ast.AstBuilder.handle_continue(self) __init__() Declaration def cpp.ast.AstBuilder.__init__(self, token_stream, filename, in_class='', visibility=None, namespace_stack=[]) HandleError() Declaration def cpp.ast.AstBuilder.HandleError(self, msg, token) Generate() Declaration def cpp.ast.AstBuilder.Generate(self) GetScope() Declaration def cpp.ast.AstBuilder.GetScope(self) GetName() Returns ([tokens], next_token_info). Declaration def cpp.ast.AstBuilder.GetName(self, seq=None) GetMethod() Declaration def cpp.ast.AstBuilder.GetMethod(self, modifiers, templated_types) handle_bool() Declaration def cpp.ast.AstBuilder.handle_bool(self) handle_char() Declaration def cpp.ast.AstBuilder.handle_char(self) handle_int() Declaration def cpp.ast.AstBuilder.handle_int(self) handle_long() Declaration def cpp.ast.AstBuilder.handle_long(self) handle_short() Declaration def cpp.ast.AstBuilder.handle_short(self) handle_double() Declaration def cpp.ast.AstBuilder.handle_double(self) handle_float() Declaration def cpp.ast.AstBuilder.handle_float(self) handle_void() Declaration def cpp.ast.AstBuilder.handle_void(self) handle_wchar_t() Declaration def cpp.ast.AstBuilder.handle_wchar_t(self) handle_unsigned() Declaration def cpp.ast.AstBuilder.handle_unsigned(self) handle_signed() Declaration def cpp.ast.AstBuilder.handle_signed(self) handle_struct() Declaration def cpp.ast.AstBuilder.handle_struct(self) handle_union() Declaration def cpp.ast.AstBuilder.handle_union(self) handle_enum() Declaration def cpp.ast.AstBuilder.handle_enum(self) handle_auto() Declaration def cpp.ast.AstBuilder.handle_auto(self) handle_register() Declaration def cpp.ast.AstBuilder.handle_register(self) handle_const() Declaration def cpp.ast.AstBuilder.handle_const(self) handle_inline() Declaration def cpp.ast.AstBuilder.handle_inline(self) handle_extern() Declaration def cpp.ast.AstBuilder.handle_extern(self) handle_static() Declaration def cpp.ast.AstBuilder.handle_static(self) handle_virtual() Declaration def cpp.ast.AstBuilder.handle_virtual(self) handle_volatile() Declaration def cpp.ast.AstBuilder.handle_volatile(self) handle_mutable() Declaration def cpp.ast.AstBuilder.handle_mutable(self) handle_public() Declaration def cpp.ast.AstBuilder.handle_public(self) handle_protected() Declaration def cpp.ast.AstBuilder.handle_protected(self) handle_private() Declaration def cpp.ast.AstBuilder.handle_private(self) handle_friend() Declaration def cpp.ast.AstBuilder.handle_friend(self) handle_static_cast() Declaration def cpp.ast.AstBuilder.handle_static_cast(self) handle_const_cast() Declaration def cpp.ast.AstBuilder.handle_const_cast(self) handle_dynamic_cast() Declaration def cpp.ast.AstBuilder.handle_dynamic_cast(self) handle_reinterpret_cast() Declaration def cpp.ast.AstBuilder.handle_reinterpret_cast(self) handle_new() Declaration def cpp.ast.AstBuilder.handle_new(self) handle_delete() Declaration def cpp.ast.AstBuilder.handle_delete(self) handle_typedef() Declaration def cpp.ast.AstBuilder.handle_typedef(self) handle_typeid() Declaration def cpp.ast.AstBuilder.handle_typeid(self) handle_typename() Declaration def cpp.ast.AstBuilder.handle_typename(self) handle_template() Declaration def cpp.ast.AstBuilder.handle_template(self) handle_true() Declaration def cpp.ast.AstBuilder.handle_true(self) handle_false() Declaration def cpp.ast.AstBuilder.handle_false(self) handle_asm() Declaration def cpp.ast.AstBuilder.handle_asm(self) handle_class() Declaration def cpp.ast.AstBuilder.handle_class(self) handle_namespace() Declaration def cpp.ast.AstBuilder.handle_namespace(self) handle_using() Declaration def cpp.ast.AstBuilder.handle_using(self) handle_explicit() Declaration def cpp.ast.AstBuilder.handle_explicit(self) handle_this() Declaration def cpp.ast.AstBuilder.handle_this(self) handle_operator() Declaration def cpp.ast.AstBuilder.handle_operator(self) handle_sizeof() Declaration def cpp.ast.AstBuilder.handle_sizeof(self) handle_case() Declaration def cpp.ast.AstBuilder.handle_case(self) handle_switch() Declaration def cpp.ast.AstBuilder.handle_switch(self) handle_default() Declaration def cpp.ast.AstBuilder.handle_default(self) handle_if() Declaration def cpp.ast.AstBuilder.handle_if(self) handle_else() Declaration def cpp.ast.AstBuilder.handle_else(self) handle_return() Declaration def cpp.ast.AstBuilder.handle_return(self) handle_goto() Declaration def cpp.ast.AstBuilder.handle_goto(self) handle_try() Declaration def cpp.ast.AstBuilder.handle_try(self) handle_catch() Declaration def cpp.ast.AstBuilder.handle_catch(self) handle_throw() Declaration def cpp.ast.AstBuilder.handle_throw(self) handle_while() Declaration def cpp.ast.AstBuilder.handle_while(self) handle_do() Declaration def cpp.ast.AstBuilder.handle_do(self) handle_for() Declaration def cpp.ast.AstBuilder.handle_for(self) handle_break() Declaration def cpp.ast.AstBuilder.handle_break(self) handle_continue() Declaration def cpp.ast.AstBuilder.handle_continue(self) _CreateVariable() Declaration def cpp.ast.AstBuilder._CreateVariable(self, pos_token, name, type_name, type_modifiers, ref_pointer_name_seq, templated_types, value=None) _GenerateOne() Declaration def cpp.ast.AstBuilder._GenerateOne(self, token) _GetTokensUpTo() Declaration def cpp.ast.AstBuilder._GetTokensUpTo(self, expected_token_type, expected_token) _GetVarTokensUpTo() Declaration def cpp.ast.AstBuilder._GetVarTokensUpTo(self, expected_token_type, *expected_tokens) _IgnoreUpTo() Declaration def cpp.ast.AstBuilder._IgnoreUpTo(self, token_type, token) _SkipIf0Blocks() Declaration def cpp.ast.AstBuilder._SkipIf0Blocks(self) _GetMatchingChar() Declaration def cpp.ast.AstBuilder._GetMatchingChar(self, open_paren, close_paren, GetNextToken=None) _GetParameters() Declaration def cpp.ast.AstBuilder._GetParameters(self) _GetNextToken() Declaration def cpp.ast.AstBuilder._GetNextToken(self) _AddBackToken() Declaration def cpp.ast.AstBuilder._AddBackToken(self, token) _AddBackTokens() Declaration def cpp.ast.AstBuilder._AddBackTokens(self, tokens) _GetMethod() Declaration def cpp.ast.AstBuilder._GetMethod(self, return_type_and_name, modifiers, templated_types, get_paren) _GetReturnTypeAndClassName() Declaration def cpp.ast.AstBuilder._GetReturnTypeAndClassName(self, token_seq) _GetNestedType() Declaration def cpp.ast.AstBuilder._GetNestedType(self, ctor) _GetTemplatedTypes() Declaration def cpp.ast.AstBuilder._GetTemplatedTypes(self) _GetBases() Declaration def cpp.ast.AstBuilder._GetBases(self) _GetClass() Declaration def cpp.ast.AstBuilder._GetClass(self, class_type, visibility, templated_types) _CreateVariable() Declaration def cpp.ast.AstBuilder._CreateVariable(self, pos_token, name, type_name, type_modifiers, ref_pointer_name_seq, templated_types, value=None) _GenerateOne() Declaration def cpp.ast.AstBuilder._GenerateOne(self, token) _GetTokensUpTo() Declaration def cpp.ast.AstBuilder._GetTokensUpTo(self, expected_token_type, expected_token) _GetVarTokensUpTo() Declaration def cpp.ast.AstBuilder._GetVarTokensUpTo(self, expected_token_type, *expected_tokens) _IgnoreUpTo() Declaration def cpp.ast.AstBuilder._IgnoreUpTo(self, token_type, token) _SkipIf0Blocks() Declaration def cpp.ast.AstBuilder._SkipIf0Blocks(self) _GetMatchingChar() Declaration def cpp.ast.AstBuilder._GetMatchingChar(self, open_paren, close_paren, GetNextToken=None) _GetParameters() Declaration def cpp.ast.AstBuilder._GetParameters(self) _GetNextToken() Declaration def cpp.ast.AstBuilder._GetNextToken(self) _AddBackToken() Declaration def cpp.ast.AstBuilder._AddBackToken(self, token) _AddBackTokens() Declaration def cpp.ast.AstBuilder._AddBackTokens(self, tokens) _GetMethod() Declaration def cpp.ast.AstBuilder._GetMethod(self, return_type_and_name, modifiers, templated_types, get_paren) _GetReturnTypeAndClassName() Declaration def cpp.ast.AstBuilder._GetReturnTypeAndClassName(self, token_seq) _GetNestedType() Declaration def cpp.ast.AstBuilder._GetNestedType(self, ctor) _GetTemplatedTypes() Declaration def cpp.ast.AstBuilder._GetTemplatedTypes(self) _GetBases() Declaration def cpp.ast.AstBuilder._GetBases(self) _GetClass() Declaration def cpp.ast.AstBuilder._GetClass(self, class_type, visibility, templated_types)"
  },
  "api/cpp/ast/class.html": {
    "href": "api/cpp/ast/class.html",
    "title": "Class cpp::ast::Class | qiotoolkit",
    "keywords": "Class cpp::ast::Class Inheritance cpp::ast::_GenericDeclaration cpp::ast::Class cpp::ast::Struct Inherited Members __init__ XXX__str__ __repr__ FullName __init__ Methods __init__() Declaration def cpp.ast.Class.__init__(self, start, end, name, bases, templated_types, body, namespace) IsDeclaration() Returns bool if this node is a declaration. Declaration def cpp.ast.Class.IsDeclaration(self) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast.Class.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast.Class.IsExportable(self) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Class.Requires(self, node) __str__() Declaration def cpp.ast.Class.__str__(self) __init__() Declaration def cpp.ast.Class.__init__(self, start, end, name, bases, templated_types, body, namespace) IsDeclaration() Returns bool if this node is a declaration. Declaration def cpp.ast.Class.IsDeclaration(self) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast.Class.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast.Class.IsExportable(self) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Class.Requires(self, node) __str__() Declaration def cpp.ast.Class.__str__(self)"
  },
  "api/cpp/ast/define.html": {
    "href": "api/cpp/ast/define.html",
    "title": "Class cpp::ast::Define | qiotoolkit",
    "keywords": "Class cpp::ast::Define Inheritance cpp::ast::Node cpp::ast::Define Inherited Members __init__ IsExportable Requires IsDefinition IsDeclaration XXX__str__ __repr__ Methods __init__() Declaration def cpp.ast.Define.__init__(self, start, end, name, definition) __str__() Declaration def cpp.ast.Define.__str__(self) __init__() Declaration def cpp.ast.Define.__init__(self, start, end, name, definition) __str__() Declaration def cpp.ast.Define.__str__(self)"
  },
  "api/cpp/ast/delete.html": {
    "href": "api/cpp/ast/delete.html",
    "title": "Class cpp::ast::Delete | qiotoolkit",
    "keywords": "Class cpp::ast::Delete Inheritance cpp::ast::Expr cpp::ast::Delete Inherited Members __str__ Requires __init__ __init__ IsExportable IsDefinition IsDeclaration XXX__str__ __repr__"
  },
  "api/cpp/ast/enum.html": {
    "href": "api/cpp/ast/enum.html",
    "title": "Class cpp::ast::Enum | qiotoolkit",
    "keywords": "Class cpp::ast::Enum Inheritance cpp::ast::_NestedType cpp::ast::Enum Inherited Members __init__ Requires IsDeclaration XXX__str__ __repr__ FullName __init__ __str__ __init__ IsExportable IsDefinition"
  },
  "api/cpp/ast/expr.html": {
    "href": "api/cpp/ast/expr.html",
    "title": "Class cpp::ast::Expr | qiotoolkit",
    "keywords": "Class cpp::ast::Expr Inheritance cpp::ast::Node cpp::ast::Expr cpp::ast::Delete cpp::ast::Friend cpp::ast::Return Inherited Members __init__ IsExportable IsDefinition IsDeclaration XXX__str__ __repr__ Methods __init__() Declaration def cpp.ast.Expr.__init__(self, start, end, expr) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Expr.Requires(self, node) __str__() Declaration def cpp.ast.Expr.__str__(self) __init__() Declaration def cpp.ast.Expr.__init__(self, start, end, expr) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Expr.Requires(self, node) __str__() Declaration def cpp.ast.Expr.__str__(self)"
  },
  "api/cpp/ast/friend.html": {
    "href": "api/cpp/ast/friend.html",
    "title": "Class cpp::ast::Friend | qiotoolkit",
    "keywords": "Class cpp::ast::Friend Inheritance cpp::ast::Expr cpp::ast::Friend Inherited Members __str__ Requires __init__ __init__ IsExportable IsDefinition IsDeclaration XXX__str__ __repr__ Methods __init__() Declaration def cpp.ast.Friend.__init__(self, start, end, expr, namespace) __init__() Declaration def cpp.ast.Friend.__init__(self, start, end, expr, namespace)"
  },
  "api/cpp/ast/function.html": {
    "href": "api/cpp/ast/function.html",
    "title": "Class cpp::ast::Function | qiotoolkit",
    "keywords": "Class cpp::ast::Function Inheritance cpp::ast::_GenericDeclaration cpp::ast::Function cpp::ast::Method Inherited Members __init__ XXX__str__ __repr__ FullName __init__ Methods __init__() Declaration def cpp.ast.Function.__init__(self, start, end, name, return_type, parameters, modifiers, templated_types, body, namespace) IsDeclaration() Returns bool if this node is a declaration. Declaration def cpp.ast.Function.IsDeclaration(self) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast.Function.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast.Function.IsExportable(self) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Function.Requires(self, node) __str__() Declaration def cpp.ast.Function.__str__(self) __init__() Declaration def cpp.ast.Function.__init__(self, start, end, name, return_type, parameters, modifiers, templated_types, body, namespace) IsDeclaration() Returns bool if this node is a declaration. Declaration def cpp.ast.Function.IsDeclaration(self) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast.Function.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast.Function.IsExportable(self) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Function.Requires(self, node) __str__() Declaration def cpp.ast.Function.__str__(self)"
  },
  "api/cpp/ast/generic-declaration.html": {
    "href": "api/cpp/ast/generic-declaration.html",
    "title": "Class cpp::ast::_GenericDeclaration | qiotoolkit",
    "keywords": "Class cpp::ast::_GenericDeclaration Inheritance cpp::ast::Node cpp::ast::_GenericDeclaration cpp::ast::Class cpp::ast::Function cpp::ast::Type cpp::ast::Typedef cpp::ast::VariableDeclaration cpp::ast::_NestedType Inherited Members __init__ IsExportable Requires IsDefinition IsDeclaration XXX__str__ __repr__ Methods __init__() Declaration def cpp.ast._GenericDeclaration.__init__(self, start, end, name, namespace) FullName() Declaration def cpp.ast._GenericDeclaration.FullName(self) __init__() Declaration def cpp.ast._GenericDeclaration.__init__(self, start, end, name, namespace) FullName() Declaration def cpp.ast._GenericDeclaration.FullName(self) _TypeStringHelper() Declaration def cpp.ast._GenericDeclaration._TypeStringHelper(self, suffix) _TypeStringHelper() Declaration def cpp.ast._GenericDeclaration._TypeStringHelper(self, suffix)"
  },
  "api/cpp/ast/goto.html": {
    "href": "api/cpp/ast/goto.html",
    "title": "Class cpp::ast::Goto | qiotoolkit",
    "keywords": "Class cpp::ast::Goto Inheritance cpp::ast::Node cpp::ast::Goto Inherited Members __init__ IsExportable Requires IsDefinition IsDeclaration XXX__str__ __repr__ Methods __init__() Declaration def cpp.ast.Goto.__init__(self, start, end, label) __str__() Declaration def cpp.ast.Goto.__str__(self) __init__() Declaration def cpp.ast.Goto.__init__(self, start, end, label) __str__() Declaration def cpp.ast.Goto.__str__(self)"
  },
  "api/cpp/ast/include.html": {
    "href": "api/cpp/ast/include.html",
    "title": "Class cpp::ast::Include | qiotoolkit",
    "keywords": "Class cpp::ast::Include Inheritance cpp::ast::Node cpp::ast::Include Inherited Members __init__ IsExportable Requires IsDefinition IsDeclaration XXX__str__ __repr__ Methods __init__() Declaration def cpp.ast.Include.__init__(self, start, end, filename, system) __str__() Declaration def cpp.ast.Include.__str__(self) __init__() Declaration def cpp.ast.Include.__init__(self, start, end, filename, system) __str__() Declaration def cpp.ast.Include.__str__(self)"
  },
  "api/cpp/ast/method.html": {
    "href": "api/cpp/ast/method.html",
    "title": "Class cpp::ast::Method | qiotoolkit",
    "keywords": "Class cpp::ast::Method Inheritance cpp::ast::Function cpp::ast::Method Inherited Members IsExportable Requires __str__ __init__ IsDeclaration IsDefinition __init__ XXX__str__ __repr__ FullName __init__ Methods __init__() Declaration def cpp.ast.Method.__init__(self, start, end, name, in_class, return_type, parameters, modifiers, templated_types, body, namespace) __init__() Declaration def cpp.ast.Method.__init__(self, start, end, name, in_class, return_type, parameters, modifiers, templated_types, body, namespace)"
  },
  "api/cpp/ast/nested-type.html": {
    "href": "api/cpp/ast/nested-type.html",
    "title": "Class cpp::ast::_NestedType | qiotoolkit",
    "keywords": "Class cpp::ast::_NestedType Inheritance cpp::ast::_GenericDeclaration cpp::ast::_NestedType cpp::ast::Enum cpp::ast::Union Inherited Members __init__ Requires IsDeclaration XXX__str__ __repr__ FullName __init__ Methods __init__() Declaration def cpp.ast._NestedType.__init__(self, start, end, name, fields, namespace) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast._NestedType.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast._NestedType.IsExportable(self) __str__() Declaration def cpp.ast._NestedType.__str__(self) __init__() Declaration def cpp.ast._NestedType.__init__(self, start, end, name, fields, namespace) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast._NestedType.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast._NestedType.IsExportable(self) __str__() Declaration def cpp.ast._NestedType.__str__(self)"
  },
  "api/cpp/ast/node.html": {
    "href": "api/cpp/ast/node.html",
    "title": "Class cpp::ast::Node | qiotoolkit",
    "keywords": "Class cpp::ast::Node Base AST node. Inheritance cpp::ast::Node cpp::ast::Define cpp::ast::Expr cpp::ast::Goto cpp::ast::Include cpp::ast::Parameter cpp::ast::Using cpp::ast::_GenericDeclaration Methods __init__() Declaration def cpp.ast.Node.__init__(self, start, end) IsDeclaration() Returns bool if this node is a declaration. Declaration def cpp.ast.Node.IsDeclaration(self) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast.Node.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast.Node.IsExportable(self) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Node.Requires(self, node) XXX__str__() Declaration def cpp.ast.Node.XXX__str__(self) __repr__() Declaration def cpp.ast.Node.__repr__(self) __init__() Declaration def cpp.ast.Node.__init__(self, start, end) IsDeclaration() Returns bool if this node is a declaration. Declaration def cpp.ast.Node.IsDeclaration(self) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast.Node.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast.Node.IsExportable(self) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Node.Requires(self, node) XXX__str__() Declaration def cpp.ast.Node.XXX__str__(self) __repr__() Declaration def cpp.ast.Node.__repr__(self) _StringHelper() Declaration def cpp.ast.Node._StringHelper(self, name, suffix) _StringHelper() Declaration def cpp.ast.Node._StringHelper(self, name, suffix)"
  },
  "api/cpp/ast/null-dict.html": {
    "href": "api/cpp/ast/null-dict.html",
    "title": "Class cpp::ast::_NullDict | qiotoolkit",
    "keywords": "Class cpp::ast::_NullDict Inheritance cpp::ast::_NullDict"
  },
  "api/cpp/ast/parameter.html": {
    "href": "api/cpp/ast/parameter.html",
    "title": "Class cpp::ast::Parameter | qiotoolkit",
    "keywords": "Class cpp::ast::Parameter Inheritance cpp::ast::Node cpp::ast::Parameter Inherited Members __init__ IsExportable IsDefinition IsDeclaration XXX__str__ __repr__ Methods __init__() Declaration def cpp.ast.Parameter.__init__(self, start, end, name, parameter_type, default) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Parameter.Requires(self, node) __str__() Declaration def cpp.ast.Parameter.__str__(self) __init__() Declaration def cpp.ast.Parameter.__init__(self, start, end, name, parameter_type, default) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Parameter.Requires(self, node) __str__() Declaration def cpp.ast.Parameter.__str__(self)"
  },
  "api/cpp/ast/return.html": {
    "href": "api/cpp/ast/return.html",
    "title": "Class cpp::ast::Return | qiotoolkit",
    "keywords": "Class cpp::ast::Return Inheritance cpp::ast::Expr cpp::ast::Return Inherited Members __str__ Requires __init__ __init__ IsExportable IsDefinition IsDeclaration XXX__str__ __repr__"
  },
  "api/cpp/ast/struct.html": {
    "href": "api/cpp/ast/struct.html",
    "title": "Class cpp::ast::Struct | qiotoolkit",
    "keywords": "Class cpp::ast::Struct Inheritance cpp::ast::Class cpp::ast::Struct Inherited Members __str__ IsExportable Requires IsDeclaration __init__ IsDefinition __init__ XXX__str__ __repr__ FullName __init__"
  },
  "api/cpp/ast/type-converter.html": {
    "href": "api/cpp/ast/type-converter.html",
    "title": "Class cpp::ast::TypeConverter | qiotoolkit",
    "keywords": "Class cpp::ast::TypeConverter Inheritance cpp::ast::TypeConverter Methods __init__() Declaration def cpp.ast.TypeConverter.__init__(self, namespace_stack) ToType() Convert [Token,...] to [Class(...), ] useful for base classes. For example, code like class Foo : public Bar<x, y> { ... }; the \"Bar<x, y>\" portion gets converted to an AST. Returns: [Class(...), ...] Declaration def cpp.ast.TypeConverter.ToType(self, tokens) DeclarationToParts() Declaration def cpp.ast.TypeConverter.DeclarationToParts(self, parts, needs_name_removed) ToParameters() Declaration def cpp.ast.TypeConverter.ToParameters(self, tokens) CreateReturnType() Declaration def cpp.ast.TypeConverter.CreateReturnType(self, return_type_seq) GetTemplateIndices() Declaration def cpp.ast.TypeConverter.GetTemplateIndices(self, names) __init__() Declaration def cpp.ast.TypeConverter.__init__(self, namespace_stack) ToType() Convert [Token,...] to [Class(...), ] useful for base classes. For example, code like class Foo : public Bar<x, y> { ... }; the \"Bar<x, y>\" portion gets converted to an AST. Returns: [Class(...), ...] Declaration def cpp.ast.TypeConverter.ToType(self, tokens) DeclarationToParts() Declaration def cpp.ast.TypeConverter.DeclarationToParts(self, parts, needs_name_removed) ToParameters() Declaration def cpp.ast.TypeConverter.ToParameters(self, tokens) CreateReturnType() Declaration def cpp.ast.TypeConverter.CreateReturnType(self, return_type_seq) GetTemplateIndices() Declaration def cpp.ast.TypeConverter.GetTemplateIndices(self, names) _GetTemplateEnd() Declaration def cpp.ast.TypeConverter._GetTemplateEnd(self, tokens, start) _GetTemplateEnd() Declaration def cpp.ast.TypeConverter._GetTemplateEnd(self, tokens, start)"
  },
  "api/cpp/ast/type.html": {
    "href": "api/cpp/ast/type.html",
    "title": "Class cpp::ast::Type | qiotoolkit",
    "keywords": "Class cpp::ast::Type Type used for any variable (eg class, primitive, struct, etc). Inheritance cpp::ast::_GenericDeclaration cpp::ast::Type Inherited Members __init__ Requires XXX__str__ __repr__ FullName __init__ Methods __init__() Args: name: str name of main type templated_types: [Class (Type?)] template type info between <> modifiers: [str] type modifiers (keywords) eg, const, mutable, etc. reference, pointer, array: bools Declaration def cpp.ast.Type.__init__(self, start, end, name, templated_types, modifiers, reference, pointer, array) __str__() Declaration def cpp.ast.Type.__str__(self) IsDeclaration() Returns bool if this node is a declaration. Declaration def cpp.ast.Type.IsDeclaration(self) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast.Type.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast.Type.IsExportable(self) __init__() Args: name: str name of main type templated_types: [Class (Type?)] template type info between <> modifiers: [str] type modifiers (keywords) eg, const, mutable, etc. reference, pointer, array: bools Declaration def cpp.ast.Type.__init__(self, start, end, name, templated_types, modifiers, reference, pointer, array) __str__() Declaration def cpp.ast.Type.__str__(self) IsDeclaration() Returns bool if this node is a declaration. Declaration def cpp.ast.Type.IsDeclaration(self) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast.Type.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast.Type.IsExportable(self)"
  },
  "api/cpp/ast/typedef.html": {
    "href": "api/cpp/ast/typedef.html",
    "title": "Class cpp::ast::Typedef | qiotoolkit",
    "keywords": "Class cpp::ast::Typedef Inheritance cpp::ast::_GenericDeclaration cpp::ast::Typedef Inherited Members __init__ IsDeclaration XXX__str__ __repr__ FullName __init__ Methods __init__() Declaration def cpp.ast.Typedef.__init__(self, start, end, name, alias, namespace) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast.Typedef.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast.Typedef.IsExportable(self) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Typedef.Requires(self, node) __str__() Declaration def cpp.ast.Typedef.__str__(self) __init__() Declaration def cpp.ast.Typedef.__init__(self, start, end, name, alias, namespace) IsDefinition() Returns bool if this node is a definition. Declaration def cpp.ast.Typedef.IsDefinition(self) IsExportable() Returns bool if this node exportable from a header file. Declaration def cpp.ast.Typedef.IsExportable(self) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.Typedef.Requires(self, node) __str__() Declaration def cpp.ast.Typedef.__str__(self)"
  },
  "api/cpp/ast/union.html": {
    "href": "api/cpp/ast/union.html",
    "title": "Class cpp::ast::Union | qiotoolkit",
    "keywords": "Class cpp::ast::Union Inheritance cpp::ast::_NestedType cpp::ast::Union Inherited Members __init__ Requires IsDeclaration XXX__str__ __repr__ FullName __init__ __str__ __init__ IsExportable IsDefinition"
  },
  "api/cpp/ast/using.html": {
    "href": "api/cpp/ast/using.html",
    "title": "Class cpp::ast::Using | qiotoolkit",
    "keywords": "Class cpp::ast::Using Inheritance cpp::ast::Node cpp::ast::Using Inherited Members __init__ IsExportable Requires IsDefinition IsDeclaration XXX__str__ __repr__ Methods __init__() Declaration def cpp.ast.Using.__init__(self, start, end, names) __str__() Declaration def cpp.ast.Using.__str__(self) __init__() Declaration def cpp.ast.Using.__init__(self, start, end, names) __str__() Declaration def cpp.ast.Using.__str__(self)"
  },
  "api/cpp/ast/variable-declaration.html": {
    "href": "api/cpp/ast/variable-declaration.html",
    "title": "Class cpp::ast::VariableDeclaration | qiotoolkit",
    "keywords": "Class cpp::ast::VariableDeclaration Inheritance cpp::ast::_GenericDeclaration cpp::ast::VariableDeclaration Inherited Members __init__ IsExportable IsDefinition IsDeclaration XXX__str__ __repr__ FullName __init__ Methods __init__() Declaration def cpp.ast.VariableDeclaration.__init__(self, start, end, name, var_type, initial_value, namespace) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.VariableDeclaration.Requires(self, node) ToString() Return a string that tries to reconstitute the variable decl. Declaration def cpp.ast.VariableDeclaration.ToString(self) __str__() Declaration def cpp.ast.VariableDeclaration.__str__(self) __init__() Declaration def cpp.ast.VariableDeclaration.__init__(self, start, end, name, var_type, initial_value, namespace) Requires() Does this AST node require the definition of the node passed in? Declaration def cpp.ast.VariableDeclaration.Requires(self, node) ToString() Return a string that tries to reconstitute the variable decl. Declaration def cpp.ast.VariableDeclaration.ToString(self) __str__() Declaration def cpp.ast.VariableDeclaration.__str__(self)"
  },
  "api/cpp/gmock/class/test/generate-methods-test.html": {
    "href": "api/cpp/gmock/class/test/generate-methods-test.html",
    "title": "Class cpp::gmock_class_test::GenerateMethodsTest | qiotoolkit",
    "keywords": "Class cpp::gmock_class_test::GenerateMethodsTest Inheritance cpp::gmock_class_test::TestCase cpp::gmock_class_test::GenerateMethodsTest Inherited Members StripLeadingWhitespace assertEqualIgnoreLeadingWhitespace Methods GenerateMethodSource() Convert C++ source to Google Mock output source lines. Declaration def cpp.gmock_class_test.GenerateMethodsTest.GenerateMethodSource(self, cpp_source) testSimpleMethod() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testSimpleMethod(self) testSimpleConstructorsAndDestructor() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testSimpleConstructorsAndDestructor(self) testVirtualDestructor() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testVirtualDestructor(self) testExplicitlyDefaultedConstructorsAndDestructor() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testExplicitlyDefaultedConstructorsAndDestructor(self) testExplicitlyDeletedConstructorsAndDestructor() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testExplicitlyDeletedConstructorsAndDestructor(self) testSimpleOverrideMethod() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testSimpleOverrideMethod(self) testSimpleConstMethod() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testSimpleConstMethod(self) testExplicitVoid() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testExplicitVoid(self) testStrangeNewlineInParameter() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testStrangeNewlineInParameter(self) testDefaultParameters() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testDefaultParameters(self) testMultipleDefaultParameters() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testMultipleDefaultParameters(self) testRemovesCommentsWhenDefaultsArePresent() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testRemovesCommentsWhenDefaultsArePresent(self) testDoubleSlashCommentsInParameterListAreRemoved() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testDoubleSlashCommentsInParameterListAreRemoved(self) testCStyleCommentsInParameterListAreNotRemoved() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testCStyleCommentsInParameterListAreNotRemoved(self) testArgsOfTemplateTypes() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testArgsOfTemplateTypes(self) testReturnTypeWithOneTemplateArg() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testReturnTypeWithOneTemplateArg(self) testReturnTypeWithManyTemplateArgs() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testReturnTypeWithManyTemplateArgs(self) testSimpleMethodInTemplatedClass() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testSimpleMethodInTemplatedClass(self) testPointerArgWithoutNames() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testPointerArgWithoutNames(self) testReferenceArgWithoutNames() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testReferenceArgWithoutNames(self) testArrayArgWithoutNames() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testArrayArgWithoutNames(self) GenerateMethodSource() Convert C++ source to Google Mock output source lines. Declaration def cpp.gmock_class_test.GenerateMethodsTest.GenerateMethodSource(self, cpp_source) testSimpleMethod() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testSimpleMethod(self) testSimpleConstructorsAndDestructor() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testSimpleConstructorsAndDestructor(self) testVirtualDestructor() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testVirtualDestructor(self) testExplicitlyDefaultedConstructorsAndDestructor() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testExplicitlyDefaultedConstructorsAndDestructor(self) testExplicitlyDeletedConstructorsAndDestructor() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testExplicitlyDeletedConstructorsAndDestructor(self) testSimpleOverrideMethod() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testSimpleOverrideMethod(self) testSimpleConstMethod() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testSimpleConstMethod(self) testExplicitVoid() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testExplicitVoid(self) testStrangeNewlineInParameter() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testStrangeNewlineInParameter(self) testDefaultParameters() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testDefaultParameters(self) testMultipleDefaultParameters() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testMultipleDefaultParameters(self) testRemovesCommentsWhenDefaultsArePresent() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testRemovesCommentsWhenDefaultsArePresent(self) testDoubleSlashCommentsInParameterListAreRemoved() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testDoubleSlashCommentsInParameterListAreRemoved(self) testCStyleCommentsInParameterListAreNotRemoved() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testCStyleCommentsInParameterListAreNotRemoved(self) testArgsOfTemplateTypes() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testArgsOfTemplateTypes(self) testReturnTypeWithOneTemplateArg() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testReturnTypeWithOneTemplateArg(self) testReturnTypeWithManyTemplateArgs() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testReturnTypeWithManyTemplateArgs(self) testSimpleMethodInTemplatedClass() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testSimpleMethodInTemplatedClass(self) testPointerArgWithoutNames() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testPointerArgWithoutNames(self) testReferenceArgWithoutNames() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testReferenceArgWithoutNames(self) testArrayArgWithoutNames() Declaration def cpp.gmock_class_test.GenerateMethodsTest.testArrayArgWithoutNames(self)"
  },
  "api/cpp/gmock/class/test/generate-mocks-test.html": {
    "href": "api/cpp/gmock/class/test/generate-mocks-test.html",
    "title": "Class cpp::gmock_class_test::GenerateMocksTest | qiotoolkit",
    "keywords": "Class cpp::gmock_class_test::GenerateMocksTest Inheritance cpp::gmock_class_test::TestCase cpp::gmock_class_test::GenerateMocksTest Inherited Members StripLeadingWhitespace assertEqualIgnoreLeadingWhitespace Methods GenerateMocks() Convert C++ source to complete Google Mock output source. Declaration def cpp.gmock_class_test.GenerateMocksTest.GenerateMocks(self, cpp_source) testNamespaces() Declaration def cpp.gmock_class_test.GenerateMocksTest.testNamespaces(self) testClassWithStorageSpecifierMacro() Declaration def cpp.gmock_class_test.GenerateMocksTest.testClassWithStorageSpecifierMacro(self) testTemplatedForwardDeclaration() Declaration def cpp.gmock_class_test.GenerateMocksTest.testTemplatedForwardDeclaration(self) testTemplatedClass() Declaration def cpp.gmock_class_test.GenerateMocksTest.testTemplatedClass(self) testTemplateInATemplateTypedef() Declaration def cpp.gmock_class_test.GenerateMocksTest.testTemplateInATemplateTypedef(self) testTemplateInATemplateTypedefWithComma() Declaration def cpp.gmock_class_test.GenerateMocksTest.testTemplateInATemplateTypedefWithComma(self) testEnumClass() Declaration def cpp.gmock_class_test.GenerateMocksTest.testEnumClass(self) GenerateMocks() Convert C++ source to complete Google Mock output source. Declaration def cpp.gmock_class_test.GenerateMocksTest.GenerateMocks(self, cpp_source) testNamespaces() Declaration def cpp.gmock_class_test.GenerateMocksTest.testNamespaces(self) testClassWithStorageSpecifierMacro() Declaration def cpp.gmock_class_test.GenerateMocksTest.testClassWithStorageSpecifierMacro(self) testTemplatedForwardDeclaration() Declaration def cpp.gmock_class_test.GenerateMocksTest.testTemplatedForwardDeclaration(self) testTemplatedClass() Declaration def cpp.gmock_class_test.GenerateMocksTest.testTemplatedClass(self) testTemplateInATemplateTypedef() Declaration def cpp.gmock_class_test.GenerateMocksTest.testTemplateInATemplateTypedef(self) testTemplateInATemplateTypedefWithComma() Declaration def cpp.gmock_class_test.GenerateMocksTest.testTemplateInATemplateTypedefWithComma(self)"
  },
  "api/cpp/gmock/class/test/test-case.html": {
    "href": "api/cpp/gmock/class/test/test-case.html",
    "title": "Class cpp::gmock_class_test::TestCase | qiotoolkit",
    "keywords": "Class cpp::gmock_class_test::TestCase Helper class that adds assert methods. Inheritance cpp::gmock_class_test::TestCase cpp::gmock_class_test::GenerateMethodsTest cpp::gmock_class_test::GenerateMocksTest Methods StripLeadingWhitespace() Strip leading whitespace in each line in 'lines'. Declaration def cpp.gmock_class_test.TestCase.StripLeadingWhitespace(self, lines) assertEqualIgnoreLeadingWhitespace() Specialized assert that ignores the indent level. Declaration def cpp.gmock_class_test.TestCase.assertEqualIgnoreLeadingWhitespace(self, expected_lines, lines) StripLeadingWhitespace() Strip leading whitespace in each line in 'lines'. Declaration def cpp.gmock_class_test.TestCase.StripLeadingWhitespace(self, lines) assertEqualIgnoreLeadingWhitespace() Specialized assert that ignores the indent level. Declaration def cpp.gmock_class_test.TestCase.assertEqualIgnoreLeadingWhitespace(self, expected_lines, lines)"
  },
  "api/cpp/tokenize/token.html": {
    "href": "api/cpp/tokenize/token.html",
    "title": "Class cpp::tokenize::Token | qiotoolkit",
    "keywords": "Class cpp::tokenize::Token Data container to represent a C++ token. Tokens can be identifiers, syntax char(s), constants, or pre-processor directives. start contains the index of the first char of the token in the source end contains the index of the last char of the token in the source Inheritance cpp::tokenize::Token Methods __init__() Declaration def cpp.tokenize.Token.__init__(self, token_type, name, start, end) __str__() Declaration def cpp.tokenize.Token.__str__(self) __init__() Declaration def cpp.tokenize.Token.__init__(self, token_type, name, start, end) __str__() Declaration def cpp.tokenize.Token.__str__(self)"
  },
  "api/crt-allocator.html": {
    "href": "api/crt-allocator.html",
    "title": "Class CrtAllocator | qiotoolkit",
    "keywords": "Class CrtAllocator C-runtime library allocator. This class is just wrapper for standard C library memory routines. implements Allocator concept Inheritance CrtAllocator Methods Malloc() Declaration void* CrtAllocator::Malloc(size_t size) Realloc() Declaration void* CrtAllocator::Realloc(void *originalPtr, size_t originalSize, size_t newSize) operator==() Declaration bool CrtAllocator::operator==(const CrtAllocator&) const RAPIDJSON_NOEXCEPT operator!=() Declaration bool CrtAllocator::operator!=(const CrtAllocator&) const RAPIDJSON_NOEXCEPT Free() Declaration static void CrtAllocator::Free(void *ptr) RAPIDJSON_NOEXCEPT"
  },
  "api/cursor-stream-wrapper.html": {
    "href": "api/cursor-stream-wrapper.html",
    "title": "Class CursorStreamWrapper | qiotoolkit",
    "keywords": "Class CursorStreamWrapper Cursor stream wrapper for counting line and column number if error exists. InputStream Any stream that implements Stream Concept Inheritance GenericStreamWrapper CursorStreamWrapper Inherited Members Flush Put PutBegin Tell HasBOM GetType GenericStreamWrapper PutEnd Peek Peek4 Constructors CursorStreamWrapper() Declaration CursorStreamWrapper<InputStream, Encoding>::CursorStreamWrapper(InputStream&is) Methods Take() Declaration Ch CursorStreamWrapper<InputStream, Encoding>::Take() GetLine() Get the error line number, if error exists. Declaration size_t CursorStreamWrapper<InputStream, Encoding>::GetLine() const GetColumn() Get the error column number, if error exists. Declaration size_t CursorStreamWrapper<InputStream, Encoding>::GetColumn() const"
  },
  "api/dependent.html": {
    "href": "api/dependent.html",
    "title": "Class Dependent | qiotoolkit",
    "keywords": "Class Dependent Inheritance Person Dependent Inherited Members Person Person ~Person operator= Constructors Dependent() Declaration Dependent::Dependent(const std::string&name, unsigned age, Education *education=0) Dependent() Declaration Dependent::Dependent(const Dependent&rhs) Methods ~Dependent() Declaration Dependent::~Dependent() operator=() Declaration Dependent&Dependent::operator=(const Dependent&rhs) Serialize() Declaration void Dependent::Serialize(Writer&writer) const"
  },
  "api/education.html": {
    "href": "api/education.html",
    "title": "Class Education | qiotoolkit",
    "keywords": "Class Education Inheritance Education Constructors Education() Declaration Education::Education(const std::string&school, double GPA) Education() Declaration Education::Education(const Education&rhs) Methods Serialize() Declaration void Education::Serialize(Writer&writer) const"
  },
  "api/employee.html": {
    "href": "api/employee.html",
    "title": "Class Employee | qiotoolkit",
    "keywords": "Class Employee Inheritance Person Employee Inherited Members Person Person ~Person operator= Constructors Employee() Declaration Employee::Employee(const std::string&name, unsigned age, bool married) Employee() Declaration Employee::Employee(const Employee&rhs) Methods ~Employee() Declaration Employee::~Employee() operator=() Declaration Employee&Employee::operator=(const Employee&rhs) AddDependent() Declaration void Employee::AddDependent(const Dependent&dependent) Serialize() Declaration void Employee::Serialize(Writer&writer) const"
  },
  "api/encoded-input-stream.html": {
    "href": "api/encoded-input-stream.html",
    "title": "Class EncodedInputStream | qiotoolkit",
    "keywords": "Class EncodedInputStream Input byte stream wrapper with a statically bound encoding. Encoding The interpretation of encoding of the stream. Either UTF8, UTF16LE, UTF16BE, UTF32LE, UTF32BE. InputByteStream Type of input byte stream. For example, FileReadStream. Inheritance EncodedInputStream Constructors EncodedInputStream() Declaration EncodedInputStream<Encoding, InputByteStream>::EncodedInputStream(const EncodedInputStream&) EncodedInputStream() Declaration EncodedInputStream<Encoding, InputByteStream>::EncodedInputStream(InputByteStream&is) Methods RAPIDJSON_STATIC_ASSERT() Declaration EncodedInputStream<Encoding, InputByteStream>::RAPIDJSON_STATIC_ASSERT(sizeof(typename InputByteStream::Ch)==1) operator=() Declaration EncodedInputStream&EncodedInputStream<Encoding, InputByteStream>::operator=(const EncodedInputStream&) Peek() Declaration Ch EncodedInputStream<Encoding, InputByteStream>::Peek() const Take() Declaration Ch EncodedInputStream<Encoding, InputByteStream>::Take() Tell() Declaration size_t EncodedInputStream<Encoding, InputByteStream>::Tell() const Put() Declaration void EncodedInputStream<Encoding, InputByteStream>::Put(Ch) Flush() Declaration void EncodedInputStream<Encoding, InputByteStream>::Flush() PutBegin() Declaration Ch* EncodedInputStream<Encoding, InputByteStream>::PutBegin() PutEnd() Declaration size_t EncodedInputStream<Encoding, InputByteStream>::PutEnd(Ch *)"
  },
  "api/encoded-input-stream/3/01-utf8/3/4/00/01-memory-stream/01/4.html": {
    "href": "api/encoded-input-stream/3/01-utf8/3/4/00/01-memory-stream/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Specialized for UTF8 MemoryStream. Inheritance > Methods EncodedInputStream() Declaration EncodedInputStream<UTF8<>, MemoryStream>::EncodedInputStream(MemoryStream&is) Peek() Declaration Ch EncodedInputStream<UTF8<>, MemoryStream>::Peek() const Take() Declaration Ch EncodedInputStream<UTF8<>, MemoryStream>::Take() Tell() Declaration size_t EncodedInputStream<UTF8<>, MemoryStream>::Tell() const Put() Declaration void EncodedInputStream<UTF8<>, MemoryStream>::Put(Ch) Flush() Declaration void EncodedInputStream<UTF8<>, MemoryStream>::Flush() PutBegin() Declaration Ch* EncodedInputStream<UTF8<>, MemoryStream>::PutBegin() PutEnd() Declaration size_t EncodedInputStream<UTF8<>, MemoryStream>::PutEnd(Ch *) EncodedInputStream() Declaration EncodedInputStream<UTF8<>, MemoryStream>::EncodedInputStream(const EncodedInputStream&) operator=() Declaration EncodedInputStream&EncodedInputStream<UTF8<>, MemoryStream>::operator=(const EncodedInputStream&)"
  },
  "api/encoded-output-stream.html": {
    "href": "api/encoded-output-stream.html",
    "title": "Class EncodedOutputStream | qiotoolkit",
    "keywords": "Class EncodedOutputStream Output byte stream wrapper with statically bound encoding. Encoding The interpretation of encoding of the stream. Either UTF8, UTF16LE, UTF16BE, UTF32LE, UTF32BE. OutputByteStream Type of input byte stream. For example, FileWriteStream. Inheritance EncodedOutputStream Constructors EncodedOutputStream() Declaration EncodedOutputStream<Encoding, OutputByteStream>::EncodedOutputStream(const EncodedOutputStream&) EncodedOutputStream() Declaration EncodedOutputStream<Encoding, OutputByteStream>::EncodedOutputStream(OutputByteStream&os, bool putBOM=true) Methods RAPIDJSON_STATIC_ASSERT() Declaration EncodedOutputStream<Encoding, OutputByteStream>::RAPIDJSON_STATIC_ASSERT(sizeof(typename OutputByteStream::Ch)==1) operator=() Declaration EncodedOutputStream&EncodedOutputStream<Encoding, OutputByteStream>::operator=(const EncodedOutputStream&) Put() Declaration void EncodedOutputStream<Encoding, OutputByteStream>::Put(Ch c) Flush() Declaration void EncodedOutputStream<Encoding, OutputByteStream>::Flush() Peek() Declaration Ch EncodedOutputStream<Encoding, OutputByteStream>::Peek() const Take() Declaration Ch EncodedOutputStream<Encoding, OutputByteStream>::Take() Tell() Declaration size_t EncodedOutputStream<Encoding, OutputByteStream>::Tell() const PutBegin() Declaration Ch* EncodedOutputStream<Encoding, OutputByteStream>::PutBegin() PutEnd() Declaration size_t EncodedOutputStream<Encoding, OutputByteStream>::PutEnd(Ch *)"
  },
  "api/examples/descent.html": {
    "href": "api/examples/descent.html",
    "title": "Class examples::Descent | qiotoolkit",
    "keywords": "Class examples::Descent Inheritance solver::SteppingSolver examples::Descent Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver get_solutions copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Methods get_identifier() Get the identifier of this solver. This identifier is denoted as the target in the request. Declaration std::string examples::Descent<Model_T>::get_identifier() const override configure() Check the identifier and version against the configuraiton. Declaration void examples::Descent<Model_T>::configure(const utils::Json&json) override init_memory_check_error_message() Declaration std::string examples::Descent<Model_T>::init_memory_check_error_message() const override target_number_of_states() Declaration size_t examples::Descent<Model_T>::target_number_of_states() const override init() Initialize the solver. Declaration void examples::Descent<Model_T>::init() override make_step() Declaration void examples::Descent<Model_T>::make_step(uint64_t) override finalize() Declaration void examples::Descent<Model_T>::finalize() override"
  },
  "api/examples/soft-spin-state.html": {
    "href": "api/examples/soft-spin-state.html",
    "title": "Class examples::SoftSpinState | qiotoolkit",
    "keywords": "Class examples::SoftSpinState Inheritance markov::State examples::SoftSpinState Inherited Members configure ~Component Component param Methods render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure examples::SoftSpinState::render() const override get_status() get_status shows a simplified state representation Like render, this produces a structured representation of the object's state. However, it is intended to be simpler in nature with the purpose of rendering the object during stream-output and logging. By default, it will fall back to the full render, but overloading this allows distinguising how the object looks during LOG vs full output. Declaration utils::Structure examples::SoftSpinState::get_status() const override get_class_name() get_class_name shows an identifier of the (derived) class name Its primary use is for type identification during stream output and logging, where a component is rendered as <ClassName: status>. Example: {c++} MyClass : public Component {} // This will render as '<MyClass>' MyClass my_object; std::cout << my_object << std::endl; Note You do not need to overload this method unless you want to change the output of the default implementation. Declaration std::string examples::SoftSpinState::get_class_name() const override memory_estimate() Declaration static size_t examples::SoftSpinState::memory_estimate(size_t N) state_only_memory_estimate() Declaration static size_t examples::SoftSpinState::state_only_memory_estimate(size_t N)"
  },
  "api/examples/soft-spin-transition.html": {
    "href": "api/examples/soft-spin-transition.html",
    "title": "Class examples::SoftSpinTransition | qiotoolkit",
    "keywords": "Class examples::SoftSpinTransition Inheritance markov::Transition examples::SoftSpinTransition Inherited Members configure render ~Component Component get_status param get_class_name Constructors SoftSpinTransition() Declaration examples::SoftSpinTransition::SoftSpinTransition() Methods <() Declaration bool examples::SoftSpinTransition::operator<(const SoftSpinTransition&trans) const <() Declaration bool examples::SoftSpinTransition::operator<(const SoftSpinTransition&trans) const"
  },
  "api/examples/soft-spin.html": {
    "href": "api/examples/soft-spin.html",
    "title": "Class examples::SoftSpin | qiotoolkit",
    "keywords": "Class examples::SoftSpin Inheritance model::GraphModel examples::SoftSpin Inherited Members Model state_only_memory_estimate init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff set_step_limit state_memory_estimate render calculate_cost_difference get_random_transition configure match_version ~BaseModel configure BaseModel edge get_const_cost node rescale node_count estimate_max_cost_diff get_term_count get_scale_factor is_empty has_initial_configuration is_rescaled edges get_initial_configuration nodes get_sweep_size get_benchmark_properties edge_count render ~Component Component get_status param get_class_name Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string examples::SoftSpin::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string examples::SoftSpin::get_version() const override configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void examples::SoftSpin::configure(const utils::Json&json) override configure() Declaration void examples::SoftSpin::configure(Configuration_T&configuration) calculate_cost() Declaration double examples::SoftSpin::calculate_cost(const State_T&state) const override calculate_cost_difference() Declaration double examples::SoftSpin::calculate_cost_difference(const State_T&state, const Transition_T&transition) const override get_random_state() Return a valid random state for the model. The various algorithms don't know how to initialize a valid state; this allows them to start with a random one. NOTE: The rng being passed should be used for randomness (as opposed to creating one for the model), as multiple threads can potentially use the same underlying model (albeit with separate rngs). Declaration State_T examples::SoftSpin::get_random_state(utils::RandomGenerator&rng) const override get_random_transition() Declaration Transition_T examples::SoftSpin::get_random_transition(const State_T&, utils::RandomGenerator&rng) const override apply_transition() Declaration void examples::SoftSpin::apply_transition(const Transition_T&transition, State_T&state) const override state_memory_estimate() Declaration size_t examples::SoftSpin::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t examples::SoftSpin::state_only_memory_estimate() const override"
  },
  "api/file-read-stream.html": {
    "href": "api/file-read-stream.html",
    "title": "Class FileReadStream | qiotoolkit",
    "keywords": "Class FileReadStream File byte stream for input using fread(). implements Stream concept Inheritance FileReadStream Constructors FileReadStream() Constructor. fp File pointer opened for read. buffer user-supplied buffer. bufferSize size of buffer in bytes. Must >=4 bytes. Declaration FileReadStream::FileReadStream(std::FILE *fp, char *buffer, size_t bufferSize) Methods Peek() Declaration Ch FileReadStream::Peek() const Take() Declaration Ch FileReadStream::Take() Tell() Declaration size_t FileReadStream::Tell() const Put() Declaration void FileReadStream::Put(Ch) Flush() Declaration void FileReadStream::Flush() PutBegin() Declaration Ch* FileReadStream::PutBegin() PutEnd() Declaration size_t FileReadStream::PutEnd(Ch *) Peek4() Declaration const Ch* FileReadStream::Peek4() const Read() Declaration void FileReadStream::Read()"
  },
  "api/file-write-stream.html": {
    "href": "api/file-write-stream.html",
    "title": "Class FileWriteStream | qiotoolkit",
    "keywords": "Class FileWriteStream Wrapper of C file stream for output using fwrite(). implements Stream concept Inheritance FileWriteStream Constructors FileWriteStream() Declaration FileWriteStream::FileWriteStream(std::FILE *fp, char *buffer, size_t bufferSize) FileWriteStream() Declaration FileWriteStream::FileWriteStream(const FileWriteStream&) Methods Put() Declaration void FileWriteStream::Put(char c) PutN() Declaration void FileWriteStream::PutN(char c, size_t n) Flush() Declaration void FileWriteStream::Flush() Peek() Declaration char FileWriteStream::Peek() const Take() Declaration char FileWriteStream::Take() Tell() Declaration size_t FileWriteStream::Tell() const PutBegin() Declaration char* FileWriteStream::PutBegin() PutEnd() Declaration size_t FileWriteStream::PutEnd(char *) operator=() Declaration FileWriteStream&FileWriteStream::operator=(const FileWriteStream&)"
  },
  "api/filter-key-handler.html": {
    "href": "api/filter-key-handler.html",
    "title": "Class FilterKeyHandler | qiotoolkit",
    "keywords": "Class FilterKeyHandler Inheritance FilterKeyHandler Constructors FilterKeyHandler() Declaration FilterKeyHandler<OutputHandler>::FilterKeyHandler(OutputHandler&outputHandler, const Ch *keyString, SizeType keyLength) FilterKeyHandler() Declaration FilterKeyHandler<OutputHandler>::FilterKeyHandler(OutputHandler&outputHandler, const Ch *keyString, SizeType keyLength) FilterKeyHandler() Declaration FilterKeyHandler<OutputHandler>::FilterKeyHandler(const FilterKeyHandler&) FilterKeyHandler() Declaration FilterKeyHandler<OutputHandler>::FilterKeyHandler(const FilterKeyHandler&) Methods Null() Declaration bool FilterKeyHandler<OutputHandler>::Null() Bool() Declaration bool FilterKeyHandler<OutputHandler>::Bool(bool b) Int() Declaration bool FilterKeyHandler<OutputHandler>::Int(int i) Uint() Declaration bool FilterKeyHandler<OutputHandler>::Uint(unsigned u) Int64() Declaration bool FilterKeyHandler<OutputHandler>::Int64(int64_t i) Uint64() Declaration bool FilterKeyHandler<OutputHandler>::Uint64(uint64_t u) Double() Declaration bool FilterKeyHandler<OutputHandler>::Double(double d) RawNumber() Declaration bool FilterKeyHandler<OutputHandler>::RawNumber(const Ch *str, SizeType len, bool copy) String() Declaration bool FilterKeyHandler<OutputHandler>::String(const Ch *str, SizeType len, bool copy) StartObject() Declaration bool FilterKeyHandler<OutputHandler>::StartObject() Key() Declaration bool FilterKeyHandler<OutputHandler>::Key(const Ch *str, SizeType len, bool copy) EndObject() Declaration bool FilterKeyHandler<OutputHandler>::EndObject(SizeType) StartArray() Declaration bool FilterKeyHandler<OutputHandler>::StartArray() EndArray() Declaration bool FilterKeyHandler<OutputHandler>::EndArray(SizeType elementCount) Null() Declaration bool FilterKeyHandler<OutputHandler>::Null() Bool() Declaration bool FilterKeyHandler<OutputHandler>::Bool(bool b) Int() Declaration bool FilterKeyHandler<OutputHandler>::Int(int i) Uint() Declaration bool FilterKeyHandler<OutputHandler>::Uint(unsigned u) Int64() Declaration bool FilterKeyHandler<OutputHandler>::Int64(int64_t i) Uint64() Declaration bool FilterKeyHandler<OutputHandler>::Uint64(uint64_t u) Double() Declaration bool FilterKeyHandler<OutputHandler>::Double(double d) RawNumber() Declaration bool FilterKeyHandler<OutputHandler>::RawNumber(const Ch *str, SizeType len, bool copy) String() Declaration bool FilterKeyHandler<OutputHandler>::String(const Ch *str, SizeType len, bool copy) StartObject() Declaration bool FilterKeyHandler<OutputHandler>::StartObject() Key() Declaration bool FilterKeyHandler<OutputHandler>::Key(const Ch *str, SizeType len, bool copy) EndObject() Declaration bool FilterKeyHandler<OutputHandler>::EndObject(SizeType) StartArray() Declaration bool FilterKeyHandler<OutputHandler>::StartArray() EndArray() Declaration bool FilterKeyHandler<OutputHandler>::EndArray(SizeType elementCount) operator=() Declaration FilterKeyHandler&FilterKeyHandler<OutputHandler>::operator=(const FilterKeyHandler&) EndValue() Declaration bool FilterKeyHandler<OutputHandler>::EndValue() operator=() Declaration FilterKeyHandler&FilterKeyHandler<OutputHandler>::operator=(const FilterKeyHandler&) EndValue() Declaration bool FilterKeyHandler<OutputHandler>::EndValue()"
  },
  "api/filter-key-reader.html": {
    "href": "api/filter-key-reader.html",
    "title": "Class FilterKeyReader | qiotoolkit",
    "keywords": "Class FilterKeyReader Inheritance FilterKeyReader Constructors FilterKeyReader() Declaration FilterKeyReader<InputStream>::FilterKeyReader(InputStream&is, const Ch *keyString, SizeType keyLength) FilterKeyReader() Declaration FilterKeyReader<InputStream>::FilterKeyReader(const FilterKeyReader&) Methods operator()() Declaration bool FilterKeyReader<InputStream>::operator()(Handler&handler) GetParseResult() Declaration const ParseResult&FilterKeyReader<InputStream>::GetParseResult() const operator=() Declaration FilterKeyReader&FilterKeyReader<InputStream>::operator=(const FilterKeyReader&)"
  },
  "api/generic-array.html": {
    "href": "api/generic-array.html",
    "title": "Class GenericArray | qiotoolkit",
    "keywords": "Class GenericArray Helper class for accessing Value of array type. Instance of this helper class is obtained by GenericValue::GetArray(). In addition to all APIs for array type, it provides range-based for loop if RAPIDJSON_HAS_CXX11_RANGE_FOR=1. Inheritance GenericArray Constructors GenericArray() Declaration GenericArray<Const, ValueT>::GenericArray(const GenericArray&rhs) GenericArray() Declaration GenericArray<Const, ValueT>::GenericArray() GenericArray() Declaration GenericArray<Const, ValueT>::GenericArray(ValueType&value) Methods operator=() Declaration GenericArray&GenericArray<Const, ValueT>::operator=(const GenericArray&rhs) ~GenericArray() Declaration GenericArray<Const, ValueT>::~GenericArray() &() Declaration GenericArray<Const, ValueT>::operator ValueType&() const &() Declaration GenericArray<Const, ValueT>::operator ValueType&() const Size() Declaration SizeType GenericArray<Const, ValueT>::Size() const Capacity() Declaration SizeType GenericArray<Const, ValueT>::Capacity() const Empty() Declaration bool GenericArray<Const, ValueT>::Empty() const Clear() Declaration void GenericArray<Const, ValueT>::Clear() const operator[]() Declaration ValueType&GenericArray<Const, ValueT>::operator[](SizeType index) const Begin() Declaration ValueIterator GenericArray<Const, ValueT>::Begin() const End() Declaration ValueIterator GenericArray<Const, ValueT>::End() const Reserve() Declaration GenericArray GenericArray<Const, ValueT>::Reserve(SizeType newCapacity, AllocatorType&allocator) const PushBack() Declaration GenericArray GenericArray<Const, ValueT>::PushBack(ValueType&value, AllocatorType&allocator) const PushBack() Declaration GenericArray GenericArray<Const, ValueT>::PushBack(StringRefType value, AllocatorType&allocator) const RAPIDJSON_DISABLEIF_RETURN() Declaration GenericArray<Const, ValueT>::RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T>>),(const GenericArray&)) PushBack(T value PopBack() Declaration GenericArray GenericArray<Const, ValueT>::PopBack() const Erase() Declaration ValueIterator GenericArray<Const, ValueT>::Erase(ConstValueIterator pos) const Erase() Declaration ValueIterator GenericArray<Const, ValueT>::Erase(ConstValueIterator first, ConstValueIterator last) const"
  },
  "api/generic-document.html": {
    "href": "api/generic-document.html",
    "title": "Class GenericDocument | qiotoolkit",
    "keywords": "Class GenericDocument A document for parsing JSON text as DOM. implements Handler concept Encoding Encoding for both parsing and string storage. Allocator Allocator for allocating memory for the DOM StackAllocator Allocator for allocating memory for stack during parsing. Although GenericDocument inherits from GenericValue, the API does not provide any virtual functions, especially no virtual destructor. To avoid memory leaks, do not delete a GenericDocument object via a pointer to a GenericValue. Inheritance GenericDocument Constructors GenericDocument() Constructor. Creates an empty document of specified type. type Mandatory type of object to create. allocator Optional allocator for allocating memory. stackCapacity Optional initial capacity of stack in bytes. stackAllocator Optional allocator for allocating memory for stack. Declaration GenericDocument<Encoding, Allocator, StackAllocator>::GenericDocument(Type type, Allocator *allocator=0, size_t stackCapacity=kDefaultStackCapacity, StackAllocator *stackAllocator=0) GenericDocument() Constructor. Creates an empty document which type is Null. allocator Optional allocator for allocating memory. stackCapacity Optional initial capacity of stack in bytes. stackAllocator Optional allocator for allocating memory for stack. Declaration GenericDocument<Encoding, Allocator, StackAllocator>::GenericDocument(Allocator *allocator=0, size_t stackCapacity=kDefaultStackCapacity, StackAllocator *stackAllocator=0) GenericDocument() Prohibit copying. Declaration GenericDocument<Encoding, Allocator, StackAllocator>::GenericDocument(const GenericDocument&) Methods ParseStream() Parse JSON text from an input stream (with Encoding conversion) parseFlags Combination of ParseFlag. SourceEncoding Encoding of input stream InputStream Type of input stream, implementing Stream concept is Input stream to be parsed. The document itself for fluent API. Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::ParseStream(InputStream&is) ParseStream() Parse JSON text from an input stream. parseFlags Combination of ParseFlag. InputStream Type of input stream, implementing Stream concept is Input stream to be parsed. The document itself for fluent API. Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::ParseStream(InputStream&is) ParseStream() Parse JSON text from an input stream (with kParseDefaultFlags) InputStream Type of input stream, implementing Stream concept is Input stream to be parsed. The document itself for fluent API. Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::ParseStream(InputStream&is) ParseInsitu() Parse JSON text from a mutable string. parseFlags Combination of ParseFlag. str Mutable zero-terminated string to be parsed. The document itself for fluent API. Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::ParseInsitu(Ch *str) ParseInsitu() Parse JSON text from a mutable string (with kParseDefaultFlags) str Mutable zero-terminated string to be parsed. The document itself for fluent API. Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::ParseInsitu(Ch *str) Parse() Parse JSON text from a read-only string (with Encoding conversion) parseFlags Combination of ParseFlag (must not contain kParseInsituFlag). SourceEncoding Transcoding from input Encoding str Read-only zero-terminated string to be parsed. Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::Parse(const typename SourceEncoding::Ch *str) Parse() Parse JSON text from a read-only string. parseFlags Combination of ParseFlag (must not contain kParseInsituFlag). str Read-only zero-terminated string to be parsed. Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::Parse(const Ch *str) Parse() Parse JSON text from a read-only string (with kParseDefaultFlags) str Read-only zero-terminated string to be parsed. Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::Parse(const Ch *str) Parse() Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::Parse(const typename SourceEncoding::Ch *str, size_t length) Parse() Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::Parse(const Ch *str, size_t length) Parse() Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::Parse(const Ch *str, size_t length) HasParseError() Whether a parse error has occurred in the last parsing. Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::HasParseError() const GetParseError() Get the ParseErrorCode of last parsing. Declaration ParseErrorCode GenericDocument<Encoding, Allocator, StackAllocator>::GetParseError() const GetErrorOffset() Get the position of last parsing error in input, 0 otherwise. Declaration size_t GenericDocument<Encoding, Allocator, StackAllocator>::GetErrorOffset() const operator ParseResult() Implicit conversion to get the last parse result. ParseResult of the last parse operation Document doc; ParseResult ok = doc.Parse(json); if (!ok) printf( \"JSON parse error: %s (%u)\\n\", GetParseError_En(ok.Code()), ok.Offset()); Declaration GenericDocument<Encoding, Allocator, StackAllocator>::operator ParseResult() const ~GenericDocument() Declaration GenericDocument<Encoding, Allocator, StackAllocator>::~GenericDocument() Swap() Exchange the contents of this document with those of another. rhs Another document. Constant complexity. GenericValue::Swap Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::Swap(GenericDocument&rhs) RAPIDJSON_NOEXCEPT Populate() Populate this document by a generator which produces SAX events. Generator A functor with bool f(Handler) prototype. g Generator functor which sends SAX events to the parameter. The document itself for fluent API. Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::Populate(Generator&g) GetAllocator() Get the allocator of this document. Declaration Allocator&GenericDocument<Encoding, Allocator, StackAllocator>::GetAllocator() GetStackCapacity() Get the capacity of stack in bytes. Declaration size_t GenericDocument<Encoding, Allocator, StackAllocator>::GetStackCapacity() const Null() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::Null() Bool() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::Bool(bool b) Int() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::Int(int i) Uint() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::Uint(unsigned i) Int64() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::Int64(int64_t i) Uint64() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::Uint64(uint64_t i) Double() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::Double(double d) RawNumber() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::RawNumber(const Ch *str, SizeType length, bool copy) String() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::String(const Ch *str, SizeType length, bool copy) StartObject() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::StartObject() Key() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::Key(const Ch *str, SizeType length, bool copy) EndObject() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::EndObject(SizeType memberCount) StartArray() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::StartArray() EndArray() Declaration bool GenericDocument<Encoding, Allocator, StackAllocator>::EndArray(SizeType elementCount) operator=() Prohibit assignment. Declaration GenericDocument&GenericDocument<Encoding, Allocator, StackAllocator>::operator=(const GenericDocument&) ClearStack() Declaration void GenericDocument<Encoding, Allocator, StackAllocator>::ClearStack() Destroy() Declaration void GenericDocument<Encoding, Allocator, StackAllocator>::Destroy()"
  },
  "api/generic-document/clear-stack-on-exit.html": {
    "href": "api/generic-document/clear-stack-on-exit.html",
    "title": "Struct GenericDocument::ClearStackOnExit | qiotoolkit",
    "keywords": "Struct GenericDocument::ClearStackOnExit Constructors ClearStackOnExit() Declaration GenericDocument<Encoding, Allocator, StackAllocator>::ClearStackOnExit::ClearStackOnExit(GenericDocument&d) ClearStackOnExit() Declaration GenericDocument<Encoding, Allocator, StackAllocator>::ClearStackOnExit::ClearStackOnExit(const ClearStackOnExit&) Methods ~ClearStackOnExit() Declaration GenericDocument<Encoding, Allocator, StackAllocator>::ClearStackOnExit::~ClearStackOnExit() operator=() Declaration ClearStackOnExit&GenericDocument<Encoding, Allocator, StackAllocator>::ClearStackOnExit::operator=(const ClearStackOnExit&)"
  },
  "api/generic-insitu-string-stream.html": {
    "href": "api/generic-insitu-string-stream.html",
    "title": "Struct GenericInsituStringStream | qiotoolkit",
    "keywords": "Struct GenericInsituStringStream A read-write string stream. This string stream is particularly designed for in-situ parsing. implements Stream concept Constructors GenericInsituStringStream() Declaration GenericInsituStringStream<Encoding>::GenericInsituStringStream(Ch *src) Methods Peek() Declaration Ch GenericInsituStringStream<Encoding>::Peek() Take() Declaration Ch GenericInsituStringStream<Encoding>::Take() Tell() Declaration size_t GenericInsituStringStream<Encoding>::Tell() Put() Declaration void GenericInsituStringStream<Encoding>::Put(Ch c) PutBegin() Declaration Ch* GenericInsituStringStream<Encoding>::PutBegin() PutEnd() Declaration size_t GenericInsituStringStream<Encoding>::PutEnd(Ch *begin) Flush() Declaration void GenericInsituStringStream<Encoding>::Flush() Push() Declaration Ch* GenericInsituStringStream<Encoding>::Push(size_t count) Pop() Declaration void GenericInsituStringStream<Encoding>::Pop(size_t count)"
  },
  "api/generic-member-iterator.html": {
    "href": "api/generic-member-iterator.html",
    "title": "Class GenericMemberIterator | qiotoolkit",
    "keywords": "Class GenericMemberIterator (Constant) member iterator for a JSON object value Const Is this a constant iterator? Encoding Encoding of the value. (Even non-string values need to have the same encoding in a document) Allocator Allocator type for allocating memory of object, array and string. This class implements a Random Access Iterator for GenericMember elements of a GenericValue, see ISO/IEC 14882:2003(E) C++ standard, 24.1 [lib.iterator.requirements]. This iterator implementation is mainly intended to avoid implicit conversions from iterator values to NULL, e.g. from GenericValue::FindMember. Define RAPIDJSON_NOMEMBERITERATORCLASS to fall back to a pointer-based implementation, if your platform doesn't provide the C++ header. GenericMember, GenericValue::MemberIterator, GenericValue::ConstMemberIterator Inheritance GenericMemberIterator Constructors GenericMemberIterator() Default constructor (singular value) Creates an iterator pointing to no element. All operations, except for comparisons, are undefined on such values. Declaration GenericMemberIterator<Const, Encoding, Allocator>::GenericMemberIterator() GenericMemberIterator() Iterator conversions to more const. it (Non-const) iterator to copy from Allows the creation of an iterator from another GenericMemberIterator that is \"less const\". Especially, creating a non-constant iterator from a constant iterator are disabled: const -> non-const (not ok) const -> const (ok) non-const -> const (ok) non-const -> non-const (ok) If the Const template parameter is already false, this constructor effectively defines a regular copy-constructor. Otherwise, the copy constructor is implicitly defined. Declaration GenericMemberIterator<Const, Encoding, Allocator>::GenericMemberIterator(const NonConstIterator&it) GenericMemberIterator() Internal constructor from plain pointer. Declaration GenericMemberIterator<Const, Encoding, Allocator>::GenericMemberIterator(Pointer p) Methods operator=() Declaration Iterator&GenericMemberIterator<Const, Encoding, Allocator>::operator=(const NonConstIterator&it) operator++() Declaration Iterator&GenericMemberIterator<Const, Encoding, Allocator>::operator++() operator--() Declaration Iterator&GenericMemberIterator<Const, Encoding, Allocator>::operator--() operator++() Declaration Iterator GenericMemberIterator<Const, Encoding, Allocator>::operator++(int) operator--() Declaration Iterator GenericMemberIterator<Const, Encoding, Allocator>::operator--(int) operator+() Declaration Iterator GenericMemberIterator<Const, Encoding, Allocator>::operator+(DifferenceType n) const operator-() Declaration Iterator GenericMemberIterator<Const, Encoding, Allocator>::operator-(DifferenceType n) const operator+=() Declaration Iterator&GenericMemberIterator<Const, Encoding, Allocator>::operator+=(DifferenceType n) operator-=() Declaration Iterator&GenericMemberIterator<Const, Encoding, Allocator>::operator-=(DifferenceType n) operator==() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator==(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const operator!=() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator!=(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const =() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator<=(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const =() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator<=(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const =() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator<=(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const =() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator>=(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const =() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator>=(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const =() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator>=(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const <() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator<(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const <() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator<(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const >() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator>(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const >() Declaration bool GenericMemberIterator<Const, Encoding, Allocator>::operator>(const GenericMemberIterator<Const_, Encoding, Allocator>&that) const operator*() Declaration Reference GenericMemberIterator<Const, Encoding, Allocator>::operator*() const >() Declaration Pointer GenericMemberIterator<Const, Encoding, Allocator>::operator->() const >() Declaration Pointer GenericMemberIterator<Const, Encoding, Allocator>::operator->() const operator[]() Declaration Reference GenericMemberIterator<Const, Encoding, Allocator>::operator[](DifferenceType n) const operator-() Distance. Declaration DifferenceType GenericMemberIterator<Const, Encoding, Allocator>::operator-(ConstIterator that) const"
  },
  "api/generic-member.html": {
    "href": "api/generic-member.html",
    "title": "Class GenericMember | qiotoolkit",
    "keywords": "Class GenericMember Name-value pair in a JSON object value. This class was internal to GenericValue. It used to be a inner struct. But a compiler (IBM XL C/C++ for AIX) have reported to have problem with that so it moved as a namespace scope struct. https://code.google.com/p/rapidjson/issues/detail?id=64 Inheritance GenericMember Constructors GenericMember() Copy constructor is not permitted. Declaration GenericMember<Encoding, Allocator>::GenericMember(const GenericMember&rhs) Methods operator=() Assignment with move semantics. rhs Source of the assignment. Its name and value will become a null value after assignment. Declaration GenericMember&GenericMember<Encoding, Allocator>::operator=(GenericMember&rhs) RAPIDJSON_NOEXCEPT"
  },
  "api/generic-memory-buffer.html": {
    "href": "api/generic-memory-buffer.html",
    "title": "Struct GenericMemoryBuffer | qiotoolkit",
    "keywords": "Struct GenericMemoryBuffer Represents an in-memory output byte stream. This class is mainly for being wrapped by EncodedOutputStream or AutoUTFOutputStream. It is similar to FileWriteBuffer but the destination is an in-memory buffer instead of a file. Differences between MemoryBuffer and StringBuffer: StringBuffer has Encoding but MemoryBuffer is only a byte buffer. StringBuffer::GetString() returns a null-terminated string. MemoryBuffer::GetBuffer() returns a buffer without terminator. Allocator type for allocating memory buffer. implements Stream concept Constructors GenericMemoryBuffer() Declaration GenericMemoryBuffer<Allocator>::GenericMemoryBuffer(Allocator *allocator=0, size_t capacity=kDefaultCapacity) Methods Put() Declaration void GenericMemoryBuffer<Allocator>::Put(Ch c) Flush() Declaration void GenericMemoryBuffer<Allocator>::Flush() Clear() Declaration void GenericMemoryBuffer<Allocator>::Clear() ShrinkToFit() Declaration void GenericMemoryBuffer<Allocator>::ShrinkToFit() Push() Declaration Ch* GenericMemoryBuffer<Allocator>::Push(size_t count) Pop() Declaration void GenericMemoryBuffer<Allocator>::Pop(size_t count) GetBuffer() Declaration const Ch* GenericMemoryBuffer<Allocator>::GetBuffer() const GetSize() Declaration size_t GenericMemoryBuffer<Allocator>::GetSize() const"
  },
  "api/generic-object.html": {
    "href": "api/generic-object.html",
    "title": "Class GenericObject | qiotoolkit",
    "keywords": "Class GenericObject Helper class for accessing Value of object type. Instance of this helper class is obtained by GenericValue::GetObject(). In addition to all APIs for array type, it provides range-based for loop if RAPIDJSON_HAS_CXX11_RANGE_FOR=1. Inheritance GenericObject Constructors GenericObject() Declaration GenericObject<Const, ValueT>::GenericObject(const GenericObject&rhs) GenericObject() Declaration GenericObject<Const, ValueT>::GenericObject() GenericObject() Declaration GenericObject<Const, ValueT>::GenericObject(ValueType&value) Methods operator=() Declaration GenericObject&GenericObject<Const, ValueT>::operator=(const GenericObject&rhs) ~GenericObject() Declaration GenericObject<Const, ValueT>::~GenericObject() &() Declaration GenericObject<Const, ValueT>::operator ValueType&() const &() Declaration GenericObject<Const, ValueT>::operator ValueType&() const MemberCount() Declaration SizeType GenericObject<Const, ValueT>::MemberCount() const MemberCapacity() Declaration SizeType GenericObject<Const, ValueT>::MemberCapacity() const ObjectEmpty() Declaration bool GenericObject<Const, ValueT>::ObjectEmpty() const operator[]() Declaration ValueType&GenericObject<Const, ValueT>::operator[](T *name) const operator[]() Declaration ValueType&GenericObject<Const, ValueT>::operator[](const GenericValue<EncodingType, SourceAllocator>&name) const MemberBegin() Declaration MemberIterator GenericObject<Const, ValueT>::MemberBegin() const MemberEnd() Declaration MemberIterator GenericObject<Const, ValueT>::MemberEnd() const MemberReserve() Declaration GenericObject GenericObject<Const, ValueT>::MemberReserve(SizeType newCapacity, AllocatorType&allocator) const HasMember() Declaration bool GenericObject<Const, ValueT>::HasMember(const Ch *name) const HasMember() Declaration bool GenericObject<Const, ValueT>::HasMember(const GenericValue<EncodingType, SourceAllocator>&name) const FindMember() Declaration MemberIterator GenericObject<Const, ValueT>::FindMember(const Ch *name) const FindMember() Declaration MemberIterator GenericObject<Const, ValueT>::FindMember(const GenericValue<EncodingType, SourceAllocator>&name) const AddMember() Declaration GenericObject GenericObject<Const, ValueT>::AddMember(ValueType&name, ValueType&value, AllocatorType&allocator) const AddMember() Declaration GenericObject GenericObject<Const, ValueT>::AddMember(ValueType&name, StringRefType value, AllocatorType&allocator) const RAPIDJSON_DISABLEIF_RETURN() Declaration GenericObject<Const, ValueT>::RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T>>),(ValueType&)) AddMember(ValueType&name AddMember() Declaration GenericObject GenericObject<Const, ValueT>::AddMember(StringRefType name, ValueType&value, AllocatorType&allocator) const AddMember() Declaration GenericObject GenericObject<Const, ValueT>::AddMember(StringRefType name, StringRefType value, AllocatorType&allocator) const RAPIDJSON_DISABLEIF_RETURN() Declaration GenericObject<Const, ValueT>::RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T>>),(GenericObject)) AddMember(StringRefType name RemoveAllMembers() Declaration void GenericObject<Const, ValueT>::RemoveAllMembers() RemoveMember() Declaration bool GenericObject<Const, ValueT>::RemoveMember(const Ch *name) const RemoveMember() Declaration bool GenericObject<Const, ValueT>::RemoveMember(const GenericValue<EncodingType, SourceAllocator>&name) const RemoveMember() Declaration MemberIterator GenericObject<Const, ValueT>::RemoveMember(MemberIterator m) const EraseMember() Declaration MemberIterator GenericObject<Const, ValueT>::EraseMember(ConstMemberIterator pos) const EraseMember() Declaration MemberIterator GenericObject<Const, ValueT>::EraseMember(ConstMemberIterator first, ConstMemberIterator last) const EraseMember() Declaration bool GenericObject<Const, ValueT>::EraseMember(const Ch *name) const EraseMember() Declaration bool GenericObject<Const, ValueT>::EraseMember(const GenericValue<EncodingType, SourceAllocator>&name) const"
  },
  "api/generic-pointer.html": {
    "href": "api/generic-pointer.html",
    "title": "Class GenericPointer | qiotoolkit",
    "keywords": "Class GenericPointer Represents a JSON Pointer. Use Pointer for UTF8 encoding and default allocator. This class implements RFC 6901 \"JavaScript Object Notation (JSON) Pointer\" (https://tools.ietf.org/html/rfc6901). A JSON pointer is for identifying a specific value in a JSON document (GenericDocument). It can simplify coding of DOM tree manipulation, because it can access multiple-level depth of DOM tree with single API call. After it parses a string representation (e.g. \"/foo/0\" or URI fragment representation (e.g. \"#/foo/0\") into its internal representation (tokens), it can be used to resolve a specific value in multiple documents, or sub-tree of documents. Contrary to GenericValue, Pointer can be copy constructed and copy assigned. Apart from assignment, a Pointer cannot be modified after construction. Although Pointer is very convenient, please aware that constructing Pointer involves parsing and dynamic memory allocation. A special constructor with user- supplied tokens eliminates these. GenericPointer depends on GenericDocument and GenericValue. ValueType The value type of the DOM tree. E.g. GenericValue<UTF8<> > Allocator The allocator type for allocating memory for internal representation. GenericPointer uses same encoding of ValueType. However, Allocator of GenericPointer is independent of Allocator of Value. Inheritance GenericPointer Constructors GenericPointer() Default constructor. Declaration GenericPointer<ValueType, Allocator>::GenericPointer(Allocator *allocator=0) GenericPointer() Constructor that parses a string or URI fragment representation. source A null-terminated, string or URI fragment representation of JSON pointer. allocator User supplied allocator for this pointer. If no allocator is provided, it creates a self-owned one. Declaration GenericPointer<ValueType, Allocator>::GenericPointer(const Ch *source, Allocator *allocator=0) GenericPointer() Constructor that parses a string or URI fragment representation, with length of the source string. source A string or URI fragment representation of JSON pointer. length Length of source. allocator User supplied allocator for this pointer. If no allocator is provided, it creates a self-owned one. Slightly faster than the overload without length. Declaration GenericPointer<ValueType, Allocator>::GenericPointer(const Ch *source, size_t length, Allocator *allocator=0) GenericPointer() Constructor with user-supplied tokens. This constructor let user supplies const array of tokens. This prevents the parsing process and eliminates allocation. This is preferred for memory constrained environments. tokens An constant array of tokens representing the JSON pointer. tokenCount Number of tokens. Example #define NAME(s) { s, sizeof(s) / sizeof(s[0]) - 1, kPointerInvalidIndex } #define INDEX(i) { #i, sizeof(#i) - 1, i } static const Pointer::Token kTokens[] = { NAME(\"foo\"), INDEX(123) }; static const Pointer p(kTokens, sizeof(kTokens) / sizeof(kTokens[0])); // Equivalent to static const Pointer p(\"/foo/123\"); #undef NAME #undef INDEX Declaration GenericPointer<ValueType, Allocator>::GenericPointer(const Token *tokens, size_t tokenCount) GenericPointer() Copy constructor. Declaration GenericPointer<ValueType, Allocator>::GenericPointer(const GenericPointer&rhs) GenericPointer() Copy constructor. Declaration GenericPointer<ValueType, Allocator>::GenericPointer(const GenericPointer&rhs, Allocator *allocator) Methods ~GenericPointer() Destructor. Declaration GenericPointer<ValueType, Allocator>::~GenericPointer() operator=() Assignment operator. Declaration GenericPointer&GenericPointer<ValueType, Allocator>::operator=(const GenericPointer&rhs) Swap() Swap the content of this pointer with an other. other The pointer to swap with. Constant complexity. Declaration GenericPointer&GenericPointer<ValueType, Allocator>::Swap(GenericPointer&other) RAPIDJSON_NOEXCEPT Append() Append a token and return a new Pointer. token Token to be appended. allocator Allocator for the newly return Pointer. A new Pointer with appended token. Declaration GenericPointer GenericPointer<ValueType, Allocator>::Append(const Token&token, Allocator *allocator=0) const Append() Append a name token with length, and return a new Pointer. name Name to be appended. length Length of name. allocator Allocator for the newly return Pointer. A new Pointer with appended token. Declaration GenericPointer GenericPointer<ValueType, Allocator>::Append(const Ch *name, SizeType length, Allocator *allocator=0) const RAPIDJSON_DISABLEIF_RETURN() Append a name token without length, and return a new Pointer. name Name (const Ch*) to be appended. allocator Allocator for the newly return Pointer. A new Pointer with appended token. Declaration GenericPointer<ValueType, Allocator>::RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch>>),(GenericPointer)) Append(T *name"
  },
  "api/generic-pointer/percent-encode-stream.html": {
    "href": "api/generic-pointer/percent-encode-stream.html",
    "title": "Class GenericPointer::PercentEncodeStream | qiotoolkit",
    "keywords": "Class GenericPointer::PercentEncodeStream A helper stream to encode character (UTF-8 code unit) into percent-encoded sequence. Inheritance GenericPointer::PercentEncodeStream Constructors PercentEncodeStream() Declaration GenericPointer<ValueType, Allocator>::PercentEncodeStream<OutputStream>::PercentEncodeStream(OutputStream&os) Methods Put() Declaration void GenericPointer<ValueType, Allocator>::PercentEncodeStream<OutputStream>::Put(char c)"
  },
  "api/generic-pointer/token.html": {
    "href": "api/generic-pointer/token.html",
    "title": "Struct GenericPointer::Token | qiotoolkit",
    "keywords": "Struct GenericPointer::Token A token is the basic units of internal representation. A JSON pointer string representation \"/foo/123\" is parsed to two tokens: \"foo\" and 123. 123 will be represented in both numeric form and string form. They are resolved according to the actual value type (object or array). For token that are not numbers, or the numeric value is out of bound (greater than limits of SizeType), they are only treated as string form (i.e. the token's index will be equal to kPointerInvalidIndex). This struct is public so that user can create a Pointer without parsing and allocation, using a special constructor."
  },
  "api/generic-reader.html": {
    "href": "api/generic-reader.html",
    "title": "Class GenericReader | qiotoolkit",
    "keywords": "Class GenericReader SAX-style JSON parser. Use Reader for UTF8 encoding and default allocator. GenericReader parses JSON text from a stream, and send events synchronously to an object implementing Handler concept. It needs to allocate a stack for storing a single decoded string during non-destructive parsing. For in-situ parsing, the decoded string is directly written to the source text string, no temporary buffer is required. A GenericReader object can be reused for parsing multiple JSON text. SourceEncoding Encoding of the input stream. TargetEncoding Encoding of the parse output. StackAllocator Allocator type for stack. Inheritance GenericReader Constructors GenericReader() Constructor. stackAllocator Optional allocator for allocating stack memory. (Only use for non-destructive parsing) stackCapacity stack capacity in bytes for storing a single decoded string. (Only use for non-destructive parsing) Declaration GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::GenericReader(StackAllocator *stackAllocator=0, size_t stackCapacity=kDefaultStackCapacity) GenericReader() Declaration GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::GenericReader(const GenericReader&) Methods Parse() Parse JSON text. parseFlags Combination of ParseFlag. InputStream Type of input stream, implementing Stream concept. Handler Type of handler, implementing Handler concept. is Input stream to be parsed. handler The handler to receive events. Whether the parsing is successful. Declaration ParseResult GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::Parse(InputStream&is, Handler&handler) Parse() Parse JSON text (with kParseDefaultFlags) InputStream Type of input stream, implementing Stream concept Handler Type of handler, implementing Handler concept. is Input stream to be parsed. handler The handler to receive events. Whether the parsing is successful. Declaration ParseResult GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::Parse(InputStream&is, Handler&handler) IterativeParseInit() Initialize JSON text token-by-token parsing. Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::IterativeParseInit() IterativeParseNext() Parse one token from JSON text. InputStream Type of input stream, implementing Stream concept Handler Type of handler, implementing Handler concept. is Input stream to be parsed. handler The handler to receive events. Whether the parsing is successful. Declaration bool GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::IterativeParseNext(InputStream&is, Handler&handler) IterativeParseComplete() Check if token-by-token parsing JSON text is complete. Whether the JSON has been fully decoded. Declaration RAPIDJSON_FORCEINLINE bool GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::IterativeParseComplete() const HasParseError() Whether a parse error has occurred in the last parsing. Declaration bool GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::HasParseError() const GetParseErrorCode() Get the ParseErrorCode of last parsing. Declaration ParseErrorCode GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::GetParseErrorCode() const GetErrorOffset() Get the position of last parsing error in input, 0 otherwise. Declaration size_t GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::GetErrorOffset() const SetParseError() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::SetParseError(ParseErrorCode code, size_t offset) operator=() Declaration GenericReader&GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::operator=(const GenericReader&) ClearStack() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ClearStack() SkipWhitespaceAndComments() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::SkipWhitespaceAndComments(InputStream&is) ParseObject() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ParseObject(InputStream&is, Handler&handler) ParseArray() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ParseArray(InputStream&is, Handler&handler) ParseNull() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ParseNull(InputStream&is, Handler&handler) ParseTrue() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ParseTrue(InputStream&is, Handler&handler) ParseFalse() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ParseFalse(InputStream&is, Handler&handler) ParseHex4() Declaration unsigned GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ParseHex4(InputStream&is, size_t escapeOffset) ParseString() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ParseString(InputStream&is, Handler&handler, bool isKey=false) ParseStringToStream() Declaration RAPIDJSON_FORCEINLINE void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ParseStringToStream(InputStream&is, OutputStream&os) ParseNumber() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ParseNumber(InputStream&is, Handler&handler) ParseValue() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ParseValue(InputStream&is, Handler&handler) Tokenize() Declaration RAPIDJSON_FORCEINLINE Token GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::Tokenize(Ch c) const Predict() Declaration RAPIDJSON_FORCEINLINE IterativeParsingState GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::Predict(IterativeParsingState state, Token token) const Transit() Declaration RAPIDJSON_FORCEINLINE IterativeParsingState GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::Transit(IterativeParsingState src, Token token, IterativeParsingState dst, InputStream&is, Handler&handler) HandleError() Declaration void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::HandleError(IterativeParsingState src, InputStream&is) IsIterativeParsingDelimiterState() Declaration RAPIDJSON_FORCEINLINE bool GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::IsIterativeParsingDelimiterState(IterativeParsingState s) const IsIterativeParsingCompleteState() Declaration RAPIDJSON_FORCEINLINE bool GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::IsIterativeParsingCompleteState(IterativeParsingState s) const IterativeParse() Declaration ParseResult GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::IterativeParse(InputStream&is, Handler&handler) Consume() Declaration static RAPIDJSON_FORCEINLINE bool GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::Consume(InputStream&is, typename InputStream::Ch expect) ScanCopyUnescapedString() Declaration static RAPIDJSON_FORCEINLINE void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ScanCopyUnescapedString(InputStream&, OutputStream&)"
  },
  "api/generic-reader/clear-stack-on-exit.html": {
    "href": "api/generic-reader/clear-stack-on-exit.html",
    "title": "Struct GenericReader::ClearStackOnExit | qiotoolkit",
    "keywords": "Struct GenericReader::ClearStackOnExit Constructors ClearStackOnExit() Declaration GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ClearStackOnExit::ClearStackOnExit(GenericReader&r) ClearStackOnExit() Declaration GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ClearStackOnExit::ClearStackOnExit(const ClearStackOnExit&) Methods ~ClearStackOnExit() Declaration GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ClearStackOnExit::~ClearStackOnExit() operator=() Declaration ClearStackOnExit&GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::ClearStackOnExit::operator=(const ClearStackOnExit&)"
  },
  "api/generic-reader/number-stream.html": {
    "href": "api/generic-reader/number-stream.html",
    "title": "Class GenericReader::NumberStream | qiotoolkit",
    "keywords": "Class GenericReader::NumberStream Inheritance GenericReader::NumberStream"
  },
  "api/generic-reader/number-stream/3/01-input-stream/00/01false/00/01false/01/4.html": {
    "href": "api/generic-reader/number-stream/3/01-input-stream/00/01false/00/01false/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods NumberStream() Declaration GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, false, false>::NumberStream(GenericReader&reader, InputStream&s) Peek() Declaration RAPIDJSON_FORCEINLINE Ch GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, false, false>::Peek() const TakePush() Declaration RAPIDJSON_FORCEINLINE Ch GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, false, false>::TakePush() Take() Declaration RAPIDJSON_FORCEINLINE Ch GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, false, false>::Take() Push() Declaration RAPIDJSON_FORCEINLINE void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, false, false>::Push(char) Tell() Declaration size_t GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, false, false>::Tell() Length() Declaration size_t GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, false, false>::Length() Pop() Declaration const char* GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, false, false>::Pop() operator=() Declaration NumberStream&GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, false, false>::operator=(const NumberStream&)"
  },
  "api/generic-reader/number-stream/3/01-input-stream/00/01true/00/01false/01/4.html": {
    "href": "api/generic-reader/number-stream/3/01-input-stream/00/01true/00/01false/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods NumberStream() Declaration GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, true, false>::NumberStream(GenericReader&reader, InputStream&is) TakePush() Declaration RAPIDJSON_FORCEINLINE Ch GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, true, false>::TakePush() Push() Declaration RAPIDJSON_FORCEINLINE void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, true, false>::Push(char c) Length() Declaration size_t GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, true, false>::Length() Pop() Declaration const char* GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, true, false>::Pop()"
  },
  "api/generic-reader/number-stream/3/01-input-stream/00/01true/00/01true/01/4.html": {
    "href": "api/generic-reader/number-stream/3/01-input-stream/00/01true/00/01true/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods NumberStream() Declaration GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, true, true>::NumberStream(GenericReader&reader, InputStream&is) Take() Declaration RAPIDJSON_FORCEINLINE Ch GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::NumberStream<InputStream, true, true>::Take()"
  },
  "api/generic-reader/stack-stream.html": {
    "href": "api/generic-reader/stack-stream.html",
    "title": "Class GenericReader::StackStream | qiotoolkit",
    "keywords": "Class GenericReader::StackStream Inheritance GenericReader::StackStream Constructors StackStream() Declaration GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::StackStream<CharType>::StackStream(internal::Stack<StackAllocator>&stack) StackStream() Declaration GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::StackStream<CharType>::StackStream(const StackStream&) Methods Put() Declaration RAPIDJSON_FORCEINLINE void GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::StackStream<CharType>::Put(Ch c) Push() Declaration RAPIDJSON_FORCEINLINE void* GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::StackStream<CharType>::Push(SizeType count) Length() Declaration size_t GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::StackStream<CharType>::Length() const Pop() Declaration Ch* GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::StackStream<CharType>::Pop() operator=() Declaration StackStream&GenericReader<SourceEncoding, TargetEncoding, StackAllocator>::StackStream<CharType>::operator=(const StackStream&)"
  },
  "api/generic-schema-document.html": {
    "href": "api/generic-schema-document.html",
    "title": "Class GenericSchemaDocument | qiotoolkit",
    "keywords": "Class GenericSchemaDocument JSON schema document. A JSON schema document is a compiled version of a JSON schema. It is basically a tree of internal::Schema. This is an immutable class (i.e. its instance cannot be modified after construction). ValueT Type of JSON value (e.g. Value ), which also determine the encoding. Allocator Allocator type for allocating memory of this document. Inheritance GenericSchemaDocument Constructors GenericSchemaDocument() Constructor. Compile a JSON document into schema document. document A JSON document as source. uri The base URI of this schema document for purposes of violation reporting. uriLength Length of name, in code points. remoteProvider An optional remote schema document provider for resolving remote reference. Can be null. allocator An optional allocator instance for allocating memory. Can be null. Declaration GenericSchemaDocument<ValueT, Allocator>::GenericSchemaDocument(const ValueType&document, const Ch *uri=0, SizeType uriLength=0, IRemoteSchemaDocumentProviderType *remoteProvider=0, Allocator *allocator=0) GenericSchemaDocument() Prohibit copying. Declaration GenericSchemaDocument<ValueT, Allocator>::GenericSchemaDocument(const GenericSchemaDocument&) Methods ~GenericSchemaDocument() Destructor. Declaration GenericSchemaDocument<ValueT, Allocator>::~GenericSchemaDocument() GetURI() Declaration const URIType&GenericSchemaDocument<ValueT, Allocator>::GetURI() const GetRoot() Get the root schema. Declaration const SchemaType&GenericSchemaDocument<ValueT, Allocator>::GetRoot() const operator=() Prohibit assignment. Declaration GenericSchemaDocument&GenericSchemaDocument<ValueT, Allocator>::operator=(const GenericSchemaDocument&) CreateSchemaRecursive() Declaration void GenericSchemaDocument<ValueT, Allocator>::CreateSchemaRecursive(const SchemaType **schema, const PointerType&pointer, const ValueType&v, const ValueType&document) CreateSchema() Declaration void GenericSchemaDocument<ValueT, Allocator>::CreateSchema(const SchemaType **schema, const PointerType&pointer, const ValueType&v, const ValueType&document) HandleRefSchema() Declaration bool GenericSchemaDocument<ValueT, Allocator>::HandleRefSchema(const PointerType&source, const SchemaType **schema, const ValueType&v, const ValueType&document) GetSchema() Declaration const SchemaType* GenericSchemaDocument<ValueT, Allocator>::GetSchema(const PointerType&pointer) const GetPointer() Declaration PointerType GenericSchemaDocument<ValueT, Allocator>::GetPointer(const SchemaType *schema) const GetTypeless() Declaration const SchemaType* GenericSchemaDocument<ValueT, Allocator>::GetTypeless() const"
  },
  "api/generic-schema-document/schema-entry.html": {
    "href": "api/generic-schema-document/schema-entry.html",
    "title": "Struct GenericSchemaDocument::SchemaEntry | qiotoolkit",
    "keywords": "Struct GenericSchemaDocument::SchemaEntry Constructors SchemaEntry() Declaration GenericSchemaDocument<ValueT, Allocator>::SchemaEntry::SchemaEntry(const PointerType&p, SchemaType *s, bool o, Allocator *allocator) Methods ~SchemaEntry() Declaration GenericSchemaDocument<ValueT, Allocator>::SchemaEntry::~SchemaEntry()"
  },
  "api/generic-schema-document/schema-ref-entry.html": {
    "href": "api/generic-schema-document/schema-ref-entry.html",
    "title": "Struct GenericSchemaDocument::SchemaRefEntry | qiotoolkit",
    "keywords": "Struct GenericSchemaDocument::SchemaRefEntry Constructors SchemaRefEntry() Declaration GenericSchemaDocument<ValueT, Allocator>::SchemaRefEntry::SchemaRefEntry(const PointerType&s, const PointerType&t, const SchemaType **outSchema, Allocator *allocator)"
  },
  "api/generic-schema-validator.html": {
    "href": "api/generic-schema-validator.html",
    "title": "Class GenericSchemaValidator | qiotoolkit",
    "keywords": "Class GenericSchemaValidator JSON Schema Validator. A SAX style JSON schema validator. It uses a GenericSchemaDocument to validate SAX events. It delegates the incoming SAX events to an output handler. The default output handler does nothing. It can be reused multiple times by calling Reset(). SchemaDocumentType Type of schema document. OutputHandler Type of output handler. Default handler does nothing. StateAllocator Allocator for storing the internal validation states. Inheritance GenericSchemaValidator Constructors GenericSchemaValidator() Constructor without output handler. schemaDocument The schema document to conform to. allocator Optional allocator for storing internal validation states. schemaStackCapacity Optional initial capacity of schema path stack. documentStackCapacity Optional initial capacity of document path stack. Declaration GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GenericSchemaValidator(const SchemaDocumentType&schemaDocument, StateAllocator *allocator=0, size_t schemaStackCapacity=kDefaultSchemaStackCapacity, size_t documentStackCapacity=kDefaultDocumentStackCapacity) GenericSchemaValidator() Constructor with output handler. schemaDocument The schema document to conform to. allocator Optional allocator for storing internal validation states. schemaStackCapacity Optional initial capacity of schema path stack. documentStackCapacity Optional initial capacity of document path stack. Declaration GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GenericSchemaValidator(const SchemaDocumentType&schemaDocument, OutputHandler&outputHandler, StateAllocator *allocator=0, size_t schemaStackCapacity=kDefaultSchemaStackCapacity, size_t documentStackCapacity=kDefaultDocumentStackCapacity) GenericSchemaValidator() Declaration GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GenericSchemaValidator(const SchemaDocumentType&schemaDocument, const SchemaType&root, const char *basePath, size_t basePathSize, StateAllocator *allocator=0, size_t schemaStackCapacity=kDefaultSchemaStackCapacity, size_t documentStackCapacity=kDefaultDocumentStackCapacity) Methods ~GenericSchemaValidator() Destructor. Declaration GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::~GenericSchemaValidator() Reset() Reset the internal states. Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::Reset() ResetError() Reset the error state. Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::ResetError() SetValidateFlags() Implementation of ISchemaValidator. Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::SetValidateFlags(unsigned flags) GetValidateFlags() Declaration virtual unsigned GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GetValidateFlags() const IsValid() Checks whether the current state is valid. Declaration virtual bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::IsValid() const GetError() Gets the error object. Declaration ValueType&GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GetError() GetError() Declaration const ValueType&GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GetError() const GetInvalidSchemaPointer() Gets the JSON pointer pointed to the invalid schema. Declaration PointerType GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GetInvalidSchemaPointer() const GetInvalidSchemaKeyword() Gets the keyword of invalid schema. Declaration const Ch* GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GetInvalidSchemaKeyword() const GetInvalidSchemaCode() Gets the error code of invalid schema. Declaration ValidateErrorCode GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GetInvalidSchemaCode() const GetInvalidDocumentPointer() Gets the JSON pointer pointed to the invalid value. Declaration PointerType GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GetInvalidDocumentPointer() const NotMultipleOf() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::NotMultipleOf(int64_t actual, const SValue&expected) NotMultipleOf() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::NotMultipleOf(uint64_t actual, const SValue&expected) NotMultipleOf() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::NotMultipleOf(double actual, const SValue&expected) AboveMaximum() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AboveMaximum(int64_t actual, const SValue&expected, bool exclusive) AboveMaximum() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AboveMaximum(uint64_t actual, const SValue&expected, bool exclusive) AboveMaximum() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AboveMaximum(double actual, const SValue&expected, bool exclusive) BelowMinimum() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::BelowMinimum(int64_t actual, const SValue&expected, bool exclusive) BelowMinimum() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::BelowMinimum(uint64_t actual, const SValue&expected, bool exclusive) BelowMinimum() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::BelowMinimum(double actual, const SValue&expected, bool exclusive) TooLong() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::TooLong(const Ch *str, SizeType length, SizeType expected) TooShort() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::TooShort(const Ch *str, SizeType length, SizeType expected) DoesNotMatch() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::DoesNotMatch(const Ch *str, SizeType length) DisallowedItem() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::DisallowedItem(SizeType index) TooFewItems() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::TooFewItems(SizeType actualCount, SizeType expectedCount) TooManyItems() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::TooManyItems(SizeType actualCount, SizeType expectedCount) DuplicateItems() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::DuplicateItems(SizeType index1, SizeType index2) TooManyProperties() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::TooManyProperties(SizeType actualCount, SizeType expectedCount) TooFewProperties() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::TooFewProperties(SizeType actualCount, SizeType expectedCount) StartMissingProperties() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::StartMissingProperties() AddMissingProperty() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddMissingProperty(const SValue&name) EndMissingProperties() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::EndMissingProperties() PropertyViolations() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::PropertyViolations(ISchemaValidator **subvalidators, SizeType count) DisallowedProperty() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::DisallowedProperty(const Ch *name, SizeType length) StartDependencyErrors() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::StartDependencyErrors() StartMissingDependentProperties() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::StartMissingDependentProperties() AddMissingDependentProperty() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddMissingDependentProperty(const SValue&targetName) EndMissingDependentProperties() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::EndMissingDependentProperties(const SValue&sourceName) AddDependencySchemaError() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddDependencySchemaError(const SValue&sourceName, ISchemaValidator *subvalidator) EndDependencyErrors() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::EndDependencyErrors() DisallowedValue() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::DisallowedValue(const ValidateErrorCode code=kValidateErrorEnum) StartDisallowedType() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::StartDisallowedType() AddExpectedType() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddExpectedType(const typename SchemaType::ValueType&expectedType) EndDisallowedType() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::EndDisallowedType(const typename SchemaType::ValueType&actualType) NotAllOf() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::NotAllOf(ISchemaValidator **subvalidators, SizeType count) NoneOf() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::NoneOf(ISchemaValidator **subvalidators, SizeType count) NotOneOf() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::NotOneOf(ISchemaValidator **subvalidators, SizeType count, bool matched=false) Disallowed() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::Disallowed() Null() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::Null() Bool() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::Bool(bool b) Int() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::Int(int i) Uint() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::Uint(unsigned u) Int64() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::Int64(int64_t i) Uint64() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::Uint64(uint64_t u) Double() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::Double(double d) RawNumber() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::RawNumber(const Ch *str, SizeType length, bool copy) String() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::String(const Ch *str, SizeType length, bool copy) StartObject() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::StartObject() Key() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::Key(const Ch *str, SizeType len, bool copy) EndObject() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::EndObject(SizeType memberCount) StartArray() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::StartArray() EndArray() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::EndArray(SizeType elementCount) CreateSchemaValidator() Declaration virtual ISchemaValidator* GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::CreateSchemaValidator(const SchemaType&root, const bool inheritContinueOnErrors) DestroySchemaValidator() Declaration virtual void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::DestroySchemaValidator(ISchemaValidator *validator) CreateHasher() Declaration virtual void* GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::CreateHasher() GetHashCode() Declaration virtual uint64_t GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GetHashCode(void *hasher) DestroryHasher() Declaration virtual void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::DestroryHasher(void *hasher) MallocState() Declaration virtual void* GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::MallocState(size_t size) FreeState() Declaration virtual void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::FreeState(void *p) GetStateAllocator() Declaration StateAllocator&GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GetStateAllocator() GetContinueOnErrors() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::GetContinueOnErrors() const BeginValue() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::BeginValue() EndValue() Declaration bool GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::EndValue() AppendToken() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AppendToken(const Ch *str, SizeType len) PushSchema() Declaration RAPIDJSON_FORCEINLINE void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::PushSchema(const SchemaType&schema) PopSchema() Declaration RAPIDJSON_FORCEINLINE void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::PopSchema() AddErrorInstanceLocation() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddErrorInstanceLocation(ValueType&result, bool parent) AddErrorSchemaLocation() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddErrorSchemaLocation(ValueType&result, PointerType schema=PointerType()) AddErrorCode() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddErrorCode(ValueType&result, const ValidateErrorCode code) AddError() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddError(ValueType&keyword, ValueType&error) AddCurrentError() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddCurrentError(const ValidateErrorCode code, bool parent=false) MergeError() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::MergeError(ValueType&other) AddNumberError() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddNumberError(const ValidateErrorCode code, ValueType&actual, const SValue&expected, const typename SchemaType::ValueType&(*exclusive)()=0) AddErrorArray() Declaration void GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::AddErrorArray(const ValidateErrorCode code, ISchemaValidator **subvalidators, SizeType count) CurrentSchema() Declaration const SchemaType&GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::CurrentSchema() const CurrentContext() Declaration Context&GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::CurrentContext() CurrentContext() Declaration const Context&GenericSchemaValidator<SchemaDocumentType, OutputHandler, StateAllocator>::CurrentContext() const"
  },
  "api/generic-stream-wrapper.html": {
    "href": "api/generic-stream-wrapper.html",
    "title": "Class GenericStreamWrapper | qiotoolkit",
    "keywords": "Class GenericStreamWrapper A Stream Wrapper. \\tThis string stream is a wrapper for any stream by just forwarding any \\treceived message to the origin stream. implements Stream concept Inheritance GenericStreamWrapper Constructors GenericStreamWrapper() Declaration GenericStreamWrapper<InputStream, Encoding>::GenericStreamWrapper(InputStream&is) Methods Peek() Declaration Ch GenericStreamWrapper<InputStream, Encoding>::Peek() const Take() Declaration Ch GenericStreamWrapper<InputStream, Encoding>::Take() Tell() Declaration size_t GenericStreamWrapper<InputStream, Encoding>::Tell() PutBegin() Declaration Ch* GenericStreamWrapper<InputStream, Encoding>::PutBegin() Put() Declaration void GenericStreamWrapper<InputStream, Encoding>::Put(Ch ch) Flush() Declaration void GenericStreamWrapper<InputStream, Encoding>::Flush() PutEnd() Declaration size_t GenericStreamWrapper<InputStream, Encoding>::PutEnd(Ch *ch) Peek4() Declaration const Ch* GenericStreamWrapper<InputStream, Encoding>::Peek4() const GetType() Declaration UTFType GenericStreamWrapper<InputStream, Encoding>::GetType() const HasBOM() Declaration bool GenericStreamWrapper<InputStream, Encoding>::HasBOM() const"
  },
  "api/generic-string-buffer.html": {
    "href": "api/generic-string-buffer.html",
    "title": "Class GenericStringBuffer | qiotoolkit",
    "keywords": "Class GenericStringBuffer Represents an in-memory output stream. Encoding Encoding of the stream. Allocator type for allocating memory buffer. implements Stream concept Inheritance GenericStringBuffer Constructors GenericStringBuffer() Declaration GenericStringBuffer<Encoding, Allocator>::GenericStringBuffer(Allocator *allocator=0, size_t capacity=kDefaultCapacity) GenericStringBuffer() Declaration GenericStringBuffer<Encoding, Allocator>::GenericStringBuffer(const GenericStringBuffer&) Methods Put() Declaration void GenericStringBuffer<Encoding, Allocator>::Put(Ch c) PutUnsafe() Declaration void GenericStringBuffer<Encoding, Allocator>::PutUnsafe(Ch c) Flush() Declaration void GenericStringBuffer<Encoding, Allocator>::Flush() Clear() Declaration void GenericStringBuffer<Encoding, Allocator>::Clear() ShrinkToFit() Declaration void GenericStringBuffer<Encoding, Allocator>::ShrinkToFit() Reserve() Declaration void GenericStringBuffer<Encoding, Allocator>::Reserve(size_t count) Push() Declaration Ch* GenericStringBuffer<Encoding, Allocator>::Push(size_t count) PushUnsafe() Declaration Ch* GenericStringBuffer<Encoding, Allocator>::PushUnsafe(size_t count) Pop() Declaration void GenericStringBuffer<Encoding, Allocator>::Pop(size_t count) GetString() Declaration const Ch* GenericStringBuffer<Encoding, Allocator>::GetString() const GetSize() Get the size of string in bytes in the string buffer. Declaration size_t GenericStringBuffer<Encoding, Allocator>::GetSize() const GetLength() Get the length of string in Ch in the string buffer. Declaration size_t GenericStringBuffer<Encoding, Allocator>::GetLength() const operator=() Declaration GenericStringBuffer&GenericStringBuffer<Encoding, Allocator>::operator=(const GenericStringBuffer&)"
  },
  "api/generic-string-ref.html": {
    "href": "api/generic-string-ref.html",
    "title": "Struct GenericStringRef | qiotoolkit",
    "keywords": "Struct GenericStringRef Reference to a constant string (not taking a copy) CharType character type of the string This helper class is used to automatically infer constant string references for string literals, especially from const (!) character arrays. The main use is for creating JSON string values without copying the source string via an Allocator. This requires that the referenced string pointers have a sufficient lifetime, which exceeds the lifetime of the associated GenericValue. Example Value v(\"foo\"); // ok, no need to copy & calculate length const char foo[] = \"foo\"; v.SetString(foo); // ok const char* bar = foo; // Value x(bar); // not ok, can't rely on bar's lifetime Value x(StringRef(bar)); // lifetime explicitly guaranteed by user Value y(StringRef(bar, 3)); // ok, explicitly pass length StringRef, GenericValue::SetString Constructors GenericStringRef() Create string reference from const character array. This constructor implicitly creates a constant string reference from a const character array. It has better performance than StringRef(const CharType*) by inferring the string length from the array length, and also supports strings containing null characters. N length of the string, automatically inferred str Constant character array, lifetime assumed to be longer than the use of the string in e.g. a GenericValue s == str Constant complexity. There is a hidden, private overload to disallow references to non-const character arrays to be created via this constructor. By this, e.g. function-scope arrays used to be filled via snprintf are excluded from consideration. In such cases, the referenced string should be copied to the GenericValue instead. Declaration GenericStringRef<CharType>::GenericStringRef(const CharType(&str)[N]) RAPIDJSON_NOEXCEPT GenericStringRef() Explicitly create string reference from const character pointer. This constructor can be used to explicitly create a reference to a constant string pointer. StringRef(const CharType*) str Constant character pointer, lifetime assumed to be longer than the use of the string in e.g. a GenericValue s == str There is a hidden, private overload to disallow references to non-const character arrays to be created via this constructor. By this, e.g. function-scope arrays used to be filled via snprintf are excluded from consideration. In such cases, the referenced string should be copied to the GenericValue instead. Declaration GenericStringRef<CharType>::GenericStringRef(const CharType *str) GenericStringRef() Create constant string reference from pointer and length. str constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue len length of the string, excluding the trailing NULL terminator s == str && length == len Constant complexity. Declaration GenericStringRef<CharType>::GenericStringRef(const CharType *str, SizeType len) GenericStringRef() Declaration GenericStringRef<CharType>::GenericStringRef(const GenericStringRef&rhs) GenericStringRef() Disallow construction from non-const array. Declaration GenericStringRef<CharType>::GenericStringRef(CharType(&str)[N]) Methods operator const Ch *() implicit conversion to plain CharType pointer Declaration GenericStringRef<CharType>::operator const Ch *() const NotNullStrLen() Declaration SizeType GenericStringRef<CharType>::NotNullStrLen(const CharType *str) operator=() Copy assignment operator not permitted - immutable type. Declaration GenericStringRef&GenericStringRef<CharType>::operator=(const GenericStringRef&rhs) StringRef() Mark a character pointer as constant string. Mark a plain character pointer as a \"string literal\". This function can be used to avoid copying a character string to be referenced as a value in a JSON GenericValue object, if the string's lifetime is known to be valid long enough. CharType Character type of the string str Constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue GenericStringRef string reference object GenericValue::GenericValue(StringRefType), GenericValue::operator=(StringRefType), GenericValue::SetString(StringRefType), GenericValue::PushBack(StringRefType, Allocator&), GenericValue::AddMember Declaration GenericStringRef<CharType>StringRef(const CharType *str) StringRef() Mark a character pointer as constant string. Mark a plain character pointer as a \"string literal\". This function can be used to avoid copying a character string to be referenced as a value in a JSON GenericValue object, if the string's lifetime is known to be valid long enough. This version has better performance with supplied length, and also supports string containing null characters. CharType character type of the string str Constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue length The length of source string. GenericStringRef string reference object Declaration GenericStringRef<CharType>StringRef(const CharType *str, size_t length)"
  },
  "api/generic-string-stream.html": {
    "href": "api/generic-string-stream.html",
    "title": "Struct GenericStringStream | qiotoolkit",
    "keywords": "Struct GenericStringStream Read-only string stream. implements Stream concept Constructors GenericStringStream() Declaration GenericStringStream<Encoding>::GenericStringStream(const Ch *src) Methods Peek() Declaration Ch GenericStringStream<Encoding>::Peek() const Take() Declaration Ch GenericStringStream<Encoding>::Take() Tell() Declaration size_t GenericStringStream<Encoding>::Tell() const PutBegin() Declaration Ch* GenericStringStream<Encoding>::PutBegin() Put() Declaration void GenericStringStream<Encoding>::Put(Ch) Flush() Declaration void GenericStringStream<Encoding>::Flush() PutEnd() Declaration size_t GenericStringStream<Encoding>::PutEnd(Ch *)"
  },
  "api/generic-value.html": {
    "href": "api/generic-value.html",
    "title": "Class GenericValue | qiotoolkit",
    "keywords": "Class GenericValue Represents a JSON value. Use Value for UTF8 encoding and default allocator. A JSON value can be one of 7 types. This class is a variant type supporting these types. Use the Value if UTF8 and default allocator Encoding Encoding of the value. (Even non-string values need to have the same encoding in a document) Allocator Allocator type for allocating memory of object, array and string. Inheritance GenericValue Constructors GenericValue() Default constructor creates a null value. Declaration GenericValue<Encoding, Allocator>::GenericValue() RAPIDJSON_NOEXCEPT GenericValue() Constructor with JSON value type. This creates a Value of specified type with default content. type Type of the value. Default content for number is zero. Declaration GenericValue<Encoding, Allocator>::GenericValue(Type type) RAPIDJSON_NOEXCEPT GenericValue() Explicit copy constructor (with allocator) Creates a copy of a Value by using the given Allocator SourceAllocator allocator of rhs rhs Value to copy from (read-only) allocator Allocator for allocating copied elements and buffers. Commonly use GenericDocument::GetAllocator(). copyConstStrings Force copying of constant strings (e.g. referencing an in-situ buffer) CopyFrom() Declaration GenericValue<Encoding, Allocator>::GenericValue(const GenericValue<Encoding, SourceAllocator>&rhs, Allocator&allocator, bool copyConstStrings=false) GenericValue() Constructor for boolean value. b Boolean value This constructor is limited to real boolean values and rejects implicitly converted types like arbitrary pointers. Use an explicit cast to bool, if you want to construct a boolean JSON value in such cases. Declaration GenericValue<Encoding, Allocator>::GenericValue(T b, RAPIDJSON_ENABLEIF((internal::IsSame<bool, T>))) RAPIDJSON_NOEXCEPT GenericValue() Constructor for int value. Declaration GenericValue<Encoding, Allocator>::GenericValue(int i) RAPIDJSON_NOEXCEPT GenericValue() Constructor for unsigned value. Declaration GenericValue<Encoding, Allocator>::GenericValue(unsigned u) RAPIDJSON_NOEXCEPT GenericValue() Constructor for int64_t value. Declaration GenericValue<Encoding, Allocator>::GenericValue(int64_t i64) RAPIDJSON_NOEXCEPT GenericValue() Constructor for uint64_t value. Declaration GenericValue<Encoding, Allocator>::GenericValue(uint64_t u64) RAPIDJSON_NOEXCEPT GenericValue() Constructor for double value. Declaration GenericValue<Encoding, Allocator>::GenericValue(double d) RAPIDJSON_NOEXCEPT GenericValue() Constructor for float value. Declaration GenericValue<Encoding, Allocator>::GenericValue(float f) RAPIDJSON_NOEXCEPT GenericValue() Constructor for constant string (i.e. do not make a copy of string) Declaration GenericValue<Encoding, Allocator>::GenericValue(const Ch *s, SizeType length) RAPIDJSON_NOEXCEPT GenericValue() Constructor for constant string (i.e. do not make a copy of string) Declaration GenericValue<Encoding, Allocator>::GenericValue(StringRefType s) RAPIDJSON_NOEXCEPT GenericValue() Constructor for copy-string (i.e. do make a copy of string) Declaration GenericValue<Encoding, Allocator>::GenericValue(const Ch *s, SizeType length, Allocator&allocator) GenericValue() Constructor for copy-string (i.e. do make a copy of string) Declaration GenericValue<Encoding, Allocator>::GenericValue(const Ch *s, Allocator&allocator) GenericValue() Constructor for Array. a An array obtained by GetArray(). Array is always pass-by-value. the source array is moved into this value and the sourec array becomes empty. Declaration GenericValue<Encoding, Allocator>::GenericValue(Array a) RAPIDJSON_NOEXCEPT GenericValue() Constructor for Object. o An object obtained by GetObject(). Object is always pass-by-value. the source object is moved into this value and the sourec object becomes empty. Declaration GenericValue<Encoding, Allocator>::GenericValue(Object o) RAPIDJSON_NOEXCEPT GenericValue() Copy constructor is not permitted. Declaration GenericValue<Encoding, Allocator>::GenericValue(const GenericValue&rhs) Methods ~GenericValue() Destructor. Need to destruct elements of array, members of object, or copy-string. Declaration GenericValue<Encoding, Allocator>::~GenericValue() operator=() Assignment with move semantics. rhs Source of the assignment. It will become a null value after assignment. Declaration GenericValue&GenericValue<Encoding, Allocator>::operator=(GenericValue&rhs) RAPIDJSON_NOEXCEPT operator=() Assignment of constant string reference (no copy) str Constant string reference to be assigned This overload is needed to avoid clashes with the generic primitive type assignment overload below. GenericStringRef, operator=(T) Declaration GenericValue&GenericValue<Encoding, Allocator>::operator=(StringRefType str) RAPIDJSON_NOEXCEPT RAPIDJSON_DISABLEIF_RETURN() Assignment with primitive types. T Either Type, int, unsigned, int64_t, uint64_t value The value to be assigned. The source type T explicitly disallows all pointer types, especially (const) Ch. This helps avoiding implicitly referencing character strings with insufficient lifetime, use SetString(const Ch, Allocator&) (for copying) or StringRef() (to explicitly mark the pointer as constant) instead. All other pointer types would implicitly convert to bool, use SetBool() instead. Set boolean value Declaration GenericValue<Encoding, Allocator>::RAPIDJSON_DISABLEIF_RETURN((internal::IsPointer<T>),(GenericValue&)) operator GetStringPointer() Declaration const RAPIDJSON_FORCEINLINE Ch* GenericValue<Encoding, Allocator>::GetStringPointer() const SetStringPointer() Declaration const RAPIDJSON_FORCEINLINE Ch* GenericValue<Encoding, Allocator>::SetStringPointer(const Ch *str) GetElementsPointer() Declaration RAPIDJSON_FORCEINLINE GenericValue* GenericValue<Encoding, Allocator>::GetElementsPointer() const SetElementsPointer() Declaration RAPIDJSON_FORCEINLINE GenericValue* GenericValue<Encoding, Allocator>::SetElementsPointer(GenericValue *elements) GetMembersPointer() Declaration RAPIDJSON_FORCEINLINE Member* GenericValue<Encoding, Allocator>::GetMembersPointer() const SetMembersPointer() Declaration RAPIDJSON_FORCEINLINE Member* GenericValue<Encoding, Allocator>::SetMembersPointer(Member *members) DoAllocMembers() Declaration RAPIDJSON_FORCEINLINE Member* GenericValue<Encoding, Allocator>::DoAllocMembers(SizeType capacity, Allocator&allocator) DoReserveMembers() Declaration void GenericValue<Encoding, Allocator>::DoReserveMembers(SizeType newCapacity, Allocator&allocator) DoFindMember() Declaration MemberIterator GenericValue<Encoding, Allocator>::DoFindMember(const GenericValue<Encoding, SourceAllocator>&name) DoClearMembers() Declaration void GenericValue<Encoding, Allocator>::DoClearMembers() DoFreeMembers() Declaration void GenericValue<Encoding, Allocator>::DoFreeMembers() DoAddMember() Declaration void GenericValue<Encoding, Allocator>::DoAddMember(GenericValue&name, GenericValue&value, Allocator&allocator) DoRemoveMember() Declaration MemberIterator GenericValue<Encoding, Allocator>::DoRemoveMember(MemberIterator m) DoEraseMembers() Declaration MemberIterator GenericValue<Encoding, Allocator>::DoEraseMembers(ConstMemberIterator first, ConstMemberIterator last) DoCopyMembers() Declaration void GenericValue<Encoding, Allocator>::DoCopyMembers(const GenericValue<Encoding, SourceAllocator>&rhs, Allocator&allocator, bool copyConstStrings) SetArrayRaw() Declaration void GenericValue<Encoding, Allocator>::SetArrayRaw(GenericValue *values, SizeType count, Allocator&allocator) SetObjectRaw() Initialize this value as object with initial data, without calling destructor. Declaration void GenericValue<Encoding, Allocator>::SetObjectRaw(Member *members, SizeType count, Allocator&allocator) SetStringRaw() Initialize this value as constant string, without calling destructor. Declaration void GenericValue<Encoding, Allocator>::SetStringRaw(StringRefType s) RAPIDJSON_NOEXCEPT SetStringRaw() Initialize this value as copy string with initial data, without calling destructor. Declaration void GenericValue<Encoding, Allocator>::SetStringRaw(StringRefType s, Allocator&allocator) RawAssign() Assignment without calling destructor. Declaration void GenericValue<Encoding, Allocator>::RawAssign(GenericValue&rhs) RAPIDJSON_NOEXCEPT StringEqual() Declaration bool GenericValue<Encoding, Allocator>::StringEqual(const GenericValue<Encoding, SourceAllocator>&rhs) const DataString() Declaration static const RAPIDJSON_FORCEINLINE Ch* GenericValue<Encoding, Allocator>::DataString(const Data&data) DataStringLength() Declaration static RAPIDJSON_FORCEINLINE SizeType GenericValue<Encoding, Allocator>::DataStringLength(const Data&data)"
  },
  "api/generic-value/array-data.html": {
    "href": "api/generic-value/array-data.html",
    "title": "Struct GenericValue::ArrayData | qiotoolkit",
    "keywords": "Struct GenericValue::ArrayData"
  },
  "api/generic-value/flag.html": {
    "href": "api/generic-value/flag.html",
    "title": "Struct GenericValue::Flag | qiotoolkit",
    "keywords": "Struct GenericValue::Flag"
  },
  "api/generic-value/number/i.html": {
    "href": "api/generic-value/number/i.html",
    "title": "Struct GenericValue::Number::I | qiotoolkit",
    "keywords": "Struct GenericValue::Number::I"
  },
  "api/generic-value/number/u.html": {
    "href": "api/generic-value/number/u.html",
    "title": "Struct GenericValue::Number::U | qiotoolkit",
    "keywords": "Struct GenericValue::Number::U"
  },
  "api/generic-value/object-data.html": {
    "href": "api/generic-value/object-data.html",
    "title": "Struct GenericValue::ObjectData | qiotoolkit",
    "keywords": "Struct GenericValue::ObjectData"
  },
  "api/generic-value/short-string.html": {
    "href": "api/generic-value/short-string.html",
    "title": "Struct GenericValue::ShortString | qiotoolkit",
    "keywords": "Struct GenericValue::ShortString Methods Usable() Declaration static bool GenericValue<Encoding, Allocator>::ShortString::Usable(SizeType len) SetLength() Declaration void GenericValue<Encoding, Allocator>::ShortString::SetLength(SizeType len) GetLength() Declaration SizeType GenericValue<Encoding, Allocator>::ShortString::GetLength() const"
  },
  "api/generic-value/string.html": {
    "href": "api/generic-value/string.html",
    "title": "Struct GenericValue::String | qiotoolkit",
    "keywords": "Struct GenericValue::String"
  },
  "api/graph/clustering.html": {
    "href": "api/graph/clustering.html",
    "title": "Class graph::Clustering | qiotoolkit",
    "keywords": "Class graph::Clustering Clustering coefficient (global and average of local). Note There are open questions on how to generalize the clustering coefficient for weighter graphs and hyper edges. Inheritance graph::Property graph::Clustering Inherited Members ~Property Methods compute() Declaration utils::Structure graph::Clustering<Graph>::compute(const Graph&g) const override"
  },
  "api/graph/compact-graph-visitor.html": {
    "href": "api/graph/compact-graph-visitor.html",
    "title": "Class graph::CompactGraphVisitor | qiotoolkit",
    "keywords": "Class graph::CompactGraphVisitor Inheritance graph::CompactGraphVisitor Constructors CompactGraphVisitor() Declaration graph::CompactGraphVisitor::CompactGraphVisitor() Methods reset() Declaration void graph::CompactGraphVisitor::reset()"
  },
  "api/graph/compact-graph.html": {
    "href": "api/graph/compact-graph.html",
    "title": "Class graph::CompactGraph | qiotoolkit",
    "keywords": "Class graph::CompactGraph Save graph mode of ising and pubo mode in compact format (BitStream) Inheritance utils::Component graph::CompactGraph Inherited Members render ~Component Component get_status param get_class_name Constructors CompactGraph() Declaration graph::CompactGraph<ELEMTYPE>::CompactGraph() Methods set_allow_dup_merge() Declaration void graph::CompactGraph<ELEMTYPE>::set_allow_dup_merge(bool value) get_const_cost() Declaration double graph::CompactGraph<ELEMTYPE>::get_const_cost() const is_empty() Declaration bool graph::CompactGraph<ELEMTYPE>::is_empty() const configure() Declaration void graph::CompactGraph<ELEMTYPE>::configure(Configuration_T&config) configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void graph::CompactGraph<ELEMTYPE>::configure(const utils::Json&) override init() Declaration void graph::CompactGraph<ELEMTYPE>::init() nodes_size() Declaration size_t graph::CompactGraph<ELEMTYPE>::nodes_size() const edges_size() Declaration size_t graph::CompactGraph<ELEMTYPE>::edges_size() const is_rescaled() Declaration bool graph::CompactGraph<ELEMTYPE>::is_rescaled() const rescale() Declaration void graph::CompactGraph<ELEMTYPE>::rescale() get_scale_factor() Declaration double graph::CompactGraph<ELEMTYPE>::get_scale_factor() const map_output() Declaration int graph::CompactGraph<ELEMTYPE>::map_output(int internal_id) const output_map() Declaration const std::map<int, int>&graph::CompactGraph<ELEMTYPE>::output_map() const edge() Declaration const Edge_T&graph::CompactGraph<ELEMTYPE>::edge(size_t edge_id) const read_next_neig() Declaration uint64_t graph::CompactGraph<ELEMTYPE>::read_next_neig(CompactGraphVisitor&reader) const read_next_coeff() Declaration double graph::CompactGraph<ELEMTYPE>::read_next_coeff(CompactGraphVisitor&reader) const is_edge_end() Declaration bool graph::CompactGraph<ELEMTYPE>::is_edge_end(uint32_t value) const is_node_end() Declaration bool graph::CompactGraph<ELEMTYPE>::is_node_end(uint32_t value) const get_locality() Declaration uint32_t graph::CompactGraph<ELEMTYPE>::get_locality() const get_min_locality() Declaration uint32_t graph::CompactGraph<ELEMTYPE>::get_min_locality() const get_avg_locality() Declaration double graph::CompactGraph<ELEMTYPE>::get_avg_locality() const get_accumulated_dependent_vars() Declaration uint64_t graph::CompactGraph<ELEMTYPE>::get_accumulated_dependent_vars() const get_max_coupling_magnitude() Declaration double graph::CompactGraph<ELEMTYPE>::get_max_coupling_magnitude() const get_min_coupling_magnitude() Declaration double graph::CompactGraph<ELEMTYPE>::get_min_coupling_magnitude() const get_sum_coefficient_degrees_total() Declaration uint64_t graph::CompactGraph<ELEMTYPE>::get_sum_coefficient_degrees_total() const estimate_max_cost_diff() Declaration double graph::CompactGraph<ELEMTYPE>::estimate_max_cost_diff() const get_node_name_to_id_map() Declaration const std::map<int, int>&graph::CompactGraph<ELEMTYPE>::get_node_name_to_id_map() const"
  },
  "api/graph/cost-edge.html": {
    "href": "api/graph/cost-edge.html",
    "title": "Class graph::CostEdge | qiotoolkit",
    "keywords": "Class graph::CostEdge Edge subclass with an associated cost. This attaches a Cost (default type: double) to each edge in a graph. This is used, for instance, to represent the coefficients in the graph representation of an Ising cost function: Inheritance graph::Edge graph::CostEdge Inherited Members nodes_count clear_node_ids Edge Edge remove_node_id num_nodes add_node_id sort_node_ids node_ids ~Component Component param Constructors CostEdge() Declaration graph::CostEdge<Cost>::CostEdge() CostEdge() Declaration graph::CostEdge<Cost>::CostEdge(Cost c) CostEdge() Declaration graph::CostEdge<Cost>::CostEdge(Cost c, const std::vector<int>&node_ids) Methods cost() Accessor for the cost. Declaration Cost graph::CostEdge<Cost>::cost() const set_cost() Setter for the cost. Declaration void graph::CostEdge<Cost>::set_cost(Cost cost) configure() Serialize as a regular edge with an entry \"c\" for the cost. Declaration void graph::CostEdge<Cost>::configure(const utils::Json&json) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure graph::CostEdge<Cost>::render() const override get_status() get_status shows a simplified state representation Like render, this produces a structured representation of the object's state. However, it is intended to be simpler in nature with the purpose of rendering the object during stream-output and logging. By default, it will fall back to the full render, but overloading this allows distinguising how the object looks during LOG vs full output. Declaration utils::Structure graph::CostEdge<Cost>::get_status() const override get_class_name() get_class_name shows an identifier of the (derived) class name Its primary use is for type identification during stream output and logging, where a component is rendered as <ClassName: status>. Example: {c++} MyClass : public Component {} // This will render as '<MyClass>' MyClass my_object; std::cout << my_object << std::endl; Note You do not need to overload this method unless you want to change the output of the default implementation. Declaration std::string graph::CostEdge<Cost>::get_class_name() const override rescale() Declaration void graph::CostEdge<Cost>::rescale(double scale_factor) override memory_estimate() Declaration static size_t graph::CostEdge<Cost>::memory_estimate(size_t num_nodes)"
  },
  "api/graph/cost-edge/get/cost.html": {
    "href": "api/graph/cost-edge/get/cost.html",
    "title": "Struct graph::CostEdge::Get_Cost | qiotoolkit",
    "keywords": "Struct graph::CostEdge::Get_Cost Methods get() Declaration static Cost&graph::CostEdge<Cost>::Get_Cost::get(CostEdge&e) get_key() Declaration static std::string graph::CostEdge<Cost>::Get_Cost::get_key()"
  },
  "api/graph/couplings.html": {
    "href": "api/graph/couplings.html",
    "title": "Class graph::Couplings | qiotoolkit",
    "keywords": "Class graph::Couplings Coupling strength statistics. Produces an average and distribution of the coupling strength. Inheritance graph::Property graph::Couplings Inherited Members ~Property Methods compute() Declaration utils::Structure graph::Couplings<Graph>::compute(const Graph&g) const override"
  },
  "api/graph/degree.html": {
    "href": "api/graph/degree.html",
    "title": "Class graph::Degree | qiotoolkit",
    "keywords": "Class graph::Degree Degree. Histogram and average degree of the nodes in the graph. Inheritance graph::Property graph::Degree Inherited Members ~Property Methods compute() Declaration utils::Structure graph::Degree<Graph>::compute(const Graph&g) const override"
  },
  "api/graph/edge-with-face.html": {
    "href": "api/graph/edge-with-face.html",
    "title": "Class graph::EdgeWithFace | qiotoolkit",
    "keywords": "Class graph::EdgeWithFace This edge class extends the CostEdge class. The key difference is that EdgeWithFace objects maintain a face ID to which the edge belongs. No validation on an edge's nodes belonging to the face is handled here. Inheritance graph::CostEdge graph::EdgeWithFace Inherited Members CostEdge set_cost CostEdge configure CostEdge rescale get_status get_class_name render cost nodes_count clear_node_ids Edge Edge remove_node_id num_nodes render add_node_id sort_node_ids get_status node_ids ~Component Component param Constructors EdgeWithFace() Constructor with node IDs list and face ID initialization. Declaration graph::EdgeWithFace<Cost>::EdgeWithFace() EdgeWithFace() Declaration graph::EdgeWithFace<Cost>::EdgeWithFace(Cost c) EdgeWithFace() Declaration graph::EdgeWithFace<Cost>::EdgeWithFace(Cost c, const std::vector<int>&node_ids) Methods face_id() Accessor and setter for the face id. Each edge has just one face. Declaration int graph::EdgeWithFace<Cost>::face_id() const set_face_id() Declaration void graph::EdgeWithFace<Cost>::set_face_id(int face_id) get_class_name() get_class_name shows an identifier of the (derived) class name Its primary use is for type identification during stream output and logging, where a component is rendered as <ClassName: status>. Example: {c++} MyClass : public Component {} // This will render as '<MyClass>' MyClass my_object; std::cout << my_object << std::endl; Note You do not need to overload this method unless you want to change the output of the default implementation. Declaration std::string graph::EdgeWithFace<Cost>::get_class_name() const override memory_estimate() Declaration static size_t graph::EdgeWithFace<Cost>::memory_estimate(size_t num_nodes)"
  },
  "api/graph/edge.html": {
    "href": "api/graph/edge.html",
    "title": "Class graph::Edge | qiotoolkit",
    "keywords": "Class graph::Edge Base representation of an edge. An edge consists of a list of ids of nodes that are part of it. For a regular graph, this list of nodes would always have lenght 2; in the case of a hypergraph it will typically be 2+. There is currently no support for directed graphs. Note A node does not know its own id as this information can change when the graph is mutated. Inheritance utils::Component graph::Edge graph::CostEdge Inherited Members ~Component Component param get_class_name Constructors Edge() Default constructor for an empty edge. Declaration graph::Edge::Edge() Edge() Constructor with node list initialization. Declaration graph::Edge::Edge(const std::vector<int>&node_ids) Methods node_ids() Accessor for the list of node ids. Declaration const std::vector<int>&graph::Edge::node_ids() const clear_node_ids() Remove all node_ids from this edge. Declaration void graph::Edge::clear_node_ids() sort_node_ids() Order the node_ids ascendingly. Declaration void graph::Edge::sort_node_ids() add_node_id() Append a node at the end of the node_id list. Declaration void graph::Edge::add_node_id(int node_id) remove_node_id() Find and remove a node from the list. This will remove exactly one instance if one is found, zero otherwise. Declaration void graph::Edge::remove_node_id(int node_id) configure() Serialize the edge's node_ids under [\"ids\"]. Declaration void graph::Edge::configure(const utils::Json&json) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure graph::Edge::render() const override get_status() get_status shows a simplified state representation Like render, this produces a structured representation of the object's state. However, it is intended to be simpler in nature with the purpose of rendering the object during stream-output and logging. By default, it will fall back to the full render, but overloading this allows distinguising how the object looks during LOG vs full output. Declaration utils::Structure graph::Edge::get_status() const override rescale() Declaration virtual void graph::Edge::rescale(double scale_factor) nodes_count() Declaration size_t graph::Edge::nodes_count() const num_nodes() Declaration size_t graph::Edge::num_nodes(const utils::Json&json) memory_estimate() Declaration static size_t graph::Edge::memory_estimate(size_t num_nodes)"
  },
  "api/graph/edge/get/node/ids.html": {
    "href": "api/graph/edge/get/node/ids.html",
    "title": "Struct graph::Edge::Get_Node_Ids | qiotoolkit",
    "keywords": "Struct graph::Edge::Get_Node_Ids Methods get() Declaration static std::vector<int>&graph::Edge::Get_Node_Ids::get(Edge&e) get_key() Declaration static std::string graph::Edge::Get_Node_Ids::get_key()"
  },
  "api/graph/face.html": {
    "href": "api/graph/face.html",
    "title": "Class graph::Face | qiotoolkit",
    "keywords": "Class graph::Face Base representation of a face. A face consists of a (face) type, a weight cost, and a list of component edge IDs Inheritance utils::Component graph::Face Inherited Members ~Component Component param get_class_name Constructors Face() Default constructor for an empty face. Declaration graph::Face<Cost>::Face() Face() Constructor with type. Declaration graph::Face<Cost>::Face(const FaceType type) Face() Constructor with cost. Declaration graph::Face<Cost>::Face(const Cost c) Face() Constructor with type and cost. Declaration graph::Face<Cost>::Face(const FaceType type, const Cost c) Face() Constructor with edge ID list initialization. Declaration graph::Face<Cost>::Face(const std::vector<int>&edge_ids) Face() Constructor with type, cost, and edge ID list initialization. Declaration graph::Face<Cost>::Face(const FaceType type, const Cost c, const std::vector<int>&edge_ids) Methods edge_ids() Accessor for the list of edge IDs. Declaration const std::vector<int>&graph::Face<Cost>::edge_ids() const type() Accessor for face type. Declaration const FaceType&graph::Face<Cost>::type() const cost() Accessor for the cost. Declaration Cost graph::Face<Cost>::cost() const set_cost() Setter for the cost. Declaration void graph::Face<Cost>::set_cost(Cost cost) sort_edge_ids() Order the list of edge IDs ascendingly. Declaration void graph::Face<Cost>::sort_edge_ids() add_edge_id() Append an edge ID to the end of the edge ID list. Declaration void graph::Face<Cost>::add_edge_id(int edge_id) remove_edge_id() Find and remove an edge ID from the edge ID list. Declaration void graph::Face<Cost>::remove_edge_id(int edge_id) configure() Serialize the face. Declaration void graph::Face<Cost>::configure(const utils::Json&json) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure graph::Face<Cost>::render() const override get_status() get_status shows a simplified state representation Like render, this produces a structured representation of the object's state. However, it is intended to be simpler in nature with the purpose of rendering the object during stream-output and logging. By default, it will fall back to the full render, but overloading this allows distinguising how the object looks during LOG vs full output. Declaration utils::Structure graph::Face<Cost>::get_status() const override rescale() Declaration void graph::Face<Cost>::rescale(double scale_factor) edges_count() Declaration size_t graph::Face<Cost>::edges_count() const memory_estimate() Declaration static size_t graph::Face<Cost>::memory_estimate(size_t num_edges)"
  },
  "api/graph/face/get/cost.html": {
    "href": "api/graph/face/get/cost.html",
    "title": "Struct graph::Face::Get_Cost | qiotoolkit",
    "keywords": "Struct graph::Face::Get_Cost Methods get() Declaration static Cost&graph::Face<Cost>::Get_Cost::get(Face&f) get_key() Declaration static std::string graph::Face<Cost>::Get_Cost::get_key()"
  },
  "api/graph/face/get/edge/ids.html": {
    "href": "api/graph/face/get/edge/ids.html",
    "title": "Struct graph::Face::Get_Edge_Ids | qiotoolkit",
    "keywords": "Struct graph::Face::Get_Edge_Ids Methods get() Declaration static std::vector<int>&graph::Face<Cost>::Get_Edge_Ids::get(Face&f) get_key() Declaration static std::string graph::Face<Cost>::Get_Edge_Ids::get_key()"
  },
  "api/graph/faced-graph-configuration.html": {
    "href": "api/graph/faced-graph-configuration.html",
    "title": "Class graph::FacedGraphConfiguration | qiotoolkit",
    "keywords": "Class graph::FacedGraphConfiguration Inheritance graph::GraphConfiguration graph::FacedGraphConfiguration model::FacedGraphModelConfiguration"
  },
  "api/graph/faced-graph-configuration/get/slc/terms.html": {
    "href": "api/graph/faced-graph-configuration/get/slc/terms.html",
    "title": "Struct graph::FacedGraphConfiguration::Get_SLC_Terms | qiotoolkit",
    "keywords": "Struct graph::FacedGraphConfiguration::Get_SLC_Terms Methods get() Declaration static std::vector<SCL_Term>&graph::FacedGraphConfiguration::Get_SLC_Terms::get(FacedGraphConfiguration&graph_config) get_key() Declaration static std::string graph::FacedGraphConfiguration::Get_SLC_Terms::get_key()"
  },
  "api/graph/faced-graph.html": {
    "href": "api/graph/faced-graph.html",
    "title": "Class graph::FacedGraph | qiotoolkit",
    "keywords": "Class graph::FacedGraph Graph representation as a collection of nodes, edges, and faces. It assumes, beyond the assumptions for Graph, that: faces are identified with a face ID 0...(F-1), where F is the number of faces. Inheritance graph::Graph graph::FacedGraph Inherited Members validate get_sum_coefficient_degrees_total get_const_cost populate_node_edge_ids render nodes_size get_min_locality get_min_coupling_magnitude get_scale_factor output_map edges configure edge node set_allow_dup_merge init get_locality get_avg_locality edges_size get_max_coupling_magnitude map_output init_memory_check is_empty get_node_name_to_id_map Graph is_rescaled get_properties nodes rescale estimate_max_cost_diff get_accumulated_dependent_vars render ~Component Component get_status param get_class_name Constructors FacedGraph() Declaration graph::FacedGraph::FacedGraph() Methods face() Get a face by ID. Declaration const Face&graph::FacedGraph::face(int face_id) const faces() Access the vector of all faces. Declaration const std::vector<Face>&graph::FacedGraph::faces() const sort() Sort the ID lists of each node, edge, and face. Graph::sort Declaration void graph::FacedGraph::sort() override validate() Validate the FacedGraph. Ensure that node, edge, and face references are consistent. validate_face Graph::validate Declaration bool graph::FacedGraph::validate() const override validate_node() Validate a node, ensuring that: the node participants in at least one edge and face, all edges listed have a valid edge ID, and the node is referenced in those edges. Declaration bool graph::FacedGraph::validate_node(int node_indx) const override validate_edge() Validate an edge, ensuring that: edges on certain face types contain a node, all nodes listed have a valid edge ID, and the node is referenced in those edges. Declaration bool graph::FacedGraph::validate_edge(size_t edge_id) const override validate_face() Validate a face, ensuring that: SquaredLinearCombination faces contain an edge, only linear edges, and have like-terms combined; all edges listed have a valid face ID; and the face is referenced in those edges. Declaration bool graph::FacedGraph::validate_face(int face_id) const validate_counts() Declaration bool graph::FacedGraph::validate_counts(int node_id, size_t edge_id) const override configure_memory_check() Declaration void graph::FacedGraph::configure_memory_check(const utils::Json&json) configure() Configure graph from the input by configuring and organizing its component nodes, edges, and faces. Input is structured as a dictionary including a value for \"terms\" which is a list of dictionaries, where each such dictionary is either an edge (given with \"ids\" and \"c\" keys) or a face (given with \"type\", \"c\", and \"terms\" keys where \"terms\" has value of a list of edge dictionaries). Declaration void graph::FacedGraph::configure(const utils::Json&json) override configure() Declaration void graph::FacedGraph::configure(Configuration_T&config) populate() Declaration void graph::FacedGraph::populate(std::vector<Face>&temp_faces, std::vector<std::vector<Edge>>&temp_edges) populate_face() Declaration void graph::FacedGraph::populate_face(Face&new_face, std::vector<Edge>&face_edges)"
  },
  "api/graph/graph-attributes.html": {
    "href": "api/graph/graph-attributes.html",
    "title": "Class graph::GraphAttributes | qiotoolkit",
    "keywords": "Class graph::GraphAttributes Inheritance graph::GraphAttributes"
  },
  "api/graph/graph-configuration.html": {
    "href": "api/graph/graph-configuration.html",
    "title": "Class graph::GraphConfiguration | qiotoolkit",
    "keywords": "Class graph::GraphConfiguration Inheritance graph::GraphConfiguration"
  },
  "api/graph/graph-configuration/get/edges.html": {
    "href": "api/graph/graph-configuration/get/edges.html",
    "title": "Struct graph::GraphConfiguration::Get_Edges | qiotoolkit",
    "keywords": "Struct graph::GraphConfiguration::Get_Edges Methods get() Declaration static std::vector<EdgeType>&graph::GraphConfiguration<EdgeType, NodeType>::Get_Edges::get(GraphConfiguration&graph_config) get_key() Declaration static std::string graph::GraphConfiguration<EdgeType, NodeType>::Get_Edges::get_key()"
  },
  "api/graph/graph-configuration/get/nodes.html": {
    "href": "api/graph/graph-configuration/get/nodes.html",
    "title": "Struct graph::GraphConfiguration::Get_Nodes | qiotoolkit",
    "keywords": "Struct graph::GraphConfiguration::Get_Nodes Methods get() Declaration static std::vector<NodeType>&graph::GraphConfiguration<EdgeType, NodeType>::Get_Nodes::get(GraphConfiguration&graph_config) get_key() Declaration static std::string graph::GraphConfiguration<EdgeType, NodeType>::Get_Nodes::get_key()"
  },
  "api/graph/graph-properties.html": {
    "href": "api/graph/graph-properties.html",
    "title": "Struct graph::GraphProperties | qiotoolkit",
    "keywords": "Struct graph::GraphProperties Constructors GraphProperties() Declaration graph::GraphProperties::GraphProperties() Methods rescale() Declaration void graph::GraphProperties::rescale()"
  },
  "api/graph/graph.html": {
    "href": "api/graph/graph.html",
    "title": "Class graph::Graph | qiotoolkit",
    "keywords": "Class graph::Graph Graph representation as a collection of nodes and edges. It assumes that: nodes are identified with a NodeId 0..(N-1) and edges are identified with an EdgeId 0..(M-1), where N (M) is the number of nodes (edges). This is a concurrent adjacency list AND edge list representation of the graph (slightly slower than using a single representation, but more versatile). Note We use a templated approach such that the accessors for nodes and edges can return the actual type rather than a limited base class view of it. Repetition of a node_id in an edge is explicitly allowed and implies a duplication of the corresponding edge_id in the node. This can be used for, e.g., squared terms in a cost function represented as a graph. Hoewever, this approach is not efficient for very high order terms. Inheritance utils::Component graph::Graph Inherited Members ~Component Component get_status param get_class_name Constructors Graph() Declaration graph::Graph<Edge, Node>::Graph() Methods set_allow_dup_merge() Declaration void graph::Graph<Edge, Node>::set_allow_dup_merge(bool value) get_const_cost() Declaration double graph::Graph<Edge, Node>::get_const_cost() const is_empty() Declaration bool graph::Graph<Edge, Node>::is_empty() const node() Get a node by NodeId. Declaration const Node&graph::Graph<Edge, Node>::node(size_t node_indx) const nodes() Access the vector of all edges. Declaration const std::vector<Node>&graph::Graph<Edge, Node>::nodes() const edge() Get an edge by EdgeId. Declaration const Edge&graph::Graph<Edge, Node>::edge(size_t edge_id) const edges() Access the vector of all edges. Declaration const std::vector<Edge>&graph::Graph<Edge, Node>::edges() const sort() Sort each node and edge. This invokes sort_edge_ids() and sort_node_ids() on all nodes and edges, respectively. It does NOT modify the order of the nodes and edges in the graph (i.e., the node_ids and edge_ids are stable under this operation). The order in which nodes are listed in each edge (and vice-versa) should not matter for the typical application (and can be unsorted either from intial input or from calls to {add,remove}_{node,edge}). This functionality is provided in case an implementation relies on either ascending order or being able to identify repetitions easily. Node::sort_edge_ids Edge::sort_node_ids Declaration virtual void graph::Graph<Edge, Node>::sort() validate() Validate the Graph. Ensure that Nodes, Edges and their references are consistent. validate_edge validate_node validate_counts Declaration virtual bool graph::Graph<Edge, Node>::validate() const validate_node() Validate a Node Ensure that the Node participates in at least one Edge, all edges listed have a valid edge_ids, and the Node is referenced in those Edges. Declaration virtual bool graph::Graph<Edge, Node>::validate_node(int node_indx) const validate_edge() Validate an Edge Ensure that the Edge includes at least one Node, all nodes listed have a valid edge_ids, and the node is referenced in those Edges. Declaration virtual bool graph::Graph<Edge, Node>::validate_edge(size_t edge_id) const validate_counts() Declaration virtual bool graph::Graph<Edge, Node>::validate_counts(int node_id, size_t edge_id) const configure() Configure the graph by configuring its components. { \"terms\": [...], \"variables\": [...], } Note The group name terms is a side effect of the cost_function input format. Declaration void graph::Graph<Edge, Node>::configure(const utils::Json&json) override configure() Declaration void graph::Graph<Edge, Node>::configure(Configuration_T&config) render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure graph::Graph<Edge, Node>::render() const override map_output() Declaration int graph::Graph<Edge, Node>::map_output(int internal_id) const output_map() Declaration const std::map<int, int>&graph::Graph<Edge, Node>::output_map() const nodes_size() Declaration size_t graph::Graph<Edge, Node>::nodes_size() const edges_size() Declaration size_t graph::Graph<Edge, Node>::edges_size() const get_locality() Declaration uint32_t graph::Graph<Edge, Node>::get_locality() const get_min_locality() Declaration uint32_t graph::Graph<Edge, Node>::get_min_locality() const get_avg_locality() Declaration double graph::Graph<Edge, Node>::get_avg_locality() const get_accumulated_dependent_vars() Declaration uint64_t graph::Graph<Edge, Node>::get_accumulated_dependent_vars() const get_max_coupling_magnitude() Declaration double graph::Graph<Edge, Node>::get_max_coupling_magnitude() const get_min_coupling_magnitude() Declaration double graph::Graph<Edge, Node>::get_min_coupling_magnitude() const get_sum_coefficient_degrees_total() Declaration uint64_t graph::Graph<Edge, Node>::get_sum_coefficient_degrees_total() const get_scale_factor() Declaration double graph::Graph<Edge, Node>::get_scale_factor() const is_rescaled() Declaration bool graph::Graph<Edge, Node>::is_rescaled() const get_properties() Declaration const GraphProperties&graph::Graph<Edge, Node>::get_properties() const rescale() Declaration void graph::Graph<Edge, Node>::rescale() estimate_max_cost_diff() Declaration double graph::Graph<Edge, Node>::estimate_max_cost_diff() const get_node_name_to_id_map() Declaration const std::map<int, int>&graph::Graph<Edge, Node>::get_node_name_to_id_map() const populate_node_edge_ids() Build the adjacency list from the edge list. This is used when the graph input is represented solely as an edge list to infer the corresponding adjacencly list representation. Declaration void graph::Graph<Edge, Node>::populate_node_edge_ids() configure_memory_check() Declaration void graph::Graph<Edge, Node>::configure_memory_check(const utils::Json&json) init_memory_check() Declaration void graph::Graph<Edge, Node>::init_memory_check() init() Declaration void graph::Graph<Edge, Node>::init()"
  },
  "api/graph/graph/get/edges.html": {
    "href": "api/graph/graph/get/edges.html",
    "title": "Struct graph::Graph::Get_Edges | qiotoolkit",
    "keywords": "Struct graph::Graph::Get_Edges Methods get() Declaration static std::vector<Edge>&graph::Graph<Edge, Node>::Get_Edges::get(Graph&g) get_key() Declaration static std::string graph::Graph<Edge, Node>::Get_Edges::get_key()"
  },
  "api/graph/graph/get/nodes.html": {
    "href": "api/graph/graph/get/nodes.html",
    "title": "Struct graph::Graph::Get_Nodes | qiotoolkit",
    "keywords": "Struct graph::Graph::Get_Nodes Methods get() Declaration static std::vector<Node>&graph::Graph<Edge, Node>::Get_Nodes::get(Graph&g) get_key() Declaration static std::string graph::Graph<Edge, Node>::Get_Nodes::get_key()"
  },
  "api/graph/index.html": {
    "href": "api/graph/index.html",
    "title": "Graph | qiotoolkit",
    "keywords": "Graph"
  },
  "api/graph/locality.html": {
    "href": "api/graph/locality.html",
    "title": "Class graph::Locality | qiotoolkit",
    "keywords": "Class graph::Locality Locality. Histogram and average number of nodes participating in an edge of the graph. (This is relevant for graph with hyper-edges, i.e., when more than 2 nodes can participate in an edge). Inheritance graph::Property graph::Locality Inherited Members ~Property Methods compute() Declaration utils::Structure graph::Locality<Graph>::compute(const Graph&g) const override"
  },
  "api/graph/node-with-faces.html": {
    "href": "api/graph/node-with-faces.html",
    "title": "Class graph::NodeWithFaces | qiotoolkit",
    "keywords": "Class graph::NodeWithFaces This node class extends the regular Node class. The key differences are that NodeWithFaces objects maintain a list of face IDs to which the node belongs and sorts its edge IDS according to the faces to which the corresponding edges belong. No validation on such edges belonging to the faces is handled here. Though NodeWithFaces inherits edge_ids_ from Node, it goes unused. Inheritance graph::Node graph::NodeWithFaces Inherited Members get_status render configure remove_edge_id Node clear_edge_ids Node ~Component Component param get_class_name Constructors NodeWithFaces() Create a node participating in a given set of edges. Declaration graph::NodeWithFaces::NodeWithFaces(const std::vector<size_t>&edge_ids={}) Methods edge_ids() Return the list of edge IDs this node participates in, in the first face. The default edge list corresponds to the 0th face, which is typically the catch-all Combination face for non-SLC terms. Declaration const std::vector<size_t>&graph::NodeWithFaces::edge_ids() const override edge_ids() Return the list of edge IDs this node participates in for a particular face. Declaration const std::vector<size_t>&graph::NodeWithFaces::edge_ids(int face_id) const edge_ids_by_face() Return the list of edge ID lists (by face) this node participates in. Declaration const std::vector<std::vector<size_t>>&graph::NodeWithFaces::edge_ids_by_face() const face_ids() Return the list of face IDs this node participates in. Declaration const std::vector<int>&graph::NodeWithFaces::face_ids() const sort_edge_ids() Ensure edge IDs are in ascending order. Declaration void graph::NodeWithFaces::sort_edge_ids() override add_edge_id() Add an edge to this node at a particular face. Declaration void graph::NodeWithFaces::add_edge_id(size_t edge_id) override add_edge_id() Declaration void graph::NodeWithFaces::add_edge_id(size_t edge_id, int face_id) sort_face_ids() Ensure face IDs are in ascending order. Declaration void graph::NodeWithFaces::sort_face_ids() add_face_id() Add a face to this node. Declaration void graph::NodeWithFaces::add_face_id(int face_id) contains_face_id() Search vector of face IDs for a particular ID. Declaration bool graph::NodeWithFaces::contains_face_id(int face_id) edges_count() Declaration size_t graph::NodeWithFaces::edges_count() const faces_count() Declaration size_t graph::NodeWithFaces::faces_count() const memory_estimate() Declaration static size_t graph::NodeWithFaces::memory_estimate(size_t num_edges)"
  },
  "api/graph/node.html": {
    "href": "api/graph/node.html",
    "title": "Class graph::Node | qiotoolkit",
    "keywords": "Class graph::Node Base class for graph nodes. A node's core property is the list of edges it participates in. This is a list of numeric edge_ids which only makes sense in the context of the Graph the note belongs to. The node does not know its own NodeId as this information might change when the graph is manipulated (nodes ids are modified to ensure they form a contiguous set 0..N). The node does not perform any validation on the list of edge_id's it is given; Ensuring validity of these is within the responsibility of the Graph. If you need additional properties on the node, you can inherit from this base class (make sure to also overload configure accordingly). Inheritance utils::Component graph::Node graph::NodeWithFaces Inherited Members ~Component Component param get_class_name Constructors Node() Create an empty node. (Not participating in any edges). Declaration graph::Node::Node() Node() Create a node participating in a given set of edges. Declaration graph::Node::Node(const std::vector<size_t>&edge_ids) Methods edge_ids() Return the list of edges this node participates in. Declaration const std::vector<size_t>&graph::Node::edge_ids() const clear_edge_ids() Remove all edge_ids. This should typically be invoked from the Graph [not directly], as remove edge_ids implies the node's NodeId should be removed from the corresponding edges. Graph::remove_node Declaration void graph::Node::clear_edge_ids() sort_edge_ids() Ensure edge_ids are in ascending order. Declaration void graph::Node::sort_edge_ids() add_edge_id() Add an edge to this node. Declaration void graph::Node::add_edge_id(size_t edge_id) remove_edge_id() Remove an edge from this node. Declaration void graph::Node::remove_edge_id(size_t edge_id) configure() Read/Write this node from/to a serializer. Declaration void graph::Node::configure(const utils::Json&json) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure graph::Node::render() const override get_status() get_status shows a simplified state representation Like render, this produces a structured representation of the object's state. However, it is intended to be simpler in nature with the purpose of rendering the object during stream-output and logging. By default, it will fall back to the full render, but overloading this allows distinguising how the object looks during LOG vs full output. Declaration utils::Structure graph::Node::get_status() const override memory_estimate() Declaration static size_t graph::Node::memory_estimate(size_t num_edges)"
  },
  "api/graph/node/get/edge/ids.html": {
    "href": "api/graph/node/get/edge/ids.html",
    "title": "Struct graph::Node::Get_Edge_Ids | qiotoolkit",
    "keywords": "Struct graph::Node::Get_Edge_Ids Methods get() Declaration static std::vector<size_t>&graph::Node::Get_Edge_Ids::get(Node&node) get_key() Declaration static std::string graph::Node::Get_Edge_Ids::get_key()"
  },
  "api/graph/property.html": {
    "href": "api/graph/property.html",
    "title": "Class graph::Property | qiotoolkit",
    "keywords": "Class graph::Property graph::Property interface An API to calculate properties of a graph g. Each implementation is expected to implement a compute method that returns the evaluated property as a structure. Inheritance graph::Property graph::Clustering graph::Couplings graph::Degree graph::Locality graph::Size Methods ~Property() Declaration virtual graph::Property<Graph>::~Property() compute() Declaration virtual utils::Structure graph::Property<Graph>::compute(const Graph&g) const =0"
  },
  "api/graph/scl/term.html": {
    "href": "api/graph/scl/term.html",
    "title": "Class graph::SCL_Term | qiotoolkit",
    "keywords": "Class graph::SCL_Term Inheritance graph::SCL_Term Constructors SCL_Term() Declaration graph::SCL_Term::SCL_Term() Methods get_edges() Declaration std::vector<Edge>&graph::SCL_Term::get_edges() get_cost() Declaration Cost&graph::SCL_Term::get_cost()"
  },
  "api/graph/scl/term/get/cost.html": {
    "href": "api/graph/scl/term/get/cost.html",
    "title": "Struct graph::SCL_Term::Get_Cost | qiotoolkit",
    "keywords": "Struct graph::SCL_Term::Get_Cost Methods get() Declaration static Cost&graph::SCL_Term::Get_Cost::get(SCL_Term&val) get_key() Declaration static std::string graph::SCL_Term::Get_Cost::get_key()"
  },
  "api/graph/scl/term/get/edges.html": {
    "href": "api/graph/scl/term/get/edges.html",
    "title": "Struct graph::SCL_Term::Get_Edges | qiotoolkit",
    "keywords": "Struct graph::SCL_Term::Get_Edges Methods get() Declaration static std::vector<Edge>&graph::SCL_Term::Get_Edges::get(SCL_Term&config) get_key() Declaration static std::string graph::SCL_Term::Get_Edges::get_key()"
  },
  "api/graph/size.html": {
    "href": "api/graph/size.html",
    "title": "Class graph::Size | qiotoolkit",
    "keywords": "Class graph::Size graph::Size Denote the number of nodes and edges in the graph. Inheritance graph::Property graph::Size Inherited Members ~Property Methods compute() Declaration utils::Structure graph::Size<Graph>::compute(const Graph&g) const override"
  },
  "api/group.html": {
    "href": "api/group.html",
    "title": "Struct Group | qiotoolkit",
    "keywords": "Struct Group Constructors Group() Declaration Group::Group()"
  },
  "api/igeneric-remote-schema-document-provider.html": {
    "href": "api/igeneric-remote-schema-document-provider.html",
    "title": "Class IGenericRemoteSchemaDocumentProvider | qiotoolkit",
    "keywords": "Class IGenericRemoteSchemaDocumentProvider Inheritance IGenericRemoteSchemaDocumentProvider Methods ~IGenericRemoteSchemaDocumentProvider() Declaration virtual IGenericRemoteSchemaDocumentProvider<SchemaDocumentType>::~IGenericRemoteSchemaDocumentProvider() GetRemoteDocument() Declaration virtual const SchemaDocumentType* IGenericRemoteSchemaDocumentProvider<SchemaDocumentType>::GetRemoteDocument(const Ch *uri, SizeType length)=0"
  },
  "api/imaxdiv/t.html": {
    "href": "api/imaxdiv/t.html",
    "title": "Struct imaxdiv_t | qiotoolkit",
    "keywords": "Struct imaxdiv_t"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API documentation | qiotoolkit",
    "keywords": "API documentation This section of the qiotoolkit documentation contains auto-generated C++ interface-descriptions for the components in the repository. For the input and output specifications of the compiled binary, check out the Specifications Section For a step-by-step guide on getting started with qiotoolkit, please refer to the Tutorial Section Models All qiotoolkit models are expected to inherit from the markov::Model base class, which defines the required methods to interface with solvers. Currently, the code base contains implementations for: Ising Model PUBO Blume-Capel (Spin-1, i.e., 3 states) Potts (p-state, no notion of \"neighboring values\") Clock (p-state, neighboring values + periodic boundaries) TSP (single-tour on fully connected graph) Poly (Experimental: Arbitrary polynomial cost function with parameters) Solvers All qiotoolkit solvers are expected to inherit from the solver::AbstractSolver base class, which defines the interface to the simulation runner. Current built-in solvers include: Simulated Annealing Parallel Tempering Population Annealing Substochastic Monte-Carlo MUlti-objective Replica Exchange (Experimental) Utilities Utils - general purpose utilties for I/O and debugging Matcher - Specification of pre-conditions for valid input Graph - Graph representation Schedule - Generators for annealing sequences and temperature sets Observe - Built-in measurement functionality"
  },
  "api/internal/big-integer.html": {
    "href": "api/internal/big-integer.html",
    "title": "Class internal::BigInteger | qiotoolkit",
    "keywords": "Class internal::BigInteger Inheritance internal::BigInteger Constructors BigInteger() Declaration internal::BigInteger::BigInteger(const BigInteger&rhs) BigInteger() Declaration internal::BigInteger::BigInteger(uint64_t u) BigInteger() Declaration internal::BigInteger::BigInteger(const char *decimals, size_t length) Methods operator=() Declaration BigInteger&internal::BigInteger::operator=(const BigInteger&rhs) operator=() Declaration BigInteger&internal::BigInteger::operator=(uint64_t u) operator+=() Declaration BigInteger&internal::BigInteger::operator+=(uint64_t u) operator*=() Declaration BigInteger&internal::BigInteger::operator*=(uint64_t u) operator*=() Declaration BigInteger&internal::BigInteger::operator*=(uint32_t u) =() Declaration BigInteger&internal::BigInteger::operator<<=(size_t shift) =() Declaration BigInteger&internal::BigInteger::operator<<=(size_t shift) =() Declaration BigInteger&internal::BigInteger::operator<<=(size_t shift) =() Declaration BigInteger&internal::BigInteger::operator<<=(size_t shift) operator==() Declaration bool internal::BigInteger::operator==(const BigInteger&rhs) const operator==() Declaration bool internal::BigInteger::operator==(const Type rhs) const MultiplyPow5() Declaration BigInteger&internal::BigInteger::MultiplyPow5(unsigned exp) Difference() Declaration bool internal::BigInteger::Difference(const BigInteger&rhs, BigInteger *out) const Compare() Declaration int internal::BigInteger::Compare(const BigInteger&rhs) const GetCount() Declaration size_t internal::BigInteger::GetCount() const GetDigit() Declaration Type internal::BigInteger::GetDigit(size_t index) const IsZero() Declaration bool internal::BigInteger::IsZero() const AppendDecimal64() Declaration void internal::BigInteger::AppendDecimal64(const char *begin, const char *end) PushBack() Declaration void internal::BigInteger::PushBack(Type digit) ParseUint64() Declaration static uint64_t internal::BigInteger::ParseUint64(const char *begin, const char *end) MulAdd64() Declaration static uint64_t internal::BigInteger::MulAdd64(uint64_t a, uint64_t b, uint64_t k, uint64_t *outHigh)"
  },
  "api/internal/decoded-stream.html": {
    "href": "api/internal/decoded-stream.html",
    "title": "Class internal::DecodedStream | qiotoolkit",
    "keywords": "Class internal::DecodedStream Inheritance internal::DecodedStream Constructors DecodedStream() Declaration internal::DecodedStream<SourceStream, Encoding>::DecodedStream(SourceStream&ss) Methods Peek() Declaration unsigned internal::DecodedStream<SourceStream, Encoding>::Peek() Take() Declaration unsigned internal::DecodedStream<SourceStream, Encoding>::Take() Decode() Declaration void internal::DecodedStream<SourceStream, Encoding>::Decode()"
  },
  "api/internal/diy-fp.html": {
    "href": "api/internal/diy-fp.html",
    "title": "Struct internal::DiyFp | qiotoolkit",
    "keywords": "Struct internal::DiyFp Constructors DiyFp() Declaration internal::DiyFp::DiyFp() DiyFp() Declaration internal::DiyFp::DiyFp(uint64_t fp, int exp) DiyFp() Declaration internal::DiyFp::DiyFp(double d) Methods operator-() Declaration DiyFp internal::DiyFp::operator-(const DiyFp&rhs) const operator*() Declaration DiyFp internal::DiyFp::operator*(const DiyFp&rhs) const Normalize() Declaration DiyFp internal::DiyFp::Normalize() const NormalizeBoundary() Declaration DiyFp internal::DiyFp::NormalizeBoundary() const NormalizedBoundaries() Declaration void internal::DiyFp::NormalizedBoundaries(DiyFp *minus, DiyFp *plus) const ToDouble() Declaration double internal::DiyFp::ToDouble() const"
  },
  "api/internal/double.html": {
    "href": "api/internal/double.html",
    "title": "Class internal::Double | qiotoolkit",
    "keywords": "Class internal::Double Inheritance internal::Double Constructors Double() Declaration internal::Double::Double() Double() Declaration internal::Double::Double(double d) Double() Declaration internal::Double::Double(uint64_t u) Methods Value() Declaration double internal::Double::Value() const Uint64Value() Declaration uint64_t internal::Double::Uint64Value() const NextPositiveDouble() Declaration double internal::Double::NextPositiveDouble() const Sign() Declaration bool internal::Double::Sign() const Significand() Declaration uint64_t internal::Double::Significand() const Exponent() Declaration int internal::Double::Exponent() const IsNan() Declaration bool internal::Double::IsNan() const IsInf() Declaration bool internal::Double::IsInf() const IsNanOrInf() Declaration bool internal::Double::IsNanOrInf() const IsNormal() Declaration bool internal::Double::IsNormal() const IsZero() Declaration bool internal::Double::IsZero() const IntegerSignificand() Declaration uint64_t internal::Double::IntegerSignificand() const IntegerExponent() Declaration int internal::Double::IntegerExponent() const ToBias() Declaration uint64_t internal::Double::ToBias() const EffectiveSignificandSize() Declaration static int internal::Double::EffectiveSignificandSize(int order)"
  },
  "api/internal/generic-regex-search.html": {
    "href": "api/internal/generic-regex-search.html",
    "title": "Class internal::GenericRegexSearch | qiotoolkit",
    "keywords": "Class internal::GenericRegexSearch Inheritance internal::GenericRegexSearch Constructors GenericRegexSearch() Declaration internal::GenericRegexSearch<RegexType, Allocator>::GenericRegexSearch(const RegexType&regex, Allocator *allocator=0) Methods ~GenericRegexSearch() Declaration internal::GenericRegexSearch<RegexType, Allocator>::~GenericRegexSearch() Match() Declaration bool internal::GenericRegexSearch<RegexType, Allocator>::Match(InputStream&is) Match() Declaration bool internal::GenericRegexSearch<RegexType, Allocator>::Match(const Ch *s) Search() Declaration bool internal::GenericRegexSearch<RegexType, Allocator>::Search(InputStream&is) Search() Declaration bool internal::GenericRegexSearch<RegexType, Allocator>::Search(const Ch *s) SearchWithAnchoring() Declaration bool internal::GenericRegexSearch<RegexType, Allocator>::SearchWithAnchoring(InputStream&is, bool anchorBegin, bool anchorEnd) GetStateSetSize() Declaration size_t internal::GenericRegexSearch<RegexType, Allocator>::GetStateSetSize() const AddState() Declaration bool internal::GenericRegexSearch<RegexType, Allocator>::AddState(Stack<Allocator>&l, SizeType index) MatchRange() Declaration bool internal::GenericRegexSearch<RegexType, Allocator>::MatchRange(SizeType rangeIndex, unsigned codepoint) const"
  },
  "api/internal/generic-regex.html": {
    "href": "api/internal/generic-regex.html",
    "title": "Class internal::GenericRegex | qiotoolkit",
    "keywords": "Class internal::GenericRegex Regular expression engine with subset of ECMAscript grammar. Supported regular expression syntax: ab Concatenation a|b Alternation a? Zero or one a* Zero or more a+ One or more a{3} Exactly 3 times a{3,} At least 3 times a{3,5} 3 to 5 times ``(ab) Grouping ^a At the beginning a$ At the end ``. Any character ``[abc] Character classes ``[a-c] Character class range ``[a-z0-9_] Character class combination ``[^abc] Negated character classes ``[^a-c] Negated character class range ``[] Backspace (U+0008) \\| \\ ... Escape characters \\f Form feed (U+000C) \\n Line feed (U+000A) \\r Carriage return (U+000D) \\t Tab (U+0009) \\v Vertical tab (U+000B) This is a Thompson NFA engine, implemented with reference to Cox, Russ. \"Regular Expression Matching Can Be Simple And Fast (but is slow in Java, Perl, PHP, Python, Ruby,...).\", https://swtch.com/~rsc/regexp/regexp1.html Inheritance internal::GenericRegex Constructors GenericRegex() Declaration internal::GenericRegex<Encoding, Allocator>::GenericRegex(const Ch *source, Allocator *allocator=0) Methods ~GenericRegex() Declaration internal::GenericRegex<Encoding, Allocator>::~GenericRegex() IsValid() Declaration bool internal::GenericRegex<Encoding, Allocator>::IsValid() const GetState() Declaration State&internal::GenericRegex<Encoding, Allocator>::GetState(SizeType index) GetState() Declaration const State&internal::GenericRegex<Encoding, Allocator>::GetState(SizeType index) const GetRange() Declaration Range&internal::GenericRegex<Encoding, Allocator>::GetRange(SizeType index) GetRange() Declaration const Range&internal::GenericRegex<Encoding, Allocator>::GetRange(SizeType index) const Parse() Declaration void internal::GenericRegex<Encoding, Allocator>::Parse(DecodedStream<InputStream, Encoding>&ds) NewState() Declaration SizeType internal::GenericRegex<Encoding, Allocator>::NewState(SizeType out, SizeType out1, unsigned codepoint) PushOperand() Declaration void internal::GenericRegex<Encoding, Allocator>::PushOperand(Stack<Allocator>&operandStack, unsigned codepoint) ImplicitConcatenation() Declaration void internal::GenericRegex<Encoding, Allocator>::ImplicitConcatenation(Stack<Allocator>&atomCountStack, Stack<Allocator>&operatorStack) Append() Declaration SizeType internal::GenericRegex<Encoding, Allocator>::Append(SizeType l1, SizeType l2) Patch() Declaration void internal::GenericRegex<Encoding, Allocator>::Patch(SizeType l, SizeType s) Eval() Declaration bool internal::GenericRegex<Encoding, Allocator>::Eval(Stack<Allocator>&operandStack, Operator op) EvalQuantifier() Declaration bool internal::GenericRegex<Encoding, Allocator>::EvalQuantifier(Stack<Allocator>&operandStack, unsigned n, unsigned m) CloneTopOperand() Declaration void internal::GenericRegex<Encoding, Allocator>::CloneTopOperand(Stack<Allocator>&operandStack) ParseUnsigned() Declaration bool internal::GenericRegex<Encoding, Allocator>::ParseUnsigned(DecodedStream<InputStream, Encoding>&ds, unsigned *u) ParseRange() Declaration bool internal::GenericRegex<Encoding, Allocator>::ParseRange(DecodedStream<InputStream, Encoding>&ds, SizeType *range) NewRange() Declaration SizeType internal::GenericRegex<Encoding, Allocator>::NewRange(unsigned codepoint) CharacterEscape() Declaration bool internal::GenericRegex<Encoding, Allocator>::CharacterEscape(DecodedStream<InputStream, Encoding>&ds, unsigned *escapedCodepoint) Min() Declaration static SizeType internal::GenericRegex<Encoding, Allocator>::Min(SizeType a, SizeType b)"
  },
  "api/internal/generic-regex/frag.html": {
    "href": "api/internal/generic-regex/frag.html",
    "title": "Struct internal::GenericRegex::Frag | qiotoolkit",
    "keywords": "Struct internal::GenericRegex::Frag Constructors Frag() Declaration internal::GenericRegex<Encoding, Allocator>::Frag::Frag(SizeType s, SizeType o, SizeType m)"
  },
  "api/internal/generic-regex/range.html": {
    "href": "api/internal/generic-regex/range.html",
    "title": "Struct internal::GenericRegex::Range | qiotoolkit",
    "keywords": "Struct internal::GenericRegex::Range"
  },
  "api/internal/generic-regex/state.html": {
    "href": "api/internal/generic-regex/state.html",
    "title": "Struct internal::GenericRegex::State | qiotoolkit",
    "keywords": "Struct internal::GenericRegex::State"
  },
  "api/internal/hasher.html": {
    "href": "api/internal/hasher.html",
    "title": "Class internal::Hasher | qiotoolkit",
    "keywords": "Class internal::Hasher Inheritance internal::Hasher Constructors Hasher() Declaration internal::Hasher<Encoding, Allocator>::Hasher(Allocator *allocator=0, size_t stackCapacity=kDefaultSize) Methods Null() Declaration bool internal::Hasher<Encoding, Allocator>::Null() Bool() Declaration bool internal::Hasher<Encoding, Allocator>::Bool(bool b) Int() Declaration bool internal::Hasher<Encoding, Allocator>::Int(int i) Uint() Declaration bool internal::Hasher<Encoding, Allocator>::Uint(unsigned u) Int64() Declaration bool internal::Hasher<Encoding, Allocator>::Int64(int64_t i) Uint64() Declaration bool internal::Hasher<Encoding, Allocator>::Uint64(uint64_t u) Double() Declaration bool internal::Hasher<Encoding, Allocator>::Double(double d) RawNumber() Declaration bool internal::Hasher<Encoding, Allocator>::RawNumber(const Ch *str, SizeType len, bool) String() Declaration bool internal::Hasher<Encoding, Allocator>::String(const Ch *str, SizeType len, bool) StartObject() Declaration bool internal::Hasher<Encoding, Allocator>::StartObject() Key() Declaration bool internal::Hasher<Encoding, Allocator>::Key(const Ch *str, SizeType len, bool copy) EndObject() Declaration bool internal::Hasher<Encoding, Allocator>::EndObject(SizeType memberCount) StartArray() Declaration bool internal::Hasher<Encoding, Allocator>::StartArray() EndArray() Declaration bool internal::Hasher<Encoding, Allocator>::EndArray(SizeType elementCount) IsValid() Declaration bool internal::Hasher<Encoding, Allocator>::IsValid() const GetHashCode() Declaration uint64_t internal::Hasher<Encoding, Allocator>::GetHashCode() const WriteType() Declaration bool internal::Hasher<Encoding, Allocator>::WriteType(Type type) WriteNumber() Declaration bool internal::Hasher<Encoding, Allocator>::WriteNumber(const Number&n) WriteBuffer() Declaration bool internal::Hasher<Encoding, Allocator>::WriteBuffer(Type type, const void *data, size_t len) Hash() Declaration static uint64_t internal::Hasher<Encoding, Allocator>::Hash(uint64_t h, uint64_t d)"
  },
  "api/internal/hasher/number.html": {
    "href": "api/internal/hasher/number.html",
    "title": "Struct internal::Hasher::Number | qiotoolkit",
    "keywords": "Struct internal::Hasher::Number"
  },
  "api/internal/is-generic-value-impl.html": {
    "href": "api/internal/is-generic-value-impl.html",
    "title": "Struct internal::IsGenericValueImpl | qiotoolkit",
    "keywords": "Struct internal::IsGenericValueImpl"
  },
  "api/internal/is-generic-value-impl/3/01-t/00/01typename/01-void/3/01typename/01-t/encoding-type794abcc01fcce01e300668fa57e4d036.html": {
    "href": "api/internal/is-generic-value-impl/3/01-t/00/01typename/01-void/3/01typename/01-t/encoding-type794abcc01fcce01e300668fa57e4d036.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/internal/is-generic-value.html": {
    "href": "api/internal/is-generic-value.html",
    "title": "Struct internal::IsGenericValue | qiotoolkit",
    "keywords": "Struct internal::IsGenericValue"
  },
  "api/internal/is-ref-counted.html": {
    "href": "api/internal/is-ref-counted.html",
    "title": "Struct internal::IsRefCounted | qiotoolkit",
    "keywords": "Struct internal::IsRefCounted"
  },
  "api/internal/is-ref-counted/3/01-t/00/01typename/01internal/enable-if-cond/3/01-t/k-ref-counted/01/4/type/01/4.html": {
    "href": "api/internal/is-ref-counted/3/01-t/00/01typename/01internal/enable-if-cond/3/01-t/k-ref-counted/01/4/type/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/internal/ischema-state-factory.html": {
    "href": "api/internal/ischema-state-factory.html",
    "title": "Class internal::ISchemaStateFactory | qiotoolkit",
    "keywords": "Class internal::ISchemaStateFactory Inheritance internal::ISchemaStateFactory Methods ~ISchemaStateFactory() Declaration virtual internal::ISchemaStateFactory<SchemaType>::~ISchemaStateFactory() CreateSchemaValidator() Declaration virtual ISchemaValidator* internal::ISchemaStateFactory<SchemaType>::CreateSchemaValidator(const SchemaType&, const bool inheritContinueOnErrors)=0 DestroySchemaValidator() Declaration virtual void internal::ISchemaStateFactory<SchemaType>::DestroySchemaValidator(ISchemaValidator *validator)=0 CreateHasher() Declaration virtual void* internal::ISchemaStateFactory<SchemaType>::CreateHasher()=0 GetHashCode() Declaration virtual uint64_t internal::ISchemaStateFactory<SchemaType>::GetHashCode(void *hasher)=0 DestroryHasher() Declaration virtual void internal::ISchemaStateFactory<SchemaType>::DestroryHasher(void *hasher)=0 MallocState() Declaration virtual void* internal::ISchemaStateFactory<SchemaType>::MallocState(size_t size)=0 FreeState() Declaration virtual void internal::ISchemaStateFactory<SchemaType>::FreeState(void *p)=0"
  },
  "api/internal/ischema-validator.html": {
    "href": "api/internal/ischema-validator.html",
    "title": "Class internal::ISchemaValidator | qiotoolkit",
    "keywords": "Class internal::ISchemaValidator Inheritance internal::ISchemaValidator Methods ~ISchemaValidator() Declaration virtual internal::ISchemaValidator::~ISchemaValidator() IsValid() Declaration virtual bool internal::ISchemaValidator::IsValid() const =0 SetValidateFlags() Declaration virtual void internal::ISchemaValidator::SetValidateFlags(unsigned flags)=0 GetValidateFlags() Declaration virtual unsigned internal::ISchemaValidator::GetValidateFlags() const =0"
  },
  "api/internal/ivalidation-error-handler.html": {
    "href": "api/internal/ivalidation-error-handler.html",
    "title": "Class internal::IValidationErrorHandler | qiotoolkit",
    "keywords": "Class internal::IValidationErrorHandler Inheritance internal::IValidationErrorHandler Methods ~IValidationErrorHandler() Declaration virtual internal::IValidationErrorHandler<SchemaType>::~IValidationErrorHandler() NotMultipleOf() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::NotMultipleOf(int64_t actual, const SValue&expected)=0 NotMultipleOf() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::NotMultipleOf(uint64_t actual, const SValue&expected)=0 NotMultipleOf() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::NotMultipleOf(double actual, const SValue&expected)=0 AboveMaximum() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::AboveMaximum(int64_t actual, const SValue&expected, bool exclusive)=0 AboveMaximum() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::AboveMaximum(uint64_t actual, const SValue&expected, bool exclusive)=0 AboveMaximum() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::AboveMaximum(double actual, const SValue&expected, bool exclusive)=0 BelowMinimum() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::BelowMinimum(int64_t actual, const SValue&expected, bool exclusive)=0 BelowMinimum() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::BelowMinimum(uint64_t actual, const SValue&expected, bool exclusive)=0 BelowMinimum() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::BelowMinimum(double actual, const SValue&expected, bool exclusive)=0 TooLong() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::TooLong(const Ch *str, SizeType length, SizeType expected)=0 TooShort() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::TooShort(const Ch *str, SizeType length, SizeType expected)=0 DoesNotMatch() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::DoesNotMatch(const Ch *str, SizeType length)=0 DisallowedItem() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::DisallowedItem(SizeType index)=0 TooFewItems() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::TooFewItems(SizeType actualCount, SizeType expectedCount)=0 TooManyItems() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::TooManyItems(SizeType actualCount, SizeType expectedCount)=0 DuplicateItems() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::DuplicateItems(SizeType index1, SizeType index2)=0 TooManyProperties() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::TooManyProperties(SizeType actualCount, SizeType expectedCount)=0 TooFewProperties() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::TooFewProperties(SizeType actualCount, SizeType expectedCount)=0 StartMissingProperties() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::StartMissingProperties()=0 AddMissingProperty() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::AddMissingProperty(const SValue&name)=0 EndMissingProperties() Declaration virtual bool internal::IValidationErrorHandler<SchemaType>::EndMissingProperties()=0 PropertyViolations() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::PropertyViolations(ISchemaValidator **subvalidators, SizeType count)=0 DisallowedProperty() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::DisallowedProperty(const Ch *name, SizeType length)=0 StartDependencyErrors() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::StartDependencyErrors()=0 StartMissingDependentProperties() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::StartMissingDependentProperties()=0 AddMissingDependentProperty() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::AddMissingDependentProperty(const SValue&targetName)=0 EndMissingDependentProperties() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::EndMissingDependentProperties(const SValue&sourceName)=0 AddDependencySchemaError() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::AddDependencySchemaError(const SValue&souceName, ISchemaValidator *subvalidator)=0 EndDependencyErrors() Declaration virtual bool internal::IValidationErrorHandler<SchemaType>::EndDependencyErrors()=0 DisallowedValue() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::DisallowedValue(const ValidateErrorCode code)=0 StartDisallowedType() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::StartDisallowedType()=0 AddExpectedType() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::AddExpectedType(const typename SchemaType::ValueType&expectedType)=0 EndDisallowedType() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::EndDisallowedType(const typename SchemaType::ValueType&actualType)=0 NotAllOf() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::NotAllOf(ISchemaValidator **subvalidators, SizeType count)=0 NoneOf() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::NoneOf(ISchemaValidator **subvalidators, SizeType count)=0 NotOneOf() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::NotOneOf(ISchemaValidator **subvalidators, SizeType count, bool matched)=0 Disallowed() Declaration virtual void internal::IValidationErrorHandler<SchemaType>::Disallowed()=0"
  },
  "api/internal/schema-validation-context.html": {
    "href": "api/internal/schema-validation-context.html",
    "title": "Struct internal::SchemaValidationContext | qiotoolkit",
    "keywords": "Struct internal::SchemaValidationContext Constructors SchemaValidationContext() Declaration internal::SchemaValidationContext<SchemaDocumentType>::SchemaValidationContext(SchemaValidatorFactoryType&f, ErrorHandlerType&eh, const SchemaType *s) Methods ~SchemaValidationContext() Declaration internal::SchemaValidationContext<SchemaDocumentType>::~SchemaValidationContext()"
  },
  "api/internal/schema.html": {
    "href": "api/internal/schema.html",
    "title": "Class internal::Schema | qiotoolkit",
    "keywords": "Class internal::Schema Inheritance internal::Schema Constructors Schema() Declaration internal::Schema<SchemaDocumentType>::Schema(SchemaDocumentType *schemaDocument, const PointerType&p, const ValueType&value, const ValueType&document, AllocatorType *allocator) Methods ~Schema() Declaration internal::Schema<SchemaDocumentType>::~Schema() GetURI() Declaration const SValue&internal::Schema<SchemaDocumentType>::GetURI() const GetPointer() Declaration const PointerType&internal::Schema<SchemaDocumentType>::GetPointer() const BeginValue() Declaration bool internal::Schema<SchemaDocumentType>::BeginValue(Context&context) const EndValue() Declaration RAPIDJSON_FORCEINLINE bool internal::Schema<SchemaDocumentType>::EndValue(Context&context) const Null() Declaration bool internal::Schema<SchemaDocumentType>::Null(Context&context) const Bool() Declaration bool internal::Schema<SchemaDocumentType>::Bool(Context&context, bool) const Int() Declaration bool internal::Schema<SchemaDocumentType>::Int(Context&context, int i) const Uint() Declaration bool internal::Schema<SchemaDocumentType>::Uint(Context&context, unsigned u) const Int64() Declaration bool internal::Schema<SchemaDocumentType>::Int64(Context&context, int64_t i) const Uint64() Declaration bool internal::Schema<SchemaDocumentType>::Uint64(Context&context, uint64_t u) const Double() Declaration bool internal::Schema<SchemaDocumentType>::Double(Context&context, double d) const String() Declaration bool internal::Schema<SchemaDocumentType>::String(Context&context, const Ch *str, SizeType length, bool) const StartObject() Declaration bool internal::Schema<SchemaDocumentType>::StartObject(Context&context) const Key() Declaration bool internal::Schema<SchemaDocumentType>::Key(Context&context, const Ch *str, SizeType len, bool) const EndObject() Declaration bool internal::Schema<SchemaDocumentType>::EndObject(Context&context, SizeType memberCount) const StartArray() Declaration bool internal::Schema<SchemaDocumentType>::StartArray(Context&context) const EndArray() Declaration bool internal::Schema<SchemaDocumentType>::EndArray(Context&context, SizeType elementCount) const GetValidateErrorKeyword() Declaration static const ValueType&internal::Schema<SchemaDocumentType>::GetValidateErrorKeyword(ValidateErrorCode validateErrorCode) AddUniqueElement() Declaration void internal::Schema<SchemaDocumentType>::AddUniqueElement(V1&a, const V2&v) AssignIfExist() Declaration void internal::Schema<SchemaDocumentType>::AssignIfExist(SchemaArray&out, SchemaDocumentType&schemaDocument, const PointerType&p, const ValueType&value, const ValueType&name, const ValueType&document) CreatePattern() Declaration RegexType* internal::Schema<SchemaDocumentType>::CreatePattern(const ValueType&value) AddType() Declaration void internal::Schema<SchemaDocumentType>::AddType(const ValueType&type) CreateParallelValidator() Declaration bool internal::Schema<SchemaDocumentType>::CreateParallelValidator(Context&context) const CreateSchemaValidators() Declaration void internal::Schema<SchemaDocumentType>::CreateSchemaValidators(Context&context, const SchemaArray&schemas, const bool inheritContinueOnErrors) const FindPropertyIndex() Declaration bool internal::Schema<SchemaDocumentType>::FindPropertyIndex(const ValueType&name, SizeType *outIndex) const CheckInt() Declaration bool internal::Schema<SchemaDocumentType>::CheckInt(Context&context, int64_t i) const CheckUint() Declaration bool internal::Schema<SchemaDocumentType>::CheckUint(Context&context, uint64_t i) const CheckDoubleMinimum() Declaration bool internal::Schema<SchemaDocumentType>::CheckDoubleMinimum(Context&context, double d) const CheckDoubleMaximum() Declaration bool internal::Schema<SchemaDocumentType>::CheckDoubleMaximum(Context&context, double d) const CheckDoubleMultipleOf() Declaration bool internal::Schema<SchemaDocumentType>::CheckDoubleMultipleOf(Context&context, double d) const DisallowedType() Declaration void internal::Schema<SchemaDocumentType>::DisallowedType(Context&context, const ValueType&actualType) const GetMember() Declaration static const ValueType* internal::Schema<SchemaDocumentType>::GetMember(const ValueType&value, const ValueType&name) AssignIfExist() Declaration static void internal::Schema<SchemaDocumentType>::AssignIfExist(bool&out, const ValueType&value, const ValueType&name) AssignIfExist() Declaration static void internal::Schema<SchemaDocumentType>::AssignIfExist(SizeType&out, const ValueType&value, const ValueType&name) IsPatternMatch() Declaration static bool internal::Schema<SchemaDocumentType>::IsPatternMatch(const RegexType *pattern, const Ch *str, SizeType)"
  },
  "api/internal/schema/pattern-property.html": {
    "href": "api/internal/schema/pattern-property.html",
    "title": "Struct internal::Schema::PatternProperty | qiotoolkit",
    "keywords": "Struct internal::Schema::PatternProperty Constructors PatternProperty() Declaration internal::Schema<SchemaDocumentType>::PatternProperty::PatternProperty() Methods ~PatternProperty() Declaration internal::Schema<SchemaDocumentType>::PatternProperty::~PatternProperty()"
  },
  "api/internal/schema/property.html": {
    "href": "api/internal/schema/property.html",
    "title": "Struct internal::Schema::Property | qiotoolkit",
    "keywords": "Struct internal::Schema::Property Constructors Property() Declaration internal::Schema<SchemaDocumentType>::Property::Property() Methods ~Property() Declaration internal::Schema<SchemaDocumentType>::Property::~Property()"
  },
  "api/internal/schema/schema-array.html": {
    "href": "api/internal/schema/schema-array.html",
    "title": "Struct internal::Schema::SchemaArray | qiotoolkit",
    "keywords": "Struct internal::Schema::SchemaArray Constructors SchemaArray() Declaration internal::Schema<SchemaDocumentType>::SchemaArray::SchemaArray() Methods ~SchemaArray() Declaration internal::Schema<SchemaDocumentType>::SchemaArray::~SchemaArray()"
  },
  "api/internal/stack.html": {
    "href": "api/internal/stack.html",
    "title": "Class internal::Stack | qiotoolkit",
    "keywords": "Class internal::Stack A type-unsafe stack for storing different types of data. Allocator Allocator for allocating stack memory. Inheritance internal::Stack Constructors Stack() Declaration internal::Stack<Allocator>::Stack(Allocator *allocator, size_t stackCapacity) Stack() Declaration internal::Stack<Allocator>::Stack(const Stack&) Methods ~Stack() Declaration internal::Stack<Allocator>::~Stack() Swap() Declaration void internal::Stack<Allocator>::Swap(Stack&rhs) RAPIDJSON_NOEXCEPT Clear() Declaration void internal::Stack<Allocator>::Clear() ShrinkToFit() Declaration void internal::Stack<Allocator>::ShrinkToFit() Reserve() Declaration RAPIDJSON_FORCEINLINE void internal::Stack<Allocator>::Reserve(size_t count=1) Push() Declaration RAPIDJSON_FORCEINLINE T* internal::Stack<Allocator>::Push(size_t count=1) PushUnsafe() Declaration RAPIDJSON_FORCEINLINE T* internal::Stack<Allocator>::PushUnsafe(size_t count=1) Pop() Declaration T* internal::Stack<Allocator>::Pop(size_t count) Top() Declaration T* internal::Stack<Allocator>::Top() Top() Declaration const T* internal::Stack<Allocator>::Top() const End() Declaration T* internal::Stack<Allocator>::End() End() Declaration const T* internal::Stack<Allocator>::End() const Bottom() Declaration T* internal::Stack<Allocator>::Bottom() Bottom() Declaration const T* internal::Stack<Allocator>::Bottom() const HasAllocator() Declaration bool internal::Stack<Allocator>::HasAllocator() const GetAllocator() Declaration Allocator&internal::Stack<Allocator>::GetAllocator() Empty() Declaration bool internal::Stack<Allocator>::Empty() const GetSize() Declaration size_t internal::Stack<Allocator>::GetSize() const GetCapacity() Declaration size_t internal::Stack<Allocator>::GetCapacity() const Expand() Declaration void internal::Stack<Allocator>::Expand(size_t count) Resize() Declaration void internal::Stack<Allocator>::Resize(size_t newCapacity) Destroy() Declaration void internal::Stack<Allocator>::Destroy() operator=() Declaration Stack&internal::Stack<Allocator>::operator=(const Stack&)"
  },
  "api/internal/stream-local-copy.html": {
    "href": "api/internal/stream-local-copy.html",
    "title": "Class internal::StreamLocalCopy | qiotoolkit",
    "keywords": "Class internal::StreamLocalCopy Inheritance internal::StreamLocalCopy"
  },
  "api/internal/stream-local-copy/3/01-stream/00/010/01/4.html": {
    "href": "api/internal/stream-local-copy/3/01-stream/00/010/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Keep reference. Inheritance > Methods StreamLocalCopy() Declaration internal::StreamLocalCopy<Stream, 0>::StreamLocalCopy(Stream&original) operator=() Declaration StreamLocalCopy&internal::StreamLocalCopy<Stream, 0>::operator=(const StreamLocalCopy&)"
  },
  "api/internal/stream-local-copy/3/01-stream/00/011/01/4.html": {
    "href": "api/internal/stream-local-copy/3/01-stream/00/011/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Do copy optimization. Inheritance > Methods StreamLocalCopy() Declaration internal::StreamLocalCopy<Stream, 1>::StreamLocalCopy(Stream&original) ~StreamLocalCopy() Declaration internal::StreamLocalCopy<Stream, 1>::~StreamLocalCopy() operator=() Declaration StreamLocalCopy&internal::StreamLocalCopy<Stream, 1>::operator=(const StreamLocalCopy&)"
  },
  "api/internal/token-helper.html": {
    "href": "api/internal/token-helper.html",
    "title": "Struct internal::TokenHelper | qiotoolkit",
    "keywords": "Struct internal::TokenHelper Methods AppendIndexToken() Declaration static RAPIDJSON_FORCEINLINE void internal::TokenHelper<Stack, Ch>::AppendIndexToken(Stack&documentStack, SizeType index)"
  },
  "api/internal/token-helper/3/01-stack/00/01char/01/4.html": {
    "href": "api/internal/token-helper/3/01-stack/00/01char/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods AppendIndexToken() Declaration static RAPIDJSON_FORCEINLINE void internal::TokenHelper<Stack, char>::AppendIndexToken(Stack&documentStack, SizeType index)"
  },
  "api/internal/type-helper.html": {
    "href": "api/internal/type-helper.html",
    "title": "Struct internal::TypeHelper | qiotoolkit",
    "keywords": "Struct internal::TypeHelper"
  },
  "api/internal/type-helper/3/01-value-type/00/01bool/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01bool/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, bool>::Is(const ValueType&v) Get() Declaration static bool internal::TypeHelper<ValueType, bool>::Get(const ValueType&v) Set() Declaration static ValueType&internal::TypeHelper<ValueType, bool>::Set(ValueType&v, bool data) Set() Declaration static ValueType&internal::TypeHelper<ValueType, bool>::Set(ValueType&v, bool data, typename ValueType::AllocatorType&)"
  },
  "api/internal/type-helper/3/01-value-type/00/01const/01typename/01-value-type/ch/01/5/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01const/01typename/01-value-type/ch/01/5/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, const typename ValueType::Ch *>::Is(const ValueType&v) Get() Declaration static StringType internal::TypeHelper<ValueType, const typename ValueType::Ch *>::Get(const ValueType&v) Set() Declaration static ValueType&internal::TypeHelper<ValueType, const typename ValueType::Ch *>::Set(ValueType&v, const StringType data) Set() Declaration static ValueType&internal::TypeHelper<ValueType, const typename ValueType::Ch *>::Set(ValueType&v, const StringType data, typename ValueType::AllocatorType&a)"
  },
  "api/internal/type-helper/3/01-value-type/00/01double/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01double/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, double>::Is(const ValueType&v) Get() Declaration static double internal::TypeHelper<ValueType, double>::Get(const ValueType&v) Set() Declaration static ValueType&internal::TypeHelper<ValueType, double>::Set(ValueType&v, double data) Set() Declaration static ValueType&internal::TypeHelper<ValueType, double>::Set(ValueType&v, double data, typename ValueType::AllocatorType&)"
  },
  "api/internal/type-helper/3/01-value-type/00/01float/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01float/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, float>::Is(const ValueType&v) Get() Declaration static float internal::TypeHelper<ValueType, float>::Get(const ValueType&v) Set() Declaration static ValueType&internal::TypeHelper<ValueType, float>::Set(ValueType&v, float data) Set() Declaration static ValueType&internal::TypeHelper<ValueType, float>::Set(ValueType&v, float data, typename ValueType::AllocatorType&)"
  },
  "api/internal/type-helper/3/01-value-type/00/01int/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01int/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, int>::Is(const ValueType&v) Get() Declaration static int internal::TypeHelper<ValueType, int>::Get(const ValueType&v) Set() Declaration static ValueType&internal::TypeHelper<ValueType, int>::Set(ValueType&v, int data) Set() Declaration static ValueType&internal::TypeHelper<ValueType, int>::Set(ValueType&v, int data, typename ValueType::AllocatorType&)"
  },
  "api/internal/type-helper/3/01-value-type/00/01int64/t/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01int64/t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, int64_t>::Is(const ValueType&v) Get() Declaration static int64_t internal::TypeHelper<ValueType, int64_t>::Get(const ValueType&v) Set() Declaration static ValueType&internal::TypeHelper<ValueType, int64_t>::Set(ValueType&v, int64_t data) Set() Declaration static ValueType&internal::TypeHelper<ValueType, int64_t>::Set(ValueType&v, int64_t data, typename ValueType::AllocatorType&)"
  },
  "api/internal/type-helper/3/01-value-type/00/01typename/01-value-type/array/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01typename/01-value-type/array/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, typename ValueType::Array>::Is(const ValueType&v) Get() Declaration static ArrayType internal::TypeHelper<ValueType, typename ValueType::Array>::Get(ValueType&v) Set() Declaration static ValueType&internal::TypeHelper<ValueType, typename ValueType::Array>::Set(ValueType&v, ArrayType data) Set() Declaration static ValueType&internal::TypeHelper<ValueType, typename ValueType::Array>::Set(ValueType&v, ArrayType data, typename ValueType::AllocatorType&)"
  },
  "api/internal/type-helper/3/01-value-type/00/01typename/01-value-type/const-array/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01typename/01-value-type/const-array/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, typename ValueType::ConstArray>::Is(const ValueType&v) Get() Declaration static ArrayType internal::TypeHelper<ValueType, typename ValueType::ConstArray>::Get(const ValueType&v)"
  },
  "api/internal/type-helper/3/01-value-type/00/01typename/01-value-type/const-object/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01typename/01-value-type/const-object/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, typename ValueType::ConstObject>::Is(const ValueType&v) Get() Declaration static ObjectType internal::TypeHelper<ValueType, typename ValueType::ConstObject>::Get(const ValueType&v)"
  },
  "api/internal/type-helper/3/01-value-type/00/01typename/01-value-type/object/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01typename/01-value-type/object/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, typename ValueType::Object>::Is(const ValueType&v) Get() Declaration static ObjectType internal::TypeHelper<ValueType, typename ValueType::Object>::Get(ValueType&v) Set() Declaration static ValueType&internal::TypeHelper<ValueType, typename ValueType::Object>::Set(ValueType&v, ObjectType data) Set() Declaration static ValueType&internal::TypeHelper<ValueType, typename ValueType::Object>::Set(ValueType&v, ObjectType data, typename ValueType::AllocatorType&)"
  },
  "api/internal/type-helper/3/01-value-type/00/01uint64/t/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01uint64/t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, uint64_t>::Is(const ValueType&v) Get() Declaration static uint64_t internal::TypeHelper<ValueType, uint64_t>::Get(const ValueType&v) Set() Declaration static ValueType&internal::TypeHelper<ValueType, uint64_t>::Set(ValueType&v, uint64_t data) Set() Declaration static ValueType&internal::TypeHelper<ValueType, uint64_t>::Set(ValueType&v, uint64_t data, typename ValueType::AllocatorType&)"
  },
  "api/internal/type-helper/3/01-value-type/00/01unsigned/01/4.html": {
    "href": "api/internal/type-helper/3/01-value-type/00/01unsigned/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Is() Declaration static bool internal::TypeHelper<ValueType, unsigned>::Is(const ValueType&v) Get() Declaration static unsigned internal::TypeHelper<ValueType, unsigned>::Get(const ValueType&v) Set() Declaration static ValueType&internal::TypeHelper<ValueType, unsigned>::Set(ValueType&v, unsigned data) Set() Declaration static ValueType&internal::TypeHelper<ValueType, unsigned>::Set(ValueType&v, unsigned data, typename ValueType::AllocatorType&)"
  },
  "api/is/proto/enum/3/0/1-quantum-util/problem/problem-type/01/4.html": {
    "href": "api/is/proto/enum/3/0/1-quantum-util/problem/problem-type/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/json-reader-stack-item.html": {
    "href": "api/json-reader-stack-item.html",
    "title": "Struct JsonReaderStackItem | qiotoolkit",
    "keywords": "Struct JsonReaderStackItem Constructors JsonReaderStackItem() Declaration JsonReaderStackItem::JsonReaderStackItem(const Value *value, State state)"
  },
  "api/json-reader.html": {
    "href": "api/json-reader.html",
    "title": "Class JsonReader | qiotoolkit",
    "keywords": "Class JsonReader Represents a JSON reader which implements Archiver concept. Inheritance JsonReader Constructors JsonReader() Constructor. json A non-const source json string for in-situ parsing. in-situ means the source JSON string will be modified after parsing. Declaration JsonReader::JsonReader(const char *json) JsonReader() Declaration JsonReader::JsonReader(const JsonReader&) Methods ~JsonReader() Destructor. Declaration JsonReader::~JsonReader() operator bool() Declaration JsonReader::operator bool() const StartObject() Declaration JsonReader&JsonReader::StartObject() Member() Declaration JsonReader&JsonReader::Member(const char *name) HasMember() Declaration bool JsonReader::HasMember(const char *name) const EndObject() Declaration JsonReader&JsonReader::EndObject() StartArray() Declaration JsonReader&JsonReader::StartArray(size_t *size=0) EndArray() Declaration JsonReader&JsonReader::EndArray() &() Declaration JsonReader&JsonReader::operator&(bool&b) &() Declaration JsonReader&JsonReader::operator&(bool&b) &() Declaration JsonReader&JsonReader::operator&(unsigned&u) &() Declaration JsonReader&JsonReader::operator&(unsigned&u) &() Declaration JsonReader&JsonReader::operator&(int&i) &() Declaration JsonReader&JsonReader::operator&(int&i) &() Declaration JsonReader&JsonReader::operator&(double&d) &() Declaration JsonReader&JsonReader::operator&(double&d) &() Declaration JsonReader&JsonReader::operator&(std::string&s) &() Declaration JsonReader&JsonReader::operator&(std::string&s) SetNull() Declaration JsonReader&JsonReader::SetNull() operator=() Declaration JsonReader&JsonReader::operator=(const JsonReader&) Next() Declaration void JsonReader::Next()"
  },
  "api/json-writer.html": {
    "href": "api/json-writer.html",
    "title": "Class JsonWriter | qiotoolkit",
    "keywords": "Class JsonWriter Inheritance JsonWriter Constructors JsonWriter() Constructor. Declaration JsonWriter::JsonWriter() JsonWriter() Declaration JsonWriter::JsonWriter(const JsonWriter&) Methods ~JsonWriter() Destructor. Declaration JsonWriter::~JsonWriter() GetString() Obtains the serialized JSON string. Declaration const char * JsonWriter::GetString() const operator bool() Declaration JsonWriter::operator bool() const StartObject() Declaration JsonWriter&JsonWriter::StartObject() Member() Declaration JsonWriter&JsonWriter::Member(const char *name) HasMember() Declaration bool JsonWriter::HasMember(const char *name) const EndObject() Declaration JsonWriter&JsonWriter::EndObject() StartArray() Declaration JsonWriter&JsonWriter::StartArray(size_t *size=0) EndArray() Declaration JsonWriter&JsonWriter::EndArray() &() Declaration JsonWriter&JsonWriter::operator&(bool&b) &() Declaration JsonWriter&JsonWriter::operator&(bool&b) &() Declaration JsonWriter&JsonWriter::operator&(unsigned&u) &() Declaration JsonWriter&JsonWriter::operator&(unsigned&u) &() Declaration JsonWriter&JsonWriter::operator&(int&i) &() Declaration JsonWriter&JsonWriter::operator&(int&i) &() Declaration JsonWriter&JsonWriter::operator&(double&d) &() Declaration JsonWriter&JsonWriter::operator&(double&d) &() Declaration JsonWriter&JsonWriter::operator&(std::string&s) &() Declaration JsonWriter&JsonWriter::operator&(std::string&s) SetNull() Declaration JsonWriter&JsonWriter::SetNull() operator=() Declaration JsonWriter&JsonWriter::operator=(const JsonWriter&)"
  },
  "api/jsonx-writer.html": {
    "href": "api/jsonx-writer.html",
    "title": "Class JsonxWriter | qiotoolkit",
    "keywords": "Class JsonxWriter Inheritance JsonxWriter Constructors JsonxWriter() Declaration JsonxWriter<OutputStream>::JsonxWriter(OutputStream&os) Methods Null() Declaration bool JsonxWriter<OutputStream>::Null() Bool() Declaration bool JsonxWriter<OutputStream>::Bool(bool b) Int() Declaration bool JsonxWriter<OutputStream>::Int(int i) Uint() Declaration bool JsonxWriter<OutputStream>::Uint(unsigned i) Int64() Declaration bool JsonxWriter<OutputStream>::Int64(int64_t i) Uint64() Declaration bool JsonxWriter<OutputStream>::Uint64(uint64_t i) Double() Declaration bool JsonxWriter<OutputStream>::Double(double d) RawNumber() Declaration bool JsonxWriter<OutputStream>::RawNumber(const char *str, SizeType length, bool) String() Declaration bool JsonxWriter<OutputStream>::String(const char *str, SizeType length, bool) StartObject() Declaration bool JsonxWriter<OutputStream>::StartObject() Key() Declaration bool JsonxWriter<OutputStream>::Key(const char *str, SizeType length, bool) EndObject() Declaration bool JsonxWriter<OutputStream>::EndObject(SizeType) StartArray() Declaration bool JsonxWriter<OutputStream>::StartArray() EndArray() Declaration bool JsonxWriter<OutputStream>::EndArray(SizeType) WriteString() Declaration bool JsonxWriter<OutputStream>::WriteString(const char *s) WriteEscapedAttributeValue() Declaration bool JsonxWriter<OutputStream>::WriteEscapedAttributeValue(const char *s, size_t length) WriteEscapedText() Declaration bool JsonxWriter<OutputStream>::WriteEscapedText(const char *s, size_t length) WriteStartElement() Declaration bool JsonxWriter<OutputStream>::WriteStartElement(const char *type, bool emptyElement=false) WriteEndElement() Declaration bool JsonxWriter<OutputStream>::WriteEndElement(const char *type) WriteNumberElement() Declaration bool JsonxWriter<OutputStream>::WriteNumberElement(const char *buffer, int length)"
  },
  "api/lookahead-parser-handler.html": {
    "href": "api/lookahead-parser-handler.html",
    "title": "Class LookaheadParserHandler | qiotoolkit",
    "keywords": "Class LookaheadParserHandler Inheritance LookaheadParserHandler LookaheadParser Constructors LookaheadParserHandler() Declaration LookaheadParserHandler::LookaheadParserHandler(char *str) Methods Null() Declaration bool LookaheadParserHandler::Null() Bool() Declaration bool LookaheadParserHandler::Bool(bool b) Int() Declaration bool LookaheadParserHandler::Int(int i) Uint() Declaration bool LookaheadParserHandler::Uint(unsigned u) Int64() Declaration bool LookaheadParserHandler::Int64(int64_t i) Uint64() Declaration bool LookaheadParserHandler::Uint64(uint64_t u) Double() Declaration bool LookaheadParserHandler::Double(double d) RawNumber() Declaration bool LookaheadParserHandler::RawNumber(const char *, SizeType, bool) String() Declaration bool LookaheadParserHandler::String(const char *str, SizeType length, bool) StartObject() Declaration bool LookaheadParserHandler::StartObject() Key() Declaration bool LookaheadParserHandler::Key(const char *str, SizeType length, bool) EndObject() Declaration bool LookaheadParserHandler::EndObject(SizeType) StartArray() Declaration bool LookaheadParserHandler::StartArray() EndArray() Declaration bool LookaheadParserHandler::EndArray(SizeType) ParseNext() Declaration void LookaheadParserHandler::ParseNext()"
  },
  "api/lookahead-parser.html": {
    "href": "api/lookahead-parser.html",
    "title": "Class LookaheadParser | qiotoolkit",
    "keywords": "Class LookaheadParser Inheritance LookaheadParserHandler LookaheadParser Inherited Members StartObject RawNumber Int64 EndObject Int ParseNext StartArray EndArray Null Uint Key String LookaheadParserHandler Bool Uint64 LookaheadParsingState Double Constructors LookaheadParser() Declaration LookaheadParser::LookaheadParser(char *str) Methods EnterObject() Declaration bool LookaheadParser::EnterObject() EnterArray() Declaration bool LookaheadParser::EnterArray() NextObjectKey() Declaration const char * LookaheadParser::NextObjectKey() NextArrayValue() Declaration bool LookaheadParser::NextArrayValue() GetInt() Declaration int LookaheadParser::GetInt() GetDouble() Declaration double LookaheadParser::GetDouble() GetString() Declaration const char * LookaheadParser::GetString() GetBool() Declaration bool LookaheadParser::GetBool() GetNull() Declaration void LookaheadParser::GetNull() SkipObject() Declaration void LookaheadParser::SkipObject() SkipArray() Declaration void LookaheadParser::SkipArray() SkipValue() Declaration void LookaheadParser::SkipValue() PeekValue() Declaration Value * LookaheadParser::PeekValue() PeekType() Declaration int LookaheadParser::PeekType() IsValid() Declaration bool LookaheadParser::IsValid() SkipOut() Declaration void LookaheadParser::SkipOut(int depth)"
  },
  "api/markov/cluster-walker.html": {
    "href": "api/markov/cluster-walker.html",
    "title": "Class markov::ClusterWalker | qiotoolkit",
    "keywords": "Class markov::ClusterWalker ClusterWalker is an abstract base class for quantum like space explorers A ClusterWalker stores multiple state and costs and has pointers to a model and random number generator to make steps. It is specifically designed to allow copy assignment (assuming the Model::State_T does), such that it can be duplicated in population markovs. The Walker provides a base implementation of the step function, which proposes a random new states, computes the cost differences, uses virtual method to decide whether to create cluster binded variables from multiple states invokes a pure virtual method to decide whether to accept, and modifies the internal states using cluster if true is returned. From this we can implement a QuantumWalker by returning acceptance rate based on quantum transverse field. Inheritance utils::Component markov::ClusterWalker markov::QuantumWalker Inherited Members configure render ~Component Component get_status param get_class_name Constructors ClusterWalker() The rng and model must be set before the object can be used. cost is only intialized after a call to init() Declaration markov::ClusterWalker<Model>::ClusterWalker() Methods init() Must be called after the rng_ and model_ have been set. It initializes the walker to a random state and precomputes its current cost. Note This is typically the only direct call to calculate_cost; from here the current cost_ is updated from the computed difference at each step. Declaration virtual void markov::ClusterWalker<Model>::init(size_t n_states=1) init_state() Declaration void markov::ClusterWalker<Model>::init_state(size_t state_index, ::utils::RandomGenerator&rng) accept() Implementations of the walker interface must provide a method to decide which steps to accept/reject. Currently this is only based on cost_difference, but the state or transition could be added. Declaration virtual bool markov::ClusterWalker<Model>::accept(const typename Model::Cost_T&cost_difference, ::utils::RandomGenerator&rng)=0 accept_cluster() Implementations of the walker interface must provide a method to decide which cluster to accept/reject. Declaration virtual bool markov::ClusterWalker<Model>::accept_cluster(::utils::RandomGenerator&rng)=0 get_transition() For models with a 'size_t' transition type, do an ordered sweep. Declaration std::enable_if<std::is_same<TT, size_t>::value, void>::type markov::ClusterWalker<Model>::get_transition(size_t variable_index, typename Model::Transition_T&transition, utils::RandomGenerator&) get_transition() For any other transition type, do a random sweep. Declaration std::enable_if<!std::is_same<TT, size_t>::value, void>::type markov::ClusterWalker<Model>::get_transition(size_t, typename Model::Transition_T&transition, utils::RandomGenerator&rng) set_model() Provide a pointer to the (non-owned) model to use for cost calculations and proposing new steps. Declaration void markov::ClusterWalker<Model>::set_model(const Model *model) model() Return a constant reference to the model being used. Declaration const Model&markov::ClusterWalker<Model>::model() get_evaluation_counter() Declaration solver::EvaluationCounter markov::ClusterWalker<Model>::get_evaluation_counter() add_difference_evaluations() Declaration void markov::ClusterWalker<Model>::add_difference_evaluations(size_t number_evals) add_function_evaluations() Declaration void markov::ClusterWalker<Model>::add_function_evaluations(size_t number_evals) reset_evaluation_counter() Declaration void markov::ClusterWalker<Model>::reset_evaluation_counter() get_lowest_cost() Declaration Model::Cost_T markov::ClusterWalker<Model>::get_lowest_cost() const get_lowest_state() Declaration const Model::State_T&markov::ClusterWalker<Model>::get_lowest_state() const get_states() Declaration const std::vector<typename Model::State_T>&markov::ClusterWalker<Model>::get_states() get_costs() Declaration const std::vector<typename Model::Cost_T>&markov::ClusterWalker<Model>::get_costs() size() Declaration size_t markov::ClusterWalker<Model>::size() try_form_clusters() Declaration void markov::ClusterWalker<Model>::try_form_clusters(size_t state_index, const typename Model::Transition_T&transition, utils::RandomGenerator&rng) try_flip_clusters() Declaration void markov::ClusterWalker<Model>::try_flip_clusters(size_t state_index, utils::RandomGenerator&rng) calculate_cost_diff() For models derived from model::FacedGraphModel, an extra parameter for a cost object is necessary to communicate cached calculations. Declaration std::enable_if<!std::is_base_of<model::FacedGraphModel<TS, TT>, TM>::value, void>::type markov::ClusterWalker<Model>::calculate_cost_diff(size_t state_index, const typename Model::Transition_T&transition) calculate_cost_diff() For models derived from model::FacedGraphModel, an extra parameter for a cost object is necessary to communicate cached calculations. Declaration std::enable_if<std::is_base_of<model::FacedGraphModel<TS, TT>, TM>::value, void>::type markov::ClusterWalker<Model>::calculate_cost_diff(size_t state_index, const typename Model::Transition_T&transition) apply_transition() For models derived from model::FacedGraphModel, an extra parameter for a cost object is necessary to communicate cached calculations. Declaration std::enable_if<!std::is_base_of<model::FacedGraphModel<TS, TT>, TM>::value, void>::type markov::ClusterWalker<Model>::apply_transition(size_t state_index, const typename Model::Transition_T&transition) apply_transition() For models derived from model::FacedGraphModel, an extra parameter for a cost object is necessary to communicate cached calculations. Declaration std::enable_if<std::is_base_of<model::FacedGraphModel<TS, TT>, TM>::value, void>::type markov::ClusterWalker<Model>::apply_transition(size_t state_index, const typename Model::Transition_T&transition) save_lowest() Store the current lowest state as the lowest. Declaration void markov::ClusterWalker<Model>::save_lowest() memory_estimate() Estimate memory consumtion using model parameters. Declaration static size_t markov::ClusterWalker<Model>::memory_estimate(const Model&model, size_t n_states) compare() Declaration static bool markov::ClusterWalker<Model>::compare(const ClusterWalker<Model>&w1, const ClusterWalker<Model>&w2)"
  },
  "api/markov/hill-climbing-walker.html": {
    "href": "api/markov/hill-climbing-walker.html",
    "title": "Class markov::HillClimbingWalker | qiotoolkit",
    "keywords": "Class markov::HillClimbingWalker A Hill climbing walker accepts every move reducing the cost and keeps moving if cost is same. NOTE: computing cost_difference is typically not superfluous as it will be needed within Walker::make_step() to update the cached cost_. Inheritance markov::Walker markov::HillClimbingWalker Inherited Members get_lowest_state check_lowest state reset_evaluation_counter make_sweep swap_state make_sweep set_model model Walker make_sweeps make_sweep attempt_transition get_evaluation_counter set_rng save_lowest rng memory_estimate apply_transition init get_lowest_cost make_step cost init apply_scale_factor compare attempt_transition apply_transition verify_cost_difference configure render ~Component Component get_status param get_class_name Methods accept() Implementations of the walker interface must provide a method to decide which steps to accept/reject. Currently this is only based on cost_difference, but the state or transition could be added. Declaration bool markov::HillClimbingWalker<Model>::accept(const typename Model::Cost_T&cost_diff) override"
  },
  "api/markov/index.html": {
    "href": "api/markov/index.html",
    "title": "Markov Chain | qiotoolkit",
    "keywords": "Markov Chain"
  },
  "api/markov/linear-sweep-model.html": {
    "href": "api/markov/linear-sweep-model.html",
    "title": "Class markov::LinearSweepModel | qiotoolkit",
    "keywords": "Class markov::LinearSweepModel Base class for implementations which wish to have full control over how an entire sweep is performed. Implementations should. Defer to accept(delta_cost) -> bool when deciding whether to apply a proposed change (this is typically the metropolis acceptance rate) 2) Call check_lowest() whenever a potentially new lowest cost is found (check_lowest, as opposed to save_lowest, does store the state as new best only if its cost is lower than the current best) 3) Keep \"cost\" updated to the one corresponding to the current state (at least before every call to check_lowest() and after the sweep is completed). Inheritance markov::Model markov::LinearSweepModel Inherited Members get_benchmark_properties estimate_max_cost_diff has_initial_configuration Model configure state_only_memory_estimate get_term_count get_sweep_size init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff get_scale_factor is_empty set_step_limit is_rescaled state_memory_estimate rescale render calculate_cost_difference get_random_transition get_const_cost configure get_random_state match_version get_version ~BaseModel configure BaseModel get_identifier render ~Component Component get_status param get_class_name Methods make_linear_sweep() Declaration virtual void markov::LinearSweepModel<State>::make_linear_sweep(double&cost, State&state, std::function<bool(double)>accept, std::function<void(void)>check_lowest) const =0"
  },
  "api/markov/metropolis.html": {
    "href": "api/markov/metropolis.html",
    "title": "Class markov::Metropolis | qiotoolkit",
    "keywords": "Class markov::Metropolis Metropolis Algorithm. Random sampling approximating the Boltzmann distribution using a Markov chain Monte Carlo approach. Inheritance markov::Walker markov::Metropolis Inherited Members get_lowest_state check_lowest state reset_evaluation_counter make_sweep swap_state make_sweep set_model model Walker make_sweeps make_sweep attempt_transition get_evaluation_counter set_rng save_lowest rng apply_transition init get_lowest_cost make_step cost init apply_scale_factor compare attempt_transition apply_transition verify_cost_difference configure render ~Component Component get_status param get_class_name Constructors Metropolis() Create a Metropolis instance with uninitialized model and state. Declaration markov::Metropolis<Model>::Metropolis() Methods temperature() Get the current temperature for sampling. Declaration double markov::Metropolis<Model>::temperature() const beta() Get the current inverse sampling temperature. Declaration double markov::Metropolis<Model>::beta() const set_temperature() Set the sampling temperature (also updates beta_). Declaration void markov::Metropolis<Model>::set_temperature(double temperature) set_beta() Declaration void markov::Metropolis<Model>::set_beta(double beta) accept() Decide whether to accept a given cost increase. Declaration bool markov::Metropolis<Model>::accept(const typename Model::Cost_T&cost_diff) override memory_estimate() Estimate memory consumption using model parameters. Declaration static size_t markov::Metropolis<Model>::memory_estimate(const Model&model)"
  },
  "api/markov/model.html": {
    "href": "api/markov/model.html",
    "title": "Class markov::Model | qiotoolkit",
    "keywords": "Class markov::Model Interface for Markov models. Implementations of the Markov model interface must provide A calculate_cost (to calculate the cost of an entire state as well as the calculate_cost_difference incurred by a specific transition). The means to generate the Monte Carlo chain (random_state, random_transition and apply_transition). The interface is templated for both the underlying Markov state and transition, such that users can decide how to represent each. The base classes markov::State and markov::Transition are provided as guidelines for designing these model-specifc types, but they are not enforced to be used. (That is, you may use Model<std::string, int> if a string is sufficient to represent your state and an int defines a transition. State Transition For initial testing, you may also opt to use the simplified classes markov::SimpleTransition and markov::SimpleModel. SimpleModel SimpleTransition Inheritance model::BaseModel markov::Model Inherited Members match_version get_version ~BaseModel configure BaseModel get_identifier ~Component Component get_status param get_class_name Constructors Model() Create an uninitialized model. Declaration markov::Model<State, Transition, Cost>::Model() Methods set_step_limit() Declaration void markov::Model<State, Transition, Cost>::set_step_limit(uint64_t limit) configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void markov::Model<State, Transition, Cost>::configure(const utils::Json&json) override configure() Declaration void markov::Model<State, Transition, Cost>::configure(model::BaseModelConfiguration&configuration) init() Initializes internal data structures (guaranteed to be called after configure()). Declaration void markov::Model<State, Transition, Cost>::init() override calculate_cost() Definition of the cost function. Evaluate the entire cost function for the state being passed. For instance, in the case of a model from statistical mechanics, this would be the Hamiltonian. Declaration virtual Cost_T markov::Model<State, Transition, Cost>::calculate_cost(const State_T&state) const =0 calculate_cost_difference() Partial evaluation of the cost function. This method should calculate the difference in cost if we move from state (=before) to the one resulting from applying transition to state (=after): \\Delta_{C} = C_{\\mathrm{after}} - C_{\\mathrm{before}} In code: State state = get_random_state(rng); Transition transition = get_random_transition(rng); double cost_before = calculate_cost(state); double cost_diff = calculate_cost_difference(state, transition); apply_transition(transition, state); // modify state double cost_after = calculate_cost(state); // before + diff should correspond to after (up to double precision) assert(cost_before + cost_diff == cost_after); Declaration virtual Cost_T markov::Model<State, Transition, Cost>::calculate_cost_difference(const State_T&state, const Transition_T&transition) const =0 get_random_state() Return a valid random state for the model. The various algorithms don't know how to initialize a valid state; this allows them to start with a random one. NOTE: The rng being passed should be used for randomness (as opposed to creating one for the model), as multiple threads can potentially use the same underlying model (albeit with separate rngs). Declaration virtual State_T markov::Model<State, Transition, Cost>::get_random_state(utils::RandomGenerator&rng) const =0 has_initial_configuration() Check if model has initial configuration. Declaration virtual bool markov::Model<State, Transition, Cost>::has_initial_configuration() const get_initial_configuration_state() Return a state from initial configuration. Declaration virtual State_T markov::Model<State, Transition, Cost>::get_initial_configuration_state() const get_random_transition() Return a random transition starting at state. The various algorithms don't know how to move throuhg markov space; this allows them to pick a random direction given a starting point. By definition, the next markov state should only depend on the current one, so only the last one is passed to this function. \"random\" does not necessitate equi-distributed here (you may choose a different distribution if your model dictates it). However, the the typical choise is to pick randomly from all possible moves at state with equal probability. Declaration virtual Transition_T markov::Model<State, Transition, Cost>::get_random_transition(const State_T&state, utils::RandomGenerator&rng) const =0 apply_transition() Apply a transition to a state. This changes the configuration represented by *state. Depending on the optimization algorithm, transition can either be applied conditionally or alaways (e.g., population dynamics). Separating the functionality into the three interfaces random_transition, calculate_cost_difference, apply_transition leaves control over the strategy with the optimization method. Declaration virtual void markov::Model<State, Transition, Cost>::apply_transition(const Transition&transition, State&state) const =0 render_state() Render a state of this model. Default implementation of how a state of this model is rendered (by' invoking the state's proper rendering mechanic). Overloading this method allows a model implementation to customize how a state is printed. This is relevant if the rendering needs to depend on model parameters in addition to the state. Declaration virtual utils::Structure markov::Model<State, Transition, Cost>::render_state(const State_T&state) const get_sweep_size() Return the number of (attempted) transition to consider one sweep. This number is expected to scale roughly with the number of variables in the model such that, on average, each variable is selected once per sweep (if selected randomly). Declaration virtual size_t markov::Model<State, Transition, Cost>::get_sweep_size() const get_term_count() Declaration virtual size_t markov::Model<State, Transition, Cost>::get_term_count() const get_benchmark_properties() Collect statistics about the model being simulated. The output of this method will appear in the Response.benchmark.input_data field. By default, we do not collect any model statistics implementations of this interface must override this method to fill the output. Declaration virtual utils::Structure markov::Model<State, Transition, Cost>::get_benchmark_properties() const render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure markov::Model<State, Transition, Cost>::render() const override is_rescaled() Declaration virtual bool markov::Model<State, Transition, Cost>::is_rescaled() const rescale() Declaration virtual void markov::Model<State, Transition, Cost>::rescale() get_scale_factor() Declaration virtual Cost_T markov::Model<State, Transition, Cost>::get_scale_factor() const get_const_cost() Declaration virtual Cost_T markov::Model<State, Transition, Cost>::get_const_cost() const is_empty() Declaration virtual bool markov::Model<State, Transition, Cost>::is_empty() const =0 state_memory_estimate() Estimate memory consumption of model state and lowest state in bytes, using paramters known by model. Numerous states will be created by solvers. Estimation of memory consumption is needed to avoid memory overflow. States may have complex nature, so knowledge of model parameters should be used for accurate estimation. For prototype models return 0 could be used. Declaration virtual size_t markov::Model<State, Transition, Cost>::state_memory_estimate() const =0 state_only_memory_estimate() Declaration virtual size_t markov::Model<State, Transition, Cost>::state_only_memory_estimate() const =0 estimate_max_cost_diff() Declaration virtual double markov::Model<State, Transition, Cost>::estimate_max_cost_diff() const estimate_min_cost_diff() Declaration virtual double markov::Model<State, Transition, Cost>::estimate_min_cost_diff() const"
  },
  "api/markov/quantum-walker.html": {
    "href": "api/markov/quantum-walker.html",
    "title": "Class markov::QuantumWalker | qiotoolkit",
    "keywords": "Class markov::QuantumWalker Quantum Algorithm. Inheritance markov::ClusterWalker markov::QuantumWalker Inherited Members init_state get_lowest_state try_form_clusters add_difference_evaluations size init try_flip_clusters calculate_cost_diff ClusterWalker save_lowest calculate_cost_diff apply_transition reset_evaluation_counter get_transition model get_costs set_model get_states get_evaluation_counter memory_estimate apply_transition get_transition add_function_evaluations compare get_lowest_cost configure render ~Component Component get_status param get_class_name Constructors QuantumWalker() Create a Metropolis instance with uninitialized model and state. Declaration markov::QuantumWalker<Model>::QuantumWalker() Methods beta() Declaration double markov::QuantumWalker<Model>::beta() const set_beta() Declaration void markov::QuantumWalker<Model>::set_beta(double beta) bond_probability() Declaration double markov::QuantumWalker<Model>::bond_probability() const set_bond_probability() Declaration void markov::QuantumWalker<Model>::set_bond_probability(double bond_prob) accept() Decide whether to accept a given cost increase. Declaration bool markov::QuantumWalker<Model>::accept(const typename Model::Cost_T&cost_diff, ::utils::RandomGenerator&rng) override accept_cluster() Decide whether to accept addition to cluster. Declaration bool markov::QuantumWalker<Model>::accept_cluster(::utils::RandomGenerator&rng) override memory_estimate() Estimate memory consumtion using model parameters. Declaration static size_t markov::QuantumWalker<Model>::memory_estimate(const Model&model)"
  },
  "api/markov/random-walker.html": {
    "href": "api/markov/random-walker.html",
    "title": "Class markov::RandomWalker | qiotoolkit",
    "keywords": "Class markov::RandomWalker A RandomWalker accepts every move. Note computing cost_difference is typically not superfluous as it will be needed within Walker::make_step() to update the cached cost_. Inheritance markov::Walker markov::RandomWalker Inherited Members get_lowest_state check_lowest state reset_evaluation_counter make_sweep swap_state make_sweep set_model model Walker make_sweeps make_sweep attempt_transition get_evaluation_counter set_rng save_lowest rng memory_estimate apply_transition init get_lowest_cost make_step cost init apply_scale_factor compare attempt_transition apply_transition verify_cost_difference configure render ~Component Component get_status param get_class_name Methods accept() Implementations of the walker interface must provide a method to decide which steps to accept/reject. Currently this is only based on cost_difference, but the state or transition could be added. Declaration bool markov::RandomWalker<Model>::accept(const typename Model::Cost_T&) override"
  },
  "api/markov/simple-model.html": {
    "href": "api/markov/simple-model.html",
    "title": "Class markov::SimpleModel | qiotoolkit",
    "keywords": "Class markov::SimpleModel Simplified Model representation. This base class has a predifined transition type (SimpleTransition) and implementations for calculate_cost_difference and apply_transition. These implementations make no assumptions about the model and they are, as a result, typically inefficient (i.e., calculating the whole calculate_cost in lieu of only the changed parts). The base class is provided as a means for rapid prototyping because it requires less interfaces to be implemented. Inheritance markov::Model markov::SimpleModel Inherited Members get_benchmark_properties estimate_max_cost_diff has_initial_configuration Model configure state_only_memory_estimate get_term_count get_sweep_size init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff get_scale_factor is_empty set_step_limit is_rescaled state_memory_estimate rescale render get_random_transition get_const_cost configure get_random_state match_version ~BaseModel configure BaseModel render ~Component Component get_status param get_class_name Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string markov::SimpleModel<State>::get_identifier() const override=0 get_version() Returns the version of the input format this implementation expects. Declaration std::string markov::SimpleModel<State>::get_version() const override=0 calculate_cost_difference() Default calculate_cost_difference implementation. This computes the expected difference of a transition by invoking calculate_cost twice. This is almost always inefficient (at the very least, one could cache the value for the starting point). SimpleModel therefore only serves the purpose of rapidly writing a base implementation to check against. Note This relies on using SimpleTransition with the model - such that both the start and end state of the transition can easily be accessed. Declaration Cost_T markov::SimpleModel<State>::calculate_cost_difference(const State_T&state, const Transition_T&transition) const override apply_transition() Default apply_transition implementation. Since SimpleTransition has Transition as a base, we can just use its apply method (which, in turn, will set state to to()). Declaration virtual void markov::SimpleModel<State>::apply_transition(const Transition_T&transition, State_T&state) const override"
  },
  "api/markov/simple-transition.html": {
    "href": "api/markov/simple-transition.html",
    "title": "Class markov::SimpleTransition | qiotoolkit",
    "keywords": "Class markov::SimpleTransition Predefined simple markov transition. This is a transition class which works for any State it simply keeps track of the state before and after the transition. This is convenient for initial testing but not efficient because: New states are repeatedly created for each (potential transition) calculate_cost_difference() cannot exploit knowledge about what changed to partially recalculate the calculate_cost (apart from calculating the diff from state and target). Inheritance markov::Transition markov::SimpleTransition Constructors SimpleTransition() Create a simple transition to an explicit target state. Declaration markov::SimpleTransition<State>::SimpleTransition(State target) Methods target() Accessor for the target state. Declaration const State&markov::SimpleTransition<State>::target() const"
  },
  "api/markov/state.html": {
    "href": "api/markov/state.html",
    "title": "Class markov::State | qiotoolkit",
    "keywords": "Class markov::State Representation of a State in the Markov chain. A markov state is one possible configuration of the underlying system. To form a markov chain it is modified according to allowed Transitions into \"neighboring\" states which typically differ from it by a simple operation (such as the change of one variable of the configuration). There are no API requirements on the state itself other than that it must be serializable (i.e., implement the Serializable interface) to allow checkpointing. utils::Renderable markov::Transition Inheritance utils::Component markov::State examples::SoftSpinState model::Binary model::BinaryWithCounter model::BlumeCapelState model::ClockState model::IsingState model::Partition model::Permutation model::PolyState model::PottsState model::PuboBinaryAdaptive Inherited Members configure render ~Component Component get_status param get_class_name"
  },
  "api/markov/tabu-walker.html": {
    "href": "api/markov/tabu-walker.html",
    "title": "Class markov::TabuWalker | qiotoolkit",
    "keywords": "Class markov::TabuWalker Tabu walker. Inheritance markov::Walker markov::TabuWalker Inherited Members get_lowest_state check_lowest state reset_evaluation_counter swap_state set_model model Walker make_sweeps attempt_transition get_evaluation_counter set_rng save_lowest rng apply_transition get_lowest_cost make_step cost init apply_scale_factor compare attempt_transition apply_transition verify_cost_difference configure render ~Component Component get_status param get_class_name Constructors TabuWalker() Create a TabuWalker instance with uninitialized model and state. Declaration markov::TabuWalker<Model>::TabuWalker() Methods init() Must be called after the rng_ and model_ have been set. It initializes the walker to a random state and precomputes its current cost. Note This is typically the only direct call to calculate_cost; from here the current cost_ is updated from the computed difference at each step. Declaration void markov::TabuWalker<Model>::init() override accept() Decide whether to accept a given cost increase. Declaration bool markov::TabuWalker<Model>::accept(const typename Model::Cost_T&cost_diff) override make_sweep() Declaration void markov::TabuWalker<Model>::make_sweep() set_tenure() Set tabu tenure parameter. Declaration void markov::TabuWalker<Model>::set_tenure(unsigned int tabu_tenure) memory_estimate() Estimate memory consumption using model parameters. Declaration static size_t markov::TabuWalker<Model>::memory_estimate(const Model&model) clear_tabu_list() Declaration std::enable_if<std::is_same<TT, size_t>::value, void>::type markov::TabuWalker<Model>::clear_tabu_list(void) clear_tabu_list() Declaration std::enable_if<!std::is_same<TT, size_t>::value, void>::type markov::TabuWalker<Model>::clear_tabu_list(void) get_transition() Declaration std::enable_if<std::is_same<TT, size_t>::value, TT>::type markov::TabuWalker<Model>::get_transition(size_t i) get_transition() Declaration std::enable_if<!std::is_same<TT, size_t>::value, TT>::type markov::TabuWalker<Model>::get_transition(size_t) local_search_init() Declaration void markov::TabuWalker<Model>::local_search_init() local_search_sweep() Declaration void markov::TabuWalker<Model>::local_search_sweep()"
  },
  "api/markov/transition.html": {
    "href": "api/markov/transition.html",
    "title": "Class markov::Transition | qiotoolkit",
    "keywords": "Class markov::Transition Base class for a markov transition. A transition describes a proposed move from the current to the next state. Depending on the algorithm, this move might be conditionally accepted, in which case the algorithm invokes apply_transition(transition, &state) on the model. Note When deciding how to represent your transition, try to envision the minimum amount of information required for apply_transition to do its work. This is typically also what calculate_cost_difference needs to efficiently calculate the resulting change in cost for a transition. markov::State markov::Model::apply_transition markov::Model::calculate_cost_difference Inheritance utils::Component markov::Transition examples::SoftSpinTransition markov::SimpleTransition model::BlumeCapelTransition model::PolyTransition model::PottsTransition model::TspTransition Inherited Members configure render ~Component Component get_status param get_class_name"
  },
  "api/markov/walker.html": {
    "href": "api/markov/walker.html",
    "title": "Class markov::Walker | qiotoolkit",
    "keywords": "Class markov::Walker Walker is an abstract base class for configuration space explorers A walker container stores its current state and cost and has pointers to a model and random number generator to make steps. It is specifically designed to allow copy assignment (assuming the Model::State_T does), such that it can be duplicated in population markovs. The Walker provides a base implementation of the step function, which proposes a random new state, computes the cost difference, invokes a pure virtual method to decide whether to accept, and modifies the internal state if true is returned. From this we can implement a RandomWalker by always returning true and a Metropolis walker by returning the Boltzmann acceptance rate. markov::Metropolis Inheritance utils::Component markov::Walker markov::HillClimbingWalker markov::Metropolis markov::RandomWalker markov::TabuWalker Inherited Members configure render ~Component Component get_status param get_class_name Constructors Walker() The rng and model must be set before the object can be used. cost is only intialized after a call to init() Declaration markov::Walker<Model>::Walker() Methods init() Must be called after the rng_ and model_ have been set. It initializes the walker to a random state and precomputes its current cost. Note This is typically the only direct call to calculate_cost; from here the current cost_ is updated from the computed difference at each step. Declaration virtual void markov::Walker<Model>::init() init() Must be called after the model_ has been set. Initializes the walker to a specific state and precomputes its current cost. Declaration virtual void markov::Walker<Model>::init(const typename Model::State_T&state) accept() Implementations of the walker interface must provide a method to decide which steps to accept/reject. Currently this is only based on cost_difference, but the state or transition could be added. Declaration virtual bool markov::Walker<Model>::accept(const typename Model::Cost_T&cost_difference)=0 verify_cost_difference() Verify cost difference does a sanity check on the calculated energy difference by evaluating the whole cost function and comparing it to the cached value. This is very costly and happens only in DEBUG builds, not in RELEASE builds. Note An exception thrown by this sanity check means that the implementations of calculate_cost and calculate_cost_difference are not compatible (or, less likely, the model or state have been modified since the total cost was cached). Declaration bool markov::Walker<Model>::verify_cost_difference(const typename Model::Cost_T&returned_difference) apply_transition() For models derived from model::FacedGraphModel, an extra parameter for a cost object is necessary to communicate cached calculations. Declaration std::enable_if<std::is_base_of<model::FacedGraphModel<TS, TT>, TM>::value, void>::type markov::Walker<Model>::apply_transition(const typename Model::Transition_T&transition, typename Model::Cost_T cost_diff) apply_transition() For all other models, no extra cost parameter is needed. Declaration std::enable_if<!std::is_base_of<model::FacedGraphModel<TS, TT>, TM>::value, void>::type markov::Walker<Model>::apply_transition(const typename Model::Transition_T&transition, typename Model::Cost_T cost_diff) make_sweep() For models derived from markov::LinearSweepModel, let the model handle the entire sweep. Declaration std::enable_if<std::is_base_of<markov::LinearSweepModel<TS>, TM>::value, void>::type markov::Walker<Model>::make_sweep() make_sweep() For models with a 'size_t' transition type, do an ordered sweep. Declaration std::enable_if<std::is_same<TT, size_t>::value&&!std::is_base_of<markov::LinearSweepModel<TS>, TM>::value, void>::type markov::Walker<Model>::make_sweep() make_sweep() For any other transition type, do a random sweep. Declaration std::enable_if<!std::is_same<TT, size_t>::value&&!std::is_base_of<markov::LinearSweepModel<TS>, TM>::value, void>::type markov::Walker<Model>::make_sweep() make_sweeps() Perform multiple sweeps. Declaration void markov::Walker<Model>::make_sweeps(size_t n_sweeps) make_step() Perform a single (random) step. Declaration void markov::Walker<Model>::make_step() attempt_transition() Attempt the given transition and apply it if accepted by the walker condition. For models derived from model::FacedGraphModel, an extra parameter for a cost object is necessary to communicate cached calculations. Declaration std::enable_if<std::is_base_of<model::FacedGraphModel<TS, TT>, TM>::value, typename Model::Cost_T>::type markov::Walker<Model>::attempt_transition(const typename Model::Transition_T&transition) attempt_transition() Attempt the given transition and apply it if accepted by the walker condition. For all other models, no extra cost parameter is needed. Declaration std::enable_if<!std::is_base_of<model::FacedGraphModel<TS, TT>, TM>::value, typename Model::Cost_T>::type markov::Walker<Model>::attempt_transition(const typename Model::Transition_T&transition) cost() Return the cost of the current state (cached within the walker). Declaration const Model::Cost_T&markov::Walker<Model>::cost() const state() Return the current state of this walker. Declaration const Model::State_T&markov::Walker<Model>::state() const set_model() Provide a pointer to the (non-owned) model to use for cost calculations and proposing new steps. Declaration void markov::Walker<Model>::set_model(const Model *model) set_rng() Provide a pointer to the (non-owned) random number generator to use. Multithreading must either be handled via mutex within the random number generator or by the calling class. Declaration void markov::Walker<Model>::set_rng(utils::RandomGenerator *rng) model() Return a constant reference to the model being used. Declaration const Model&markov::Walker<Model>::model() rng() Return a reference to the random number generator to use. Declaration utils::RandomGenerator&markov::Walker<Model>::rng() swap_state() Swap the state with another instance. This exchanges the internal markov::State and the associated (cached) cost_ with another metropolis instance. Declaration void markov::Walker<Model>::swap_state(Walker *other) get_evaluation_counter() Declaration solver::EvaluationCounter markov::Walker<Model>::get_evaluation_counter() reset_evaluation_counter() Declaration void markov::Walker<Model>::reset_evaluation_counter() save_lowest() Unconditionally store the current state as the lowest (during init) Declaration void markov::Walker<Model>::save_lowest() check_lowest() Save the current state as new best if its cost is lower than the previous best. Declaration void markov::Walker<Model>::check_lowest() get_lowest_cost() Declaration Model::Cost_T markov::Walker<Model>::get_lowest_cost() const apply_scale_factor() Declaration void markov::Walker<Model>::apply_scale_factor(double scale_factor) get_lowest_state() Declaration const Model::State_T&markov::Walker<Model>::get_lowest_state() const memory_estimate() Estimate memory consumption using model parameters. Declaration static size_t markov::Walker<Model>::memory_estimate(const Model&model) compare() Declaration static bool markov::Walker<Model>::compare(const Walker<Model>&w1, const Walker<Model>&w2)"
  },
  "api/matcher/all-of-matcher.html": {
    "href": "api/matcher/all-of-matcher.html",
    "title": "Class matcher::AllOfMatcher | qiotoolkit",
    "keywords": "Class matcher::AllOfMatcher Inheritance matcher::AllOfMatcher Constructors AllOfMatcher() Declaration matcher::AllOfMatcher<A, B>::AllOfMatcher(const A&a, const B&b) Methods matches() Declaration bool matcher::AllOfMatcher<A, B>::matches(const T&value) const explain() Declaration std::string matcher::AllOfMatcher<A, B>::explain(const T&value) const"
  },
  "api/matcher/all-of.html": {
    "href": "api/matcher/all-of.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/any-matcher.html": {
    "href": "api/matcher/any-matcher.html",
    "title": "Class matcher::AnyMatcher | qiotoolkit",
    "keywords": "Class matcher::AnyMatcher Inheritance matcher::AnyMatcher Methods matches() Declaration bool matcher::AnyMatcher::matches(const T&) const explain() Declaration std::string matcher::AnyMatcher::explain(const T&value) const"
  },
  "api/matcher/any-of-matcher.html": {
    "href": "api/matcher/any-of-matcher.html",
    "title": "Class matcher::AnyOfMatcher | qiotoolkit",
    "keywords": "Class matcher::AnyOfMatcher Inheritance matcher::AnyOfMatcher Constructors AnyOfMatcher() Declaration matcher::AnyOfMatcher<A, B>::AnyOfMatcher(const A&a, const B&b) Methods matches() Declaration bool matcher::AnyOfMatcher<A, B>::matches(const T&value) const explain() Declaration std::string matcher::AnyOfMatcher<A, B>::explain(const T&value) const"
  },
  "api/matcher/any-of.html": {
    "href": "api/matcher/any-of.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/any.html": {
    "href": "api/matcher/any.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/ascending.html": {
    "href": "api/matcher/ascending.html",
    "title": "Class matcher::Ascending | qiotoolkit",
    "keywords": "Class matcher::Ascending Inheritance matcher::Ascending Methods in_order() Declaration bool matcher::Ascending::in_order(const A&a, const B&b) explain() Declaration std::string matcher::Ascending::explain() reverse() Declaration std::string matcher::Ascending::reverse()"
  },
  "api/matcher/descending.html": {
    "href": "api/matcher/descending.html",
    "title": "Class matcher::Descending | qiotoolkit",
    "keywords": "Class matcher::Descending Inheritance matcher::Descending Methods in_order() Declaration bool matcher::Descending::in_order(const A&a, const B&b) explain() Declaration std::string matcher::Descending::explain() reverse() Declaration std::string matcher::Descending::reverse()"
  },
  "api/matcher/each-matcher.html": {
    "href": "api/matcher/each-matcher.html",
    "title": "Class matcher::EachMatcher | qiotoolkit",
    "keywords": "Class matcher::EachMatcher Inheritance matcher::EachMatcher Constructors EachMatcher() Declaration matcher::EachMatcher<ElementMatcher>::EachMatcher(ElementMatcher element_matcher) Methods matches() Declaration bool matcher::EachMatcher<ElementMatcher>::matches(const std::vector<T>&container) const explain() Declaration std::string matcher::EachMatcher<ElementMatcher>::explain(const std::vector<T>&container) const"
  },
  "api/matcher/each.html": {
    "href": "api/matcher/each.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/equal-to-matcher.html": {
    "href": "api/matcher/equal-to-matcher.html",
    "title": "Class matcher::EqualToMatcher | qiotoolkit",
    "keywords": "Class matcher::EqualToMatcher Inheritance matcher::EqualToMatcher Constructors EqualToMatcher() Declaration matcher::EqualToMatcher<T>::EqualToMatcher(const T&expected) Methods matches() Declaration bool matcher::EqualToMatcher<T>::matches(const V&value) const explain() Declaration std::string matcher::EqualToMatcher<T>::explain(const V&value) const"
  },
  "api/matcher/equal-to.html": {
    "href": "api/matcher/equal-to.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/greater-equal-matcher.html": {
    "href": "api/matcher/greater-equal-matcher.html",
    "title": "Class matcher::GreaterEqualMatcher | qiotoolkit",
    "keywords": "Class matcher::GreaterEqualMatcher Inheritance matcher::GreaterEqualMatcher Constructors GreaterEqualMatcher() Declaration matcher::GreaterEqualMatcher<T>::GreaterEqualMatcher(const T&expected) Methods matches() Declaration bool matcher::GreaterEqualMatcher<T>::matches(const V&value) const explain() Declaration std::string matcher::GreaterEqualMatcher<T>::explain(const V&value) const"
  },
  "api/matcher/greater-equal.html": {
    "href": "api/matcher/greater-equal.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/greater-than-matcher.html": {
    "href": "api/matcher/greater-than-matcher.html",
    "title": "Class matcher::GreaterThanMatcher | qiotoolkit",
    "keywords": "Class matcher::GreaterThanMatcher Inheritance matcher::GreaterThanMatcher Constructors GreaterThanMatcher() Declaration matcher::GreaterThanMatcher<T>::GreaterThanMatcher(const T&expected) Methods matches() Declaration bool matcher::GreaterThanMatcher<T>::matches(const V&value) const explain() Declaration std::string matcher::GreaterThanMatcher<T>::explain(const V&value) const"
  },
  "api/matcher/greater-than.html": {
    "href": "api/matcher/greater-than.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/index.html": {
    "href": "api/matcher/index.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/is-empty-matcher.html": {
    "href": "api/matcher/is-empty-matcher.html",
    "title": "Class matcher::IsEmptyMatcher | qiotoolkit",
    "keywords": "Class matcher::IsEmptyMatcher Inheritance matcher::IsEmptyMatcher Methods matches() Declaration bool matcher::IsEmptyMatcher::matches(const T&value) const explain() Declaration std::string matcher::IsEmptyMatcher::explain(const T&value) const"
  },
  "api/matcher/is-empty.html": {
    "href": "api/matcher/is-empty.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/is-sorted-matcher.html": {
    "href": "api/matcher/is-sorted-matcher.html",
    "title": "Class matcher::IsSortedMatcher | qiotoolkit",
    "keywords": "Class matcher::IsSortedMatcher Inheritance matcher::IsSortedMatcher Constructors IsSortedMatcher() Declaration matcher::IsSortedMatcher<Order>::IsSortedMatcher(const Order&order) Methods matches() Declaration bool matcher::IsSortedMatcher<Order>::matches(const std::vector<T>&v) const explain() Declaration std::string matcher::IsSortedMatcher<Order>::explain(const std::vector<T>&v) const"
  },
  "api/matcher/is-sorted.html": {
    "href": "api/matcher/is-sorted.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/less-equal-matcher.html": {
    "href": "api/matcher/less-equal-matcher.html",
    "title": "Class matcher::LessEqualMatcher | qiotoolkit",
    "keywords": "Class matcher::LessEqualMatcher Inheritance matcher::LessEqualMatcher Constructors LessEqualMatcher() Declaration matcher::LessEqualMatcher<T>::LessEqualMatcher(const T&expected) Methods matches() Declaration bool matcher::LessEqualMatcher<T>::matches(const V&value) const explain() Declaration std::string matcher::LessEqualMatcher<T>::explain(const V&value) const"
  },
  "api/matcher/less-equal.html": {
    "href": "api/matcher/less-equal.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/less-than-matcher.html": {
    "href": "api/matcher/less-than-matcher.html",
    "title": "Class matcher::LessThanMatcher | qiotoolkit",
    "keywords": "Class matcher::LessThanMatcher Inheritance matcher::LessThanMatcher Constructors LessThanMatcher() Declaration matcher::LessThanMatcher<T>::LessThanMatcher(const T&expected) Methods matches() Declaration bool matcher::LessThanMatcher<T>::matches(const V&value) const explain() Declaration std::string matcher::LessThanMatcher<T>::explain(const V&value) const"
  },
  "api/matcher/less-than.html": {
    "href": "api/matcher/less-than.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/none-of-matcher.html": {
    "href": "api/matcher/none-of-matcher.html",
    "title": "Class matcher::NoneOfMatcher | qiotoolkit",
    "keywords": "Class matcher::NoneOfMatcher Inheritance matcher::NoneOfMatcher Constructors NoneOfMatcher() Declaration matcher::NoneOfMatcher<A, B>::NoneOfMatcher(const A&a, const B&b) Methods matches() Declaration bool matcher::NoneOfMatcher<A, B>::matches(const T&value) const explain() Declaration std::string matcher::NoneOfMatcher<A, B>::explain(const T&value) const"
  },
  "api/matcher/none-of.html": {
    "href": "api/matcher/none-of.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/not-matcher.html": {
    "href": "api/matcher/not-matcher.html",
    "title": "Class matcher::NotMatcher | qiotoolkit",
    "keywords": "Class matcher::NotMatcher Inheritance matcher::NotMatcher Constructors NotMatcher() Declaration matcher::NotMatcher<M>::NotMatcher(const M&m) Methods matches() Declaration bool matcher::NotMatcher<M>::matches(const T&value) const explain() Declaration std::string matcher::NotMatcher<M>::explain(const T&value) const"
  },
  "api/matcher/not.html": {
    "href": "api/matcher/not.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/size-is-matcher.html": {
    "href": "api/matcher/size-is-matcher.html",
    "title": "Class matcher::SizeIsMatcher | qiotoolkit",
    "keywords": "Class matcher::SizeIsMatcher Inheritance matcher::SizeIsMatcher Constructors SizeIsMatcher() Declaration matcher::SizeIsMatcher<SizeMatcher>::SizeIsMatcher(const SizeMatcher&size_matcher) Methods matches() Declaration bool matcher::SizeIsMatcher<SizeMatcher>::matches(const T&container) const explain() Declaration std::string matcher::SizeIsMatcher<SizeMatcher>::explain(const T&container) const"
  },
  "api/matcher/size-is.html": {
    "href": "api/matcher/size-is.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/matcher/strictly-ascending.html": {
    "href": "api/matcher/strictly-ascending.html",
    "title": "Class matcher::StrictlyAscending | qiotoolkit",
    "keywords": "Class matcher::StrictlyAscending Inheritance matcher::StrictlyAscending Methods in_order() Declaration bool matcher::StrictlyAscending::in_order(const A&a, const B&b) explain() Declaration std::string matcher::StrictlyAscending::explain() reverse() Declaration std::string matcher::StrictlyAscending::reverse()"
  },
  "api/matcher/strictly-descending.html": {
    "href": "api/matcher/strictly-descending.html",
    "title": "Class matcher::StrictlyDescending | qiotoolkit",
    "keywords": "Class matcher::StrictlyDescending Inheritance matcher::StrictlyDescending Methods in_order() Declaration bool matcher::StrictlyDescending::in_order(const A&a, const B&b) explain() Declaration std::string matcher::StrictlyDescending::explain() reverse() Declaration std::string matcher::StrictlyDescending::reverse()"
  },
  "api/memory-pool-allocator.html": {
    "href": "api/memory-pool-allocator.html",
    "title": "Class MemoryPoolAllocator | qiotoolkit",
    "keywords": "Class MemoryPoolAllocator Default memory allocator used by the parser and DOM. This allocator allocate memory blocks from pre-allocated memory chunks. It does not free memory blocks. And Realloc() only allocate new memory. The memory chunks are allocated by BaseAllocator, which is CrtAllocator by default. User may also supply a buffer as the first chunk. If the user-buffer is full then additional chunks are allocated by BaseAllocator. The user-buffer is not deallocated by this allocator. BaseAllocator the allocator type for allocating memory chunks. Default is CrtAllocator. implements Allocator concept Inheritance MemoryPoolAllocator Constructors MemoryPoolAllocator() Constructor with chunkSize. chunkSize The size of memory chunk. The default is kDefaultChunkSize. baseAllocator The allocator for allocating memory chunks. Declaration MemoryPoolAllocator<BaseAllocator>::MemoryPoolAllocator(size_t chunkSize=kDefaultChunkCapacity, BaseAllocator *baseAllocator=0) MemoryPoolAllocator() Constructor with user-supplied buffer. The user buffer will be used firstly. When it is full, memory pool allocates new chunk with chunk size. The user buffer will not be deallocated when this allocator is destructed. buffer User supplied buffer. size Size of the buffer in bytes. It must at least larger than sizeof(ChunkHeader). chunkSize The size of memory chunk. The default is kDefaultChunkSize. baseAllocator The allocator for allocating memory chunks. Declaration MemoryPoolAllocator<BaseAllocator>::MemoryPoolAllocator(void *buffer, size_t size, size_t chunkSize=kDefaultChunkCapacity, BaseAllocator *baseAllocator=0) MemoryPoolAllocator() Declaration MemoryPoolAllocator<BaseAllocator>::MemoryPoolAllocator(const MemoryPoolAllocator&rhs) RAPIDJSON_NOEXCEPT Methods GetChunkHead() Declaration static ChunkHeader* MemoryPoolAllocator<BaseAllocator>::GetChunkHead(SharedData *shared) GetChunkBuffer() Declaration static uint8_t* MemoryPoolAllocator<BaseAllocator>::GetChunkBuffer(SharedData *shared) AlignBuffer() Declaration static void* MemoryPoolAllocator<BaseAllocator>::AlignBuffer(void *buf, size_t&size) operator=() Declaration MemoryPoolAllocator&MemoryPoolAllocator<BaseAllocator>::operator=(const MemoryPoolAllocator&rhs) RAPIDJSON_NOEXCEPT ~MemoryPoolAllocator() Destructor. This deallocates all memory chunks, excluding the user-supplied buffer. Declaration MemoryPoolAllocator<BaseAllocator>::~MemoryPoolAllocator() RAPIDJSON_NOEXCEPT Clear() Deallocates all memory chunks, excluding the first/user one. Declaration void MemoryPoolAllocator<BaseAllocator>::Clear() RAPIDJSON_NOEXCEPT Capacity() Computes the total capacity of allocated memory chunks. total capacity in bytes. Declaration size_t MemoryPoolAllocator<BaseAllocator>::Capacity() const RAPIDJSON_NOEXCEPT Size() Computes the memory blocks allocated. total used bytes. Declaration size_t MemoryPoolAllocator<BaseAllocator>::Size() const RAPIDJSON_NOEXCEPT Shared() Whether the allocator is shared. true or false. Declaration bool MemoryPoolAllocator<BaseAllocator>::Shared() const RAPIDJSON_NOEXCEPT Malloc() Allocates a memory block. (concept Allocator) Declaration void* MemoryPoolAllocator<BaseAllocator>::Malloc(size_t size) Realloc() Resizes a memory block (concept Allocator) Declaration void* MemoryPoolAllocator<BaseAllocator>::Realloc(void *originalPtr, size_t originalSize, size_t newSize) operator==() Compare (equality) with another MemoryPoolAllocator. Declaration bool MemoryPoolAllocator<BaseAllocator>::operator==(const MemoryPoolAllocator&rhs) const RAPIDJSON_NOEXCEPT operator!=() Compare (inequality) with another MemoryPoolAllocator. Declaration bool MemoryPoolAllocator<BaseAllocator>::operator!=(const MemoryPoolAllocator&rhs) const RAPIDJSON_NOEXCEPT Free() Frees a memory block (concept Allocator) Declaration static void MemoryPoolAllocator<BaseAllocator>::Free(void *ptr) RAPIDJSON_NOEXCEPT AddChunk() Creates a new chunk. capacity Capacity of the chunk in bytes. true if success. Declaration bool MemoryPoolAllocator<BaseAllocator>::AddChunk(size_t capacity)"
  },
  "api/memory-pool-allocator/chunk-header.html": {
    "href": "api/memory-pool-allocator/chunk-header.html",
    "title": "Struct MemoryPoolAllocator::ChunkHeader | qiotoolkit",
    "keywords": "Struct MemoryPoolAllocator::ChunkHeader Chunk header for perpending to each chunk. Chunks are stored as a singly linked list."
  },
  "api/memory-pool-allocator/shared-data.html": {
    "href": "api/memory-pool-allocator/shared-data.html",
    "title": "Struct MemoryPoolAllocator::SharedData | qiotoolkit",
    "keywords": "Struct MemoryPoolAllocator::SharedData"
  },
  "api/memory-stream.html": {
    "href": "api/memory-stream.html",
    "title": "Struct MemoryStream | qiotoolkit",
    "keywords": "Struct MemoryStream Represents an in-memory input byte stream. This class is mainly for being wrapped by EncodedInputStream or AutoUTFInputStream. It is similar to FileReadBuffer but the source is an in-memory buffer instead of a file. Differences between MemoryStream and StringStream: StringStream has encoding but MemoryStream is a byte stream. MemoryStream needs size of the source buffer and the buffer don't need to be null terminated. StringStream assume null-terminated string as source. MemoryStream supports Peek4() for encoding detection. StringStream is specified with an encoding so it should not have Peek4(). implements Stream concept Constructors MemoryStream() Declaration MemoryStream::MemoryStream(const Ch *src, size_t size) Methods Peek() Declaration Ch MemoryStream::Peek() const Take() Declaration Ch MemoryStream::Take() Tell() Declaration size_t MemoryStream::Tell() const PutBegin() Declaration Ch* MemoryStream::PutBegin() Put() Declaration void MemoryStream::Put(Ch) Flush() Declaration void MemoryStream::Flush() PutEnd() Declaration size_t MemoryStream::PutEnd(Ch *) Peek4() Declaration const Ch* MemoryStream::Peek4() const"
  },
  "api/message-handler.html": {
    "href": "api/message-handler.html",
    "title": "Struct MessageHandler | qiotoolkit",
    "keywords": "Struct MessageHandler Inherited Members Int64 Uint Uint64 String Double Int StartArray RawNumber Bool Key Null EndArray Constructors MessageHandler() Declaration MessageHandler::MessageHandler() Methods StartObject() Declaration bool MessageHandler::StartObject() String() Declaration bool MessageHandler::String(const char *str, SizeType length, bool) EndObject() Declaration bool MessageHandler::EndObject(SizeType) Default() Declaration bool MessageHandler::Default()"
  },
  "api/model/abstract-ising.html": {
    "href": "api/model/abstract-ising.html",
    "title": "Class model::AbstractIsing | qiotoolkit",
    "keywords": "Class model::AbstractIsing Ising Model. Inheritance model::GraphModel model::AbstractIsing Inherited Members Model state_only_memory_estimate init get_initial_configuration_state estimate_min_cost_diff set_step_limit state_memory_estimate render configure ~BaseModel configure BaseModel edge get_const_cost node rescale node_count estimate_max_cost_diff get_term_count get_scale_factor is_empty has_initial_configuration is_rescaled edges get_initial_configuration nodes get_sweep_size get_benchmark_properties edge_count render ~Component Component get_status param get_class_name Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::AbstractIsing<State_T, Cost_T>::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::AbstractIsing<State_T, Cost_T>::get_version() const override match_version() Checks the string argument against the expected version. This can be overloaded to accept other version than the one returned by get_version(). Declaration void model::AbstractIsing<State_T, Cost_T>::match_version(const std::string&version) override calculate_cost() Cost function: \\mathcal{H} = -\\sum_{j\\in\\mathrm{\\{edges\\}}} c_j\\prod_{i\\in j}s_i Declaration double model::AbstractIsing<State_T, Cost_T>::calculate_cost(const State_T&state) const override calculate_cost_difference() Cost difference: \\Delta_{i\\to i'} = 2 \\sum_{j\\in e_i} c_j\\prod_{i\\in j}s_i Declaration double model::AbstractIsing<State_T, Cost_T>::calculate_cost_difference(const State_T&state, const Transition_T&spin_id) const override get_random_state() Return a random Ising state. The number of Ising variables (terms) is determined from the number of nodes (edges) in the underlying graph. Declaration State_T model::AbstractIsing<State_T, Cost_T>::get_random_state(utils::RandomGenerator&rng) const override get_initial_configuration_state() Declaration State_T model::AbstractIsing<State_T, Cost_T>::get_initial_configuration_state() const override get_random_transition() Return a random Single spin update. We represent a single spin update as merely the index of the spin variable that will flip. Declaration Transition_T model::AbstractIsing<State_T, Cost_T>::get_random_transition(const State_T&, utils::RandomGenerator&rng) const override apply_transition() Flip the spin specified by spin_id. Declaration void model::AbstractIsing<State_T, Cost_T>::apply_transition(const Transition_T&spin_id, State_T&state) const override=0 configure() Serialize metadata and the underlying graph. The underlying graph represents the \"disorder\" of the Ising model (glass) we are simulating. Declaration void model::AbstractIsing<State_T, Cost_T>::configure(const utils::Json&json) override configure() Declaration void model::AbstractIsing<State_T, Cost_T>::configure(typename Graph::Configuration_T&configuration) render_state() Render a state of this model. Default implementation of how a state of this model is rendered (by' invoking the state's proper rendering mechanic). Overloading this method allows a model implementation to customize how a state is printed. This is relevant if the rendering needs to depend on model parameters in addition to the state. Declaration utils::Structure model::AbstractIsing<State_T, Cost_T>::render_state(const State_T&state) const override state_memory_estimate() Declaration size_t model::AbstractIsing<State_T, Cost_T>::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::AbstractIsing<State_T, Cost_T>::state_only_memory_estimate() const override estimate_max_cost_diff() Declaration double model::AbstractIsing<State_T, Cost_T>::estimate_max_cost_diff() const override estimate_min_cost_diff() Declaration double model::AbstractIsing<State_T, Cost_T>::estimate_min_cost_diff() const override get_term() Calculate the term with id term_id. Declaration virtual double model::AbstractIsing<State_T, Cost_T>::get_term(const State_T&state, size_t term_id) const =0"
  },
  "api/model/abstract-pubo.html": {
    "href": "api/model/abstract-pubo.html",
    "title": "Class model::AbstractPubo | qiotoolkit",
    "keywords": "Class model::AbstractPubo Inheritance model::GraphModel model::AbstractPubo Inherited Members Model state_only_memory_estimate init get_initial_configuration_state calculate_cost estimate_min_cost_diff set_step_limit state_memory_estimate render calculate_cost_difference configure ~BaseModel configure BaseModel edge get_const_cost node rescale node_count estimate_max_cost_diff get_term_count get_scale_factor is_empty has_initial_configuration is_rescaled get_initial_configuration get_sweep_size get_benchmark_properties edge_count render ~Component Component get_status param get_class_name Constructors AbstractPubo() Declaration model::AbstractPubo<State_T, Cost_T>::AbstractPubo() Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::AbstractPubo<State_T, Cost_T>::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::AbstractPubo<State_T, Cost_T>::get_version() const override match_version() Checks the string argument against the expected version. This can be overloaded to accept other version than the one returned by get_version(). Declaration void model::AbstractPubo<State_T, Cost_T>::match_version(const std::string&version) override ~AbstractPubo() Declaration virtual model::AbstractPubo<State_T, Cost_T>::~AbstractPubo() configure() Populates model internals from the input json. Declaration void model::AbstractPubo<State_T, Cost_T>::configure(const utils::Json&json) override configure() Declaration void model::AbstractPubo<State_T, Cost_T>::configure(typename Graph::Configuration_T&configuration) get_random_state() Return a valid random state for the model. The various algorithms don't know how to initialize a valid state; this allows them to start with a random one. NOTE: The rng being passed should be used for randomness (as opposed to creating one for the model), as multiple threads can potentially use the same underlying model (albeit with separate rngs). Declaration State_T model::AbstractPubo<State_T, Cost_T>::get_random_state(utils::RandomGenerator&rng) const override get_initial_configuration_state() Declaration State_T model::AbstractPubo<State_T, Cost_T>::get_initial_configuration_state() const override get_random_transition() Return a random transition starting at state. The various algorithms don't know how to move throuhg markov space; this allows them to pick a random direction given a starting point. By definition, the next markov state should only depend on the current one, so only the last one is passed to this function. \"random\" does not necessitate equi-distributed here (you may choose a different distribution if your model dictates it). However, the the typical choise is to pick randomly from all possible moves at state with equal probability. Declaration Transition_T model::AbstractPubo<State_T, Cost_T>::get_random_transition(const State_T&, utils::RandomGenerator&rng) const override apply_transition() Apply a transition to a state. This changes the configuration represented by *state. Depending on the optimization algorithm, transition can either be applied conditionally or alaways (e.g., population dynamics). Separating the functionality into the three interfaces random_transition, calculate_cost_difference, apply_transition leaves control over the strategy with the optimization method. Declaration virtual void model::AbstractPubo<State_T, Cost_T>::apply_transition(const Transition_T&transition, State_T&state) const override=0 render_state() Render a state of this model. Default implementation of how a state of this model is rendered (by' invoking the state's proper rendering mechanic). Overloading this method allows a model implementation to customize how a state is printed. This is relevant if the rendering needs to depend on model parameters in addition to the state. Declaration utils::Structure model::AbstractPubo<State_T, Cost_T>::render_state(const State_T&state) const override state_memory_estimate() Declaration size_t model::AbstractPubo<State_T, Cost_T>::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::AbstractPubo<State_T, Cost_T>::state_only_memory_estimate() const override estimate_min_cost_diff() Declaration double model::AbstractPubo<State_T, Cost_T>::estimate_min_cost_diff() const override edges() Return a vector of all the edges. Declaration const std::vector<Edge>&model::GraphModel<State_T, Transition_T, Cost_T>::edges() const nodes() Return a vector of all the nodes. Declaration const std::vector<Node>&model::GraphModel<State_T, Transition_T, Cost_T>::nodes() const"
  },
  "api/model/base-model-configuration.html": {
    "href": "api/model/base-model-configuration.html",
    "title": "Class model::BaseModelConfiguration | qiotoolkit",
    "keywords": "Class model::BaseModelConfiguration Inheritance model::BaseModelConfiguration model::BaseModelPreviewConfiguration model::FacedGraphModelConfiguration model::GraphModelConfiguration model::MaxSatConfiguration model::PolyConfiguration model::Terms::TermsConfiguration model::TspConfiguration"
  },
  "api/model/base-model-configuration/get/type.html": {
    "href": "api/model/base-model-configuration/get/type.html",
    "title": "Struct model::BaseModelConfiguration::Get_Type | qiotoolkit",
    "keywords": "Struct model::BaseModelConfiguration::Get_Type Methods get() Declaration static std::string&model::BaseModelConfiguration::Get_Type::get(BaseModelConfiguration&m) get_key() Declaration static std::string model::BaseModelConfiguration::Get_Type::get_key()"
  },
  "api/model/base-model-configuration/get/version.html": {
    "href": "api/model/base-model-configuration/get/version.html",
    "title": "Struct model::BaseModelConfiguration::Get_Version | qiotoolkit",
    "keywords": "Struct model::BaseModelConfiguration::Get_Version Methods get() Declaration static std::string&model::BaseModelConfiguration::Get_Version::get(BaseModelConfiguration&m) get_key() Declaration static std::string model::BaseModelConfiguration::Get_Version::get_key()"
  },
  "api/model/base-model-preview-configuration.html": {
    "href": "api/model/base-model-preview-configuration.html",
    "title": "Class model::BaseModelPreviewConfiguration | qiotoolkit",
    "keywords": "Class model::BaseModelPreviewConfiguration Inheritance model::BaseModelConfiguration model::BaseModelPreviewConfiguration"
  },
  "api/model/base-model.html": {
    "href": "api/model/base-model.html",
    "title": "Class model::BaseModel | qiotoolkit",
    "keywords": "Class model::BaseModel BaseModel class (non-markov specific) Base class implementing methods needed for model selection. A pointer to this base class can be used by the owner of the model (through it needs to be dynamic-cast to a pointer to the specific model type when setting it on the solver). [!NOTE] This is different from the markov::Model class which has the interfaces to interact with markov-based optimizers. Inheritance utils::Component model::BaseModel markov::Model Inherited Members render ~Component Component get_status param get_class_name Constructors BaseModel() Declaration model::BaseModel::BaseModel()=default Methods ~BaseModel() Declaration virtual model::BaseModel::~BaseModel()=default get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration virtual std::string model::BaseModel::get_identifier() const =0 get_version() Returns the version of the input format this implementation expects. Declaration virtual std::string model::BaseModel::get_version() const =0 configure() Populates model internals from the input json. Declaration void model::BaseModel::configure(const utils::Json&json) override configure() Populates model internals from the input configuration. Declaration void model::BaseModel::configure(BaseModelConfiguration&configuration) configure() Populates the model from a related model The trelated model is considered useless after this. Declaration void model::BaseModel::configure(BaseModel *base) init() Initializes internal data structures (guaranteed to be called after configure()). Declaration void model::BaseModel::init() match_version() Checks the string argument against the expected version. This can be overloaded to accept other version than the one returned by get_version(). Declaration void model::BaseModel::match_version(const std::string&version)"
  },
  "api/model/binary-with-counter.html": {
    "href": "api/model/binary-with-counter.html",
    "title": "Class model::BinaryWithCounter | qiotoolkit",
    "keywords": "Class model::BinaryWithCounter Inheritance markov::State model::BinaryWithCounter Inherited Members configure ~Component Component get_status param get_class_name Constructors BinaryWithCounter() Declaration model::BinaryWithCounter<T>::BinaryWithCounter() BinaryWithCounter() Declaration model::BinaryWithCounter<T>::BinaryWithCounter(size_t N, size_t M) Methods copy_state_only() Declaration void model::BinaryWithCounter<T>::copy_state_only(const BinaryWithCounter&other) render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure model::BinaryWithCounter<T>::render() const override render() Declaration utils::Structure model::BinaryWithCounter<T>::render(const std::map<int, int>&ids_map) const memory_estimate() Declaration static size_t model::BinaryWithCounter<T>::memory_estimate(size_t N, size_t M) state_only_memory_estimate() Declaration static size_t model::BinaryWithCounter<T>::state_only_memory_estimate(size_t N)"
  },
  "api/model/binary.html": {
    "href": "api/model/binary.html",
    "title": "Class model::Binary | qiotoolkit",
    "keywords": "Class model::Binary Inheritance markov::State model::Binary model::PuboCompactState Inherited Members configure ~Component Component get_status param get_class_name Constructors Binary() Declaration model::Binary::Binary() Binary() Declaration model::Binary::Binary(size_t N, size_t) Methods copy_state_only() Declaration void model::Binary::copy_state_only(const Binary&other) render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure model::Binary::render() const override render() Declaration utils::Structure model::Binary::render(const std::map<int, int>&) const memory_estimate() Declaration static size_t model::Binary::memory_estimate(size_t N, size_t) state_only_memory_estimate() Declaration static size_t model::Binary::state_only_memory_estimate(size_t N)"
  },
  "api/model/blume-capel-state.html": {
    "href": "api/model/blume-capel-state.html",
    "title": "Class model::BlumeCapelState | qiotoolkit",
    "keywords": "Class model::BlumeCapelState Inheritance markov::State model::BlumeCapelState Inherited Members configure ~Component Component get_status param get_class_name Constructors BlumeCapelState() Declaration model::BlumeCapelState::BlumeCapelState() BlumeCapelState() Declaration model::BlumeCapelState::BlumeCapelState(size_t N, size_t M) Methods term() Declaration int model::BlumeCapelState::term(size_t edge_id) const render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure model::BlumeCapelState::render() const override copy_state_only() Declaration void model::BlumeCapelState::copy_state_only(const BlumeCapelState&other) get_spins() Declaration const std::vector<int>&model::BlumeCapelState::get_spins() const memory_estimate() Declaration static size_t model::BlumeCapelState::memory_estimate(size_t N, size_t M) state_only_memory_estimate() Declaration static size_t model::BlumeCapelState::state_only_memory_estimate(size_t N)"
  },
  "api/model/blume-capel-transition.html": {
    "href": "api/model/blume-capel-transition.html",
    "title": "Class model::BlumeCapelTransition | qiotoolkit",
    "keywords": "Class model::BlumeCapelTransition Inheritance markov::Transition model::BlumeCapelTransition Inherited Members configure render ~Component Component get_status param get_class_name Constructors BlumeCapelTransition() Declaration model::BlumeCapelTransition::BlumeCapelTransition() BlumeCapelTransition() Declaration model::BlumeCapelTransition::BlumeCapelTransition(size_t spin_id, int value) Methods spin_id() Declaration size_t model::BlumeCapelTransition::spin_id() const value() Declaration int model::BlumeCapelTransition::value() const operator==() Declaration bool model::BlumeCapelTransition::operator==(const BlumeCapelTransition&trans) const"
  },
  "api/model/blume-capel.html": {
    "href": "api/model/blume-capel.html",
    "title": "Class model::BlumeCapel | qiotoolkit",
    "keywords": "Class model::BlumeCapel Inheritance model::GraphModel model::BlumeCapel Inherited Members Model state_only_memory_estimate init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff set_step_limit state_memory_estimate render calculate_cost_difference get_random_transition configure match_version ~BaseModel configure BaseModel edge get_const_cost node rescale node_count estimate_max_cost_diff get_term_count get_scale_factor is_empty has_initial_configuration is_rescaled edges get_initial_configuration nodes get_sweep_size get_benchmark_properties edge_count render ~Component Component get_status param get_class_name Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::BlumeCapel::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::BlumeCapel::get_version() const override cost_term() Declaration double model::BlumeCapel::cost_term(const State_T&state, size_t j) const cost_term() Declaration double model::BlumeCapel::cost_term(const State_T&state, size_t j, size_t modified_spin, int modified_value) const calculate_cost() Declaration double model::BlumeCapel::calculate_cost(const State_T&state) const override calculate_cost_difference() Declaration double model::BlumeCapel::calculate_cost_difference(const State_T&state, const Transition_T&transition) const override get_random_state() Return a valid random state for the model. The various algorithms don't know how to initialize a valid state; this allows them to start with a random one. NOTE: The rng being passed should be used for randomness (as opposed to creating one for the model), as multiple threads can potentially use the same underlying model (albeit with separate rngs). Declaration BlumeCapel::State_T model::BlumeCapel::get_random_state(utils::RandomGenerator&rng) const override get_random_transition() Declaration BlumeCapel::Transition_T model::BlumeCapel::get_random_transition(const State_T&state, utils::RandomGenerator&rng) const override apply_transition() Declaration void model::BlumeCapel::apply_transition(const Transition_T&transition, State_T&state) const override configure() Populates model internals from the input json. Declaration void model::BlumeCapel::configure(const utils::Json&json) override configure() Declaration void model::BlumeCapel::configure(Graph::Configuration_T&configuration) render_state() Declaration utils::Structure model::BlumeCapel::render_state(const State_T&state) const override state_memory_estimate() Declaration size_t model::BlumeCapel::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::BlumeCapel::state_only_memory_estimate() const override"
  },
  "api/model/clock-configuration.html": {
    "href": "api/model/clock-configuration.html",
    "title": "Class model::ClockConfiguration | qiotoolkit",
    "keywords": "Class model::ClockConfiguration Inheritance model::GraphModelConfiguration model::ClockConfiguration Inherited Members map_initial_configuration"
  },
  "api/model/clock-configuration/get/number/of/states.html": {
    "href": "api/model/clock-configuration/get/number/of/states.html",
    "title": "Struct model::ClockConfiguration::Get_Number_of_States | qiotoolkit",
    "keywords": "Struct model::ClockConfiguration::Get_Number_of_States Methods get() Declaration static size_t&model::ClockConfiguration::Get_Number_of_States::get(ClockConfiguration&config) get_key() Declaration static std::string model::ClockConfiguration::Get_Number_of_States::get_key()"
  },
  "api/model/clock-state.html": {
    "href": "api/model/clock-state.html",
    "title": "Class model::ClockState | qiotoolkit",
    "keywords": "Class model::ClockState Clock state representation. Represents: N discretized clock spins as a vector M state terms as {x: double, y: double} The state terms hold the sum of cosines (sines) of the discretized clock model directions, respectively. I.e., term[j].x = \\sum_{i \\in j} cos(s_i * 2\\pi/q) term[j].y = \\sum_{i \\in j} sin(s_i * 2\\pi/q) Inheritance markov::State model::ClockState Inherited Members ~Component Component get_status param get_class_name Constructors ClockState() Create an uninitialized clock state. Declaration model::ClockState::ClockState() ClockState() Create a clock state with N spins and M terms. Declaration model::ClockState::ClockState(size_t N, size_t M) Methods configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void model::ClockState::configure(const utils::Json&json) override copy_state_only() Declaration void model::ClockState::copy_state_only(const ClockState&other) render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure model::ClockState::render() const override memory_estimate() Declaration static size_t model::ClockState::memory_estimate(size_t N, size_t M) state_only_memory_estimate() Declaration static size_t model::ClockState::state_only_memory_estimate(size_t N)"
  },
  "api/model/clock-state/term.html": {
    "href": "api/model/clock-state/term.html",
    "title": "Struct model::ClockState::Term | qiotoolkit",
    "keywords": "Struct model::ClockState::Term"
  },
  "api/model/clock-transition.html": {
    "href": "api/model/clock-transition.html",
    "title": "Struct model::ClockTransition | qiotoolkit",
    "keywords": "Struct model::ClockTransition Clock transition representation. Which spin to change and to what value. Methods operator==() Declaration bool model::ClockTransition::operator==(const ClockTransition&trans) const"
  },
  "api/model/clock.html": {
    "href": "api/model/clock.html",
    "title": "Class model::Clock | qiotoolkit",
    "keywords": "Class model::Clock Inheritance model::GraphModel model::Clock Inherited Members Model state_only_memory_estimate init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff set_step_limit state_memory_estimate render calculate_cost_difference get_random_transition configure match_version ~BaseModel configure BaseModel edge get_const_cost node rescale node_count estimate_max_cost_diff get_term_count get_scale_factor is_empty has_initial_configuration is_rescaled edges get_initial_configuration configure nodes get_sweep_size get_benchmark_properties edge_count render ~Component Component get_status param get_class_name Constructors Clock() Declaration model::Clock::Clock() Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::Clock::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::Clock::get_version() const override calculate_cost() Calculate the Clock Hamiltonian. The standard clock Hamiltonian is defined for edges involving two nodes: \\(\\mathcal{H}' = \\sum_{ij} \\mathrm{cost}_{ij}\\vec{s_i}\\vec{s_j}\\), Where \\(\\vec{s_i}\\) are equi-distributed 2d vectors on the unit circle. (Equivalently: \\(\\vec{s_i}\\vec{s_j} = \\cos(\\theta_i - \\theta_j)\\) with \\(\\theta_i = 2\\pi i/q\\).) Here we use a generalization to n-node hyperedges using the sum of planar vectors partcipating in the edge: \\(v_e = \\frac{1}{|e|} \\sum_{i\\in e} \\vec{s_i}\\), Where \\(\\vec{s_i}\\) is defined as above and \\(|e|\\) is the number of nodes in the hyper-edge. With this our Hamiltonian can be expressed as: $ \\mathcal{H} = \\sum_e \\mathrm{cost}_e (2*v_e^2-1), where the rescaling ensures that the generalization corresponds to the standard defintion for edges with 2 nodes (i.e, +1 when aligned, -1 when anti-aligned, 0 when perpendicular). This means that the contribution is +1 * cost_e when the clock spins are aligned (in any direction) and -1 * cost_e when the clock spins add up to zero. Declaration double model::Clock::calculate_cost(const State_T&state) const override calculate_cost_difference() Compute the difference resulting from transition This recomputes v_e for each of the terms in which transition.spin_id is involved. Declaration double model::Clock::calculate_cost_difference(const State_T&state, const Transition_T&transition) const override get_random_state() Build a random Clock state. This function decides on the number of discretized clock spins and the possible values of each to return (according to the model configuration). Partially precomputed terms (term[j].x, etc.) are populated here. Declaration Clock::State_T model::Clock::get_random_state(utils::RandomGenerator&rng) const override get_random_transition() Create a random transition for state. This picks a random spin_id and proposes a new_value that is different from the current one. Declaration Clock::Transition_T model::Clock::get_random_transition(const State_T&state, utils::RandomGenerator&rng) const override apply_transition() Change state according to transition. This sets the modified spin to its new value and updates the partially precomputed terms that are affected by this change. Declaration void model::Clock::apply_transition(const Transition_T&transition, State_T&state) const override configure() Serialize the number of states q and the underlying graph. Declaration void model::Clock::configure(const utils::Json&json) override configure() Declaration void model::Clock::configure(Configuration_T&conf) initialize_terms() Initialize the state.terms according to the model and current state.spins. Declaration void model::Clock::initialize_terms(State_T&state) const state_memory_estimate() Estimate memory consumption for state. Declaration size_t model::Clock::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::Clock::state_only_memory_estimate() const override calculate_term() This computes the Hamiltonian contribution of the edge edge_id. If specified, dx and dy are applied to the term (this is used to emulate a modified configuration within calculate_cost_difference). Declaration double model::Clock::calculate_term(const State_T&state, size_t edge_id, double dx=0, double dy=0) const set_number_of_states() Set the number of states to q and precompute the cos/sin values for the discretized angles corresponding to 1..(q-1) * 2\\pi/q. Declaration void model::Clock::set_number_of_states(size_t q)"
  },
  "api/model/cost-cache.html": {
    "href": "api/model/cost-cache.html",
    "title": "Class model::CostCache | qiotoolkit",
    "keywords": "Class model::CostCache Inheritance model::CostCache Constructors CostCache() Declaration model::CostCache::CostCache() CostCache() Declaration model::CostCache::CostCache(double v) CostCache() Declaration model::CostCache::CostCache(double v, std::vector<double>c) Methods operator double() Declaration model::CostCache::operator double() const render() Declaration utils::Structure model::CostCache::render() const"
  },
  "api/model/faced-graph-model-configuration.html": {
    "href": "api/model/faced-graph-model-configuration.html",
    "title": "Class model::FacedGraphModelConfiguration | qiotoolkit",
    "keywords": "Class model::FacedGraphModelConfiguration Fced Graph Model Configuration. This is a base class for an intermidiate loading of data for various Faced Graph Models. Graph Models will be configured form this class by moving its data. Inheritance model::BaseModelConfiguration graph::FacedGraphConfiguration model::FacedGraphModelConfiguration"
  },
  "api/model/faced-graph-model.html": {
    "href": "api/model/faced-graph-model.html",
    "title": "Class model::FacedGraphModel | qiotoolkit",
    "keywords": "Class model::FacedGraphModel Faced Graph Model. This is a base class for models with a cost function that can be expressed as a graph with faces. Inheritance markov::Model model::FacedGraphModel Inherited Members get_benchmark_properties estimate_max_cost_diff has_initial_configuration Model state_only_memory_estimate get_term_count get_sweep_size init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff get_scale_factor is_empty set_step_limit is_rescaled state_memory_estimate render get_random_transition get_const_cost configure get_random_state match_version get_version ~BaseModel configure BaseModel get_identifier render ~Component Component get_status param get_class_name Methods nodes() Return a vector of all the nodes. Declaration const std::vector<Node>&model::FacedGraphModel<State_T, Transition_T, Cost_T>::nodes() const node_count() Return the number of nodes. Declaration size_t model::FacedGraphModel<State_T, Transition_T, Cost_T>::node_count() const node() Return a specific node by node ID. Declaration const Node&model::FacedGraphModel<State_T, Transition_T, Cost_T>::node(size_t id) const edges() Return a vector of all the edges. Declaration const std::vector<Edge>&model::FacedGraphModel<State_T, Transition_T, Cost_T>::edges() const edge() Return a specific edge by edge ID. Declaration const Edge&model::FacedGraphModel<State_T, Transition_T, Cost_T>::edge(size_t id) const edge_count() Return the number of edges. Declaration size_t model::FacedGraphModel<State_T, Transition_T, Cost_T>::edge_count() const faces() Return a vector of all the faces. Declaration const std::vector<Face>&model::FacedGraphModel<State_T, Transition_T, Cost_T>::faces() const face() Return a specific edge by face ID. Declaration const Face&model::FacedGraphModel<State_T, Transition_T, Cost_T>::face(size_t id) const configure() Configure the graph from input. Declaration void model::FacedGraphModel<State_T, Transition_T, Cost_T>::configure(const utils::Json&json) override configure() Declaration void model::FacedGraphModel<State_T, Transition_T, Cost_T>::configure(Configuration_T&configuration) calculate_cost_difference() Partial evaluation of the cost function. This method should calculate the difference in cost if we move from state (=before) to the one resulting from applying transition to state (=after): \\Delta_{C} = C_{\\mathrm{after}} - C_{\\mathrm{before}} In code: State state = get_random_state(rng); Transition transition = get_random_transition(rng); double cost_before = calculate_cost(state); double cost_diff = calculate_cost_difference(state, transition); apply_transition(transition, state); // modify state double cost_after = calculate_cost(state); // before + diff should correspond to after (up to double precision) assert(cost_before + cost_diff == cost_after); Declaration Cost_T model::FacedGraphModel<State_T, Transition_T, Cost_T>::calculate_cost_difference(const State_T&, const Transition_T&) const override calculate_cost_difference() Declaration virtual Cost_T model::FacedGraphModel<State_T, Transition_T, Cost_T>::calculate_cost_difference(const State_T&state, const Transition_T&transition, const Cost_T *cost) const =0 apply_transition() Declaration virtual void model::FacedGraphModel<State_T, Transition_T, Cost_T>::apply_transition(const Transition_T&transition, State_T&state, Cost_T *cost) const =0 get_sweep_size() Declaration size_t model::FacedGraphModel<State_T, Transition_T, Cost_T>::get_sweep_size() const override get_term_count() Declaration size_t model::FacedGraphModel<State_T, Transition_T, Cost_T>::get_term_count() const override get_benchmark_properties() Fill the graph benchmarking properties. Declaration utils::Structure model::FacedGraphModel<State_T, Transition_T, Cost_T>::get_benchmark_properties() const override is_rescaled() Declaration bool model::FacedGraphModel<State_T, Transition_T, Cost_T>::is_rescaled() const override rescale() Declaration void model::FacedGraphModel<State_T, Transition_T, Cost_T>::rescale() override get_scale_factor() Declaration Cost_T model::FacedGraphModel<State_T, Transition_T, Cost_T>::get_scale_factor() const override get_const_cost() Declaration Cost_T model::FacedGraphModel<State_T, Transition_T, Cost_T>::get_const_cost() const override is_empty() Declaration bool model::FacedGraphModel<State_T, Transition_T, Cost_T>::is_empty() const override collate() Manage the coefficient collation logic for a single term with degree at most 2. Declaration void model::FacedGraphModel<State_T, Transition_T, Cost_T>::collate(std::map<int, double>&coefficients, const double&term_cost, const std::vector<int>&term_nodes, int node_id, const graph::FaceType&ftype) const estimate_max_cost_diff() Compute an upper bound to the maximum cost difference from a single state flip using the triangle inequality. Implicitly expands SLC terms in cost function to obtain a tighter bound at the cost of additional memory. Declaration virtual double model::FacedGraphModel<State_T, Transition_T, Cost_T>::estimate_max_cost_diff() const override insert_val_to_bbstrees() Declaration virtual void model::FacedGraphModel<State_T, Transition_T, Cost_T>::insert_val_to_bbstrees(double val, std::multiset<double>&tree_A, std::multiset<double>*tree_B=nullptr) const =0 amend_collation() Declaration virtual void model::FacedGraphModel<State_T, Transition_T, Cost_T>::amend_collation(std::map<int, double>&coeffs, int node_id) const =0 populate_bbstrees() Simulate the expanded form of grouped terms to collate quadratic and linear coefficients of terms including a given node ID to populate balanced binary search trees of term weights for maximum cost difference estimation. This function is used by children models to implement estimate_min_cost_diff by overriding the functions insert_val_to_bbstrees and amend_collation. Declaration void model::FacedGraphModel<State_T, Transition_T, Cost_T>::populate_bbstrees(int node_id, std::multiset<double>&tree_A, std::multiset<double>*tree_B=nullptr) const"
  },
  "api/model/get/model.html": {
    "href": "api/model/get/model.html",
    "title": "Struct model::Get_Model | qiotoolkit",
    "keywords": "Struct model::Get_Model Methods get() Declaration static ConfigurationType&model::Get_Model<ConfigurationType>::get(ConfigurationType&m) get_key() Declaration static std::string model::Get_Model<ConfigurationType>::get_key()"
  },
  "api/model/graph-compact-model.html": {
    "href": "api/model/graph-compact-model.html",
    "title": "Class model::GraphCompactModel | qiotoolkit",
    "keywords": "Class model::GraphCompactModel Graph Compact Model. This is with a cost function that can be expressed as a compact graph. GraphCompactModel is samilar to GraphModel except GraphCompactModel use a compact representation and it only allow sequential visiting Inheritance markov::Model model::GraphCompactModel Inherited Members get_benchmark_properties estimate_max_cost_diff has_initial_configuration Model state_only_memory_estimate get_term_count get_sweep_size get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff get_scale_factor is_empty set_step_limit is_rescaled state_memory_estimate render calculate_cost_difference get_random_transition get_const_cost configure get_random_state match_version get_version ~BaseModel configure BaseModel get_identifier render ~Component Component get_status param get_class_name Constructors GraphCompactModel() Declaration model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::GraphCompactModel() Methods ~GraphCompactModel() Declaration virtual model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::~GraphCompactModel() configure() Configure the graph from JSON document. Declaration void model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::configure(const utils::Json&json) override configure() Configure the graph from preloaded graph. Declaration void model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::configure(Configuration_T&configuration) init() Initializes internal data structures (guaranteed to be called after configure()). Declaration void model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::init() override get_sweep_size() Declaration size_t model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::get_sweep_size() const override get_term_count() Declaration size_t model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::get_term_count() const override node_count() Return the number of nodes. Declaration size_t model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::node_count() const edge_count() Return the number of edges. Declaration size_t model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::edge_count() const edge() Declaration const Edge_T&model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::edge(size_t edge_id) const get_benchmark_properties() Fill the graph benchmarking properties. Declaration utils::Structure model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::get_benchmark_properties() const override is_rescaled() Declaration bool model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::is_rescaled() const override rescale() Declaration void model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::rescale() override get_scale_factor() Declaration double model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::get_scale_factor() const override get_const_cost() Declaration double model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::get_const_cost() const override is_empty() Declaration bool model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::is_empty() const override estimate_max_cost_diff() Declaration virtual double model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::estimate_max_cost_diff() const override has_initial_configuration() Declaration bool model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::has_initial_configuration() const override get_initial_configuration() Declaration const std::vector<std::pair<int, int>>&model::GraphCompactModel<State_T, Transition_T, Element_T, Cost_T>::get_initial_configuration() const"
  },
  "api/model/graph-model-configuration.html": {
    "href": "api/model/graph-model-configuration.html",
    "title": "Class model::GraphModelConfiguration | qiotoolkit",
    "keywords": "Class model::GraphModelConfiguration Graph Model Configuration. This is a base class for an intermidiate loading of data for various Graph Models. Graph Models will be configured form this class by moving its data. Inheritance model::BaseModelConfiguration graph::GraphConfiguration model::GraphModelConfiguration model::ClockConfiguration Methods map_initial_configuration() Declaration void model::GraphModelConfiguration::map_initial_configuration(const std::map<int, int>&node_name_to_id_map, std::vector<std::pair<int, int>>&id_val_configuration)"
  },
  "api/model/graph-model-configuration/get/initial/configuration.html": {
    "href": "api/model/graph-model-configuration/get/initial/configuration.html",
    "title": "Struct model::GraphModelConfiguration::Get_Initial_Configuration | qiotoolkit",
    "keywords": "Struct model::GraphModelConfiguration::Get_Initial_Configuration Methods get() Declaration static std::vector<std::pair<int, int>>&model::GraphModelConfiguration::Get_Initial_Configuration::get(class GraphModelConfiguration&config) get_key() Declaration static std::string model::GraphModelConfiguration::Get_Initial_Configuration::get_key()"
  },
  "api/model/graph-model.html": {
    "href": "api/model/graph-model.html",
    "title": "Class model::GraphModel | qiotoolkit",
    "keywords": "Class model::GraphModel Graph Model. This is a base class for models with a cost function that can be expressed as a graph. It takes care of the boiler plate to initialize and access the different graph components. Note Currently, it is limited to a graph with blank nodes and edges that have a double-valued cost attributes. If necessary, this can be made configurable in the future either by extending the list of template arguments here or by using multiple inheritance (i.e., removing the markov::Model base class from GraphModel). Inheritance markov::Model model::GraphModel Inherited Members get_benchmark_properties estimate_max_cost_diff has_initial_configuration Model state_only_memory_estimate get_term_count get_sweep_size init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff get_scale_factor is_empty set_step_limit is_rescaled state_memory_estimate render calculate_cost_difference get_random_transition get_const_cost configure get_random_state match_version get_version ~BaseModel configure BaseModel get_identifier render ~Component Component get_status param get_class_name Methods nodes() Return a vector of all the nodes. Declaration const std::vector<Node>&model::GraphModel<State_T, Transition_T, Cost_T>::nodes() const node_count() Return the number of nodes. Declaration size_t model::GraphModel<State_T, Transition_T, Cost_T>::node_count() const node() Return a specific node by NodeId. Declaration const Node&model::GraphModel<State_T, Transition_T, Cost_T>::node(size_t id) const edges() Return a vector of all the edges. Declaration const std::vector<Edge>&model::GraphModel<State_T, Transition_T, Cost_T>::edges() const edge_count() Return the number of edges. Declaration size_t model::GraphModel<State_T, Transition_T, Cost_T>::edge_count() const edge() Return a specific edge by EdgeId. Declaration const Edge&model::GraphModel<State_T, Transition_T, Cost_T>::edge(size_t id) const configure() Configure the graph from JSON document. Declaration void model::GraphModel<State_T, Transition_T, Cost_T>::configure(const utils::Json&json) override configure() Configure the graph from preloaded graph. Declaration void model::GraphModel<State_T, Transition_T, Cost_T>::configure(Configuration_T&configuration) get_sweep_size() Declaration size_t model::GraphModel<State_T, Transition_T, Cost_T>::get_sweep_size() const override get_term_count() Declaration size_t model::GraphModel<State_T, Transition_T, Cost_T>::get_term_count() const override get_benchmark_properties() Fill the graph benchmarking properties. Declaration utils::Structure model::GraphModel<State_T, Transition_T, Cost_T>::get_benchmark_properties() const override is_rescaled() Declaration bool model::GraphModel<State_T, Transition_T, Cost_T>::is_rescaled() const override rescale() Declaration void model::GraphModel<State_T, Transition_T, Cost_T>::rescale() override get_scale_factor() Declaration double model::GraphModel<State_T, Transition_T, Cost_T>::get_scale_factor() const override get_const_cost() Declaration double model::GraphModel<State_T, Transition_T, Cost_T>::get_const_cost() const override is_empty() Declaration bool model::GraphModel<State_T, Transition_T, Cost_T>::is_empty() const override estimate_max_cost_diff() Declaration virtual double model::GraphModel<State_T, Transition_T, Cost_T>::estimate_max_cost_diff() const override has_initial_configuration() Declaration bool model::GraphModel<State_T, Transition_T, Cost_T>::has_initial_configuration() const override get_initial_configuration() Declaration const std::vector<std::pair<int, int>>&model::GraphModel<State_T, Transition_T, Cost_T>::get_initial_configuration() const"
  },
  "api/model/index.html": {
    "href": "api/model/index.html",
    "title": "model:: | qiotoolkit",
    "keywords": "Model"
  },
  "api/model/ising-compact-state.html": {
    "href": "api/model/ising-compact-state.html",
    "title": "Class model::IsingCompactState | qiotoolkit",
    "keywords": "Class model::IsingCompactState ISING model state for IsingCompact. Inheritance model::IsingState model::IsingCompactState Inherited Members copy_state_only IsingState render render memory_estimate state_only_memory_estimate IsingState configure ~Component Component get_status param get_class_name Constructors IsingCompactState() Declaration model::IsingCompactState::IsingCompactState() IsingCompactState() Create an Ising state with N spins and M terms. All spins are initialized to 0 (\"up\" or \"+1\"). A true value represents \"down\" or \"-1\". As such, the boolean value can be considered as representing the sign. Declaration model::IsingCompactState::IsingCompactState(size_t N, size_t)"
  },
  "api/model/ising-compact.html": {
    "href": "api/model/ising-compact.html",
    "title": "Class model::IsingCompact | qiotoolkit",
    "keywords": "Class model::IsingCompact Ising model which use GraphCompactModel as model base. Inheritance model::GraphCompactModel model::IsingCompact Inherited Members Model state_only_memory_estimate get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff set_step_limit state_memory_estimate render calculate_cost_difference get_random_transition configure ~BaseModel configure BaseModel init get_const_cost get_sweep_size is_empty get_term_count GraphCompactModel has_initial_configuration is_rescaled rescale edge_count estimate_max_cost_diff edge get_scale_factor get_initial_configuration node_count ~GraphCompactModel get_benchmark_properties render ~Component Component get_status param get_class_name Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::IsingCompact<Element_T>::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::IsingCompact<Element_T>::get_version() const override match_version() Checks the string argument against the expected version. This can be overloaded to accept other version than the one returned by get_version(). Declaration void model::IsingCompact<Element_T>::match_version(const std::string&version) override calculate_cost() Cost function: \\mathcal{H} = -\\sum_{j\\in\\mathrm{\\{edges\\}}} c_j\\prod_{i\\in j}s_i Declaration double model::IsingCompact<Element_T>::calculate_cost(const State_T&state) const override calculate_cost_difference() Cost difference: \\Delta_{i\\to i'} = 2 \\sum_{j\\in e_i} c_j\\prod_{i\\in j}s_i Declaration double model::IsingCompact<Element_T>::calculate_cost_difference(const IsingCompactState&state, const size_t&spin_id) const override get_random_state() Return a random Ising state. The number of Ising variables (terms) is determined from the number of nodes (edges) in the underlying graph. Declaration IsingCompactState model::IsingCompact<Element_T>::get_random_state(utils::RandomGenerator&rng) const override get_initial_configuration_state() Declaration IsingCompactState model::IsingCompact<Element_T>::get_initial_configuration_state() const override get_random_transition() Return a random Single spin update. We represent a single spin update as merely the index of the spin variable that will flip. Declaration size_t model::IsingCompact<Element_T>::get_random_transition(const IsingCompactState&, utils::RandomGenerator&rng) const override apply_transition() Flip the spin specified by spin_id. Declaration void model::IsingCompact<Element_T>::apply_transition(const size_t&spin_id, IsingCompactState&state) const override configure() Serialize metadata and the underlying graph. The underlying graph represents the \"disorder\" of the Ising model (glass) we are simulating. Declaration void model::IsingCompact<Element_T>::configure(const utils::Json&json) override configure() Declaration void model::IsingCompact<Element_T>::configure(typename GraphCompact::Configuration_T&configuration) render_state() Declaration utils::Structure model::IsingCompact<Element_T>::render_state(const IsingCompactState&state) const override state_memory_estimate() Declaration size_t model::IsingCompact<Element_T>::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::IsingCompact<Element_T>::state_only_memory_estimate() const override estimate_min_cost_diff() Declaration double model::IsingCompact<Element_T>::estimate_min_cost_diff() const override estimate_max_cost_diff() Declaration double model::IsingCompact<Element_T>::estimate_max_cost_diff() const override get_term() Declaration double model::IsingCompact<Element_T>::get_term(const State_T&state, size_t term_id) const"
  },
  "api/model/ising-grouped.html": {
    "href": "api/model/ising-grouped.html",
    "title": "Class model::IsingGrouped | qiotoolkit",
    "keywords": "Class model::IsingGrouped Inheritance model::FacedGraphModel model::IsingGrouped Inherited Members has_initial_configuration Model state_only_memory_estimate init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff set_step_limit state_memory_estimate render calculate_cost_difference get_random_transition configure ~BaseModel configure BaseModel estimate_max_cost_diff get_benchmark_properties node faces get_term_count get_sweep_size calculate_cost_difference edge_count nodes get_scale_factor get_const_cost is_empty edge face is_rescaled node_count collate populate_bbstrees edges rescale render ~Component Component get_status param get_class_name Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::IsingGrouped::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::IsingGrouped::get_version() const override match_version() Checks the string argument against the expected version. This can be overloaded to accept other version than the one returned by get_version(). Declaration void model::IsingGrouped::match_version(const std::string&version) override configure() Populates model internals from the input json. Declaration void model::IsingGrouped::configure(const utils::Json&json) override configure() Declaration void model::IsingGrouped::configure(typename Base_T::Configuration_T&configuration) get_random_state() Return a valid random state for the model. The various algorithms don't know how to initialize a valid state; this allows them to start with a random one. NOTE: The rng being passed should be used for randomness (as opposed to creating one for the model), as multiple threads can potentially use the same underlying model (albeit with separate rngs). Declaration State_T model::IsingGrouped::get_random_state(utils::RandomGenerator&rng) const override get_random_transition() Return a random Single spin update. We represent a single spin update as merely the index of the spin variable that will flip. Declaration Transition_T model::IsingGrouped::get_random_transition(const State_T&, utils::RandomGenerator&rng) const override render_state() Declaration utils::Structure model::IsingGrouped::render_state(const State_T&state) const override state_memory_estimate() Declaration size_t model::IsingGrouped::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::IsingGrouped::state_only_memory_estimate() const override calculate_cost() Declaration Cost_T model::IsingGrouped::calculate_cost(const State_T&state) const calculate_cost_difference() Declaration Cost_T model::IsingGrouped::calculate_cost_difference(const State_T&state, const Transition_T&transition, const Cost_T *cost) const override apply_transition() Declaration void model::IsingGrouped::apply_transition(const Transition_T&transition, State_T&state, Cost_T *cost) const override apply_transition() Declaration void model::IsingGrouped::apply_transition(const Transition_T&transition, State_T&state) const override get_term() Evaluate the term with id edge_id. Declaration double model::IsingGrouped::get_term(const State_T&state, size_t edge_id) const insert_val_to_bbstrees() Declaration void model::IsingGrouped::insert_val_to_bbstrees(double val, std::multiset<double>&tree_A, std::multiset<double>*tree_B=nullptr) const override amend_collation() Declaration void model::IsingGrouped::amend_collation(std::map<int, double>&coeffs, int node_id) const override estimate_min_cost_diff() Declaration double model::IsingGrouped::estimate_min_cost_diff() const"
  },
  "api/model/ising-state.html": {
    "href": "api/model/ising-state.html",
    "title": "Class model::IsingState | qiotoolkit",
    "keywords": "Class model::IsingState Ising state representation. We represent an ising state as both the boolean value of each spin and the product of the spins in each term. Inheritance markov::State model::IsingState model::IsingCompactState model::IsingTermCachedState Inherited Members configure ~Component Component get_status param get_class_name Constructors IsingState() Declaration model::IsingState::IsingState() IsingState() Create an Ising state with N spins and M terms. All spins are initialized to 0 (\"up\" or \"+1\"). A true value represents \"down\" or \"-1\". As such, the boolean value can be considered as representing the sign. Declaration model::IsingState::IsingState(size_t N, size_t) Methods render() Render the spins of the state. Declaration utils::Structure model::IsingState::render() const override render() Declaration utils::Structure model::IsingState::render(const std::map<int, int>&) const copy_state_only() Declaration void model::IsingState::copy_state_only(const IsingState&other) memory_estimate() Declaration static size_t model::IsingState::memory_estimate(size_t N, size_t) state_only_memory_estimate() Declaration static size_t model::IsingState::state_only_memory_estimate(size_t N)"
  },
  "api/model/ising-term-cached-state.html": {
    "href": "api/model/ising-term-cached-state.html",
    "title": "Class model::IsingTermCachedState | qiotoolkit",
    "keywords": "Class model::IsingTermCachedState Ising state representation with term cache. Inheritance model::IsingState model::IsingTermCachedState Inherited Members copy_state_only IsingState render render IsingState configure ~Component Component get_status param get_class_name Constructors IsingTermCachedState() Declaration model::IsingTermCachedState::IsingTermCachedState() IsingTermCachedState() Declaration model::IsingTermCachedState::IsingTermCachedState(size_t N, size_t M) Methods copy_state_only() Declaration void model::IsingTermCachedState::copy_state_only(const IsingTermCachedState&other) memory_estimate() Declaration static size_t model::IsingTermCachedState::memory_estimate(size_t N, size_t M) state_only_memory_estimate() Declaration static size_t model::IsingTermCachedState::state_only_memory_estimate(size_t N)"
  },
  "api/model/ising-term-cached.html": {
    "href": "api/model/ising-term-cached.html",
    "title": "Class model::IsingTermCached | qiotoolkit",
    "keywords": "Class model::IsingTermCached Inheritance model::AbstractIsing model::IsingTermCached Inherited Members Model init render_state calculate_cost apply_transition set_step_limit render calculate_cost_difference get_random_transition configure configure estimate_min_cost_diff render_state get_identifier match_version configure state_only_memory_estimate get_random_transition get_initial_configuration_state get_version get_random_state estimate_max_cost_diff state_memory_estimate calculate_cost calculate_cost_difference get_version ~BaseModel configure BaseModel get_identifier edge get_const_cost node rescale node_count get_term_count get_scale_factor is_empty has_initial_configuration is_rescaled edges get_initial_configuration configure nodes get_sweep_size get_benchmark_properties edge_count render ~Component Component get_status param get_class_name Methods apply_transition() Flip the spin specified by spin_id. Declaration void model::IsingTermCached::apply_transition(const Transition_T&spin_id, IsingTermCachedState&state) const override get_term() Get the term with id term_id from cache. Declaration double model::IsingTermCached::get_term(const IsingTermCachedState&state, size_t term_id) const override"
  },
  "api/model/ising.html": {
    "href": "api/model/ising.html",
    "title": "Class model::Ising | qiotoolkit",
    "keywords": "Class model::Ising Inheritance model::AbstractIsing model::Ising Inherited Members Model init render_state calculate_cost set_step_limit render calculate_cost_difference get_random_transition configure configure estimate_min_cost_diff render_state get_identifier match_version configure state_only_memory_estimate get_random_transition get_initial_configuration_state get_version get_random_state estimate_max_cost_diff state_memory_estimate calculate_cost calculate_cost_difference apply_transition get_version ~BaseModel configure BaseModel get_identifier edge get_const_cost node rescale node_count get_term_count get_scale_factor is_empty has_initial_configuration is_rescaled edges get_initial_configuration configure nodes get_sweep_size get_benchmark_properties edge_count render ~Component Component get_status param get_class_name Methods apply_transition() Flip the spin specified by spin_id. Declaration void model::Ising::apply_transition(const size_t&spin_id, State_T&state) const override get_term() Calculate the term with id term_id. Declaration double model::Ising::get_term(const IsingState&state, size_t term_id) const override"
  },
  "api/model/max-sat-configuration.html": {
    "href": "api/model/max-sat-configuration.html",
    "title": "Class model::MaxSatConfiguration | qiotoolkit",
    "keywords": "Class model::MaxSatConfiguration MaxSat stream configuration. Inheritance model::BaseModelConfiguration model::MaxSatConfiguration"
  },
  "api/model/max-sat-configuration/get/terms.html": {
    "href": "api/model/max-sat-configuration/get/terms.html",
    "title": "Struct model::MaxSatConfiguration::Get_Terms | qiotoolkit",
    "keywords": "Struct model::MaxSatConfiguration::Get_Terms Methods get() Declaration static std::vector<utils::Dimacs::Clause>&model::MaxSatConfiguration::Get_Terms::get(MaxSatConfiguration&config) get_key() Declaration static std::string model::MaxSatConfiguration::Get_Terms::get_key()"
  },
  "api/model/max-sat-state.html": {
    "href": "api/model/max-sat-state.html",
    "title": "Class model::MaxSatState | qiotoolkit",
    "keywords": "Class model::MaxSatState Representation of a MaxSat state. We store the variable values and a counter for each clause. Inheritance model::MaxSatState Constructors MaxSatState() Default constructor for containers. Declaration model::MaxSatState<Counter_T>::MaxSatState() MaxSatState() Create a MaxSatState with nvar variables and ncl clauses. [!NOTE] MaxSat will always create an extra clause at the begining such that the actual clauses can be accessed with 1-based indices. Declaration model::MaxSatState<Counter_T>::MaxSatState(size_t nvar, size_t ncl) Methods copy_state_only() Copy only the state from another MaxSatState. Declaration void model::MaxSatState<Counter_T>::copy_state_only(const MaxSatState&other) render() Render the state by dumping the variable values. [!NOTE] To get correct labelling, use the MaxSat::render_state(...) method. Declaration utils::Structure model::MaxSatState<Counter_T>::render() const memory_estimate() Declaration static size_t model::MaxSatState<Counter_T>::memory_estimate(size_t variables, size_t clauses) state_only_memory_estimate() Declaration static size_t model::MaxSatState<Counter_T>::state_only_memory_estimate(size_t variables)"
  },
  "api/model/max-sat.html": {
    "href": "api/model/max-sat.html",
    "title": "Class model::MaxSat | qiotoolkit",
    "keywords": "Class model::MaxSat MaxSatModel. Natively simulates weighted satisfiability problems. Inheritance markov::Model model::MaxSat Inherited Members get_benchmark_properties estimate_max_cost_diff has_initial_configuration Model state_only_memory_estimate get_term_count get_sweep_size init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff get_scale_factor is_empty set_step_limit is_rescaled state_memory_estimate rescale render calculate_cost_difference get_random_transition get_const_cost configure match_version ~BaseModel BaseModel render ~Component Component get_status param get_class_name Constructors MaxSat() Declaration model::MaxSat<Counter_T>::MaxSat() Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::MaxSat<Counter_T>::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::MaxSat<Counter_T>::get_version() const override create_state() Create an all-false state with the correct number of variables and clause-counters for this model. Declaration State_T model::MaxSat<Counter_T>::create_state() const create_state() Create a state with specific initial variable values. Declaration State_T model::MaxSat<Counter_T>::create_state(std::vector<bool>variables) const get_random_state() Create a state with random initial variable values. Declaration State_T model::MaxSat<Counter_T>::get_random_state(utils::RandomGenerator&rng) const override get_random_transition() Pick a random transition. Declaration size_t model::MaxSat<Counter_T>::get_random_transition(const State_T&, utils::RandomGenerator&rng) const override calculate_cost() Calculate the cost (sum of active weights) for state. The cost for (weighted) MaxSat is defined as the sum of the weights of the UNSATISIFIED clauses. Declaration Cost_T model::MaxSat<Counter_T>::calculate_cost(const State_T&state) const override calculate_cost_difference() Calculate the change in cost if transition were applied. Declaration Cost_T model::MaxSat<Counter_T>::calculate_cost_difference(const State_T&state, const size_t&transition) const override apply_transition() Apply the effects of transition to the variable and counters in state. Declaration void model::MaxSat<Counter_T>::apply_transition(const size_t&transition, State_T&state) const override configure() Read a max-sat problem from json. Declaration void model::MaxSat<Counter_T>::configure(const utils::Json&json) override configure() Configure using stream configuration. Declaration void model::MaxSat<Counter_T>::configure(Configuration_T&config) configure() Read a max-sat problem from dimacs. Declaration void model::MaxSat<Counter_T>::configure(const utils::Dimacs&dimacs) configure() Turn a list of clauses into adj-list representation for simulation. This uses the position in variables as the variable_id and makes clauses 1-indexed instead (with a negation in the adj-list denoting negated participation in a clause). Declaration void model::MaxSat<Counter_T>::configure(const std::vector<utils::Dimacs::Clause>&clauses) configure() Take the configuration from another model. (this allows changing the counter type after configuration) Declaration void model::MaxSat<Counter_T>::configure(model::BaseModel *base) override render_state() Render a state with the original variable names. Example: [1, 2, 3, -4, -5, 6] mean there were six variables in the original input with consecutive names 1..6 and the solution found has variables 4 and 5 negated. Declaration virtual utils::Structure model::MaxSat<Counter_T>::render_state(const State_T&state) const override is_empty() Declaration bool model::MaxSat<Counter_T>::is_empty() const override state_memory_estimate() Declaration size_t model::MaxSat<Counter_T>::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::MaxSat<Counter_T>::state_only_memory_estimate() const override get_term_count() Declaration size_t model::MaxSat<Counter_T>::get_term_count() const override get_max_weight() Declaration Cost_T model::MaxSat<Counter_T>::get_max_weight() const get_max_vars_in_clause() Declaration size_t model::MaxSat<Counter_T>::get_max_vars_in_clause() const estimate_max_cost_diff() Declaration double model::MaxSat<Counter_T>::estimate_max_cost_diff() const override estimate_min_cost_diff() Declaration double model::MaxSat<Counter_T>::estimate_min_cost_diff() const override"
  },
  "api/model/model-registrar.html": {
    "href": "api/model/model-registrar.html",
    "title": "Struct model::ModelRegistrar | qiotoolkit",
    "keywords": "Struct model::ModelRegistrar Helper struct to statically fill the registry. Constructors ModelRegistrar() Declaration model::ModelRegistrar<Model_T>::ModelRegistrar(int)"
  },
  "api/model/model-registration-impl.html": {
    "href": "api/model/model-registration-impl.html",
    "title": "Class model::ModelRegistrationImpl | qiotoolkit",
    "keywords": "Class model::ModelRegistrationImpl Shared implementation of the Registry entry (templated) Inheritance model::ModelRegistrationInterface model::ModelRegistrationImpl Inherited Members ~ModelRegistrationInterface Methods create() Create an instance of the model. Declaration BaseModel* model::ModelRegistrationImpl<Model_T>::create() const override"
  },
  "api/model/model-registration-interface.html": {
    "href": "api/model/model-registration-interface.html",
    "title": "Class model::ModelRegistrationInterface | qiotoolkit",
    "keywords": "Class model::ModelRegistrationInterface Interface for an individual Model's registry entry. For now this only allows instantiating an instance of the model. Inheritance model::ModelRegistrationInterface model::ModelRegistrationImpl Methods ~ModelRegistrationInterface() Declaration virtual model::ModelRegistrationInterface::~ModelRegistrationInterface() create() Create an instance of the model. Declaration virtual BaseModel* model::ModelRegistrationInterface::create() const =0"
  },
  "api/model/model-registry.html": {
    "href": "api/model/model-registry.html",
    "title": "Class model::ModelRegistry | qiotoolkit",
    "keywords": "Class model::ModelRegistry Registry for model selection. The model registry allows models to be instantiated from their identifier Usage: Registering a new model: class MyModel : public [model::BaseModel](xref:classmodel_1_1BaseModel) { public: // Must have a constructor without arguments. MyModel() = default; // This is the identifier the model is registered with. std::string get_identifier() const override { return \"my_model\"; } ... } [REGISTER_MODEL(MyModel)](xref:model__registry_8h_1ad6bd7a2bf339ad155cb53db753d98cbc); ``` * Instantiating a model by identifier: ```c++ auto* my_model = [model::ModelRegistry::create](xref:classmodel_1_1ModelRegistry_1abab837dbb1601ca2bdb9a7d0ea91217d)(\"my_model\"); ``` Inheritance model::ModelRegistry Constructors ModelRegistry() This is a singleton class. Declaration model::ModelRegistry::ModelRegistry() Methods has() Check whether a model with that identifier is registered. Declaration static bool model::ModelRegistry::has(const std::string&identifier) get() Find and return the model registration. Declaration static const ModelRegistrationInterface* model::ModelRegistry::get(const std::string&identifier) create() Find the model registration and create an instance. Declaration static BaseModel* model::ModelRegistry::create(const std::string&identifier) add() Add an entry to the model registry. This is used by the ModelRegistrar in the REGISTER_MODEL macro, you should not need to invoke it directly. Declaration static void model::ModelRegistry::add(const std::string&identifier, std::unique_ptr<ModelRegistrationInterface>&&registration) instance() Access the singleton. Declaration static ModelRegistry&model::ModelRegistry::instance()"
  },
  "api/model/partition.html": {
    "href": "api/model/partition.html",
    "title": "Class model::Partition | qiotoolkit",
    "keywords": "Class model::Partition Partition state. This implements a markov::State that is a partition of N elements into two sets (with the first one of size K). It is optimized for two operations: Querying whether a given number is in the first set 2) Swapping two random elements from different groups For this, two internal vectors of the respective elements are kept. These are NOT sorted and the class does not provide an interface to select a specific number to swap (they can only be selected by their index, while the current ordering is unknown). Note If you need more sets or don't want the respective set sizes to be fixed, the PottsState is likely a better candidate for your use case. Inheritance markov::State model::Partition Inherited Members configure ~Component Component get_status param get_class_name Constructors Partition() Create an uninitialized partition. Declaration model::Partition::Partition() Methods in_first() query whether number is in the first set. Declaration bool model::Partition::in_first(size_t number) const swap_indices() Swap the indices idx_first, idx_second The indices refer to the current (unsorted) internal list of the elements in the first and second set. Declaration void model::Partition::swap_indices(size_t idx_first, size_t idx_second) render() Render the two sets. Declaration utils::Structure model::Partition::render() const override copy_state_only() Declaration void model::Partition::copy_state_only(const Partition&other) random() Generate a random partition of N elements with the first set of size K. Declaration Partition model::Partition::random(size_t N, size_t K, utils::RandomGenerator&rng)"
  },
  "api/model/permutation.html": {
    "href": "api/model/permutation.html",
    "title": "Class model::Permutation | qiotoolkit",
    "keywords": "Class model::Permutation Inheritance markov::State model::Permutation Inherited Members configure ~Component Component get_status param get_class_name Constructors Permutation() Declaration model::Permutation::Permutation() Permutation() Declaration model::Permutation::Permutation(size_t N) Methods operator[]() Declaration size_t model::Permutation::operator[](size_t i) const size() Declaration size_t model::Permutation::size() const move_node() Declaration void model::Permutation::move_node(size_t a, size_t b) swap_nodes() Declaration void model::Permutation::swap_nodes(size_t a, size_t b) swap_edges() Declaration void model::Permutation::swap_edges(size_t a, size_t b) render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure model::Permutation::render() const override copy_state_only() Declaration void model::Permutation::copy_state_only(const Permutation&other) random() Declaration Permutation model::Permutation::random(size_t N, utils::RandomGenerator&rng) memory_estimate() Declaration static size_t model::Permutation::memory_estimate(size_t N) state_only_memory_estimate() Declaration static size_t model::Permutation::state_only_memory_estimate(size_t N)"
  },
  "api/model/poly-configuration.html": {
    "href": "api/model/poly-configuration.html",
    "title": "Class model::PolyConfiguration | qiotoolkit",
    "keywords": "Class model::PolyConfiguration Inheritance model::BaseModelConfiguration model::PolyConfiguration"
  },
  "api/model/poly-configuration/get/terms.html": {
    "href": "api/model/poly-configuration/get/terms.html",
    "title": "Struct model::PolyConfiguration::Get_Terms | qiotoolkit",
    "keywords": "Struct model::PolyConfiguration::Get_Terms Methods get() Declaration static std::vector<PolyTermConfiguration>&model::PolyConfiguration::Get_Terms::get(PolyConfiguration&config) get_key() Declaration static std::string model::PolyConfiguration::Get_Terms::get_key()"
  },
  "api/model/poly-spins-configuration.html": {
    "href": "api/model/poly-spins-configuration.html",
    "title": "Class model::PolySpinsConfiguration | qiotoolkit",
    "keywords": "Class model::PolySpinsConfiguration Inheritance model::PolySpinsConfiguration model::PolyTermConfiguration Constructors PolySpinsConfiguration() Declaration model::PolySpinsConfiguration::PolySpinsConfiguration()"
  },
  "api/model/poly-spins-configuration/get/constant.html": {
    "href": "api/model/poly-spins-configuration/get/constant.html",
    "title": "Struct model::PolySpinsConfiguration::Get_Constant | qiotoolkit",
    "keywords": "Struct model::PolySpinsConfiguration::Get_Constant Methods get() Declaration static double&model::PolySpinsConfiguration::Get_Constant::get(PolySpinsConfiguration&config) get_key() Declaration static std::string model::PolySpinsConfiguration::Get_Constant::get_key()"
  },
  "api/model/poly-spins-configuration/get/ids.html": {
    "href": "api/model/poly-spins-configuration/get/ids.html",
    "title": "Struct model::PolySpinsConfiguration::Get_Ids | qiotoolkit",
    "keywords": "Struct model::PolySpinsConfiguration::Get_Ids Methods get() Declaration static std::vector<size_t>&model::PolySpinsConfiguration::Get_Ids::get(PolySpinsConfiguration&config) get_key() Declaration static std::string model::PolySpinsConfiguration::Get_Ids::get_key()"
  },
  "api/model/poly-state.html": {
    "href": "api/model/poly-state.html",
    "title": "Class model::PolyState | qiotoolkit",
    "keywords": "Class model::PolyState PolyState. besides storing the Ising spins, PolyState is also initialized by the model to store intermediate results of the cost function evaluations for each term. This allows efficient evaluation and application of the cost difference a specific update would cause. Inheritance markov::State model::PolyState Inherited Members configure ~Component Component get_status param get_class_name Methods render() Render the current state of the spins in the model in the azure response output format: {\"0\": +1, \"1\": -1, ...}. Declaration utils::Structure model::PolyState::render() const copy_state_only() Declaration void model::PolyState::copy_state_only(const PolyState&other) memory_estimate() Declaration static size_t model::PolyState::memory_estimate(size_t n_spins, size_t n_terms, size_t n_parameters) state_only_memory_estimate() Declaration static size_t model::PolyState::state_only_memory_estimate(size_t n_spins)"
  },
  "api/model/poly-term-configuration.html": {
    "href": "api/model/poly-term-configuration.html",
    "title": "Class model::PolyTermConfiguration | qiotoolkit",
    "keywords": "Class model::PolyTermConfiguration Inheritance model::PolySpinsConfiguration model::PolyTermConfiguration Inherited Members PolySpinsConfiguration Constructors PolyTermConfiguration() Declaration model::PolyTermConfiguration::PolyTermConfiguration()"
  },
  "api/model/poly-term-configuration/get/exponent.html": {
    "href": "api/model/poly-term-configuration/get/exponent.html",
    "title": "Struct model::PolyTermConfiguration::Get_Exponent | qiotoolkit",
    "keywords": "Struct model::PolyTermConfiguration::Get_Exponent Methods get() Declaration static int&model::PolyTermConfiguration::Get_Exponent::get(PolyTermConfiguration&config) get_key() Declaration static std::string model::PolyTermConfiguration::Get_Exponent::get_key()"
  },
  "api/model/poly-term-configuration/get/parameter.html": {
    "href": "api/model/poly-term-configuration/get/parameter.html",
    "title": "Struct model::PolyTermConfiguration::Get_Parameter | qiotoolkit",
    "keywords": "Struct model::PolyTermConfiguration::Get_Parameter Methods get() Declaration static std::string&model::PolyTermConfiguration::Get_Parameter::get(PolyTermConfiguration&config) get_key() Declaration static std::string model::PolyTermConfiguration::Get_Parameter::get_key()"
  },
  "api/model/poly-term-configuration/get/terms.html": {
    "href": "api/model/poly-term-configuration/get/terms.html",
    "title": "Struct model::PolyTermConfiguration::Get_Terms | qiotoolkit",
    "keywords": "Struct model::PolyTermConfiguration::Get_Terms Methods get() Declaration static std::vector<PolySpinsConfiguration>&model::PolyTermConfiguration::Get_Terms::get(PolyTermConfiguration&config) get_key() Declaration static std::string model::PolyTermConfiguration::Get_Terms::get_key()"
  },
  "api/model/poly-transition.html": {
    "href": "api/model/poly-transition.html",
    "title": "Class model::PolyTransition | qiotoolkit",
    "keywords": "Class model::PolyTransition PolyTransition. We define two types of transitions: If spin_id is positive, the transition applies a spin-flip to the spin with this id. Otherwise the transition changes the parameter values to the ones denoted in parameter_values (all may change concurrently). Inheritance markov::Transition model::PolyTransition Inherited Members configure render ~Component Component get_status param get_class_name Methods is_spin_flip() Declaration bool model::PolyTransition::is_spin_flip() const spin_id() Declaration size_t model::PolyTransition::spin_id() const set_spin_id() Declaration void model::PolyTransition::set_spin_id(size_t spin_id) parameter_values() Declaration const std::vector<double>&model::PolyTransition::parameter_values() const set_parameter_values() Declaration void model::PolyTransition::set_parameter_values(const std::vector<double>&values)"
  },
  "api/model/poly.html": {
    "href": "api/model/poly.html",
    "title": "Class model::Poly | qiotoolkit",
    "keywords": "Class model::Poly Poly Model. Defines an Ising model with polynomial cost function. The cost function can be defined via recursive nesting of terms of the form: term_i = c_i p_i (\\sum_j term_j) ^ e_i or - term_i = c_i p_i \\prod_j s_j where c_i is a numeric constant p_i is a parameter (which can be changed during the simulation) e_i is an integer exponent s_i is an Ising spin Note The limitation to Ising spins and products only in non-leaf of such spins is deliberate (this avoids needing to track the number of zeros in products). See Poly::configure() for the input format definition. Inheritance markov::Model model::Poly Inherited Members get_benchmark_properties estimate_max_cost_diff has_initial_configuration Model state_only_memory_estimate get_term_count get_sweep_size init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff get_scale_factor is_empty set_step_limit is_rescaled state_memory_estimate rescale render calculate_cost_difference get_random_transition get_const_cost configure match_version ~BaseModel configure BaseModel render ~Component Component get_status param get_class_name Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::Poly::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::Poly::get_version() const override get_const_cost() Declaration double model::Poly::get_const_cost() const override is_empty() Declaration bool model::Poly::is_empty() const override create_state() Create a state with specific spin and parameter values. Parameters: spins array of initial spin values {-1, 1} parameters array of initial parameter values (defaults to all-1). Returns: An initialized state with intermediate term values populated. Declaration PolyState model::Poly::create_state(std::vector<int>spins, std::vector<double>parameters={}) const get_random_state() Create a random state. This fill the state with random spin values {-1, +1} and all parameters set to 1.0. Declaration PolyState model::Poly::get_random_state(utils::RandomGenerator&rng) const override create_spin_flip() Create a specific spin flip. This returns a transition which spins flip spin_id. Declaration PolyTransition model::Poly::create_spin_flip(size_t spin_id) const create_parameter_change() Create a parameter change. This returns a transition which substitutes the model parameters. Declaration PolyTransition model::Poly::create_parameter_change(const std::vector<double>values) const get_random_transition() Return a random spin flip. The default markov transition for Poly is a random spin flip. create_parameter_change to manually create a parameter transition. Declaration PolyTransition model::Poly::get_random_transition(const PolyState&state, utils::RandomGenerator&rng) const override calculate_cost() Get the full cost function. We can entirely rely on the root term's intermediate value. Declaration double model::Poly::calculate_cost(const PolyState&state) const override calculate_cost_difference() Calculate the cost difference for a transition. Declaration double model::Poly::calculate_cost_difference(const PolyState&state, const PolyTransition&transition) const override apply_transition() Apply a transition to a state. Declaration void model::Poly::apply_transition(const PolyTransition&transition, PolyState&state) const override get_sweep_size() Declaration size_t model::Poly::get_sweep_size() const override configure() Populates model internals from the input json. Declaration void model::Poly::configure(const utils::Json&json) override configure() Declaration void model::Poly::configure(Configuration_T&configuration) print() Declaration std::string model::Poly::print() const get_parameters() Declaration std::vector<std::string>model::Poly::get_parameters() const get_spin_overlap() Declaration double model::Poly::get_spin_overlap(const PolyState&s, const PolyState&t) const get_term_overlap() Declaration double model::Poly::get_term_overlap(const PolyState&s, const PolyState&t) const state_memory_estimate() Declaration size_t model::Poly::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::Poly::state_only_memory_estimate() const override configure_term() Read a term from the input configuration. Declaration void model::Poly::configure_term(const utils::Json&json, int parent=-1) configure_term() Declaration void model::Poly::configure_term(PolySpinsConfiguration&input, int parent=-1) configure_term() Declaration void model::Poly::configure_term(PolyTermConfiguration&input, int parent=-1) configure_term() Declaration void model::Poly::configure_term(std::vector<PolyTermConfiguration>&, int parent=-1) initialize_terms() Initialize a state. This takes a state with spins and parameters set and populates its intermediate evaluation results in terms. This is the only time we evaluate all of the terms. All subsequent calls to calculate_cost(state) and calculate_cost_difference(state, transition) rely on these terms. Declaration void model::Poly::initialize_terms(PolyState&state) const calculate_term_differences() Calculate difference for each term. This calculates all the nodes affected by a transition and bubbles those changes up to the root node of the poly tree. Declaration std::map<size_t, double>model::Poly::calculate_term_differences(const PolyState&state, const PolyTransition&transition) const term_factor() Return the factor preceding term term_id This computes the product constant * parameter where the parameter is optional and taken from the set of parameters passed. Declaration double model::Poly::term_factor(const std::vector<double>parameters, size_t term_id) const term_to_string() Render a term's string representation (recursively) Declaration std::string model::Poly::term_to_string(size_t term_id) const"
  },
  "api/model/poly/term.html": {
    "href": "api/model/poly/term.html",
    "title": "Struct model::Poly::Term | qiotoolkit",
    "keywords": "Struct model::Poly::Term Representation of a recursive term in the polynomial. A term takes the form constant * parameter (sum_j term_j) ^ exponent or - constant * parameter (prod_j spin_j) The term stores its own properties (constant, parameter_id, exponent) and the id of its parent term. It does not track a list of its child terms or spins, since we typically evaluate the cost function bottom-up. (top-down traversel, as needed by term_to_string is inefficient). Note For terms of the second kind, there is no exponent. Constructors Term() Initialize a default term. Declaration model::Poly::Term::Term(int parent_id_=-1) Methods is_leaf_node() Declaration bool model::Poly::Term::is_leaf_node() const has_constant() Declaration bool model::Poly::Term::has_constant() const has_parameter() Declaration bool model::Poly::Term::has_parameter() const"
  },
  "api/model/potts-state.html": {
    "href": "api/model/potts-state.html",
    "title": "Class model::PottsState | qiotoolkit",
    "keywords": "Class model::PottsState Potts state representation. Represents N potts spins as a vector . Inheritance markov::State model::PottsState Inherited Members configure ~Component Component get_status param get_class_name Constructors PottsState() Declaration model::PottsState::PottsState() PottsState() Initialize a state of N potts spins to 0. Declaration model::PottsState::PottsState(size_t N) Methods render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure model::PottsState::render() const override copy_state_only() Declaration void model::PottsState::copy_state_only(const PottsState&other) memory_estimate() Declaration static size_t model::PottsState::memory_estimate(size_t N) state_only_memory_estimate() Declaration static size_t model::PottsState::state_only_memory_estimate(size_t N)"
  },
  "api/model/potts-transition.html": {
    "href": "api/model/potts-transition.html",
    "title": "Class model::PottsTransition | qiotoolkit",
    "keywords": "Class model::PottsTransition Potts transition representation. Which spin to change and to what value. Inheritance markov::Transition model::PottsTransition Inherited Members configure render ~Component Component get_status param get_class_name Constructors PottsTransition() Declaration model::PottsTransition::PottsTransition() PottsTransition() Initialize a transition of spin_id to value. Note The choice of value (both its range and w.r.t. the current value of spins[spin_id] is handled by the model. Declaration model::PottsTransition::PottsTransition(size_t spin_id, size_t value) Methods apply() Apply the transition to the given state. Declaration void model::PottsTransition::apply(PottsState&state) const spin_id() Declaration size_t model::PottsTransition::spin_id() const value() Declaration size_t model::PottsTransition::value() const"
  },
  "api/model/potts.html": {
    "href": "api/model/potts.html",
    "title": "Class model::Potts | qiotoolkit",
    "keywords": "Class model::Potts Potts Model. This model implements a hamiltonian of the form \\(\\mathcal{H} = \\sum_j c_j \\delta_{s_{j,1}, s{j,2}, \\ldots}\\), where \\(\\delta\\) is the kronecker delta, which is 1 iff all its subscripts are identical (and 0 otherwise). That is: Each term in this cost function will contribute only if all Potts spins participating in it are of the same value. Inheritance model::GraphModel model::Potts Inherited Members Model state_only_memory_estimate init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff set_step_limit state_memory_estimate render calculate_cost_difference get_random_transition configure match_version ~BaseModel configure BaseModel edge get_const_cost node rescale node_count estimate_max_cost_diff get_term_count get_scale_factor is_empty has_initial_configuration is_rescaled edges get_initial_configuration configure nodes get_sweep_size get_benchmark_properties edge_count render ~Component Component get_status param get_class_name Constructors Potts() Declaration model::Potts::Potts() Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::Potts::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::Potts::get_version() const override calculate_cost() Calculate the Potts Hamiltonian. Declaration double model::Potts::calculate_cost(const PottsState&state) const override calculate_cost_difference() Recompute the parts affected by transition. Declaration double model::Potts::calculate_cost_difference(const PottsState&state, const PottsTransition&transition) const override get_random_state() Return a random Potts state. This function decides on the number of potts spins and the possible values of each to return (according to the model configuration). Declaration PottsState model::Potts::get_random_state(utils::RandomGenerator&rng) const override get_random_transition() Create a random transition for state. Declaration PottsTransition model::Potts::get_random_transition(const PottsState&state, utils::RandomGenerator&rng) const override apply_transition() Change state according to transition. Declaration void model::Potts::apply_transition(const PottsTransition&transition, PottsState&state) const override configure() Serialize q and the underlying graph. Declaration void model::Potts::configure(const utils::Json&json) override state_memory_estimate() Declaration size_t model::Potts::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::Potts::state_only_memory_estimate() const override calculate_term() Declaration double model::Potts::calculate_term(const PottsState&state, size_t edge_id) const calculate_term() Declaration double model::Potts::calculate_term(const PottsState&state, size_t edge_id, const PottsTransition&transition) const"
  },
  "api/model/pubo-adaptive.html": {
    "href": "api/model/pubo-adaptive.html",
    "title": "Class model::PuboAdaptive | qiotoolkit",
    "keywords": "Class model::PuboAdaptive Adaptive Pubo Model. This pubo implementation aims for adaptability to per-state memory constraints while using a cache-friendly graph representation. The numeric type used for indexing can be templated. This type needs to be chosen such that #variables < std::numeric_limits ::max() - 2. (the last two values of the range are used as sentinels in the graph representation). If the graph has high-locality terms, there should (ideally) be some unused range between #variables and that upper limit; this range is used to index into the cache. The number of terms for which caching can be used is limited by the width of that empty range. The graph representation uses a contigous chunk of memory initialized with an adjacency list for each node. For each term, the first 8 bytes contain the coefficient, followed by a sentinel terminated list of variable_ids (or cache_ids) participating in the term. The sentinel type (NEXT_TERM or NEXT_VAR) denotes when the last term of a variable is reached. During configuration of the graph representaion, the maximum number of bytes for each state can be specified. If this number exceeds the required bytes to store the boolean variables, the extra bytes are used to preferentially cache the number of zeros in high-locality terms (using either 32-bit or 8-bit counters). This has the effect of both reducing the graph size and time to compute a term. Inheritance markov::LinearSweepModel model::PuboAdaptive Inherited Members make_linear_sweep get_benchmark_properties estimate_max_cost_diff has_initial_configuration Model state_only_memory_estimate get_term_count get_sweep_size init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff get_scale_factor is_empty set_step_limit is_rescaled state_memory_estimate rescale render calculate_cost_difference get_random_transition get_const_cost configure ~BaseModel configure BaseModel render ~Component Component get_status param get_class_name Constructors PuboAdaptive() Create an unconfigured PuboAdaptive model. Declaration model::PuboAdaptive<Index>::PuboAdaptive() Methods get_identifier() Return the identifier of this model. Declaration std::string model::PuboAdaptive<Index>::get_identifier() const override get_version() Return the version of this model. Declaration std::string model::PuboAdaptive<Index>::get_version() const override match_version() Accept both version 1.0 and 1.1. Declaration void model::PuboAdaptive<Index>::match_version(const std::string&version) override configure() Configure the model from input. Declaration void model::PuboAdaptive<Index>::configure(const utils::Json&json) override configure() Declaration void model::PuboAdaptive<Index>::configure(Configuration_T&config) get_const_cost() Declaration double model::PuboAdaptive<Index>::get_const_cost() const override is_empty() Declaration bool model::PuboAdaptive<Index>::is_empty() const override configure() Declaration void model::PuboAdaptive<Index>::configure(model::Terms&&terms, size_t max_state_size_in_bytes) get_random_state() Create a random initial state. Declaration State_T model::PuboAdaptive<Index>::get_random_state(utils::RandomGenerator&rng) const override state_memory_estimate() Get memory estimation for state. Declaration size_t model::PuboAdaptive<Index>::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::PuboAdaptive<Index>::state_only_memory_estimate() const override get_random_transition() Create a random transition. Declaration Transition_T model::PuboAdaptive<Index>::get_random_transition(const State_T&, utils::RandomGenerator&rng) const override apply_transition() Applying a random transition is done by advancing the graph pointer to the offset corresponding to the variable being flipped. Declaration void model::PuboAdaptive<Index>::apply_transition(const Transition_T&transition, State_T&state) const override calculate_cost() Evaluate the whole cost function. Note The adjacency list representation is inefficient for this purpose, but we don't expect to evaluate this frequently. For non-cached terms, double counting is avoided by ensuring neighbor ids are larger than the variable we are processing For cached terms we use a std::vector to keep track which ones have been counted. Declaration double model::PuboAdaptive<Index>::calculate_cost(const State_T&state) const override calculate_cost_difference() The cost difference of an arbitrary transition is evaluated by setting up the state pointers and advancing the graph pointer to the offset corresponding to the variable being flipped. Declaration double model::PuboAdaptive<Index>::calculate_cost_difference(const State_T&state, const Transition_T&transition) const override make_linear_sweep() For a linear sweep, we can avoid the overhead of repeatedly setting up state pointers and jumping to specific offsets in the graph; it can simply be processed in order. Declaration void model::PuboAdaptive<Index>::make_linear_sweep(double&cost, State_T&state, std::function<bool(double)>accept, std::function<void(void)>check_lowest) const override render_state() Render the state as a structure mapping (original) names to pubo values. NOTE: the mapping is true=zero, false=1. Declaration utils::Structure model::PuboAdaptive<Index>::render_state(const State_T&state) const override get_sweep_size() One sweep consists of attempting to update each variable once. Declaration size_t model::PuboAdaptive<Index>::get_sweep_size() const override flip_spin() Flip a spin by applying xor with a shifted bit. Declaration void model::PuboAdaptive<Index>::flip_spin(uint64_t *spins, Index index) const get_spin_value() Extract a bit by masking with a shifted bit. Declaration bool model::PuboAdaptive<Index>::get_spin_value(const uint64_t *spins, Index index) const get_cache() Select the appropriate (type and index) of the cache for a given cache_id. NOTE: the cache_id=index-var_count_ is in [0..cache_count_). Declaration uint32_t model::PuboAdaptive<Index>::get_cache(size_t cache_id, const uint32_t *cache32, const uint8_t *cache8) const update_cache() Add the cache_change to the appropriate (type and index) of the cache. Declaration void model::PuboAdaptive<Index>::update_cache(size_t cache_id, uint32_t *cache32, uint8_t *cache8, uint8_t cache_change) const configure_state_size() Calculate how many terms we want to and can afford to cache. After a call to this method, state_size_ and the cache counters/offsets have been initialized to the correct values. Declaration void model::PuboAdaptive<Index>::configure_state_size(const model::Terms&terms, size_t max_state_size_in_bytes) configure_graph() Allocate and fill the adjacency list graph representation. Declaration void model::PuboAdaptive<Index>::configure_graph(const model::Terms&terms) calculate_term_difference() Declaration double model::PuboAdaptive<Index>::calculate_term_difference(uint8_t *&p, bool spin_value, const uint64_t *spins, const uint32_t *cache32, const uint8_t *cache8) const update_caches() Declaration void model::PuboAdaptive<Index>::update_caches(uint8_t *&p, bool spin, uint32_t *cache32, uint8_t *cache8) const take_index() Interpret the next sizeof(Index) bytes as an Index and advance the pointer. Declaration static Index model::PuboAdaptive<Index>::take_index(uint8_t *&p) take_double() Interpret the next 8 bytes as a double and advance the pointer. Declaration static double model::PuboAdaptive<Index>::take_double(uint8_t *&p) put_double() Declaration static void model::PuboAdaptive<Index>::put_double(uint8_t *&p, double d) put_index() Declaration static void model::PuboAdaptive<Index>::put_index(uint8_t *&p, Index index)"
  },
  "api/model/pubo-binary-adaptive.html": {
    "href": "api/model/pubo-binary-adaptive.html",
    "title": "Class model::PuboBinaryAdaptive | qiotoolkit",
    "keywords": "Class model::PuboBinaryAdaptive Adaptive Binary State. This adaptive state stores its state in a contigous (self allocated) chunk of heap memory (pointed to by data_). This chunk is organized as follows: +-----------------------------------------------------------------------+ | Binary values stored in uint64_t | 32-bit counters | 8-bit counters | +---------------------------------+-----+-----++++++ | 0101010100001010011111011110101101 | 256 | 42 | 3 | 0 | 7 | 2 | 1 | +---------------------------------+-----+-----++++++ The first section consists of as many uint64_t as needed to store the state of each variable in the problem Counters are used to cache the number of zeros in a given term. Their usage is allocated problem-dependent to the highest-locality terms and according to memory allowance passed during configuration. Note In addition to limiting per-state memory, PuboAdaptive can be templated for the index type (i.e. uint16_t). Because chache ids are appended to the variable ids; they must fit within the numeric range of the type used for indexing as well (see below). Inheritance markov::State model::PuboBinaryAdaptive Inherited Members configure render ~Component Component get_status param get_class_name Constructors PuboBinaryAdaptive() Create an empty adaptive state (used by std::vector) Declaration model::PuboBinaryAdaptive::PuboBinaryAdaptive() PuboBinaryAdaptive() Create an adaptive state of the desired size and initialize it to zero. Declaration model::PuboBinaryAdaptive::PuboBinaryAdaptive(size_t size) PuboBinaryAdaptive() Declaration model::PuboBinaryAdaptive::PuboBinaryAdaptive(const PuboBinaryAdaptive&other) PuboBinaryAdaptive() Declaration model::PuboBinaryAdaptive::PuboBinaryAdaptive(PuboBinaryAdaptive&&other) Methods operator=() Copy another state (allocating memory if it is empty). Declaration PuboBinaryAdaptive&model::PuboBinaryAdaptive::operator=(const PuboBinaryAdaptive&other) operator=() Move assignment can be done without copy. Declaration PuboBinaryAdaptive&model::PuboBinaryAdaptive::operator=(PuboBinaryAdaptive&&other) copy_state_only() We need to copy the whole state (including caches); the model cannot compute the cost function without them. This functionality is exclusively used to keep track of the best cost milestones I expect this to happen rarely enough that we can afford the overhead. Declaration void model::PuboBinaryAdaptive::copy_state_only(const PuboBinaryAdaptive&other) memory_estimate() Declaration static size_t model::PuboBinaryAdaptive::memory_estimate(size_t size) state_only_memory_estimate() Declaration static size_t model::PuboBinaryAdaptive::state_only_memory_estimate(size_t size)"
  },
  "api/model/pubo-compact-state.html": {
    "href": "api/model/pubo-compact-state.html",
    "title": "Class model::PuboCompactState | qiotoolkit",
    "keywords": "Class model::PuboCompactState PUBO model state for IsingCompact. Inheritance model::Binary model::PuboCompactState Inherited Members copy_state_only render Binary memory_estimate Binary render state_only_memory_estimate configure ~Component Component get_status param get_class_name Constructors PuboCompactState() Declaration model::PuboCompactState::PuboCompactState() PuboCompactState() Create an Ising state with N spins and M terms. All spins are initialized to 0 (\"True\"). A true value represents \"False\". As such, the boolean value can be considered as representing the sign. Declaration model::PuboCompactState::PuboCompactState(size_t N, size_t)"
  },
  "api/model/pubo-compact.html": {
    "href": "api/model/pubo-compact.html",
    "title": "Class model::PuboCompact | qiotoolkit",
    "keywords": "Class model::PuboCompact Inheritance model::GraphCompactModel model::PuboCompact Inherited Members Model state_only_memory_estimate get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff set_step_limit state_memory_estimate render calculate_cost_difference get_random_transition configure ~BaseModel configure BaseModel init get_const_cost get_sweep_size is_empty get_term_count GraphCompactModel has_initial_configuration is_rescaled rescale edge_count estimate_max_cost_diff edge get_scale_factor get_initial_configuration node_count ~GraphCompactModel get_benchmark_properties render ~Component Component get_status param get_class_name Constructors PuboCompact() Declaration model::PuboCompact<Element_T>::PuboCompact() Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::PuboCompact<Element_T>::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::PuboCompact<Element_T>::get_version() const override match_version() Checks the string argument against the expected version. This can be overloaded to accept other version than the one returned by get_version(). Declaration void model::PuboCompact<Element_T>::match_version(const std::string&version) override calculate_cost() Cost function: \\mathcal{H} = -\\sum_{j\\in\\mathrm{\\{edges\\}}} c_j\\prod_{i\\in j}s_i Declaration double model::PuboCompact<Element_T>::calculate_cost(const State_T&state) const override calculate_cost_difference() Cost difference: \\Delta_{i\\to i'} = 2 \\sum_{j\\in e_i} c_j\\prod_{i\\in j}s_i Declaration double model::PuboCompact<Element_T>::calculate_cost_difference(const State_T&state, const Transition_T&spin_id) const override get_random_state() Return a random Pubo state. The number of variables (terms) is determined from the number of nodes (edges) in the underlying graph. Declaration State_T model::PuboCompact<Element_T>::get_random_state(utils::RandomGenerator&rng) const override get_initial_configuration_state() Return a state created from initial configuration. Declaration State_T model::PuboCompact<Element_T>::get_initial_configuration_state() const override get_random_transition() Return a random Single spin update. We represent a single spin update as merely the index of the spin variable that will flip. Declaration Transition_T model::PuboCompact<Element_T>::get_random_transition(const State_T&, utils::RandomGenerator&rng) const override apply_transition() Flip the spin specified by spin_id. Declaration void model::PuboCompact<Element_T>::apply_transition(const Transition_T&transition, State_T&state) const override configure() Serialize metadata and the underlying graph. The underlying graph represents the \"disorder\" of the Ising model (glass) we are simulating. Declaration void model::PuboCompact<Element_T>::configure(const utils::Json&json) override configure() Declaration void model::PuboCompact<Element_T>::configure(typename GraphCompact::Configuration_T&configuration) render_state() Declaration utils::Structure model::PuboCompact<Element_T>::render_state(const State_T&state) const override state_memory_estimate() Declaration size_t model::PuboCompact<Element_T>::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::PuboCompact<Element_T>::state_only_memory_estimate() const override estimate_min_cost_diff() Declaration double model::PuboCompact<Element_T>::estimate_min_cost_diff() const override get_term() Declaration double model::PuboCompact<Element_T>::get_term(const State_T&state, size_t term_id) const"
  },
  "api/model/pubo-grouped.html": {
    "href": "api/model/pubo-grouped.html",
    "title": "Class model::PuboGrouped | qiotoolkit",
    "keywords": "Class model::PuboGrouped Inheritance model::FacedGraphModel model::PuboGrouped Inherited Members has_initial_configuration Model state_only_memory_estimate init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff set_step_limit state_memory_estimate render calculate_cost_difference get_random_transition configure ~BaseModel configure BaseModel estimate_max_cost_diff get_benchmark_properties node faces get_term_count get_sweep_size calculate_cost_difference edge_count nodes get_scale_factor get_const_cost is_empty edge face is_rescaled node_count collate populate_bbstrees edges rescale render ~Component Component get_status param get_class_name Constructors PuboGrouped() Declaration model::PuboGrouped<T>::PuboGrouped() Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::PuboGrouped<T>::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::PuboGrouped<T>::get_version() const override match_version() Checks the string argument against the expected version. This can be overloaded to accept other version than the one returned by get_version(). Declaration void model::PuboGrouped<T>::match_version(const std::string&version) override configure() Populates model internals from the input json. Declaration void model::PuboGrouped<T>::configure(const utils::Json&json) override configure() Declaration void model::PuboGrouped<T>::configure(typename Base_T::Configuration_T&configuration) get_random_state() Return a valid random state for the model. The various algorithms don't know how to initialize a valid state; this allows them to start with a random one. NOTE: The rng being passed should be used for randomness (as opposed to creating one for the model), as multiple threads can potentially use the same underlying model (albeit with separate rngs). Declaration State_T model::PuboGrouped<T>::get_random_state(utils::RandomGenerator&rng) const override get_random_transition() Declaration Transition_T model::PuboGrouped<T>::get_random_transition(const State_T&, utils::RandomGenerator&rng) const override render_state() Declaration utils::Structure model::PuboGrouped<T>::render_state(const State_T&state) const override calculate_cost() Declaration Cost_T model::PuboGrouped<T>::calculate_cost(const State_T&state) const calculate_cost_difference() Declaration Cost_T model::PuboGrouped<T>::calculate_cost_difference(const State_T&state, const Transition_T&transition, const Cost_T *cost) const apply_transition() Declaration void model::PuboGrouped<T>::apply_transition(const Transition_T&transition, State_T&state, Cost_T *cost) const apply_transition() Declaration void model::PuboGrouped<T>::apply_transition(const Transition_T&transition, State_T&state) const override state_memory_estimate() Declaration size_t model::PuboGrouped<T>::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::PuboGrouped<T>::state_only_memory_estimate() const override insert_val_to_bbstrees() Declaration virtual void model::PuboGrouped<T>::insert_val_to_bbstrees(double val, std::multiset<double>&tree_A, std::multiset<double>*tree_B) const override amend_collation() Declaration virtual void model::PuboGrouped<T>::amend_collation(std::map<int, double>&coeffs, int node_id) const override estimate_min_cost_diff() Declaration double model::PuboGrouped<T>::estimate_min_cost_diff() const"
  },
  "api/model/pubo-with-counter.html": {
    "href": "api/model/pubo-with-counter.html",
    "title": "Class model::PuboWithCounter | qiotoolkit",
    "keywords": "Class model::PuboWithCounter Inheritance model::AbstractPubo model::PuboWithCounter Inherited Members Model init render_state calculate_cost apply_transition set_step_limit render calculate_cost_difference get_random_transition configure state_memory_estimate state_only_memory_estimate estimate_min_cost_diff apply_transition configure render_state get_random_state get_identifier ~AbstractPubo edges match_version AbstractPubo nodes get_random_transition get_initial_configuration_state get_version get_version ~BaseModel configure BaseModel get_identifier edge get_const_cost node rescale node_count estimate_max_cost_diff get_term_count get_scale_factor is_empty has_initial_configuration is_rescaled get_initial_configuration get_sweep_size get_benchmark_properties edge_count render ~Component Component get_status param get_class_name Methods configure() Populates model internals from the input json. Declaration void model::PuboWithCounter<T>::configure(const utils::Json&json) override configure() Declaration void model::PuboWithCounter<T>::configure(typename Base_T::Configuration_T&configuration) calculate_cost() Declaration double model::PuboWithCounter<T>::calculate_cost(const State_T&state) const override calculate_cost_difference() Declaration double model::PuboWithCounter<T>::calculate_cost_difference(const State_T&state, const Transition_T&transition) const override apply_transition() Declaration void model::PuboWithCounter<T>::apply_transition(const Transition_T&transition, State_T&state) const override"
  },
  "api/model/pubo.html": {
    "href": "api/model/pubo.html",
    "title": "Class model::Pubo | qiotoolkit",
    "keywords": "Class model::Pubo Inheritance model::AbstractPubo model::Pubo Inherited Members Model init render_state set_step_limit render get_random_transition configure state_memory_estimate state_only_memory_estimate estimate_min_cost_diff apply_transition configure render_state get_random_state get_identifier ~AbstractPubo edges configure match_version AbstractPubo nodes get_random_transition get_initial_configuration_state get_version get_version ~BaseModel configure BaseModel get_identifier edge get_const_cost node rescale node_count estimate_max_cost_diff get_term_count get_scale_factor is_empty has_initial_configuration is_rescaled get_initial_configuration configure get_sweep_size get_benchmark_properties edge_count render ~Component Component get_status param get_class_name Methods calculate_cost() Definition of the cost function. Evaluate the entire cost function for the state being passed. For instance, in the case of a model from statistical mechanics, this would be the Hamiltonian. Declaration double model::Pubo::calculate_cost(const State_T&state) const override calculate_cost_difference() Partial evaluation of the cost function. This method should calculate the difference in cost if we move from state (=before) to the one resulting from applying transition to state (=after): \\Delta_{C} = C_{\\mathrm{after}} - C_{\\mathrm{before}} In code: State state = get_random_state(rng); Transition transition = get_random_transition(rng); double cost_before = calculate_cost(state); double cost_diff = calculate_cost_difference(state, transition); apply_transition(transition, state); // modify state double cost_after = calculate_cost(state); // before + diff should correspond to after (up to double precision) assert(cost_before + cost_diff == cost_after); Declaration double model::Pubo::calculate_cost_difference(const State_T&state, const Transition_T&transition) const override apply_transition() Apply a transition to a state. This changes the configuration represented by *state. Depending on the optimization algorithm, transition can either be applied conditionally or alaways (e.g., population dynamics). Separating the functionality into the three interfaces random_transition, calculate_cost_difference, apply_transition leaves control over the strategy with the optimization method. Declaration void model::Pubo::apply_transition(const Transition_T&transition, State_T&state) const override"
  },
  "api/model/terms.html": {
    "href": "api/model/terms.html",
    "title": "Class model::Terms | qiotoolkit",
    "keywords": "Class model::Terms Inheritance utils::Component model::Terms Inherited Members render ~Component Component get_status param get_class_name Methods configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void model::Terms::configure(const utils::Json&json) override configure() Declaration void model::Terms::configure(Configuration_T&config) init() Declaration void model::Terms::init()"
  },
  "api/model/terms/stats.html": {
    "href": "api/model/terms/stats.html",
    "title": "Class model::Terms::Stats | qiotoolkit",
    "keywords": "Class model::Terms::Stats Inheritance model::Terms::Stats Constructors Stats() Declaration model::Terms::Stats::Stats() Methods clear() Declaration void model::Terms::Stats::clear()"
  },
  "api/model/terms/term.html": {
    "href": "api/model/terms/term.html",
    "title": "Class model::Terms::Term | qiotoolkit",
    "keywords": "Class model::Terms::Term Inheritance utils::Component model::Terms::Term Inherited Members ~Component Component get_status param Methods configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void model::Terms::Term::configure(const utils::Json&json) override <() Declaration bool model::Terms::Term::operator<(const Term&other) const <() Declaration bool model::Terms::Term::operator<(const Term&other) const render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure model::Terms::Term::render() const override get_class_name() get_class_name shows an identifier of the (derived) class name Its primary use is for type identification during stream output and logging, where a component is rendered as <ClassName: status>. Example: {c++} MyClass : public Component {} // This will render as '<MyClass>' MyClass my_object; std::cout << my_object << std::endl; Note You do not need to overload this method unless you want to change the output of the default implementation. Declaration std::string model::Terms::Term::get_class_name() const override"
  },
  "api/model/terms/term/get/cost.html": {
    "href": "api/model/terms/term/get/cost.html",
    "title": "Struct model::Terms::Term::Get_Cost | qiotoolkit",
    "keywords": "Struct model::Terms::Term::Get_Cost Methods get() Declaration static double&model::Terms::Term::Get_Cost::get(Term&term) get_key() Declaration static std::string model::Terms::Term::Get_Cost::get_key()"
  },
  "api/model/terms/term/get/variable/names.html": {
    "href": "api/model/terms/term/get/variable/names.html",
    "title": "Struct model::Terms::Term::Get_Variable_Names | qiotoolkit",
    "keywords": "Struct model::Terms::Term::Get_Variable_Names Methods get() Declaration static std::set<int>&model::Terms::Term::Get_Variable_Names::get(Term&term) get_key() Declaration static std::string model::Terms::Term::Get_Variable_Names::get_key()"
  },
  "api/model/terms/terms-configuration.html": {
    "href": "api/model/terms/terms-configuration.html",
    "title": "Class model::Terms::TermsConfiguration | qiotoolkit",
    "keywords": "Class model::Terms::TermsConfiguration Terms Configuration. This is a class for an intermidiate loading of data for Terms class, which will be configured form this class by moving its data. Model configuration is used due to using same data in tests. Inheritance model::BaseModelConfiguration model::Terms::TermsConfiguration"
  },
  "api/model/terms/terms-configuration/get/terms.html": {
    "href": "api/model/terms/terms-configuration/get/terms.html",
    "title": "Struct model::Terms::TermsConfiguration::Get_Terms | qiotoolkit",
    "keywords": "Struct model::Terms::TermsConfiguration::Get_Terms Methods get() Declaration static std::vector<Term>&model::Terms::TermsConfiguration::Get_Terms::get(TermsConfiguration&config) get_key() Declaration static std::string model::Terms::TermsConfiguration::Get_Terms::get_key()"
  },
  "api/model/terms/variable.html": {
    "href": "api/model/terms/variable.html",
    "title": "Class model::Terms::Variable | qiotoolkit",
    "keywords": "Class model::Terms::Variable Inheritance utils::Component model::Terms::Variable Inherited Members configure ~Component Component get_status param Methods <() Declaration bool model::Terms::Variable::operator<(const Variable&other) const <() Declaration bool model::Terms::Variable::operator<(const Variable&other) const render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure model::Terms::Variable::render() const override get_class_name() get_class_name shows an identifier of the (derived) class name Its primary use is for type identification during stream output and logging, where a component is rendered as <ClassName: status>. Example: {c++} MyClass : public Component {} // This will render as '<MyClass>' MyClass my_object; std::cout << my_object << std::endl; Note You do not need to overload this method unless you want to change the output of the default implementation. Declaration std::string model::Terms::Variable::get_class_name() const override"
  },
  "api/model/tsp-configuration.html": {
    "href": "api/model/tsp-configuration.html",
    "title": "Class model::TspConfiguration | qiotoolkit",
    "keywords": "Class model::TspConfiguration Inheritance model::BaseModelConfiguration model::TspConfiguration"
  },
  "api/model/tsp-configuration/get/dist.html": {
    "href": "api/model/tsp-configuration/get/dist.html",
    "title": "Struct model::TspConfiguration::Get_Dist | qiotoolkit",
    "keywords": "Struct model::TspConfiguration::Get_Dist Methods get() Declaration static std::vector<std::vector<double>>&model::TspConfiguration::Get_Dist::get(TspConfiguration&config) get_key() Declaration static std::string model::TspConfiguration::Get_Dist::get_key()"
  },
  "api/model/tsp-configuration/get/model.html": {
    "href": "api/model/tsp-configuration/get/model.html",
    "title": "Struct model::TspConfiguration::Get_Model | qiotoolkit",
    "keywords": "Struct model::TspConfiguration::Get_Model Methods get() Declaration static TspConfiguration&model::TspConfiguration::Get_Model::get(TspConfiguration&config) get_key() Declaration static std::string model::TspConfiguration::Get_Model::get_key()"
  },
  "api/model/tsp-transition.html": {
    "href": "api/model/tsp-transition.html",
    "title": "Class model::TspTransition | qiotoolkit",
    "keywords": "Class model::TspTransition Inheritance markov::Transition model::TspTransition Inherited Members configure render ~Component Component get_status param Constructors TspTransition() Declaration model::TspTransition::TspTransition() TspTransition() Declaration model::TspTransition::TspTransition(Type type, size_t a, size_t b) Methods apply() Declaration void model::TspTransition::apply(Permutation&permutation) const get_class_name() get_class_name shows an identifier of the (derived) class name Its primary use is for type identification during stream output and logging, where a component is rendered as <ClassName: status>. Example: {c++} MyClass : public Component {} // This will render as '<MyClass>' MyClass my_object; std::cout << my_object << std::endl; Note You do not need to overload this method unless you want to change the output of the default implementation. Declaration std::string model::TspTransition::get_class_name() const override type() Declaration Type model::TspTransition::type() const a() Declaration size_t model::TspTransition::a() const b() Declaration size_t model::TspTransition::b() const operator==() Declaration bool model::TspTransition::operator==(const TspTransition&trans) const random() Declaration TspTransition model::TspTransition::random(size_t N, utils::RandomGenerator&rng)"
  },
  "api/model/tsp.html": {
    "href": "api/model/tsp.html",
    "title": "Class model::Tsp | qiotoolkit",
    "keywords": "Class model::Tsp Inheritance markov::Model model::Tsp Inherited Members get_benchmark_properties estimate_max_cost_diff has_initial_configuration Model state_only_memory_estimate get_term_count get_sweep_size init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff get_scale_factor is_empty set_step_limit is_rescaled state_memory_estimate rescale render calculate_cost_difference get_random_transition get_const_cost configure match_version ~BaseModel configure BaseModel render ~Component Component get_status param Constructors Tsp() Declaration model::Tsp::Tsp() Methods get_identifier() Returns the identifier string of the model type (e.g., \"ising\"). Declaration std::string model::Tsp::get_identifier() const override get_version() Returns the version of the input format this implementation expects. Declaration std::string model::Tsp::get_version() const override calculate_cost() Declaration double model::Tsp::calculate_cost(const Permutation&p) const override calculate_cost_difference() Declaration double model::Tsp::calculate_cost_difference(const Permutation&p, const TspTransition&t) const override get_random_state() Return a valid random state for the model. The various algorithms don't know how to initialize a valid state; this allows them to start with a random one. NOTE: The rng being passed should be used for randomness (as opposed to creating one for the model), as multiple threads can potentially use the same underlying model (albeit with separate rngs). Declaration Permutation model::Tsp::get_random_state(utils::RandomGenerator&rng) const override get_random_transition() Declaration TspTransition model::Tsp::get_random_transition(const Permutation&p, utils::RandomGenerator&rng) const override apply_transition() Declaration void model::Tsp::apply_transition(const TspTransition&transition, Permutation&p) const override configure() Populates model internals from the input json. Declaration void model::Tsp::configure(const utils::Json&json) override configure() Declaration void model::Tsp::configure(Configuration_T&config) get_class_name() get_class_name shows an identifier of the (derived) class name Its primary use is for type identification during stream output and logging, where a component is rendered as <ClassName: status>. Example: {c++} MyClass : public Component {} // This will render as '<MyClass>' MyClass my_object; std::cout << my_object << std::endl; Note You do not need to overload this method unless you want to change the output of the default implementation. Declaration std::string model::Tsp::get_class_name() const override get_const_cost() Declaration double model::Tsp::get_const_cost() const override is_empty() Declaration bool model::Tsp::is_empty() const override state_memory_estimate() Declaration size_t model::Tsp::state_memory_estimate() const override state_only_memory_estimate() Declaration size_t model::Tsp::state_only_memory_estimate() const override"
  },
  "api/my-handler.html": {
    "href": "api/my-handler.html",
    "title": "Struct MyHandler | qiotoolkit",
    "keywords": "Struct MyHandler Constructors MyHandler() Declaration MyHandler::MyHandler() MyHandler() Declaration MyHandler::MyHandler(const MyHandler&noCopyConstruction) Methods Null() Declaration bool MyHandler::Null() Bool() Declaration bool MyHandler::Bool(bool b) Int() Declaration bool MyHandler::Int(int i) Uint() Declaration bool MyHandler::Uint(unsigned u) Int64() Declaration bool MyHandler::Int64(int64_t i) Uint64() Declaration bool MyHandler::Uint64(uint64_t u) Double() Declaration bool MyHandler::Double(double d) RawNumber() Declaration bool MyHandler::RawNumber(const char *str, SizeType length, bool) String() Declaration bool MyHandler::String(const char *str, SizeType length, bool) StartObject() Declaration bool MyHandler::StartObject() Key() Declaration bool MyHandler::Key(const char *str, SizeType length, bool) EndObject() Declaration bool MyHandler::EndObject(SizeType memberCount) StartArray() Declaration bool MyHandler::StartArray() EndArray() Declaration bool MyHandler::EndArray(SizeType elementCount) Null() Declaration bool MyHandler::Null() Bool() Declaration bool MyHandler::Bool(bool b) Int() Declaration bool MyHandler::Int(int i) Uint() Declaration bool MyHandler::Uint(unsigned u) Int64() Declaration bool MyHandler::Int64(int64_t i) Uint64() Declaration bool MyHandler::Uint64(uint64_t u) Double() Declaration bool MyHandler::Double(double d) RawNumber() Declaration bool MyHandler::RawNumber(const char *str, SizeType length, bool copy) String() Declaration bool MyHandler::String(const char *str, SizeType length, bool copy) StartObject() Declaration bool MyHandler::StartObject() Key() Declaration bool MyHandler::Key(const char *str, SizeType length, bool copy) EndObject() Declaration bool MyHandler::EndObject(SizeType memberCount) StartArray() Declaration bool MyHandler::StartArray() EndArray() Declaration bool MyHandler::EndArray(SizeType elementCount) operator=() Declaration MyHandler&MyHandler::operator=(const MyHandler&noAssignment)"
  },
  "api/my-string.html": {
    "href": "api/my-string.html",
    "title": "Class MyString | qiotoolkit",
    "keywords": "Class MyString Inheritance MyString Constructors MyString() Declaration MyString::MyString() MyString() Declaration MyString::MyString(const char *a_c_string) MyString() Declaration MyString::MyString(const MyString&string) MyString() Declaration MyString::MyString() MyString() Declaration MyString::MyString(const char *a_c_string) MyString() Declaration MyString::MyString(const MyString&string) Methods operator=() Declaration const MyString&MyString::operator=(const MyString&rhs) operator=() Declaration const MyString&MyString::operator=(const MyString&rhs) CloneCString() Declaration const char * MyString::CloneCString(const char *a_c_string) CloneCString() Declaration static const char* MyString::CloneCString(const char *a_c_string) ~MyString() Declaration MyString::~MyString() c_string() Declaration const char* MyString::c_string() const Length() Declaration size_t MyString::Length() const Set() Declaration void MyString::Set(const char *c_string) ~MyString() Declaration MyString::~MyString() c_string() Declaration const char* MyString::c_string() const Length() Declaration size_t MyString::Length() const Set() Declaration void MyString::Set(const char *c_string)"
  },
  "api/name-comparator.html": {
    "href": "api/name-comparator.html",
    "title": "Struct NameComparator | qiotoolkit",
    "keywords": "Struct NameComparator Methods operator()() Declaration bool NameComparator::operator()(const Value::Member&lhs, const Value::Member&rhs) const"
  },
  "api/observe/average-and-count.html": {
    "href": "api/observe/average-and-count.html",
    "title": "Class observe::AverageAndCount | qiotoolkit",
    "keywords": "Class observe::AverageAndCount Inheritance observe::Average observe::AverageAndCount observe::MinMax Inherited Members record reset record record record record Average record ~Observable record record configure ~Component Component get_status param get_class_name Methods render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::AverageAndCount::render() const override"
  },
  "api/observe/average.html": {
    "href": "api/observe/average.html",
    "title": "Class observe::Average | qiotoolkit",
    "keywords": "Class observe::Average Average observable. Keeps track of the sum of values and total weight in order to produce the weighted average of recorded data points since the last reset. Inheritance observe::Observable observe::Average observe::AverageAndCount Inherited Members record ~Observable record record configure ~Component Component get_status param get_class_name Constructors Average() Declaration observe::Average::Average() Methods reset() Declaration void observe::Average::reset() override record() Declaration void observe::Average::record(double value, double weight) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::Average::render() const override record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/average2.html": {
    "href": "api/observe/average2.html",
    "title": "Class observe::Average2 | qiotoolkit",
    "keywords": "Class observe::Average2 Average2 observable. Additionally keeps track of the sum of squares to produce the standard deviation of recorded data points. Inheritance observe::MinMax observe::Average2 observe::BinWidthDistribution observe::RangedDistribution Inherited Members Average MinMax record ~Observable record record configure ~Component Component get_status param get_class_name Constructors Average2() Declaration observe::Average2::Average2() Methods reset() Declaration void observe::Average2::reset() override record() Declaration void observe::Average2::record(double value, double weight) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::Average2::render() const override record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/batched.html": {
    "href": "api/observe/batched.html",
    "title": "Class observe::Batched | qiotoolkit",
    "keywords": "Class observe::Batched Batched observable. This creates a \"batched\" version of any observable which records a timeline with batches of size batch_size. I.e., after a total weight of batch_size has been recorded, the observable is rendered to the timeline of batches and the observable itself is reset. Example: Batched(BinWidthDistribution(0.2), 1000) records the evolution of a histogram: 1000 values are recorded into each histogram the histogram is grouped into bins of width 0.2 after each 1000, the histogram is stored and a new one started. Inheritance observe::Observable observe::Batched Inherited Members record ~Observable record record configure ~Component Component get_status param get_class_name Constructors Batched() Declaration observe::Batched::Batched(std::unique_ptr<Observable>&&observable, double batch_size) Batched() Declaration observe::Batched::Batched(Observable *observable, double batch_size) Batched() Declaration observe::Batched::Batched(const Batched&)=delete Methods operator=() Declaration Batched&observe::Batched::operator=(const Batched&)=delete reset() Declaration void observe::Batched::reset() override record() Declaration void observe::Batched::record(double value, double weight) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::Batched::render() const override record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/bin-width-distribution.html": {
    "href": "api/observe/bin-width-distribution.html",
    "title": "Class observe::BinWidthDistribution | qiotoolkit",
    "keywords": "Class observe::BinWidthDistribution BinWidthDistribution observable. In addition to the mean and standard deviation, keeps track of the full histogram of recorded values in bins of the specified bin_width. This histogram can become quite large if you specify a small bin width in relation to the range of recorded values. Note There is a bin centered around 0 and bins are directly adjacent to each other. Inheritance observe::Average2 observe::BinWidthDistribution Inherited Members Average2 Average MinMax record ~Observable record record configure ~Component Component get_status param get_class_name Constructors BinWidthDistribution() Declaration observe::BinWidthDistribution::BinWidthDistribution(double bin_width) Methods reset() Declaration void observe::BinWidthDistribution::reset() override record() Declaration void observe::BinWidthDistribution::record(double value, double weight) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::BinWidthDistribution::render() const override record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/constant.html": {
    "href": "api/observe/constant.html",
    "title": "Class observe::Constant | qiotoolkit",
    "keywords": "Class observe::Constant Constant observable. Keeps track of the last value (the assumption is that this observable is used to indicate a constant associated with other observables, hence the name). It does not keep track of previously recorded values. Inheritance observe::Observable observe::Constant Inherited Members record ~Observable record record configure ~Component Component get_status param get_class_name Constructors Constant() Declaration observe::Constant::Constant() Methods reset() Declaration void observe::Constant::reset() override record() Declaration void observe::Constant::record(double value, double weight) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::Constant::render() const override record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/index.html": {
    "href": "api/observe/index.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/observe/log-batched.html": {
    "href": "api/observe/log-batched.html",
    "title": "Class observe::LogBatched | qiotoolkit",
    "keywords": "Class observe::LogBatched LograithmicBatched. This creates a \"logarithmically batched\" version of any observable which records a timeline with batches doubling in size over time. I.e., after a total weight of 32 has been recorded, the observable is rendered to the timeline of batches and the observable itself is reset with a new batch size of 64. Example: LogBatched(BinWidthDistribution(0.2), 16) records the evolution of a histogram: 16 values are recorded into the first batch 32 values will be recorded into the next batch the histogram is grouped into bins of width 0.2 Inheritance observe::Observable observe::LogBatched Inherited Members record ~Observable record record configure ~Component Component get_status param get_class_name Constructors LogBatched() Declaration observe::LogBatched::LogBatched(std::unique_ptr<Observable>&&observable, double initial_batch_size=1) LogBatched() Declaration observe::LogBatched::LogBatched(const LogBatched&)=delete Methods operator=() Declaration LogBatched&observe::LogBatched::operator=(const LogBatched&)=delete reset() Declaration void observe::LogBatched::reset() override record() Declaration void observe::LogBatched::record(double value, double weight) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::LogBatched::render() const override record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/milestone.html": {
    "href": "api/observe/milestone.html",
    "title": "Class observe::Milestone | qiotoolkit",
    "keywords": "Class observe::Milestone Record when new values are reached. This records a timeline of when a new value is recorded. If the recorded values are monotonically decreasing (or increasing), this translates to a timeline of when a new lowest (or highest) value is found. Inheritance observe::Observable observe::Milestone Inherited Members record ~Observable record record configure ~Component Component get_status param get_class_name Constructors Milestone() Declaration observe::Milestone::Milestone(const std::string&key_label=\"key\", const std::string&value_label=\"value\") Methods reset() Declaration void observe::Milestone::reset() override record() Declaration void observe::Milestone::record(double value_label, double weight) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::Milestone::render() const override record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/min-max.html": {
    "href": "api/observe/min-max.html",
    "title": "Class observe::MinMax | qiotoolkit",
    "keywords": "Class observe::MinMax MinMax observable. In addition to the average value, keeps track of the smallest and largest value recorded. Inheritance observe::AverageAndCount observe::MinMax observe::Average2 Inherited Members Average record ~Observable record record configure ~Component Component get_status param get_class_name Constructors MinMax() Declaration observe::MinMax::MinMax() Methods reset() Declaration void observe::MinMax::reset() override record() Declaration void observe::MinMax::record(double value, double weight) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::MinMax::render() const override record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/observable.html": {
    "href": "api/observe/observable.html",
    "title": "Class observe::Observable | qiotoolkit",
    "keywords": "Class observe::Observable Observable Interface. An observable can be reset and allows recoding of values with individual weights (the default weight being 1.0). Depending on the type of the observable, it will keep track of the last recorded value, the mean since the last reset or a full histogram of values (see implementations). Inheritance utils::Component observe::Observable observe::Average observe::Batched observe::Constant observe::LogBatched observe::Milestone observe::Windowed Inherited Members configure render ~Component Component get_status param get_class_name Methods ~Observable() Declaration virtual observe::Observable::~Observable() reset() Declaration virtual void observe::Observable::reset()=0 record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/observer.html": {
    "href": "api/observe/observer.html",
    "title": "Class observe::Observer | qiotoolkit",
    "keywords": "Class observe::Observer Inheritance utils::ComponentWithOutput observe::Observer solver::Solver Inherited Members set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors Observer() Declaration observe::Observer::Observer() Methods restart() Declaration void observe::Observer::restart(size_t step) is_watching() Declaration bool observe::Observer::is_watching(const std::string&identifier) const set_observable_label() Declaration void observe::Observer::set_observable_label(const std::string&identifier, const T&value) clear_observable_label() Declaration void observe::Observer::clear_observable_label(const std::string&identifier) scoped_observable_label() Declaration ScopedLabel observe::Observer::scoped_observable_label(const std::string&label, T value) observe() Declaration void observe::Observer::observe(const std::string&identifier, double value, double weight=1.0) configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void observe::Observer::configure(const utils::Json&json) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure observe::Observer::render() const override"
  },
  "api/observe/observer/factory.html": {
    "href": "api/observe/observer/factory.html",
    "title": "Class observe::Observer::Factory | qiotoolkit",
    "keywords": "Class observe::Observer::Factory Inheritance observe::Observer::Factory Inherited Members ~ObservableFactory Methods create_observable() Declaration virtual std::unique_ptr<Observable>observe::Observer::Factory<T>::create_observable() const"
  },
  "api/observe/observer/group.html": {
    "href": "api/observe/observer/group.html",
    "title": "Class observe::Observer::Group | qiotoolkit",
    "keywords": "Class observe::Observer::Group Inheritance utils::Component observe::Observer::Group Inherited Members configure ~Component Component get_status param get_class_name Methods select_subgroup() Declaration Observer::Group * observe::Observer::Group::select_subgroup(const Label&label) has_observable() Declaration bool observe::Observer::Group::has_observable(const std::string&identifier) add_observable() Declaration Observable&observe::Observer::Group::add_observable(const std::string&identifier, std::unique_ptr<Observable>&&observable) select_observable() Declaration Observable&observe::Observer::Group::select_observable(const std::string&identifier) render() Declaration utils::Structure observe::Observer::Group::render() const override"
  },
  "api/observe/observer/observable-factory.html": {
    "href": "api/observe/observer/observable-factory.html",
    "title": "Class observe::Observer::ObservableFactory | qiotoolkit",
    "keywords": "Class observe::Observer::ObservableFactory Inheritance observe::Observer::ObservableFactory Methods ~ObservableFactory() Declaration virtual observe::Observer::ObservableFactory::~ObservableFactory() create_observable() Declaration virtual std::unique_ptr<Observable>observe::Observer::ObservableFactory::create_observable() const =0"
  },
  "api/observe/observer/protocol.html": {
    "href": "api/observe/observer/protocol.html",
    "title": "Class observe::Observer::Protocol | qiotoolkit",
    "keywords": "Class observe::Observer::Protocol Inheritance utils::Component observe::Observer::Protocol Inherited Members render ~Component Component get_status param get_class_name Methods configure() Declaration void observe::Observer::Protocol::configure(const utils::Json&json) override is_watching() Declaration bool observe::Observer::Protocol::is_watching(const std::string&name) const select_group() Declaration Observer::Group * observe::Observer::Protocol::select_group(Group&groups, size_t restart_step, std::map<std::string, utils::Structure>labels_) const create_observable() Declaration std::unique_ptr<Observable>observe::Observer::Protocol::create_observable(const std::string&name) const"
  },
  "api/observe/observer/scoped-label.html": {
    "href": "api/observe/observer/scoped-label.html",
    "title": "Class observe::Observer::ScopedLabel | qiotoolkit",
    "keywords": "Class observe::Observer::ScopedLabel Inheritance observe::Observer::ScopedLabel Constructors ScopedLabel() Declaration observe::Observer::ScopedLabel::ScopedLabel(Observer *observer, const std::string&label) ScopedLabel() Declaration observe::Observer::ScopedLabel::ScopedLabel(const ScopedLabel&)=default Methods operator=() Declaration ScopedLabel&observe::Observer::ScopedLabel::operator=(const ScopedLabel&copy)=default ~ScopedLabel() Declaration virtual observe::Observer::ScopedLabel::~ScopedLabel()"
  },
  "api/observe/ranged-distribution.html": {
    "href": "api/observe/ranged-distribution.html",
    "title": "Class observe::RangedDistribution | qiotoolkit",
    "keywords": "Class observe::RangedDistribution RangedDistribution observable. In addition to the mean and standard deviation, keeps track of binned counts of the values within low and high (divided into bins bins). Values outside the specified range affect the mean and stddev, but are not recorded in the histogram. This observable is useful if you're only interested in the counts for a specific (known) value range. Inheritance observe::Average2 observe::RangedDistribution Inherited Members Average2 Average MinMax record ~Observable record record configure ~Component Component get_status param get_class_name Constructors RangedDistribution() Declaration observe::RangedDistribution::RangedDistribution(double low, double high, int bins) Methods reset() Declaration void observe::RangedDistribution::reset() override record() Declaration void observe::RangedDistribution::record(double value, double weight) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::RangedDistribution::render() const override record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/windowed.html": {
    "href": "api/observe/windowed.html",
    "title": "Class observe::Windowed | qiotoolkit",
    "keywords": "Class observe::Windowed Windowed observable. This creates a \"windowed\" version of any observable such that the current state of the contained observable always reflects the last window_size values recorded. This is implemented by keeping track of the recorded values in the queue and removing them when the window_size is exceeded. Note The window_size is implemented as a weight; if all your recorded values have a weight of 1, this translates to window_size observables being tracked; if they differ it can be more or less, accordingly. Inheritance observe::Observable observe::Windowed Inherited Members record ~Observable record record configure ~Component Component get_status param get_class_name Constructors Windowed() Declaration observe::Windowed::Windowed(std::unique_ptr<Observable>&&observable, double window_size) Windowed() Declaration observe::Windowed::Windowed(const Windowed&)=delete Methods operator=() Declaration Windowed&observe::Windowed::operator=(const Windowed&)=delete reset() Declaration void observe::Windowed::reset() override record() Declaration void observe::Windowed::record(double value, double weight) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure observe::Windowed::render() const override record() Declaration void observe::Observable::record(double value) record() Declaration void observe::Observable::record(int value) record() Declaration void observe::Observable::record(size_t value) record() Declaration virtual void observe::Observable::record(double value, double weight)=0"
  },
  "api/observe/windowed/value-and-weight.html": {
    "href": "api/observe/windowed/value-and-weight.html",
    "title": "Class observe::Windowed::ValueAndWeight | qiotoolkit",
    "keywords": "Class observe::Windowed::ValueAndWeight Inheritance utils::Component observe::Windowed::ValueAndWeight Inherited Members configure ~Component Component get_status param get_class_name Constructors ValueAndWeight() Declaration observe::Windowed::ValueAndWeight::ValueAndWeight() ValueAndWeight() Declaration observe::Windowed::ValueAndWeight::ValueAndWeight(double value_, double weight_) Methods render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure observe::Windowed::ValueAndWeight::render() const override"
  },
  "api/on-the-fly-prime-table.html": {
    "href": "api/on-the-fly-prime-table.html",
    "title": "Class OnTheFlyPrimeTable | qiotoolkit",
    "keywords": "Class OnTheFlyPrimeTable Inheritance PrimeTable OnTheFlyPrimeTable Inherited Members ~PrimeTable Methods IsPrime() Declaration bool OnTheFlyPrimeTable::IsPrime(int n) const override GetNextPrime() Declaration int OnTheFlyPrimeTable::GetNextPrime(int p) const override IsPrime() Declaration virtual bool OnTheFlyPrimeTable::IsPrime(int n) const GetNextPrime() Declaration virtual int OnTheFlyPrimeTable::GetNextPrime(int p) const"
  },
  "api/optimal/learning/bounds-exception.html": {
    "href": "api/optimal/learning/bounds-exception.html",
    "title": "Class optimal_learning::BoundsException | qiotoolkit",
    "keywords": "Class optimal_learning::BoundsException \\rst Overview** Exception to capture value < min_value OR value > max_value. Stores value, min, and max for debugging/logging/reacting purposes. Message Format** The what() message is formatted in the class ctor (capitals indicate variable information):: R\"%%( BoundsException: VALUE is not in range [MIN, MAX]. CUSTOM_MESSAGE FUNCTION_NAME FILE_LINE_INFO )%%\" \\endrst Inheritance optimal_learning::OptimalLearningException optimal_learning::BoundsException optimal_learning::LowerBoundException optimal_learning::UpperBoundException Inherited Members OptimalLearningException OptimalLearningException what AppendCustomMessageAndDebugInfo OptimalLearningException Constructors BoundsException() \\rst Constructs a BoundsException object with extra fields to flesh out the what() message. :line_info[] ptr to char array containing FILE and LINE info; e.g., from OL_STRINGIFY_FILE_AND_LINE :func_info[]: optional ptr to char array from OL_CURRENT_FUNCTION_NAME or similar :custom_message[]: optional ptr to char array with any additional text/info to print/log :value: the value that violates its min or max bound :min: the minimum bound for value :max: the maximum bound for value \\endrst Declaration optimal_learning::BoundsException<ValueType>::BoundsException(char const *line_info, char const *func_info, char const *custom_message, ValueType value_in, ValueType min_in, ValueType max_in) BoundsException() Declaration optimal_learning::BoundsException<ValueType>::BoundsException(char const *name_in, char const *line_info, char const *func_info, char const *custom_message, ValueType value_in, ValueType min_in, ValueType max_in) Methods value() Declaration ValueType optimal_learning::BoundsException<ValueType>::value() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT max() Declaration ValueType optimal_learning::BoundsException<ValueType>::max() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT min() Declaration ValueType optimal_learning::BoundsException<ValueType>::min() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT OL_DISALLOW_DEFAULT_AND_ASSIGN() Declaration optimal_learning::BoundsException<ValueType>::OL_DISALLOW_DEFAULT_AND_ASSIGN(BoundsException)"
  },
  "api/optimal/learning/closed-interval.html": {
    "href": "api/optimal/learning/closed-interval.html",
    "title": "Struct optimal_learning::ClosedInterval | qiotoolkit",
    "keywords": "Struct optimal_learning::ClosedInterval \\rst Container to represent the mathematical notion of a closed interval, commonly written \\ms [a,b]\\me. The closed interval \\ms [a,b]\\me is the set of all numbers \\ms x \\in \\mathbb{R}\\me such that \\ms a \\leq x \\leq b\\me. Note that \"closed\" here indicates the interval includes both endpoints. An interval with \\ms a > b\\me is considered empty. This struct is \"trivial\" and \"standard layout\" and thus \"POD\" (in the C++11 sense). http://en.cppreference.com/w/cpp/types/is_pod http://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special/7189821#7189821 This struct is not an aggregate; list (aka brace) initialization and a 2-argument constructor are both available:: ClosedInterval tmp(1.0, 2.0); // this ctor makes it non-aggregate ClosedInterval tmp{1.0, 2.0}; // and brace-style (aka initializer list) inits also work \\endrst Constructors ClosedInterval() \\rst Explicitly defaulted default constructor. Defining a custom ctor (below) disables the default ctor, so we explicitly default it. This is needed to maintain POD-ness. \\endrst Declaration optimal_learning::ClosedInterval::ClosedInterval()=default ClosedInterval() \\rst Constructs a ClosedInterval object with specified min, max. The presence of this ctor makes this object a non-aggregate, so brace-initialization follow list initialization rules (not aggregate initialization): http://en.cppreference.com/w/cpp/language/list_initialization :min_in left bound of the interval :max_in: right bound of the interval \\endrst Declaration optimal_learning::ClosedInterval::ClosedInterval(double min_in, double max_in) Methods IsInside() \\rst Check if a value is inside this ClosedInterval. :value the value to check true if min \\ms\\leq\\me value \\ms\\leq\\me max \\endrst Declaration bool optimal_learning::ClosedInterval::IsInside(double value) const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT Length() \\rst Compute the length of this ClosedInterval; result can be negative (i.e., an empty interval). length of the interval \\endrst Declaration double optimal_learning::ClosedInterval::Length() const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT IsEmpty() \\rst Checks whether the interval is \\ms\\emptyset\\me (i.e., max < min). Equivalent to Length() \\ms\\geq\\me 0.0. true if the interval is non-empty: max \\ms\\geq\\me min \\endrst Declaration bool optimal_learning::ClosedInterval::IsEmpty() const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT"
  },
  "api/optimal/learning/covariance-interface.html": {
    "href": "api/optimal/learning/covariance-interface.html",
    "title": "Class optimal_learning::CovarianceInterface | qiotoolkit",
    "keywords": "Class optimal_learning::CovarianceInterface \\rst Abstract class to enable evaluation of covariance functionssupports the evaluation of the covariance between two points, as well as the gradient with respect to those coordinates and gradient/hessian with respect to the hyperparameters of the covariance function. Covariance operaters, cov(x_1, x_2) are SPD. Due to the symmetry, there is no need to differentiate wrt x_1 and x_2; hence the gradient operation should only take gradients wrt dim variables, where dim = |x_1| Hyperparameters (denoted \\theta_j) are stored as class member data by subclasses. This class has only pure virtual functions, making it abstract. Users cannot instantiate this class directly. \\endrst Inheritance optimal_learning::CovarianceInterface optimal_learning::MaternNu2p5 optimal_learning::SquareExponential Methods ~CovarianceInterface() Declaration virtual optimal_learning::CovarianceInterface::~CovarianceInterface()=default Covariance() \\rst Computes the covariance function of the function values and their gradients of two points, cov(point_one, point_two). Points must be arrays with length dim. The covariance function is guaranteed to be symmetric by definition: Covariance(x, y) = Covariance(y, x). This function is also positive definite by definition. :point_one[dim] first spatial coordinate :derivatives_one[dim]: which derivatives of point_one are available :num_derivatives_one: int, the number of derivatives of point one :point_two[dim]: second spatial coordinate :derivatives_two[dim]: which derivatives of point_two are available :num_derivatives_two: int, the number of derivatives of point two cov[1+num_derivatives_one][1+num_derivatives_two]: value of covariance between the function values and their gradients of the input points \\endrst Declaration virtual void optimal_learning::CovarianceInterface::Covariance(double const *restrict point_one, int const *restrict derivatives_one, int num_derivatives_one, double const *restrict point_two, int const *restrict derivatives_two, int num_derivatives_two, double *restrict cov) const noexcept=0 GradCovariance() \\rst Computes the gradient of this.Covariance(point_one, point_two) with respect to the FIRST argument, point_one. This distinction is important for maintaining the desired symmetry. Cov(x, y) = Cov(y, x). Additionally, \\pderiv{Cov(x, y)}{x} = \\pderiv{Cov(y, x)}{x}. However, in general, \\pderiv{Cov(x, y)}{x} != \\pderiv{Cov(y, x)}{y} (NOT equal! These may differ by a negative sign) Hence to avoid separate implementations for differentiating against first vs second argument, this function only handles differentiation against the first argument. If you need \\pderiv{Cov(y, x)}{x}, just swap points x and y. :point_one[dim] first spatial coordinate :derivatives_one[dim]: which derivatives of point_one are available :num_derivatives_one: int, the number of derivatives of point one :point_two[dim]: second spatial coordinate :derivatives_two[dim]: which derivatives of point_two are available :num_derivatives_two: int, the number of derivatives of point two \\output grad_cov[dim][1+num_derivatives_one][1+num_derivatives_two]: (i, j, k)-th entry is \\pderiv{cov(x_1, x_2)(j, k))}{x1_i} \\endrst Declaration virtual void optimal_learning::CovarianceInterface::GradCovariance(double const *restrict point_one, int const *restrict derivatives_one, int num_derivatives_one, double const *restrict point_two, int const *restrict derivatives_two, int num_derivatives_two, double *restrict grad_cov) const noexcept OL_NONNULL_POINTERS=0 GetNumberOfHyperparameters() \\rst Returns the number of hyperparameters. This base class only allows for a maximum of dim + 1 hyperparameters but subclasses may implement additional ones. The number of hyperparameters. Return 0 to disable hyperparameter-related gradients, optimizations. \\endrst Declaration virtual int optimal_learning::CovarianceInterface::GetNumberOfHyperparameters() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT=0 HyperparameterGradCovariance() \\rst Similar to GradCovariance(), except gradients are computed w.r.t. the hyperparameters. Unlike GradCovariance(), the order of point_one and point_two is irrelevant here (since we are not differentiating against either of them). Thus the matrix of grad covariances (wrt hyperparameters) is symmetric. :point_one[dim] first spatial coordinate :derivatives_one[dim]: which derivatives of point_one are available :num_derivatives_one: int, the number of derivatives of point one :point_two[dim]: second spatial coordinate :derivatives_two[dim]: which derivatives of point_two are available :num_derivatives_two: int, the number of derivatives of point two \\output :grad_hyperparameter_cov[this.GetNumberOfHyperparameters()][1+num_derivatives_one][1+num_derivatives_two]: (i, j, k)-th entry is \\pderiv{cov(x_1, x_2)(j, k)}{\\theta_i} \\endrst Declaration virtual void optimal_learning::CovarianceInterface::HyperparameterGradCovariance(double const *restrict point_one, int const *restrict derivatives_one, int num_derivatives_one, double const *restrict point_two, int const *restrict derivatives_two, int num_derivatives_two, double *restrict grad_hyperparameter_cov) const noexcept OL_NONNULL_POINTERS=0 SetHyperparameters() \\rst Sets the hyperparameters. Hyperparameter ordering is defined implicitly by GetHyperparameters: [alpha=\\sigma_f^2, length_0, ..., length_{n-1}] :hyperparameters[this.GetNumberOfHyperparameters()] hyperparameters to set \\endrst Declaration virtual void optimal_learning::CovarianceInterface::SetHyperparameters(double const *restrict hyperparameters) noexcept OL_NONNULL_POINTERS=0 GetHyperparameters() \\rst Gets the hyperparameters. Ordering is [alpha=\\sigma_f^2, length_0, ..., length_{n-1}] \\output :hyperparameters[this.GetNumberOfHyperparameters()]: values of current hyperparameters \\endrst Declaration virtual void optimal_learning::CovarianceInterface::GetHyperparameters(double *restrict hyperparameters) const noexcept OL_NONNULL_POINTERS=0 Clone() \\rst For implementing the virtual (copy) constructor idiom. :Pointer to a constructed object that is a subclass of CovarianceInterface \\endrst Declaration virtual CovarianceInterface* optimal_learning::CovarianceInterface::Clone() const OL_WARN_UNUSED_RESULT=0"
  },
  "api/optimal/learning/dummy-domain.html": {
    "href": "api/optimal/learning/dummy-domain.html",
    "title": "Class optimal_learning::DummyDomain | qiotoolkit",
    "keywords": "Class optimal_learning::DummyDomain \\rst A dummy domain; commonly paired with the NullOptimizer. Use when domain is irrelevant. It does not track any member data and claims all points are inside. \\endrst Inheritance optimal_learning::DummyDomain Methods CheckPointInside() \\rst Always returns true: DummyDomain contains all points. :point[dim] point to check true if point is inside the domain or on its boundary, false otherwise \\endrst Declaration bool optimal_learning::DummyDomain::CheckPointInside(double const *restrict OL_UNUSED(point)) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT"
  },
  "api/optimal/learning/expected-improvement-evaluator.html": {
    "href": "api/optimal/learning/expected-improvement-evaluator.html",
    "title": "Class optimal_learning::ExpectedImprovementEvaluator | qiotoolkit",
    "keywords": "Class optimal_learning::ExpectedImprovementEvaluator \\rst A class to encapsulate the computation of expected improvement and its spatial gradient. This class handles the general EI computation case using monte carlo integration; it can support q,p-EI optimization. It is designed to work with any GaussianProcess. Additionally, this class has no state and within the context of EI optimization, it is meant to be accessed by const reference only. The random numbers needed for EI computation will be passed as parameters instead of contained as members to make multithreading more straightforward. \\endrst Inheritance optimal_learning::ExpectedImprovementEvaluator Constructors ExpectedImprovementEvaluator() \\rst Constructs a ExpectedImprovementEvaluator object. All inputs are required; no default constructor nor copy/assignment are allowed. :gaussian_process GaussianProcess object (holds points_sampled, values, noise_variance, derived quantities) that describes the underlying GP :num_mc_iterations: number of monte carlo iterations :best_so_far: best (minimum) objective function value (in points_sampled_value) \\endrst Declaration optimal_learning::ExpectedImprovementEvaluator::ExpectedImprovementEvaluator(const GaussianProcess&gaussian_process_in, int num_mc_iterations, double best_so_far) ExpectedImprovementEvaluator() Declaration optimal_learning::ExpectedImprovementEvaluator::ExpectedImprovementEvaluator(ExpectedImprovementEvaluator&&other) Methods dim() Declaration int optimal_learning::ExpectedImprovementEvaluator::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_mc_iterations() Declaration int optimal_learning::ExpectedImprovementEvaluator::num_mc_iterations() noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT best_so_far() Declaration double optimal_learning::ExpectedImprovementEvaluator::best_so_far() noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT gaussian_process() Declaration const GaussianProcess* optimal_learning::ExpectedImprovementEvaluator::gaussian_process() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT ComputeObjectiveFunction() \\rst Wrapper for ComputeExpectedImprovement(); see that function for details. \\endrst Declaration double optimal_learning::ExpectedImprovementEvaluator::ComputeObjectiveFunction(StateType *ei_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradObjectiveFunction() \\rst Wrapper for ComputeGradExpectedImprovement(); see that function for details. \\endrst Declaration void optimal_learning::ExpectedImprovementEvaluator::ComputeGradObjectiveFunction(StateType *ei_state, double *restrict grad_EI) const OL_NONNULL_POINTERS ComputeExpectedImprovement() \\rst Computes the expected improvement EI(Xs) = E_n[[f^*_n(X) - min(f(Xs_1),...,f(Xs_m))]^+], where Xs are potential points to sample (union of points_to_sample and points_being_sampled) and X are already sampled points. The ^+ indicates that the expression in the expectation evaluates to 0 if it is negative. f^*(X) is the MINIMUM over all known function evaluations (points_sampled_value), whereas f(Xs) are GP-predicted function evaluations. points_to_sample is the \"q\" and points_being_sampled is the \"p\" in q,p-EI. In words, we are computing the expected improvement (over the current best_so_far, best known objective function value) that would result from sampling (aka running new experiments) at points_to_sample with points_being_sampled concurrent/ongoing experiments. In general, the EI expression is complex and difficult to evaluate; hence we use Monte-Carlo simulation to approximate it. When faster (e.g., analytic) techniques are available, we will prefer them. The idea of the MC approach is to repeatedly sample at the union of points_to_sample and points_being_sampled. This is analogous to gaussian_process_interface.sample_point_from_gp, but we sample num_union points at once: y = \\mu + Lw where \\mu is the GP-mean, L is the chol_factor(GP-variance) and w is a vector of num_union draws from N(0, 1). Then: improvement_per_step = max(max(best_so_far - y), 0.0) Observe that the inner max means only the smallest component of y contributes in each iteration. We compute the improvement over many random draws and average. .. Note:: These comments were copied into ExpectedImprovementInterface.compute_expected_improvement() in interfaces/expected_improvement_interface.py. :ei_state[1] properly configured state object \\output :ei_state[1]: state with temporary storage modified; normal_rng modified the expected improvement from sampling points_to_sample with points_being_sampled concurrent experiments \\endrst \\rst Let Ls * Ls^T = Vars and w = vector of IID normal(0,1) variables Then: y = mus + Ls * w (Equation 4, from file docs) simulates drawing from our GP with mean mus and variance Vars. Then as given in the file docs, we compute the improvement: Then the improvement for this single sample is:: I = { best_known - min(y) if (best_known - min(y) > 0) (Equation 5 from file docs) { 0 else This is implemented as max_{y} (best_known - y). Notice that improvement takes the value 0 if it would be negative. Since we cannot compute min(y) directly, we do so via monte-carlo (MC) integration. That is, we draw from the GP repeatedly, computing improvement during each iteration, and averaging the result. See Scott's PhD thesis, sec 6.2. .. Note:: comments here are copied to _compute_expected_improvement_monte_carlo() in python_version/expected_improvement.py \\endrst Declaration double optimal_learning::ExpectedImprovementEvaluator::ComputeExpectedImprovement(StateType *ei_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradExpectedImprovement() \\rst Computes the (partial) derivatives of the expected improvement with respect to each point of points_to_sample. As with ComputeExpectedImprovement(), this computation accounts for the effect of points_being_sampled concurrent experiments. points_to_sample is the \"q\" and points_being_sampled is the \"p\" in q,p-EI.. In general, the expressions for gradients of EI are complex and difficult to evaluate; hence we use Monte-Carlo simulation to approximate it. When faster (e.g., analytic) techniques are available, we will prefer them. The MC computation of grad EI is similar to the computation of EI (decsribed in compute_expected_improvement). We differentiate y = \\mu + Lw wrt points_to_sample; only terms from the gradient of \\mu and L contribute. In EI, we computed: improvement_per_step = max(max(best_so_far - y), 0.0) and noted that only the smallest component of y may contribute (if it is > 0.0). Call this index winner. Thus in computing grad EI, we only add gradient terms that are attributable to the winner-th component of y. .. Note:: These comments were copied into ExpectedImprovementInterface.compute_expected_improvement() in interfaces/expected_improvement_interface.py. :ei_state[1] properly configured state object \\output :ei_state[1]: state with temporary storage modified; normal_rng modified :grad_EI[dim][num_to_sample]: gradient of EI, \\pderiv{EI(Xq \\cup Xp)}{Xq_{d,i}} where Xq is points_to_sample and Xp is points_being_sampled (grad EI from sampling points_to_sample with points_being_sampled concurrent experiments wrt each dimension of the points in points_to_sample) \\endrst \\rst Computes gradient of EI (see ExpectedImprovementEvaluator::ComputeGradExpectedImprovement) wrt points_to_sample (stored in union_of_points[0:num_to_sample]). Mechanism is similar to the computation of EI, where points' contributions to the gradient are thrown out of their corresponding improvement <= 0.0. Thus \\nabla(\\mu) only contributes when the winner (point w/best improvement this iteration) is the current point. That is, the gradient of \\mu at x_i wrt x_j is 0 unless i == j (and only this result is stored in ei_state->grad_mu). The interaction with ei_state->grad_chol_decomp is harder to know a priori (like with grad_mu) and has a more complex structure (rank 3 tensor), so the derivative wrt x_j is computed fully, and the relevant submatrix (indexed by the current winner) is accessed each iteration. .. Note:: comments here are copied to _compute_grad_expected_improvement_monte_carlo() in python_version/expected_improvement.py \\endrst Declaration void optimal_learning::ExpectedImprovementEvaluator::ComputeGradExpectedImprovement(StateType *ei_state, double *restrict grad_EI) const OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::ExpectedImprovementEvaluator::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(ExpectedImprovementEvaluator)"
  },
  "api/optimal/learning/expected-improvement-mcmcevaluator.html": {
    "href": "api/optimal/learning/expected-improvement-mcmcevaluator.html",
    "title": "Class optimal_learning::ExpectedImprovementMCMCEvaluator | qiotoolkit",
    "keywords": "Class optimal_learning::ExpectedImprovementMCMCEvaluator \\rst A class to encapsulate the computation of knowledge gradient and its spatial gradient. This class handles the general KG computation case using monte carlo integration; it can support q,p-KG optimization. It is designed to work with any GaussianProcess. Additionally, this class has no state and within the context of KG optimization, it is meant to be accessed by const reference only. The random numbers needed for KG computation will be passed as parameters instead of contained as members to make multithreading more straightforward. \\endrst Inheritance optimal_learning::ExpectedImprovementMCMCEvaluator Constructors ExpectedImprovementMCMCEvaluator() \\rst Constructs a KnowledgeGradientEvaluator object. All inputs are required; no default constructor nor copy/assignment are allowed. :gaussian_process GaussianProcess object (holds points_sampled, values, noise_variance, derived quantities) that describes the underlying GP :discrete_pts[dim][num_pts]: the set of points to approximate the KG factor :num_pts: number of points in discrete_pts :num_mc_iterations: number of monte carlo iterations :best_so_far: best (minimum) objective function value (in points_sampled_value) \\endrst Declaration optimal_learning::ExpectedImprovementMCMCEvaluator::ExpectedImprovementMCMCEvaluator(const GaussianProcessMCMC&gaussian_process_mcmc, int num_mc_iterations, double const *best_so_far, std::vector<typename ExpectedImprovementState::EvaluatorType>*evaluator_vector) Methods dim() Declaration int optimal_learning::ExpectedImprovementMCMCEvaluator::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_mcmc() Declaration int optimal_learning::ExpectedImprovementMCMCEvaluator::num_mcmc() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT expected_improvement_evaluator_list() Declaration std::vector<ExpectedImprovementEvaluator>* optimal_learning::ExpectedImprovementMCMCEvaluator::expected_improvement_evaluator_list() const noexcept OL_WARN_UNUSED_RESULT best_so_far_list() Declaration std::vector<double>optimal_learning::ExpectedImprovementMCMCEvaluator::best_so_far_list(double const *best_so_far) const noexcept OL_WARN_UNUSED_RESULT ComputeObjectiveFunction() \\rst Wrapper for ComputeKnowledgeGradient(); see that function for details. \\endrst Declaration double optimal_learning::ExpectedImprovementMCMCEvaluator::ComputeObjectiveFunction(StateType *ei_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradObjectiveFunction() \\rst Wrapper for ComputeGradKnowledgeGradient(); see that function for details. \\endrst Declaration void optimal_learning::ExpectedImprovementMCMCEvaluator::ComputeGradObjectiveFunction(StateType *ei_state, double *restrict grad_EI) const OL_NONNULL_POINTERS ComputeExpectedImprovement() \\rst Computes the knowledge gradient :kg_state[1] properly configured state object \\output :kg_state[1]: state with temporary storage modified; normal_rng modified the knowledge gradient from sampling points_to_sample with points_being_sampled concurrent experiments \\endrst \\rst Compute Knowledge Gradient This version requires the discretization of A (the feasibe domain). The discretization usually is: some set + points previous sampled + points being sampled + points to sample \\endrst Declaration double optimal_learning::ExpectedImprovementMCMCEvaluator::ComputeExpectedImprovement(StateType *ei_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradExpectedImprovement() \\rst Computes the (partial) derivatives of the knowledge gradient with respect to each point of points_to_sample. As with ComputeKnowledgeGradient(), this computation accounts for the effect of points_being_sampled concurrent experiments. points_to_sample is the \"q\" and points_being_sampled is the \"p\" in q,p-KG. :kg_state[1] properly configured state object \\output :kg_state[1]: state with temporary storage modified; normal_rng modified :grad_KG[dim][num_to_sample]: gradient of KG, \\pderiv{KG(Xq \\cup Xp)}{Xq_{d,i}} where Xq is points_to_sample and Xp is points_being_sampled (grad KG from sampling points_to_sample with points_being_sampled concurrent experiments wrt each dimension of the points in points_to_sample) \\endrst \\rst Computes gradient of KG (see KnowledgeGradientEvaluator::ComputeGradKnowledgeGradient) wrt points_to_sample (stored in union_of_points[0:num_to_sample]). Mechanism is similar to the computation of KG, where points' contributions to the gradient are thrown out of their corresponding improvement <= 0.0. Thus \\nabla(\\mu) only contributes when the winner (point w/best improvement this iteration) is the current point. That is, the gradient of \\mu at x_i wrt x_j is 0 unless i == j (and only this result is stored in kg_state->grad_mu). The interaction with kg_state->grad_chol_decomp is harder to know a priori (like with grad_mu) and has a more complex structure (rank 3 tensor), so the derivative wrt x_j is computed fully, and the relevant submatrix (indexed by the current winner) is accessed each iteration. .. Note:: comments here are copied to _compute_grad_knowledge_gradient_monte_carlo() in python_version/knowledge_gradient.py \\endrst Declaration void optimal_learning::ExpectedImprovementMCMCEvaluator::ComputeGradExpectedImprovement(StateType *ei_state, double *restrict grad_EI) const OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::ExpectedImprovementMCMCEvaluator::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(ExpectedImprovementMCMCEvaluator)"
  },
  "api/optimal/learning/expected-improvement-mcmcstate.html": {
    "href": "api/optimal/learning/expected-improvement-mcmcstate.html",
    "title": "Struct optimal_learning::ExpectedImprovementMCMCState | qiotoolkit",
    "keywords": "Struct optimal_learning::ExpectedImprovementMCMCState \\rst State object for KnowledgeGradientEvaluator. This tracks the points being sampled in concurrent experiments (points_being_sampled) ALONG with the points currently being evaluated via knowledge gradient for future experiments (called points_to_sample); these are the p and q of q,p-KG, respectively. points_to_sample joined with points_being_sampled is stored in union_of_points in that order. This struct also tracks the state of the GaussianProcess that underlies the knowledge gradient computation: the GP state is built to handle the initial union_of_points, and subsequent updates to points_to_sample in this object also update the GP state. This struct also holds a pointer to a random number generator needed for Monte Carlo integrated KG computations. .. WARNING:: Users MUST guarantee that multiple state objects DO NOT point to the same RNG (in a multithreaded env). See general comments on State structs in gpp_common.hpp's header docs. \\endrst Constructors ExpectedImprovementMCMCState() \\rst Constructs an KnowledgeGradientMCMCState object with a specified source of randomness for the purpose of computing KG (and its gradient) over the specified set of points to sample. This establishes properly sized/initialized temporaries for KG computation, including dependent state from the associated Gaussian Process (which arrives as part of the kg_evaluator). .. WARNING:: This object is invalidated if the associated kg_evaluator is mutated. SetupState() should be called to reset. .. WARNING:: Using this object to compute gradients when configure_for_gradients := false results in UNDEFINED BEHAVIOR. :kg_evaluator knowledge gradient evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: points at which to evaluate KG and/or its gradient to check their value in future experiments (i.e., test points for GP predictions) :points_being_sampled[dim][num_being_sampled]: points being sampled in concurrent experiments :num_to_sample: number of potential future samples; gradients are evaluated wrt these points (i.e., the \"q\" in q,p-KG) :num_being_sampled: number of points being sampled in concurrent experiments (i.e., the \"p\" in q,p-KG) :configure_for_gradients: true if this object will be used to compute gradients, false otherwise :normal_rng[1]: pointer to a properly initialized* NormalRNG object .. NOTE:: The NormalRNG object must already be seeded. If multithreaded computation is used for KG, then every state object must have a different NormalRNG (different seeds, not just different objects). \\endrst Declaration optimal_learning::ExpectedImprovementMCMCState::ExpectedImprovementMCMCState(const EvaluatorType&ei_evaluator, double const *restrict points_to_sample, double const *restrict points_being_sampled, int num_to_sample_in, int num_being_sampled_in, int const *restrict gradients_in, int num_gradients_in, bool configure_for_gradients, NormalRNGInterface *normal_rng_in, std::vector<typename ExpectedImprovementEvaluator::StateType>*ei_state_vector) ExpectedImprovementMCMCState() Declaration optimal_learning::ExpectedImprovementMCMCState::ExpectedImprovementMCMCState(ExpectedImprovementMCMCState&&other) Methods GetProblemSize() Declaration int optimal_learning::ExpectedImprovementMCMCState::GetProblemSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT GetCurrentPoint() \\rst Get the points_to_sample: potential future samples whose KG (and/or gradients) are being evaluated \\output :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::ExpectedImprovementMCMCState::GetCurrentPoint(double *restrict points_to_sample) const noexcept OL_NONNULL_POINTERS SetCurrentPoint() \\rst Change the potential samples whose KG (and/or gradient) are being evaluated. Update the state's derived quantities to be consistent with the new points. :kg_evaluator expected improvement evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::ExpectedImprovementMCMCState::SetCurrentPoint(const EvaluatorType&kg_evaluator, double const *restrict points_to_sample_in) OL_NONNULL_POINTERS SetupState() \\rst Configures this state object with new points_to_sample, the location of the potential samples whose KG is to be evaluated. Ensures all state variables & temporaries are properly sized. Properly sets all dependent state variables (e.g., GaussianProcess's state) for KG evaluation. .. WARNING:: This object's state is INVALIDATED if the kg_evaluator (including the GaussianProcess it depends on) used in SetupState is mutated! SetupState() should be called again in such a situation. :kg_evaluator knowledge gradient evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::ExpectedImprovementMCMCState::SetupState(const EvaluatorType&ei_evaluator, double const *restrict points_to_sample) OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::ExpectedImprovementMCMCState::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(ExpectedImprovementMCMCState) BuildUnionOfPoints() \\rst Create a vector with the union of points_to_sample and points_being_sampled (the latter is appended to the former). Note the l-value return. Assigning the return to a std::vector or passing it as an argument to the ctor will result in copy-elision or move semantics; no copying/performance loss. :points_to_sample[dim][num_to_sample]: points at which to evaluate KG and/or its gradient to check their value in future experiments (i.e., test points for GP predictions) :points_being_sampled[dim][num_being_sampled]: points being sampled in concurrent experiments :num_to_sample: number of potential future samples; gradients are evaluated wrt these points (i.e., the \"q\" in q,p-KG) :num_being_sampled: number of points being sampled in concurrent experiments (i.e., the \"p\" in q,p-KG) :dim: the number of spatial dimensions of each point array std::vector with the union of the input arrays: points_being_sampled is appended to points_to_sample \\endrst Declaration static std::vector<double>optimal_learning::ExpectedImprovementMCMCState::BuildUnionOfPoints(double const *restrict points_to_sample, double const *restrict points_being_sampled, int num_to_sample, int num_being_sampled, int dim) noexcept OL_WARN_UNUSED_RESULT"
  },
  "api/optimal/learning/expected-improvement-state.html": {
    "href": "api/optimal/learning/expected-improvement-state.html",
    "title": "Struct optimal_learning::ExpectedImprovementState | qiotoolkit",
    "keywords": "Struct optimal_learning::ExpectedImprovementState \\rst State object for ExpectedImprovementEvaluator. This tracks the points being sampled in concurrent experiments (points_being_sampled) ALONG with the points currently being evaluated via expected improvement for future experiments (called points_to_sample); these are the p and q of q,p-EI, respectively. points_to_sample joined with points_being_sampled is stored in union_of_points in that order. This struct also tracks the state of the GaussianProcess that underlies the expected improvement computation: the GP state is built to handle the initial union_of_points, and subsequent updates to points_to_sample in this object also update the GP state. This struct also holds a pointer to a random number generator needed for Monte Carlo integrated EI computations. .. WARNING:: Users MUST guarantee that multiple state objects DO NOT point to the same RNG (in a multithreaded env). See general comments on State structs in gpp_common.hpp's header docs. \\endrst Constructors ExpectedImprovementState() \\rst Constructs an ExpectedImprovementState object with a specified source of randomness for the purpose of computing EI (and its gradient) over the specified set of points to sample. This establishes properly sized/initialized temporaries for EI computation, including dependent state from the associated Gaussian Process (which arrives as part of the ei_evaluator). .. WARNING:: This object is invalidated if the associated ei_evaluator is mutated. SetupState() should be called to reset. .. WARNING:: Using this object to compute gradients when configure_for_gradients := false results in UNDEFINED BEHAVIOR. :ei_evaluator expected improvement evaluator object that specifies the parameters & GP for EI evaluation :points_to_sample[dim][num_to_sample]: points at which to evaluate EI and/or its gradient to check their value in future experiments (i.e., test points for GP predictions) :points_being_sampled[dim][num_being_sampled]: points being sampled in concurrent experiments :num_to_sample: number of potential future samples; gradients are evaluated wrt these points (i.e., the \"q\" in q,p-EI) :num_being_sampled: number of points being sampled in concurrent experiments (i.e., the \"p\" in q,p-EI) :configure_for_gradients: true if this object will be used to compute gradients, false otherwise :normal_rng[1]: pointer to a properly initialized* NormalRNG object .. NOTE:: The NormalRNG object must already be seeded. If multithreaded computation is used for EI, then every state object must have a different NormalRNG (different seeds, not just different objects). \\endrst Declaration optimal_learning::ExpectedImprovementState::ExpectedImprovementState(const EvaluatorType&ei_evaluator, double const *restrict points_to_sample, double const *restrict points_being_sampled, int num_to_sample_in, int num_being_sampled_in, bool configure_for_gradients, NormalRNGInterface *normal_rng_in) ExpectedImprovementState() Declaration optimal_learning::ExpectedImprovementState::ExpectedImprovementState(ExpectedImprovementState&&other) Methods GetProblemSize() Declaration int optimal_learning::ExpectedImprovementState::GetProblemSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT GetCurrentPoint() \\rst Get the points_to_sample: potential future samples whose EI (and/or gradients) are being evaluated \\output :points_to_sample[dim][num_to_sample]: potential future samples whose EI (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::ExpectedImprovementState::GetCurrentPoint(double *restrict points_to_sample) const noexcept OL_NONNULL_POINTERS SetCurrentPoint() \\rst Change the potential samples whose EI (and/or gradient) are being evaluated. Update the state's derived quantities to be consistent with the new points. :ei_evaluator expected improvement evaluator object that specifies the parameters & GP for EI evaluation :points_to_sample[dim][num_to_sample]: potential future samples whose EI (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::ExpectedImprovementState::SetCurrentPoint(const EvaluatorType&ei_evaluator, double const *restrict points_to_sample) OL_NONNULL_POINTERS SetupState() \\rst Configures this state object with new points_to_sample, the location of the potential samples whose EI is to be evaluated. Ensures all state variables & temporaries are properly sized. Properly sets all dependent state variables (e.g., GaussianProcess's state) for EI evaluation. .. WARNING:: This object's state is INVALIDATED if the ei_evaluator (including the GaussianProcess it depends on) used in SetupState is mutated! SetupState() should be called again in such a situation. :ei_evaluator expected improvement evaluator object that specifies the parameters & GP for EI evaluation :points_to_sample[dim][num_to_sample]: potential future samples whose EI (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::ExpectedImprovementState::SetupState(const EvaluatorType&ei_evaluator, double const *restrict points_to_sample) OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::ExpectedImprovementState::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(ExpectedImprovementState) BuildUnionOfPoints() \\rst Create a vector with the union of points_to_sample and points_being_sampled (the latter is appended to the former). Note the l-value return. Assigning the return to a std::vector or passing it as an argument to the ctor will result in copy-elision or move semantics; no copying/performance loss. :points_to_sample[dim][num_to_sample]: points at which to evaluate EI and/or its gradient to check their value in future experiments (i.e., test points for GP predictions) :points_being_sampled[dim][num_being_sampled]: points being sampled in concurrent experiments :num_to_sample: number of potential future samples; gradients are evaluated wrt these points (i.e., the \"q\" in q,p-EI) :num_being_sampled: number of points being sampled in concurrent experiments (i.e., the \"p\" in q,p-EI) :dim: the number of spatial dimensions of each point array std::vector with the union of the input arrays: points_being_sampled is appended to points_to_sample \\endrst Declaration static std::vector<double>optimal_learning::ExpectedImprovementState::BuildUnionOfPoints(double const *restrict points_to_sample, double const *restrict points_being_sampled, int num_to_sample, int num_being_sampled, int dim) noexcept OL_WARN_UNUSED_RESULT"
  },
  "api/optimal/learning/gaussian-process-mcmc.html": {
    "href": "api/optimal/learning/gaussian-process-mcmc.html",
    "title": "Struct optimal_learning::GaussianProcessMCMC | qiotoolkit",
    "keywords": "Struct optimal_learning::GaussianProcessMCMC Constructors GaussianProcessMCMC() Declaration optimal_learning::GaussianProcessMCMC::GaussianProcessMCMC(double const *restrict hypers_mcmc, double const *restrict noises_mcmc, int num_mcmc, double const *restrict points_sampled_in, double const *restrict points_sampled_value_in, int const *restrict derivatives_in, int num_derivatives_in, int dim_in, int num_sampled_in) OL_NONNULL_POINTERS Methods num_mcmc() Declaration int optimal_learning::GaussianProcessMCMC::num_mcmc() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT dim() Declaration int optimal_learning::GaussianProcessMCMC::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_sampled() Declaration int optimal_learning::GaussianProcessMCMC::num_sampled() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_derivatives() Declaration int optimal_learning::GaussianProcessMCMC::num_derivatives() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT points_sampled() Declaration const std::vector<double>&optimal_learning::GaussianProcessMCMC::points_sampled() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT points_sampled_value() Declaration const std::vector<double>&optimal_learning::GaussianProcessMCMC::points_sampled_value() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT derivatives() Declaration const std::vector<int>&optimal_learning::GaussianProcessMCMC::derivatives() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT"
  },
  "api/optimal/learning/gaussian-process.html": {
    "href": "api/optimal/learning/gaussian-process.html",
    "title": "Class optimal_learning::GaussianProcess | qiotoolkit",
    "keywords": "Class optimal_learning::GaussianProcess \\rst Object that encapsulates Gaussian Process Priors (GPPs). A GPP is defined by a set of (sample point, function value, noise variance) triples along with a covariance function that relates the points. Each point has dimension dim. These are the training data; for example, each sample point might specify an experimental cohort and the corresponding function value is the objective measured for that experiment. There is one noise variance value per function value; this is the measurement error and is treated as N(0, noise_variance) Gaussian noise. GPPs estimate a real process \\ms f(x) = GP(m(x), k(x,x'))\\me (see file docs). This class deals with building an estimator to the actual process using measurements taken from the actual processthe (sample point, function val, noise) triple. Then predictions about unknown points can be made by sampling from the GPPin particular, finding the (predicted) mean and variance. These functions (and their gradients) are provided in ComputeMeanOfPoints, ComputeVarianceOfPoints, etc. Further mathematical details are given in the implementation comments, but we are essentially computing: | ComputeMeanOfPoints : K(Xs, X) * [K(X,X) + \\sigma_n^2 I]^{-1} * y | ComputeVarianceOfPoints: K(Xs, Xs) - K(Xs,X) * [K(X,X) + \\sigma_n^2 I]^{-1} * K(X,Xs) This (estimated) mean and variance characterize the predicted distributions of the actual \\ms m(x), k(x,x')\\me functions that underly our GP. .. Note:: the preceding comments are copied in Python: interfaces/gaussian_process_interface.py For testing and experimental purposes, this class provides a framework for sampling points from the GP (i.e., given a point to sample and predicted measurement noise) as well as adding additional points to an already-formed GP. Sampling points requires drawing from \\ms N(0,1)\\me so this class also holds PRNG state to do so via the NormalRNG object from gpp_random. .. NOTE:: Functions that manipulate the PRNG directly or indirectly (changing state, generating points) are NOT THREAD-SAFE. All thread-safe functions are marked const. These mean/variance methods require some external state: namely, the set of potential points to sample. Additionally, temporaries and derived quantities depending on these \"points to sample\" eliminate redundant computation. This external state is handled through PointsToSampleState objects, which are constructed separately and filled through PointsToSampleState::SetupState() which interacts with functions in this class. \\endrst Inheritance optimal_learning::GaussianProcess Constructors GaussianProcess() \\rst Constructs a GaussianProcess object. All inputs are required; no default constructor nor copy/assignment are allowed. .. Warning:: points_sampled is not allowed to contain duplicate points; doing so results in singular covariance matrices. :covariance the CovarianceFunction object encoding assumptions about the GP's behavior on our data :points_sampled[dim][num_sampled]: points that have already been sampled :points_sampled_value[num_sampled*(num_derivatives+1)]: values and derivatives of the already-sampled points, if only values are available, they should be used by setting points_sampled_value[i*(num_derivatives+1)] = value[i], when derivatives componens of points_sampled_value could be set to 0. :noise_variance[num_derivatives + 1]: the \\sigma_n^2 (noise variance) associated w/observation, points_sampled_value :dim: the spatial dimension of a point (i.e., number of independent params in experiment) :num_sampled: number of already-sampled points \\endrst Declaration optimal_learning::GaussianProcess::GaussianProcess(const CovarianceInterface&covariance_in, double const *restrict points_sampled_in, double const *restrict points_sampled_value_in, double const *restrict noise_variance_in, int const *restrict derivatives_in, int num_derivatives_in, int dim_in, int num_sampled_in) OL_NONNULL_POINTERS GaussianProcess() Declaration optimal_learning::GaussianProcess::GaussianProcess(const GaussianProcess&source) Methods dim() Declaration int optimal_learning::GaussianProcess::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_sampled() Declaration int optimal_learning::GaussianProcess::num_sampled() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_derivatives() Declaration int optimal_learning::GaussianProcess::num_derivatives() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT points_sampled() Declaration const std::vector<double>&optimal_learning::GaussianProcess::points_sampled() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT points_sampled_value() Declaration const std::vector<double>&optimal_learning::GaussianProcess::points_sampled_value() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT noise_variance() Declaration const std::vector<double>&optimal_learning::GaussianProcess::noise_variance() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT derivatives() Declaration const std::vector<int>&optimal_learning::GaussianProcess::derivatives() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT get_mean() Declaration double optimal_learning::GaussianProcess::get_mean() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT get_K_inv_y() Declaration const std::vector<double>&optimal_learning::GaussianProcess::get_K_inv_y() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT SetCovarianceHyperparameters() \\rst Change the hyperparameters of this GP's covariance function. Also forces recomputation of all derived quantities for GP to remain consistent. .. WARNING:: Using this function invalidates any PointsToSampleState objects created with \"this\" object. For any such objects \"state\", call state.SetupState(...) to restore them. :hyperparameters_new[covariance_ptr->GetNumberOfHyperparameters] new hyperparameter array \\endrst Declaration void optimal_learning::GaussianProcess::SetCovarianceHyperparameters(double const *restrict hyperparameters_new) OL_NONNULL_POINTERS FillPointsToSampleState() \\rst Sets up the PointsToSampleState object so that it can be used to compute GP mean, variance, and gradients thereof. ASSUMES all needed space is ALREADY ALLOCATED. This function should not be called directly; instead use PointsToSampleState::SetupState(). :points_to_sample_state[1] pointer to a PointsToSampleState object where all space has been properly allocated \\output :points_to_sample_state[1]: pointer to a fully configured PointsToSampleState object. overwrites input \\endrst \\rst Sets up precomputed quantities needed for mean, variance, and gradients thereof. These quantities are: Ks := Ks_{k,i} = cov(X_k, Xs_i) (used by mean, variance) Then if we need gradients: | K^-1 * Ks := solution X of K_{k,l} * X_{l,i} = Ks{k,i} (used by variance, grad variance) | gradient of Ks := C_{d,k,i} = \\pderiv{Ks_{k,i}}{Xs_{d,i}} (used by grad mean, grad variance) \\endrst Declaration void optimal_learning::GaussianProcess::FillPointsToSampleState(StateType *points_to_sample_state) const OL_NONNULL_POINTERS AddPointsToGP() \\rst Add the specified (point, fcn value, noise variance) historical data to this GP. Forces recomputation of all derived quantities for GP to remain consistent. :new_points[dim][num_new_points] coordinates of each new point to add :new_points_value[num_new_points]: function value at each new point :new_points_noise_variance[num_new_points]: \\sigma_n^2 corresponding to the signal noise in measuring new_points_value :num_new_points: number of new points to add to the GP \\endrst Declaration void optimal_learning::GaussianProcess::AddPointsToGP(double const *restrict new_points, double const *restrict new_points_value, int num_new_points, bool mean_change=true) AddSampledPointsToGP() Declaration void optimal_learning::GaussianProcess::AddSampledPointsToGP(double const *restrict new_points, double const *restrict new_points_value, int num_new_points) NewSampledValue() Declaration void optimal_learning::GaussianProcess::NewSampledValue(double const *restrict new_points_value, int num_new_points, int sampling_point_index, bool mean_change) SamplePointFromGP() \\rst Sample a function value from a Gaussian Process prior, provided a point at which to sample. Uses the formula function_value = gpp_mean + sqrt(gpp_variance) * w1 + sqrt(noise_variance) * w2, where w1, w2 are draws from \\ms N(0,1)\\me. .. NOTE:: Set noise_variance to 0 if you want \"accurate\" draws from the GP. BUT if the drawn (point, value) pair is meant to be added back into the GP (e.g., for testing), then this point MUST be drawn with noise_variance equal to the noise associated with \"point\" as a member of \"points_sampled\" :point_to_sample[dim] coordinates of the point at which to generate a function value (from GP) :noise_variance_this_point: if this point is to be added into the GP, it needs to be generated with its associated noise var function value drawn from this GP \\endrst \\rst Samples function values from a GPP given a list of points. Samples by: function_value = gpp_mean + gpp_variance * w, where w is a single draw from N(0,1). We only draw one point at a time (i.e., num_to_sample fixed at 1). We want multiple draws from the same GPP; drawing many points per step would be akin to sampling multiple GPPs. Thus gpp_mean, gpp_variance, and w all have size 1. If the GPP does not receive any data, then on the first step, gpp_mean = 0 and gpp_variance is just the \"covariance\" of a single point. Then we iterate through the remaining points in points_sampled, generating gpp_mean, gpp_variance, and a sample function value. \\endrst Declaration void optimal_learning::GaussianProcess::SamplePointFromGP(double const *restrict point_to_sample, double *results) noexcept OL_NONNULL_POINTERS SamplePointsFromGP() \\rst Sample only function values for a list of points \\endrst Declaration int optimal_learning::GaussianProcess::SamplePointsFromGP(double const *restrict points_to_sample, const int num_sample, double *results) noexcept OL_NONNULL_POINTERS SampleGlobalOptimaFromGP() \\rst Approximate the global optima of the GP. \\endrst Declaration void optimal_learning::GaussianProcess::SampleGlobalOptimaFromGP(int const num_optima, int const inner_number, const TensorProductDomain&domain, double *points_optima) noexcept OL_NONNULL_POINTERS ComputeMeanOfPoints() \\rst Computes the mean of this GP at each of Xs (points_to_sample). .. Note:: points_to_sample should not contain duplicate points. .. Note:: comments are copied in Python: interfaces/gaussian_process_interface.py :points_to_sample_state a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) \\output :mean_of_points[num_to_sample]: mean of GP, one per GP dimension \\endrst \\rst Calculates the mean (from the GPP) of a set of points: mus = Ks^T * K^-1 * y See Rasmussen and Willians page 19 alg 2.1 \\endrst Declaration void optimal_learning::GaussianProcess::ComputeMeanOfPoints(const StateType&points_to_sample_state, double *restrict mean_of_points) const noexcept OL_NONNULL_POINTERS ComputeMeanOfAdditionalPoints() \\rst :discrete_pts[dim][num_pts] the set of points to approximate the KG factor :num_pts: number of points in discrete_pts \\output :mean_of_points[num_pts]: mean of GP, one per GP dimension \\endrst \\rst Calculates the mean (from the GPP) of a set of points: mus = Ks^T * K^-1 * y See Rasmussen and Willians page 19 alg 2.1 \\endrst Declaration void optimal_learning::GaussianProcess::ComputeMeanOfAdditionalPoints(double const *discrete_pts, int num_pts, int const *gradients_discrete_pts, int num_gradients_discrete_pts, double *restrict mean_of_points) const noexcept ComputeGradMeanOfPoints() \\rst Computes the gradient of the mean of this GP at each of Xs (points_to_sample) wrt Xs. .. Note:: points_to_sample should not contain duplicate points. Note that grad_mu is nominally sized: grad_mu[dim][num_to_sample][num_to_sample]. However, for 0 <= i,j < num_to_sample, i != j, grad_mu[d][i][j] = 0. (See references or implementation for further details.) Thus, grad_mu is stored in a reduced form which only tracks the nonzero entries. .. Note:: comments are copied in Python: interfaces/gaussian_process_interface.py :points_to_sample_state a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) \\output :grad_mu[dim][state.num_derivatives]: gradient of the mean of the GP. grad_mu[d][i] is actually the gradient of \\mu_i with respect to x_{d,i}, the d-th dimension of the i-th entry of points_to_sample. \\endrst \\rst Gradient of the mean of a GP. Note that the output storage skips known zeros (see declaration docs for details). See Scott Clark's PhD thesis for more spelled out mathematical details, but this is a reasonably straightforward differentiation of: mus = Ks^T * K^-1 * y wrt Xs (so only Ks contributes derivative terms) \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradMeanOfPoints(const StateType&points_to_sample_state, double *restrict grad_mu) const noexcept OL_NONNULL_POINTERS ComputeGradMeanOfAdditionalPoints() Declaration void optimal_learning::GaussianProcess::ComputeGradMeanOfAdditionalPoints(double const *discrete_pts, int num_pts, int const *gradients_discrete_pts, int num_gradients_discrete_pts, double *restrict grad_mu) const noexcept ComputeVarianceOfPoints() \\rst Computes the variance (matrix) of this GP at each point of Xs (points_to_sample). The variance matrix is symmetric (in fact, SPD) and is stored in the LOWER TRIANGLE. .. Note:: points_to_sample should not contain duplicate points. .. Note:: comments are copied in Python: interfaces/gaussian_process_interface.py :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :var_star[num_to_sample][num_to_sample]: variance of GP evaluated at points_to_sample, LOWER TRIANGLE \\endrst \\rst Mathematically, we are computing Vars (Var_star), the GP variance. Vars is defined at the top of this file (Equation 3) and in Rasmussen & Williams, Equation 2.19: | L * L^T = K | V = L^-1 * Ks | Vars = Kss - (V^T * V) This quantity is: Kss: the covariance between test points based on the prior distribution minus V^T * V: the information observations give us about the objective function Notice that Vars is clearly symmetric. Kss is SPD. And V^T * V = (V^T * V)^T is symmetric (and is in fact SPD). V^T * V = Ks^T * K^-1 * K_s is SPD because: X^T * A * X is SPD when A is SPD AND X has full rank (X need not be square) Ks has full rank as long as K & Kss are SPD; K^-1 is SPD because K is SPD. It turns out that Vars is SPD. In Equation 1 (Rasmussen & Williams 2.18), it is clear that the combined covariance matrix is SPD (as long as no duplicate points and the covariance function is valid). A matrix of the form:: [ A B ] [ B^T C ] is SPD if and only if A is SPD AND (C - B^T * A^-1 * B) is SPD. Here, A = K, B = Ks, C = Kss. This (aka Schur Complement) can be shown readily:: [ A B ] = [ I 0 ] * [ A 0 ] * [ I A^-1 * B ] [ B^T C ] [ (A^-1 * B)^T I ] * [ 0 (C - B^T * A^-1 * B)] [ 0 I ] This factorization is valid because A is SPD (and thus invertible). Then by the X^T * A * X rule for SPD-ness, we know the block-diagonal matrix in the center is SPD. Hence the SPD-ness of V^T * V follows readily. For more information, see: http://en.wikipedia.org/wiki/Schur_complement [num_to_sample * num_gradients_to_sample] [num_to_sample*(the number of gradients in the bracket below)] \\endrst Declaration void optimal_learning::GaussianProcess::ComputeVarianceOfPoints(StateType *points_to_sample_state, int const *restrict gradients_to_sample_part2, int num_gradients_to_sample_part2, double *restrict var_star) const noexcept ComputeCovarianceOfPoints() \\rst Computes the covariance (matrix) of this GP at each point of Xs (points_to_sample) and each point of discrete points. .. Note:: points_to_sample should not contain duplicate points. .. Note:: comments are copied in Python: interfaces/gaussian_process_interface.py :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :discrete_pts[dim][num_pts]: the set of points to approximate the KG factor :num_pts: number of points in discrete_pts \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :var_star[num_to_sample][num_pts]: covariance of GP evaluated at points_to_sample and discrete_pts \\endrst \\rst Mathematically, we are computing Covars (Covar_star), the GP covariance. Vars is defined at the top of this file (Equation 3) and in Rasmussen & Williams, Equation 2.19: | L * L^T = K | V = L^-1 * Ks | W = L^-1 * Kt | Vars = Kst - (V^T * W) This quantity is: Kst: the covariance between two sets of test points based on the prior distribution minus V^T * W: the information observations give us about the objective function For more information, see: http://en.wikipedia.org/wiki/Schur_complement :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :discrete_pts[dim][num_pts]: the set of points to approximate the KG factor :num_pts: number of points in discrete_pts \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :var_star[num_to_sample][num_pts]: covariance of GP evaluated at points_to_sample and discrete_pts \\endrst Declaration void optimal_learning::GaussianProcess::ComputeCovarianceOfPoints(StateType *points_to_sample_state, double const *restrict discrete_pts, int num_pts, int const *restrict gradients_discrete_pts, int num_gradients_discrete_pts, bool precomputed, double const *ktd, double *restrict var_star) const noexcept ComputeTrain() \\rst Computes the covariance (matrix) of this GP at each point of Xs (points_to_sample) and each point of discrete points. .. Note:: points_to_sample should not contain duplicate points. .. Note:: comments are copied in Python: interfaces/gaussian_process_interface.py :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :discrete_pts[dim][num_pts]: the set of points to approximate the KG factor :num_pts: number of points in discrete_pts \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :var_star[num_to_sample][num_pts]: covariance of GP evaluated at points_to_sample and discrete_pts \\endrst \\rst Mathematically, we are computing Covars (Covar_star), the GP covariance. Vars is defined at the top of this file (Equation 3) and in Rasmussen & Williams, Equation 2.19: | L * L^T = K | V = L^-1 * Ks | W = L^-1 * Kt | Vars = Kst - (V^T * W) This quantity is: Kst: the covariance between two sets of test points based on the prior distribution minus V^T * W: the information observations give us about the objective function For more information, see: http://en.wikipedia.org/wiki/Schur_complement :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :discrete_pts[dim][num_pts]: the set of points to approximate the KG factor :num_pts: number of points in discrete_pts \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :var_star[num_to_sample][num_pts]: covariance of GP evaluated at points_to_sample and discrete_pts \\endrst Declaration void optimal_learning::GaussianProcess::ComputeTrain(double const *restrict discrete_pts, int num_pts, int const *restrict gradients_discrete_pts, int num_gradients_discrete_pts, double *restrict var_star) const noexcept OL_NONNULL_POINTERS ComputeGradVarianceOfPoints() \\rst Similar to ComputeGradCholeskyVarianceOfPoints() except this does not include the gradient terms from the cholesky factorization. Description will not be duplicated here. \\endrst \\rst This is just a thin wrapper that calls ComputeGradVarianceOfPointsPerPoint() in a loop num_derivatives times. See ComputeGradVarianceOfPointsPerPoint()'s function comments and implementation for more mathematical details on the derivation, algorithm, optimizations, etc. \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradVarianceOfPoints(StateType *points_to_sample_state, double *restrict grad_var) const noexcept OL_NONNULL_POINTERS ComputeGradCovarianceOfPoints() \\rst :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :discrete_pts[dim][num_pts]: the set of points to approximate the KG factor :num_pts: number of points in discrete_pts \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :grad_var[dim][num_to_sample][num_pts][state->num_derivatives]: gradient of the variance of the GP. grad_var[d][i][j][k] is actually the gradients of var_{i,j} with respect to x_{d,k}, the d-th dimension of the k-th entry of points_to_sample \\endrst \\rst This is just a thin wrapper that calls ComputeGradCovarianceOfPointsPerPoint() in a loop num_derivatives times. See ComputeGradVarianceOfPointsPerPoint()'s function comments and implementation for more mathematical details on the derivation, algorithm, optimizations, etc. \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradCovarianceOfPoints(StateType *points_to_sample_state, double const *restrict discrete_pts, int num_pts, int const *restrict gradients_discrete_pts, int num_gradients_discrete_pts, bool precomputed, double const *ktd, double *restrict grad_var) const noexcept ComputeGradCholeskyVarianceOfPoints() \\rst Computes the gradient of the cholesky factorization of the variance of this GP with respect to points_to_sample. This function accounts for the effect on the gradient resulting from cholesky-factoring the variance matrix. See Smith 1995 for algorithm details. points_to_sample is not allowed to contain duplicate points. Violating this results in a singular variance matrix. Note that grad_chol is nominally sized: grad_chol[dim][num_to_sample][num_to_sample][num_to_sample]. Let this be indexed grad_chol[d][i][j][k], which is read the derivative of var[i][j] with respect to x_{d,k} (x = points_to_sample) .. Note:: comments are copied in Python: interfaces/gaussian_process_interface.py :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :chol_var[num_to_sample][num_to_sample]: the variance (matrix) of this GP at each point of Xs (points_to_sample) e.g., from the cholesky factorization of ComputeVarianceOfPoints \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :grad_chol[dim][num_to_sample][num_to_sample][state->num_derivatives]: gradient of the cholesky-factored variance of the GP. grad_chol[d][i][j][k] is actually the gradients of var_{i,j} with respect to x_{d,k}, the d-th dimension of the k-th entry of points_to_sample store in UPPER triangle \\endrst \\rst This is just a thin wrapper that calls ComputeGradCholeskyVarianceOfPointsPerPoint() in a loop num_derivatives times. See ComputeGradCholeskyVarianceOfPointsPerPoint()'s function comments and implementation for more mathematical details on the algorithm. \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradCholeskyVarianceOfPoints(StateType *points_to_sample_state, double const *restrict chol_var, double *restrict grad_chol) const noexcept OL_NONNULL_POINTERS ComputeGradInverseCholeskyVarianceOfPoints() \\rst Computes the gradient of the invers of the cholesky factorization of the variance of this GP with respect to points_to_sample. Note that grad_chol is nominally sized: grad_chol[dim][num_to_sample][num_to_sample][num_to_sample]. Let this be indexed grad_chol[d][i][j][k], which is read the derivative of var[i][j] with respect to x_{d,k} (x = points_to_sample) .. Note:: comments are copied in Python: interfaces/gaussian_process_interface.py :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :chol_var[num_to_sample][num_to_sample]: the variance (matrix) of this GP at each point of Xs (points_to_sample) e.g., from the cholesky factorization of ComputeVarianceOfPoints \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :grad_var[dim][num_to_sample][num_pts + num_to_sample][state->num_derivatives]: gradient of the invers of the cholesky-factored variance of the GP. grad_chol[d][i][j][k] is actually the gradients of var_{i,j} with respect to x_{d,k}, the d-th dimension of the k-th entry of points_to_sample \\endrst \\rst Compute the derivatives of the inverse of the cholesky factor wrt to the points to sample. \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradInverseCholeskyVarianceOfPoints(StateType *points_to_sample_state, double const *restrict chol_var, double const *restrict var, double const *restrict cov, double const *restrict discrete_pts, int num_pts, bool precomputed, double const *ktd, double *restrict grad_chol) const noexcept ComputeGradInverseCholeskyCovarianceOfPoints() \\rst Computes the gradient of the invers of the cholesky factorization of the variance of this GP with respect to points_to_sample. Note that grad_chol is nominally sized: grad_chol[dim][num_to_sample][num_to_sample][num_to_sample]. Let this be indexed grad_chol[d][i][j][k], which is read the derivative of var[i][j] with respect to x_{d,k} (x = points_to_sample) .. Note:: comments are copied in Python: interfaces/gaussian_process_interface.py :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :chol_var[num_to_sample][num_to_sample]: the variance (matrix) of this GP at each point of Xs (points_to_sample) e.g., from the cholesky factorization of ComputeVarianceOfPoints \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :grad_var[dim][num_to_sample][num_pts][state->num_derivatives]: gradient of the invers of the cholesky-factored variance of the GP. grad_chol[d][i][j][k] is actually the gradients of var_{i,j} with respect to x_{d,k}, the d-th dimension of the k-th entry of points_to_sample \\endrst \\rst Compute the derivatives of the inverse of the cholesky factor wrt to the points to sample. \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradInverseCholeskyCovarianceOfPoints(StateType *points_to_sample_state, double const *restrict chol_var, double const *restrict grad_chol, double const *restrict chol_inv_times_cov, double const *restrict discrete_pts, int num_pts, bool precomputed, double const *ktd, double *restrict grad_inverse_chol) const noexcept SetExplicitSeed() \\rst Seed the random number generator with the specified seed. See gpp_random, struct NormalRNG for details. :seed new seed to set \\endrst Declaration void optimal_learning::GaussianProcess::SetExplicitSeed(EngineType::result_type seed) noexcept SetRandomizedSeed() \\rst Seed the random number generator using a combination of the specified seed, current time, and potentially other factors. See gpp_random, struct NormalRNG for details. :seed base value for new seed \\endrst Declaration void optimal_learning::GaussianProcess::SetRandomizedSeed(EngineType::result_type seed) noexcept ResetToMostRecentSeed() \\rst Seeds the generator with its last used seed value. Useful for testinge.g., can conduct multiple runs with the same initial conditions \\endrst Declaration void optimal_learning::GaussianProcess::ResetToMostRecentSeed() noexcept Clone() \\rst Clones \"this\" GaussianProcess. Pointer to a constructed object that is a copy of \"this\" \\endrst Declaration GaussianProcess * optimal_learning::GaussianProcess::Clone() const OL_WARN_UNUSED_RESULT OL_DISALLOW_DEFAULT_AND_ASSIGN() Declaration optimal_learning::GaussianProcess::OL_DISALLOW_DEFAULT_AND_ASSIGN(GaussianProcess) BuildCovarianceMatrixWithNoiseVariance() Declaration void optimal_learning::GaussianProcess::BuildCovarianceMatrixWithNoiseVariance() noexcept BuildMixCovarianceMatrix() \\rst :cov_matrix[num_sampled][num_to_sample]: computed \"mix\" covariance matrix \\endrst Declaration void optimal_learning::GaussianProcess::BuildMixCovarianceMatrix(double const *restrict points_to_sample, int num_to_sample, int const *restrict derivatives_to_sample, int num_derivatives_to_sample, double *restrict cov_mat) const noexcept ComputeGradVarianceOfPointsPerPoint() \\rst Similar to ComputeGradCholeskyVarianceOfPointsPerPoint() except this does not include the gradient terms from the cholesky factorization. Description will not be duplicated here. \\endrst \\rst CORE IDEA** Similar to ComputeGradCholeskyVarianceOfPoints() below, except this function does not account for the cholesky decomposition. That is, it produces derivatives wrt Xs_{d,p} (points_to_sample) of: Vars = Kss - (V^T * V) = Kss - Ks^T * K^-1 * Ks (see ComputeVarianceOfPoints) .. NOTE:: normally Xs_p would be the p-th point of Xs (all dimensions); here Xs_{d,p} more explicitly refers to the d-th spatial dimension of the p-th point. This function only returns the derivative wrt a single choice of p, as specified by diff_index. Expanded index notation: Vars_{i,j} = Kss_{i,j} - Ks^T_{i,l} * K^-1_{l,k} * Ks_{k,j} Recall Ks_{k,i} = cov(X_k, Xs_i) = cov(Xs_i, X_k) where Xs is points_to_sample and X is points_sampled. (Note this is not equivalent to saying Ks = Ks^T, although this would be true if |Xs| == |X|.) As a result of this symmetry, \\pderiv{Ks_{k,i}}{Xs_{d,i}} = \\pderiv{Ks_{i,k}}{Xs_{d,i}} (that's d(cov(Xs_i, X_k))/d(Xs_i)) We are being more strict with index labels than is standard to clearly specify tensor dimensions. To be clear: i,j range over num_to_sample l,k are the only non-free indices; they range over num_sampled d,p describe the SPECIFIC point being differentiated against in Xs (points_to_sample): d over dimension, p* over num_to_sample NOTE: p is fixed! Unlike all other indices, p refers to a SPECIFIC point in the range [0, ..., num_to_sample-1]. Thus, \\pderiv{Ks_{k,i}}{Xs_{d,i}} is a 3-tensor (A_{d,k,i}) (repeated i is not summation since they denote components of a derivative) while \\pderiv{Ks_{i,l}}{Xs_{d,p}} is a 2-tensor (A_{d,l}) b/c only \\pderiv{Ks_{i=p,l}}{Xs_{d,p}} is nonzero, and {d,l} are the only remaining free indices. Then differentiating against Xs_{d,p} (recall that this is a specific point b/c p is fixed): | \\pderiv{Vars_{i,j}}{Xs_{d,p}} = \\pderiv{K_ss{i,j}}{Xs_{d,p}} - | (\\pderiv{Ks_{i,l}}{Xs_{d,p}} * K^-1_{l,k} * Ks_{k,j} + K_s{i,l} * K^-1_{l,k} * \\pderiv{Ks_{k,j}}{Xs_{d,p}}) Many of these terms are analytically known to be 0: \\pderiv{Ks_{i,l}}{Xs_{d,p}} = 0 when p != i (see NOTE above). A similar statement holds for the other gradient term. Observe that the second term in the parens, Ks_{i,l} * K^-1_{l,k} * \\pderiv{Ks_{k,j}}{Xs_{d,p}}, can be reordered to \"look\" like the first term. We use three symmetries: K^-1{l,k} = K^-1{k,l}, Ks_{i,l} = Ks_{l,i}, and \\pderiv{Ks_{k,j}}{Xs_{d,p}} = \\pderiv{Ks_{j,k}}{Xs_{d,p}} Then we can write: K_s{i,l} * K^-1_{l,k} * \\pderiv{Ks_{k,j}}{Xs_{d,p}} = \\pderiv{Ks_{j,k}}{Xs_{d,p}} * K^-1_{k,l} * K_s{l,i} Now left and right terms have the same index ordering (i,j match; k,l are not free and thus immaterial) The final result, accounting for analytic zeros is given here for convenience:: DVars_{d,i,j} \\equiv \\pderiv{Vars_{i,j}}{Xs_{d,p}} =`` { \\pderiv{K_ss{i,j}}{Xs_{d,p}} - 2\\pderiv{Ks_{i,l}}{Xs_{d,p}} * K^-1_{l,k} * Ks_{k,j} : WHEN p == i == j { \\pderiv{K_ss{i,j}}{Xs_{d,p}} - \\pderiv{Ks_{i,l}}{Xs_{d,p}} * K^-1_{l,k} * Ks_{k,j} : WHEN p == i != j { \\pderiv{K_ss{i,j}}{Xs_{d,p}} - \\pderiv{Ks_{j,k}}{Xs_{d,p}} * K^-1_{k,l} * Ks_{l,i} : WHEN p == j != i { 0 : otherwise The first item has a factor of 2 b/c it gets a contribution from both parts of the sum since p == i and p == j. The ordering DVars_{d,i,j} is significant: this is the ordering (d changes the fastest) in storage. OPTIMIZATIONS** Implementing this formula naively results in a large amount of redundant computation, so we now describe the optimizations present in our implementation. The first thing to notice is that the result, \\pderiv{Vars_{i,j}}{Xs_{d,p}}, has a lot of 0s. In particular, only the p-th block row and p-th block column have nonzero entries (blocks are size dim, indexed d). Currently, we will not be taking advantage of this sparsity because the consumer of DVars, ComputeGradCholeskyVarianceOfPoints(), is not implemented with sparsity in mind. Similarly, the next thing to notice is that if we ignore the case p == i == j, then we see that the expressions for p == i and p == j are actually identical (e.g., take the p == j case and exchange j = i and k = l). So think of DVars as a block matrix; each block has dimension entries, and the blocks are indexed over i (rows), j (cols). Then we see that the code is block-symmetric: DVars_{d,i,j} = Dvars_{d,j,i}. So we can compute it by filling in the p-th block column and then copy that data into the p-th block row. Additionally, the derivative terms represent matrix-matrix products: C_{l,j} = K^-1_{l,k} * Ks_{k,j} (and K^-1_{k,l} * Ks_{l,i}, which is just a change of index labels) is a matrix product. We compute this using back-substitutions to avoid explicitly forming K^-1. C_{l,j} is num_sampled X num_to_sample. Then D_{d,i=p,j} = \\pderiv{Ks_{i=p,l}}{Xs_{d,p}} * C_{l,j} is another matrix product (result size dim * num_to_sample) (i = p indicates that index i collapses out since this deriv term is zero if p != i). Note that we store \\pderiv{Ks_{i=p,l}}{Xs_{d,p}} = \\pderiv{Ks_{l,i=p}}{Xs_{d,p}} as A_{d,l,i} and grab the i = p-th block. Again, only the p-th point of points_to_sample is differentiated against; p specfied in diff_index. \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradVarianceOfPointsPerPoint(StateType *points_to_sample_state, int diff_index, double *restrict grad_var) const noexcept OL_NONNULL_POINTERS ComputeGradCovarianceOfPointsPerPoint() \\rst :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :discrete_pts[dim][num_pts]: the set of points to approximate the KG factor :num_pts: number of points in discrete_pts :diff_index: index of points_to_sample in {0, .. num_to_sample-1} to be differentiated against \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :grad_chol[dim][num_to_sample][num_pts]: gradient of the cholesky-factored variance of the GP. grad_chol[d][i][j] is actually the gradients of var_{i,j} with respect to x_{d,k}, the d-th dimension of the k-th entry of points_to_sample, where k = diff_index \\endrst \\rst CORE IDEA** Similar to ComputeGradCholeskyVarianceOfPoints() below, except this function does not account for the cholesky decomposition. That is, it produces derivatives wrt Xs_{d,p} (points_to_sample) of: Vars = Kss - (V^T * V) = Kss - Ks^T * K^-1 * Ks (see ComputeVarianceOfPoints) .. NOTE:: normally Xs_p would be the p-th point of Xs (all dimensions); here Xs_{d,p} more explicitly refers to the d-th spatial dimension of the p-th point. This function only returns the derivative wrt a single choice of p, as specified by diff_index. Expanded index notation: Vars_{i,j} = Kss_{i,j} - Ks^T_{i,l} * K^-1_{l,k} * Ks_{k,j} Recall Ks_{k,i} = cov(X_k, Xs_i) = cov(Xs_i, Xs_k) where Xs is points_to_sample and X is points_sampled. (Note this is not equivalent to saying Ks = Ks^T, although this would be true if |Xs| == |X|.) As a result of this symmetry, \\pderiv{Ks_{k,i}}{Xs_{d,i}} = \\pderiv{Ks_{i,k}}{Xs_{d,i}} (that's d(cov(Xs_i, X_k))/d(Xs_i)) We are being more strict with index labels than is standard to clearly specify tensor dimensions. To be clear: i,j range over num_to_sample l,k are the only non-free indices; they range over num_sampled d,p describe the SPECIFIC point being differentiated against in Xs (points_to_sample): d over dimension, p* over num_to_sample NOTE: p is fixed! Unlike all other indices, p refers to a SPECIFIC point in the range [0, ..., num_to_sample-1]. Thus, \\pderiv{Ks_{k,i}}{Xs_{d,i}} is a 3-tensor (A_{d,k,i}) (repeated i is not summation since they denote components of a derivative) while \\pderiv{Ks_{i,l}}{Xs_{d,p}} is a 2-tensor (A_{d,l}) b/c only \\pderiv{Ks_{i=p,l}}{Xs_{d,p}} is nonzero, and {d,l} are the only remaining free indices. Then differentiating against Xs_{d,p} (recall that this is a specific point b/c p is fixed): | \\pderiv{Vars_{i,j}}{Xs_{d,p}} = \\pderiv{K_ss{i,j}}{Xs_{d,p}} - | (\\pderiv{Ks_{i,l}}{Xs_{d,p}} * K^-1_{l,k} * Ks_{k,j} + K_s{i,l} * K^-1_{l,k} * \\pderiv{Ks_{k,j}}{Xs_{d,p}}) Many of these terms are analytically known to be 0: \\pderiv{Ks_{i,l}}{Xs_{d,p}} = 0 when p != i (see NOTE above). A similar statement holds for the other gradient term. Observe that the second term in the parens, Ks_{i,l} * K^-1_{l,k} * \\pderiv{Ks_{k,j}}{Xs_{d,p}}, can be reordered to \"look\" like the first term. We use three symmetries: K^-1{l,k} = K^-1{k,l}, Ks_{i,l} = Ks_{l,i}, and \\pderiv{Ks_{k,j}}{Xs_{d,p}} = \\pderiv{Ks_{j,k}}{Xs_{d,p}} Then we can write: K_s{i,l} * K^-1_{l,k} * \\pderiv{Ks_{k,j}}{Xs_{d,p}} = \\pderiv{Ks_{j,k}}{Xs_{d,p}} * K^-1_{k,l} * K_s{l,i} Now left and right terms have the same index ordering (i,j match; k,l are not free and thus immaterial) The final result, accounting for analytic zeros is given here for convenience:: DVars_{d,i,j} \\equiv \\pderiv{Vars_{i,j}}{Xs_{d,p}} =`` { \\pderiv{K_ss{i,j}}{Xs_{d,p}} - 2\\pderiv{Ks_{i,l}}{Xs_{d,p}} * K^-1_{l,k} * Ks_{k,j} : WHEN p == i == j { \\pderiv{K_ss{i,j}}{Xs_{d,p}} - \\pderiv{Ks_{i,l}}{Xs_{d,p}} * K^-1_{l,k} * Ks_{k,j} : WHEN p == i != j { \\pderiv{K_ss{i,j}}{Xs_{d,p}} - \\pderiv{Ks_{j,k}}{Xs_{d,p}} * K^-1_{k,l} * K_s{l,i} : WHEN p == j != i { 0 : otherwise The first item has a factor of 2 b/c it gets a contribution from both parts of the sum since p == i and p == j. The ordering DVars_{d,i,j} is significant: this is the ordering (d changes the fastest) in storage. OPTIMIZATIONS** Implementing this formula naively results in a large amount of redundant computation, so we now describe the optimizations present in our implementation. The first thing to notice is that the result, \\pderiv{Vars_{i,j}}{Xs_{d,p}}, has a lot of 0s. In particular, only the p-th block row and p-th block column have nonzero entries (blocks are size dim, indexed d). Currently, we will not be taking advantage of this sparsity because the consumer of DVars, ComputeGradCholeskyVarianceOfPoints(), is not implemented with sparsity in mind. Similarly, the next thing to notice is that if we ignore the case p == i == j, then we see that the expressions for p == i and p == j are actually identical (e.g., take the p == j case and exchange j = i and k = l). So think of DVars as a block matrix; each block has dimension entries, and the blocks are indexed over i (rows), j (cols). Then we see that the code is block-symmetric: DVars_{d,i,j} = Dvars_{d,j,i}. So we can compute it by filling in the p-th block column and then copy that data into the p-th block row. Additionally, the derivative terms represent matrix-matrix products: C_{l,j} = K^-1_{l,k} * Ks_{k,j} (and K^-1_{k,l} * Ks_{l,i}, which is just a change of index labels) is a matrix product. We compute this using back-substitutions to avoid explicitly forming K^-1. C_{l,j} is num_sampled X num_to_sample. Then D_{d,i=p,j} = \\pderiv{Ks_{i=p,l}}{Xs_{d,p}} * C_{l,j} is another matrix product (result size dim * num_to_sample) (i = p indicates that index i collapses out since this deriv term is zero if p != i). Note that we store \\pderiv{Ks_{i=p,l}}{Xs_{d,p}} = \\pderiv{Ks_{l,i=p}}{Xs_{d,p}} as A_{d,l,i} and grab the i = p-th block. Again, only the p-th point of points_to_sample is differentiated against; p specfied in diff_index. \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradCovarianceOfPointsPerPoint(StateType *points_to_sample_state, int diff_index, double const *restrict discrete_pts, int num_pts, int const *restrict gradients_discrete_pts, int num_gradients_discrete_pts, bool precomputed, double const *kt, double *restrict grad_var) const noexcept ComputeGradCholeskyVarianceOfPointsPerPoint() \\rst Computes the gradient of the cholesky factorization of the variance of this GP with respect to the diff_index-th point in points_to_sample. This internal method is meant to be used by ComputeGradCholeskyVarianceOfPoints() to construct the gradient wrt all points of points_to_sample. See that function for more details. :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :diff_index: index of points_to_sample in {0, .. num_to_sample-1} to be differentiated against :chol_var[num_to_sample][num_to_sample]: the variance (matrix) of this GP at each point of Xs (points_to_sample) e.g., from the cholesky factorization of ComputeVarianceOfPoints \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :grad_chol[dim][num_to_sample][num_to_sample]: gradient of the inverse of the cholesky-factored variance of the GP. grad_chol[d][i][j] is actually the gradients of var_{i,j} with respect to x_{d,k}, the d-th dimension of the k-th entry of points_to_sample, where k = diff_index \\endrst \\rst Differentiates the cholesky factorization of the GP variance. | Vars = Kss - (V^T * V) (see ComputeVarianceOfPoints) | C * C^T = Vars This function differentiates C wrt the p-th point of points_to_sample; p specfied in diff_index Just as users of a lower triangular matrix L[i][j] should not access the upper triangle (j > i), users of the result of this function, grad_chol[d][i][j], should not access the upper block triangle with j > i. See Smith 1995 for full details of computing gradients of the cholesky factorization store in the UPPER triangle. \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradCholeskyVarianceOfPointsPerPoint(StateType *points_to_sample_state, int diff_index, double const *restrict chol_var, double *restrict grad_chol) const noexcept OL_NONNULL_POINTERS ComputeGradInverseCholeskyVarianceOfPointsPerPoint() \\rst Computes the gradient of the invers of the cholesky factorization of the variance of this GP with respect to the diff_index-th point in points_to_sample. This internal method is meant to be used by ComputeGradInverseCholeskyVarianceOfPoints() to construct the gradient wrt all points of points_to_sample. See that function for more details. :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :diff_index: index of points_to_sample in {0, .. num_to_sample-1} to be differentiated against :chol_var[num_to_sample][num_to_sample]: the variance (matrix) of this GP at each point of Xs (points_to_sample) e.g., from the cholesky factorization of ComputeVarianceOfPoints \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :grad_chol[dim][num_to_sample][num_to_sample]: gradient of the cholesky-factored variance of the GP. grad_chol[d][i][j] is actually the gradients of var_{i,j} with respect to x_{d,k}, the d-th dimension of the k-th entry of points_to_sample, where k = diff_index \\endrst \\rst Compute the derivatives of the inverse of the cholesky factor wrt to the points to sample. \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradInverseCholeskyVarianceOfPointsPerPoint(StateType *points_to_sample_state, int diff_index, double const *restrict chol_var, double const *restrict var, double const *restrict cov, double const *restrict discrete_pts, int num_pts, bool precomputed, double const *kt, double *restrict grad_chol) const noexcept OL_NONNULL_POINTERS ComputeGradInverseCholeskyCovarianceOfPointsPerPoint() \\rst Computes the gradient of the invers of the cholesky factorization of the variance of this GP with respect to the diff_index-th point in points_to_sample. This internal method is meant to be used by ComputeGradInverseCholeskyVarianceOfPoints() to construct the gradient wrt all points of points_to_sample. See that function for more details. :points_to_sample_state[1] ptr to a FULLY CONFIGURED PointsToSampleState (configure via PointsToSampleState::SetupState) :diff_index: index of points_to_sample in {0, .. num_to_sample-1} to be differentiated against :chol_var[num_to_sample][num_to_sample]: the variance (matrix) of this GP at each point of Xs (points_to_sample) e.g., from the cholesky factorization of ComputeVarianceOfPoints \\output :points_to_sample_state[1]: ptr to a FULLY CONFIGURED PointsToSampleState; only temporary state may be mutated :grad_chol[dim][num_to_sample][num_to_sample]: gradient of the cholesky-factored variance of the GP. grad_chol[d][i][j] is actually the gradients of var_{i,j} with respect to x_{d,k}, the d-th dimension of the k-th entry of points_to_sample, where k = diff_index \\endrst \\rst Compute the derivatives of the inverse of the cholesky factor wrt to the points to sample. \\endrst Declaration void optimal_learning::GaussianProcess::ComputeGradInverseCholeskyCovarianceOfPointsPerPoint(StateType *points_to_sample_state, int diff_index, double const *restrict chol_var, double const *restrict grad_chol_pt, double const *restrict chol_inv_times_cov, double const *restrict discrete_pts, int num_pts, bool precomputed, double const *kt, double *restrict grad_inverse_chol) const noexcept OL_NONNULL_POINTERS RecomputeDerivedVariables() \\rst Recomputes (including resizing as needed) the derived quantities in this class. This function should be called any time state variables are changed. \\endrst Declaration void optimal_learning::GaussianProcess::RecomputeDerivedVariables(bool mean_change=true) RecomputeCholeskyVariables() Declaration void optimal_learning::GaussianProcess::RecomputeCholeskyVariables() RecomputeMeanVariables() Declaration void optimal_learning::GaussianProcess::RecomputeMeanVariables(bool mean_change=true)"
  },
  "api/optimal/learning/gradient-descent-optimizer-line-search.html": {
    "href": "api/optimal/learning/gradient-descent-optimizer-line-search.html",
    "title": "Class optimal_learning::GradientDescentOptimizerLineSearch | qiotoolkit",
    "keywords": "Class optimal_learning::GradientDescentOptimizerLineSearch \\rst Gradient descent (GD) optimization. This class optimizes using restarted GD (see comments on the Optimize()) function. \\endrst Inheritance optimal_learning::GradientDescentOptimizerLineSearch Constructors GradientDescentOptimizerLineSearch() Declaration optimal_learning::GradientDescentOptimizerLineSearch<ObjectiveFunctionEvaluator_, DomainType_>::GradientDescentOptimizerLineSearch()=default Methods Optimize() \\rst Optimize a given objective function (represented by ObjectiveFunctionEvaluator; see file comments for what this must provide) using restarted gradient descent (GD). See section 2a) and 3b, i) in the header docs and the docs for GradientDescentOptimization() for more details. Guaranteed to call GradientDescentOptimization() AT MOST max_num_restarts times. GradientDescentOptimization() implements gradient descent; see function comments above for details. This method calls gradient descent, then restarts (by calling GD again) from the GD's result point. This is done until max_num_restarts is reached or the result point stops changing (compared to tolerance). Note that we are using an absolute tolerance, based on the size of the most recent step*. Here, 'step' is the distance covered by the last restart, not the last GD iteration (as in GradientDescentOptimization()). The suggested value is 1.0e-7, although this may need to be loosened for problems with 'difficult' optima (e.g., the shape is not locally very peaked). Setting too high of a tolerance can cause wrong answerse.g., we stop at a point that is not an optima but simply an region with small gradient. Setting the tolerance too low may make convergence impossible; GD could get stuck (bouncing between the same few points) or numerical effects could make it impossible to satisfy tolerance. As opposed to say based on changes in the objective function. Solution is guaranteed to lie within the region specified by \"domain\"; note that this may not be a true optima (i.e., the gradient may be substantially nonzero). problem_size refers to objective_state->GetProblemSize(), the number of dimensions in a \"point\" aka the number of variables being optimized. (This might be the spatial dimension for EI or the number of hyperparameters for log likelihood.) :objective_evaluator reference to object that can compute the objective function and its gradient :gd_parameters: GradientDescentParameters object that describes the parameters controlling gradient descent optimization (e.g., number of iterations, tolerances, learning rate) :domain: object specifying the domain to optimize over (see gpp_domain.hpp) :objective_state[1]: a properly configured state object for the ObjectiveFunctionEvaluator template parameter objective_state.GetCurrentPoint() will be used to obtain the initial guess \\output :objective_state[1]: a state object whose temporary data members may have been modified objective_state.GetCurrentPoint() will return the point yielding the best objective function value according to gradient descent number of errors, always 0 \\endrst Declaration int optimal_learning::GradientDescentOptimizerLineSearch<ObjectiveFunctionEvaluator_, DomainType_>::Optimize(const ObjectiveFunctionEvaluator&objective_evaluator, const ParameterStruct&gd_parameters, const DomainType&domain, typename ObjectiveFunctionEvaluator::StateType *objective_state) const OL_NONNULL_POINTERS OL_DISALLOW_COPY_AND_ASSIGN() Declaration optimal_learning::GradientDescentOptimizerLineSearch<ObjectiveFunctionEvaluator_, DomainType_>::OL_DISALLOW_COPY_AND_ASSIGN(GradientDescentOptimizerLineSearch)"
  },
  "api/optimal/learning/gradient-descent-optimizer.html": {
    "href": "api/optimal/learning/gradient-descent-optimizer.html",
    "title": "Class optimal_learning::GradientDescentOptimizer | qiotoolkit",
    "keywords": "Class optimal_learning::GradientDescentOptimizer \\rst Gradient descent (GD) optimization. This class optimizes using restarted GD (see comments on the Optimize()) function. \\endrst Inheritance optimal_learning::GradientDescentOptimizer Constructors GradientDescentOptimizer() Declaration optimal_learning::GradientDescentOptimizer<ObjectiveFunctionEvaluator_, DomainType_>::GradientDescentOptimizer()=default Methods Optimize() \\rst Optimize a given objective function (represented by ObjectiveFunctionEvaluator; see file comments for what this must provide) using restarted gradient descent (GD). See section 2a) and 3b, i) in the header docs and the docs for GradientDescentOptimization() for more details. Guaranteed to call GradientDescentOptimization() AT MOST max_num_restarts times. GradientDescentOptimization() implements gradient descent; see function comments above for details. This method calls gradient descent, then restarts (by calling GD again) from the GD's result point. This is done until max_num_restarts is reached or the result point stops changing (compared to tolerance). Note that we are using an absolute tolerance, based on the size of the most recent step*. Here, 'step' is the distance covered by the last restart, not the last GD iteration (as in GradientDescentOptimization()). The suggested value is 1.0e-7, although this may need to be loosened for problems with 'difficult' optima (e.g., the shape is not locally very peaked). Setting too high of a tolerance can cause wrong answerse.g., we stop at a point that is not an optima but simply an region with small gradient. Setting the tolerance too low may make convergence impossible; GD could get stuck (bouncing between the same few points) or numerical effects could make it impossible to satisfy tolerance. As opposed to say based on changes in the objective function. Solution is guaranteed to lie within the region specified by \"domain\"; note that this may not be a true optima (i.e., the gradient may be substantially nonzero). problem_size refers to objective_state->GetProblemSize(), the number of dimensions in a \"point\" aka the number of variables being optimized. (This might be the spatial dimension for EI or the number of hyperparameters for log likelihood.) :objective_evaluator reference to object that can compute the objective function and its gradient :gd_parameters: GradientDescentParameters object that describes the parameters controlling gradient descent optimization (e.g., number of iterations, tolerances, learning rate) :domain: object specifying the domain to optimize over (see gpp_domain.hpp) :objective_state[1]: a properly configured state object for the ObjectiveFunctionEvaluator template parameter objective_state.GetCurrentPoint() will be used to obtain the initial guess \\output :objective_state[1]: a state object whose temporary data members may have been modified objective_state.GetCurrentPoint() will return the point yielding the best objective function value according to gradient descent number of errors, always 0 \\endrst Declaration int optimal_learning::GradientDescentOptimizer<ObjectiveFunctionEvaluator_, DomainType_>::Optimize(const ObjectiveFunctionEvaluator&objective_evaluator, const ParameterStruct&gd_parameters, const DomainType&domain, typename ObjectiveFunctionEvaluator::StateType *objective_state) const OL_NONNULL_POINTERS OL_DISALLOW_COPY_AND_ASSIGN() Declaration optimal_learning::GradientDescentOptimizer<ObjectiveFunctionEvaluator_, DomainType_>::OL_DISALLOW_COPY_AND_ASSIGN(GradientDescentOptimizer)"
  },
  "api/optimal/learning/gradient-descent-parameters.html": {
    "href": "api/optimal/learning/gradient-descent-parameters.html",
    "title": "Struct optimal_learning::GradientDescentParameters | qiotoolkit",
    "keywords": "Struct optimal_learning::GradientDescentParameters \\rst Container to hold parameters that specify the behavior of Gradient Descent. .. Note:: these comments are copied in build_gradient_descent_parameters() in cpp_wrappers/optimizer_parameters.py. That function wraps this struct's ctor. Iterations** The total number of gradient descent steps is at most num_multistarts * max_num_steps * max_num_restarts Generally, allowing more iterations leads to a better solution but costs more time. Averaging (TODO(GH-390): NOT IMPLEMTED YET)** When optimizing stochastic objective functions, it can often be beneficial to average some number of gradient descent steps to obtain the final result (vs just returning the last step). Polyak-Ruppert averaging: postprocessing step where we replace x_n with: \\overbar{x} = \\frac{1}{n - n_0} \\sum_{t=n_0 + 1}^n x_t n_0 = 0 averages all steps; n_0 = n - 1 is equivalent to returning x_n directly. Here, num_steps_averaged is n - n_0. num_steps_averaged < 0: averages all steps num_steps_averaged == 0: do not average num_steps_averaged > 0 and <= max_num_steps: average the specified number of steps max_steps_averaged > max_num_steps: average all steps Learning Rate** GD may be implemented using a learning rate: pre_mult * (i+1)^{-\\gamma}, where i is the current iteration Larger gamma causes the GD step size to (artificially) scale down faster. Smaller pre_mult (artificially) shrinks the GD step size. Generally, taking a very large number of small steps leads to the most robustness; but it is very slow. Tolerances** Larger relative changes are potentially less robust but lead to faster convergence. Large tolerances run faster but may lead to high errors or false convergence (e.g., if the tolerance is 1.0e-3 and the learning rate control forces steps to fall below 1.0e-3 quickly, then GD will quit \"successfully\" without genuinely converging.) \\endrst Constructors GradientDescentParameters() Declaration optimal_learning::GradientDescentParameters::GradientDescentParameters()=delete GradientDescentParameters() \\rst Construct a GradientDescentParameters object. Default, copy, and assignment constructor are disallowed. INPUTS: See member declarations below for a description of each parameter. \\endrst Declaration optimal_learning::GradientDescentParameters::GradientDescentParameters(int num_multistarts_in, int max_num_steps_in, int max_num_restarts_in, int num_steps_averaged_in, double gamma_in, double pre_mult_in, double max_relative_change_in, double tolerance_in) GradientDescentParameters() Declaration optimal_learning::GradientDescentParameters::GradientDescentParameters(GradientDescentParameters&&OL_UNUSED(other))=default"
  },
  "api/optimal/learning/identify-type.html": {
    "href": "api/optimal/learning/identify-type.html",
    "title": "Struct optimal_learning::IdentifyType | qiotoolkit",
    "keywords": "Struct optimal_learning::IdentifyType \\rst Work-around for compilers (icc <= v13.0, gcc <= v4.5, msvcc <= 2013) that cannot deal with:: struct Foo { SomeType i; }; Foo f; SomeType y = decltype(f)::i; That is, resolve the scoping operator with decltype(). Instead, do:: SomeType y = IdentifyType<decltype(f)>::type::i; This can be removed once the relevant compilers support decltype + scoping. \\endrst"
  },
  "api/optimal/learning/invalid-value-exception.html": {
    "href": "api/optimal/learning/invalid-value-exception.html",
    "title": "Class optimal_learning::InvalidValueException | qiotoolkit",
    "keywords": "Class optimal_learning::InvalidValueException \\rst Overview** Exception to capture value != truth (+/- tolerance). The tolerance parameter is optional and only usable with floating point data types. Stores value and truth (and tolerance as applicable) for debugging/logging/reacting purposes. Message Format** The what() message is formatted in the class ctor (capitals indicate variable information):: R\"%%( InvalidValueException: VALUE != TRUTH (value != truth). CUSTOM_MESSAGE FUNCTION_NAME FILE_LINE_INFO )%%\" OR :: R\"%%( InvalidValueException: VALUE != TRUTH ± TOLERANCE (value != truth ± tolerance). CUSTOM_MESSAGE FUNCTION_NAME FILE_LINE_INFO )%%\" Depending on which ctor was used. \\endrst Inheritance optimal_learning::OptimalLearningException optimal_learning::InvalidValueException Inherited Members OptimalLearningException OptimalLearningException what AppendCustomMessageAndDebugInfo OptimalLearningException Constructors InvalidValueException() \\rst Constructs a InvalidValueException object with extra fields to flesh out the what() message. :line_info[] ptr to char array containing FILE and LINE info; e.g., from OL_STRINGIFY_FILE_AND_LINE :func_info[]: optional ptr to char array from OL_CURRENT_FUNCTION_NAME or similar :custom_message[]: optional ptr to char array with any additional text/info to print/log :value: the invalid value :truth: what \"value\" is supposed to be \\endrst Declaration optimal_learning::InvalidValueException<ValueType>::InvalidValueException(char const *line_info, char const *func_info, char const *custom_message, ValueType value_in, ValueType truth_in) InvalidValueException() \\rst Constructs a InvalidValueException object with extra fields to flesh out the what() message. This ctor additionally has an input for tolerance, and is only enabled for floating point types. :line_info[] ptr to char array containing FILE and LINE info; e.g., from OL_STRINGIFY_FILE_AND_LINE :func_info[]: optional ptr to char array from OL_CURRENT_FUNCTION_NAME or similar :custom_message[]: optional ptr to char array with any additional text/info to print/log :value: the invalid value :truth: what \"value\" is supposed to be :tolerance: the maximum acceptable error in |value - truth| \\endrst Declaration optimal_learning::InvalidValueException<ValueType>::InvalidValueException(char const *line_info, char const *func_info, char const *custom_message, ValueType value_in, ValueType truth_in, ValueType tolerance_in) Methods value() Declaration ValueType optimal_learning::InvalidValueException<ValueType>::value() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT truth() Declaration ValueType optimal_learning::InvalidValueException<ValueType>::truth() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT tolerance() Declaration ValueType optimal_learning::InvalidValueException<ValueType>::tolerance() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT OL_DISALLOW_DEFAULT_AND_ASSIGN() Declaration optimal_learning::InvalidValueException<ValueType>::OL_DISALLOW_DEFAULT_AND_ASSIGN(InvalidValueException)"
  },
  "api/optimal/learning/knowledge-gradient-evaluator.html": {
    "href": "api/optimal/learning/knowledge-gradient-evaluator.html",
    "title": "Class optimal_learning::KnowledgeGradientEvaluator | qiotoolkit",
    "keywords": "Class optimal_learning::KnowledgeGradientEvaluator \\rst A class to encapsulate the computation of knowledge gradient and its spatial gradient. This class handles the general KG computation case using monte carlo integration; it can support q,p-KG optimization. It is designed to work with any GaussianProcess. Additionally, this class has no state and within the context of KG optimization, it is meant to be accessed by const reference only. The random numbers needed for KG computation will be passed as parameters instead of contained as members to make multithreading more straightforward. \\endrst Inheritance optimal_learning::KnowledgeGradientEvaluator Constructors KnowledgeGradientEvaluator() \\rst Constructs a KnowledgeGradientEvaluator object. All inputs are required; no default constructor nor copy/assignment are allowed. :gaussian_process GaussianProcess object (holds points_sampled, values, noise_variance, derived quantities) that describes the underlying GP :discrete_pts[dim][num_pts]: the set of points to approximate the KG factor :num_pts: number of points in discrete_pts :num_mc_iterations: number of monte carlo iterations :best_so_far: best (minimum) objective function value (in points_sampled_value) \\endrst Declaration optimal_learning::KnowledgeGradientEvaluator<DomainType>::KnowledgeGradientEvaluator(const GaussianProcess&gaussian_process_in, const int num_fidelity, double const *discrete_pts, int num_pts, int num_mc_iterations, const DomainType&domain, const GradientDescentParameters&optimizer_parameters, double best_so_far) KnowledgeGradientEvaluator() Declaration optimal_learning::KnowledgeGradientEvaluator<DomainType>::KnowledgeGradientEvaluator(KnowledgeGradientEvaluator&&other) Methods dim() Declaration int optimal_learning::KnowledgeGradientEvaluator<DomainType>::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_fidelity() Declaration int optimal_learning::KnowledgeGradientEvaluator<DomainType>::num_fidelity() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_mc_iterations() Declaration int optimal_learning::KnowledgeGradientEvaluator<DomainType>::num_mc_iterations() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT best_so_far() Declaration double optimal_learning::KnowledgeGradientEvaluator<DomainType>::best_so_far() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT gradient_descent_params() Declaration GradientDescentParameters optimal_learning::KnowledgeGradientEvaluator<DomainType>::gradient_descent_params() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT domain() Declaration DomainType optimal_learning::KnowledgeGradientEvaluator<DomainType>::domain() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT number_discrete_pts() Declaration int optimal_learning::KnowledgeGradientEvaluator<DomainType>::number_discrete_pts() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT discrete_pts_copy() Declaration std::vector<double>optimal_learning::KnowledgeGradientEvaluator<DomainType>::discrete_pts_copy() const noexcept OL_WARN_UNUSED_RESULT discrete_points() Declaration std::vector<double>optimal_learning::KnowledgeGradientEvaluator<DomainType>::discrete_points(double const *discrete_pts, int num_pts) const noexcept OL_WARN_UNUSED_RESULT gaussian_process() Declaration const GaussianProcess* optimal_learning::KnowledgeGradientEvaluator<DomainType>::gaussian_process() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT ComputeObjectiveFunction() \\rst Wrapper for ComputeKnowledgeGradient(); see that function for details. \\endrst Declaration double optimal_learning::KnowledgeGradientEvaluator<DomainType>::ComputeObjectiveFunction(StateType *kg_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradObjectiveFunction() \\rst Wrapper for ComputeGradKnowledgeGradient(); see that function for details. \\endrst Declaration void optimal_learning::KnowledgeGradientEvaluator<DomainType>::ComputeGradObjectiveFunction(StateType *kg_state, double *restrict grad_KG) const OL_NONNULL_POINTERS ComputeKnowledgeGradient() \\rst Computes the knowledge gradient :kg_state[1] properly configured state object \\output :kg_state[1]: state with temporary storage modified; normal_rng modified the knowledge gradient from sampling points_to_sample with points_being_sampled concurrent experiments \\endrst \\rst Compute Knowledge Gradient This version requires the discretization of A (the feasibe domain). The discretization usually is: some set + points previous sampled + points being sampled + points to sample \\endrst Declaration double optimal_learning::KnowledgeGradientEvaluator<DomainType>::ComputeKnowledgeGradient(StateType *kg_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradKnowledgeGradient() \\rst Computes the (partial) derivatives of the knowledge gradient with respect to each point of points_to_sample. As with ComputeKnowledgeGradient(), this computation accounts for the effect of points_being_sampled concurrent experiments. points_to_sample is the \"q\" and points_being_sampled is the \"p\" in q,p-KG. :kg_state[1] properly configured state object \\output :kg_state[1]: state with temporary storage modified; normal_rng modified :grad_KG[dim][num_to_sample]: gradient of KG, \\pderiv{KG(Xq \\cup Xp)}{Xq_{d,i}} where Xq is points_to_sample and Xp is points_being_sampled (grad KG from sampling points_to_sample with points_being_sampled concurrent experiments wrt each dimension of the points in points_to_sample) \\endrst \\rst Computes gradient of KG (see KnowledgeGradientEvaluator::ComputeGradKnowledgeGradient) wrt points_to_sample (stored in union_of_points[0:num_to_sample]). Mechanism is similar to the computation of KG, where points' contributions to the gradient are thrown out of their corresponding improvement <= 0.0. Thus \\nabla(\\mu) only contributes when the winner (point w/best improvement this iteration) is the current point. That is, the gradient of \\mu at x_i wrt x_j is 0 unless i == j (and only this result is stored in kg_state->grad_mu). The interaction with kg_state->grad_chol_decomp is harder to know a priori (like with grad_mu) and has a more complex structure (rank 3 tensor), so the derivative wrt x_j is computed fully, and the relevant submatrix (indexed by the current winner) is accessed each iteration. .. Note:: comments here are copied to _compute_grad_knowledge_gradient_monte_carlo() in python_version/knowledge_gradient.py \\endrst Declaration double optimal_learning::KnowledgeGradientEvaluator<DomainType>::ComputeGradKnowledgeGradient(StateType *kg_state, double *restrict grad_KG) const OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::KnowledgeGradientEvaluator<DomainType>::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(KnowledgeGradientEvaluator)"
  },
  "api/optimal/learning/knowledge-gradient-mcmcevaluator.html": {
    "href": "api/optimal/learning/knowledge-gradient-mcmcevaluator.html",
    "title": "Class optimal_learning::KnowledgeGradientMCMCEvaluator | qiotoolkit",
    "keywords": "Class optimal_learning::KnowledgeGradientMCMCEvaluator \\rst A class to encapsulate the computation of knowledge gradient and its spatial gradient. This class handles the general KG computation case using monte carlo integration; it can support q,p-KG optimization. It is designed to work with any GaussianProcess. Additionally, this class has no state and within the context of KG optimization, it is meant to be accessed by const reference only. The random numbers needed for KG computation will be passed as parameters instead of contained as members to make multithreading more straightforward. \\endrst Inheritance optimal_learning::KnowledgeGradientMCMCEvaluator Constructors KnowledgeGradientMCMCEvaluator() \\rst Constructs a KnowledgeGradientEvaluator object. All inputs are required; no default constructor nor copy/assignment are allowed. :gaussian_process GaussianProcess object (holds points_sampled, values, noise_variance, derived quantities) that describes the underlying GP :discrete_pts[dim][num_pts]: the set of points to approximate the KG factor :num_pts: number of points in discrete_pts :num_mc_iterations: number of monte carlo iterations :best_so_far: best (minimum) objective function value (in points_sampled_value) \\endrst Declaration optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::KnowledgeGradientMCMCEvaluator(const GaussianProcessMCMC&gaussian_process_mcmc, const int num_fidelity, double const *discrete_pts_lst, int num_pts, int num_mc_iterations, const DomainType&domain, const GradientDescentParameters&optimizer_parameters, double const *best_so_far, std::vector<typename KnowledgeGradientState<DomainType>::EvaluatorType>*evaluator_vector) Methods dim() Declaration int optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_fidelity() Declaration int optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::num_fidelity() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT number_discrete_pts() Declaration int optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::number_discrete_pts() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_mcmc() Declaration int optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::num_mcmc() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT knowledge_gradient_evaluator_list() Declaration std::vector<KnowledgeGradientEvaluator<DomainType>>* optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::knowledge_gradient_evaluator_list() const noexcept OL_WARN_UNUSED_RESULT discrete_points_list() Declaration std::vector<double>optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::discrete_points_list(double const *discrete_pts_lst, int num_pts) const noexcept OL_WARN_UNUSED_RESULT best_so_far_list() Declaration std::vector<double>optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::best_so_far_list(double const *best_so_far) const noexcept OL_WARN_UNUSED_RESULT ComputeCost() \\rst compute the cost. \\endrst Declaration double optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::ComputeCost(StateType *kg_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradCost() \\rst compute the gradient of the cost. \\endrst Declaration void optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::ComputeGradCost(StateType *kg_state, double *restrict grad_cost) const OL_NONNULL_POINTERS ComputeObjectiveFunction() \\rst Wrapper for ComputeKnowledgeGradient(); see that function for details. \\endrst Declaration double optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::ComputeObjectiveFunction(StateType *kg_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradObjectiveFunction() \\rst Wrapper for ComputeGradKnowledgeGradient(); see that function for details. \\endrst Declaration void optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::ComputeGradObjectiveFunction(StateType *kg_state, double *restrict grad_KG) const OL_NONNULL_POINTERS ComputeKnowledgeGradient() \\rst Computes the knowledge gradient :kg_state[1] properly configured state object \\output :kg_state[1]: state with temporary storage modified; normal_rng modified the knowledge gradient from sampling points_to_sample with points_being_sampled concurrent experiments \\endrst \\rst Compute Knowledge Gradient This version requires the discretization of A (the feasibe domain). The discretization usually is: some set + points previous sampled + points being sampled + points to sample \\endrst Declaration double optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::ComputeKnowledgeGradient(StateType *kg_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradKnowledgeGradient() \\rst Computes the (partial) derivatives of the knowledge gradient with respect to each point of points_to_sample. As with ComputeKnowledgeGradient(), this computation accounts for the effect of points_being_sampled concurrent experiments. points_to_sample is the \"q\" and points_being_sampled is the \"p\" in q,p-KG. :kg_state[1] properly configured state object \\output :kg_state[1]: state with temporary storage modified; normal_rng modified :grad_KG[dim][num_to_sample]: gradient of KG, \\pderiv{KG(Xq \\cup Xp)}{Xq_{d,i}} where Xq is points_to_sample and Xp is points_being_sampled (grad KG from sampling points_to_sample with points_being_sampled concurrent experiments wrt each dimension of the points in points_to_sample) \\endrst \\rst Computes gradient of KG (see KnowledgeGradientEvaluator::ComputeGradKnowledgeGradient) wrt points_to_sample (stored in union_of_points[0:num_to_sample]). Mechanism is similar to the computation of KG, where points' contributions to the gradient are thrown out of their corresponding improvement <= 0.0. Thus \\nabla(\\mu) only contributes when the winner (point w/best improvement this iteration) is the current point. That is, the gradient of \\mu at x_i wrt x_j is 0 unless i == j (and only this result is stored in kg_state->grad_mu). The interaction with kg_state->grad_chol_decomp is harder to know a priori (like with grad_mu) and has a more complex structure (rank 3 tensor), so the derivative wrt x_j is computed fully, and the relevant submatrix (indexed by the current winner) is accessed each iteration. .. Note:: comments here are copied to _compute_grad_knowledge_gradient_monte_carlo() in python_version/knowledge_gradient.py \\endrst Declaration void optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::ComputeGradKnowledgeGradient(StateType *kg_state, double *restrict grad_KG) const OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::KnowledgeGradientMCMCEvaluator<DomainType>::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(KnowledgeGradientMCMCEvaluator)"
  },
  "api/optimal/learning/knowledge-gradient-mcmcstate.html": {
    "href": "api/optimal/learning/knowledge-gradient-mcmcstate.html",
    "title": "Struct optimal_learning::KnowledgeGradientMCMCState | qiotoolkit",
    "keywords": "Struct optimal_learning::KnowledgeGradientMCMCState \\rst State object for KnowledgeGradientEvaluator. This tracks the points being sampled in concurrent experiments (points_being_sampled) ALONG with the points currently being evaluated via knowledge gradient for future experiments (called points_to_sample); these are the p and q of q,p-KG, respectively. points_to_sample joined with points_being_sampled is stored in union_of_points in that order. This struct also tracks the state of the GaussianProcess that underlies the knowledge gradient computation: the GP state is built to handle the initial union_of_points, and subsequent updates to points_to_sample in this object also update the GP state. This struct also holds a pointer to a random number generator needed for Monte Carlo integrated KG computations. .. WARNING:: Users MUST guarantee that multiple state objects DO NOT point to the same RNG (in a multithreaded env). See general comments on State structs in gpp_common.hpp's header docs. \\endrst Constructors KnowledgeGradientMCMCState() \\rst Constructs an KnowledgeGradientMCMCState object with a specified source of randomness for the purpose of computing KG (and its gradient) over the specified set of points to sample. This establishes properly sized/initialized temporaries for KG computation, including dependent state from the associated Gaussian Process (which arrives as part of the kg_evaluator). .. WARNING:: This object is invalidated if the associated kg_evaluator is mutated. SetupState() should be called to reset. .. WARNING:: Using this object to compute gradients when configure_for_gradients := false results in UNDEFINED BEHAVIOR. :kg_evaluator knowledge gradient evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: points at which to evaluate KG and/or its gradient to check their value in future experiments (i.e., test points for GP predictions) :points_being_sampled[dim][num_being_sampled]: points being sampled in concurrent experiments :num_to_sample: number of potential future samples; gradients are evaluated wrt these points (i.e., the \"q\" in q,p-KG) :num_being_sampled: number of points being sampled in concurrent experiments (i.e., the \"p\" in q,p-KG) :configure_for_gradients: true if this object will be used to compute gradients, false otherwise :normal_rng[1]: pointer to a properly initialized* NormalRNG object .. NOTE:: The NormalRNG object must already be seeded. If multithreaded computation is used for KG, then every state object must have a different NormalRNG (different seeds, not just different objects). \\endrst Declaration optimal_learning::KnowledgeGradientMCMCState<DomainType>::KnowledgeGradientMCMCState(const EvaluatorType&kg_evaluator, double const *restrict points_to_sample, double const *restrict points_being_sampled, int num_to_sample_in, int num_being_sampled_in, int num_pts_in, int const *restrict gradients_in, int num_gradients_in, bool configure_for_gradients, NormalRNGInterface *normal_rng_in, std::vector<typename KnowledgeGradientEvaluator<DomainType>::StateType>*kg_state_vector) KnowledgeGradientMCMCState() Declaration optimal_learning::KnowledgeGradientMCMCState<DomainType>::KnowledgeGradientMCMCState(KnowledgeGradientMCMCState&&other) Methods GetProblemSize() Declaration int optimal_learning::KnowledgeGradientMCMCState<DomainType>::GetProblemSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT GetCurrentPoint() \\rst Get the points_to_sample: potential future samples whose KG (and/or gradients) are being evaluated \\output :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::KnowledgeGradientMCMCState<DomainType>::GetCurrentPoint(double *restrict points_to_sample) const noexcept OL_NONNULL_POINTERS SetCurrentPoint() \\rst Change the potential samples whose KG (and/or gradient) are being evaluated. Update the state's derived quantities to be consistent with the new points. :kg_evaluator expected improvement evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::KnowledgeGradientMCMCState<DomainType>::SetCurrentPoint(const EvaluatorType&kg_evaluator, double const *restrict points_to_sample_in) OL_NONNULL_POINTERS SetupState() \\rst Configures this state object with new points_to_sample, the location of the potential samples whose KG is to be evaluated. Ensures all state variables & temporaries are properly sized. Properly sets all dependent state variables (e.g., GaussianProcess's state) for KG evaluation. .. WARNING:: This object's state is INVALIDATED if the kg_evaluator (including the GaussianProcess it depends on) used in SetupState is mutated! SetupState() should be called again in such a situation. :kg_evaluator knowledge gradient evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::KnowledgeGradientMCMCState<DomainType>::SetupState(const EvaluatorType&kg_evaluator, double const *restrict points_to_sample) OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::KnowledgeGradientMCMCState<DomainType>::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(KnowledgeGradientMCMCState) BuildUnionOfPoints() \\rst Create a vector with the union of points_to_sample and points_being_sampled (the latter is appended to the former). Note the l-value return. Assigning the return to a std::vector or passing it as an argument to the ctor will result in copy-elision or move semantics; no copying/performance loss. :points_to_sample[dim][num_to_sample]: points at which to evaluate KG and/or its gradient to check their value in future experiments (i.e., test points for GP predictions) :points_being_sampled[dim][num_being_sampled]: points being sampled in concurrent experiments :num_to_sample: number of potential future samples; gradients are evaluated wrt these points (i.e., the \"q\" in q,p-KG) :num_being_sampled: number of points being sampled in concurrent experiments (i.e., the \"p\" in q,p-KG) :dim: the number of spatial dimensions of each point array std::vector with the union of the input arrays: points_being_sampled is appended to points_to_sample \\endrst Declaration static std::vector<double>optimal_learning::KnowledgeGradientMCMCState<DomainType>::BuildUnionOfPoints(double const *restrict points_to_sample, double const *restrict points_being_sampled, int num_to_sample, int num_being_sampled, int dim) noexcept OL_WARN_UNUSED_RESULT"
  },
  "api/optimal/learning/knowledge-gradient-state.html": {
    "href": "api/optimal/learning/knowledge-gradient-state.html",
    "title": "Struct optimal_learning::KnowledgeGradientState | qiotoolkit",
    "keywords": "Struct optimal_learning::KnowledgeGradientState \\rst State object for KnowledgeGradientEvaluator. This tracks the points being sampled in concurrent experiments (points_being_sampled) ALONG with the points currently being evaluated via knowledge gradient for future experiments (called points_to_sample); these are the p and q of q,p-KG, respectively. points_to_sample joined with points_being_sampled is stored in union_of_points in that order. This struct also tracks the state of the GaussianProcess that underlies the knowledge gradient computation: the GP state is built to handle the initial union_of_points, and subsequent updates to points_to_sample in this object also update the GP state. This struct also holds a pointer to a random number generator needed for Monte Carlo integrated KG computations. .. WARNING:: Users MUST guarantee that multiple state objects DO NOT point to the same RNG (in a multithreaded env). See general comments on State structs in gpp_common.hpp's header docs. \\endrst Constructors KnowledgeGradientState() \\rst Constructs an KnowledgeGradientState object with a specified source of randomness for the purpose of computing KG (and its gradient) over the specified set of points to sample. This establishes properly sized/initialized temporaries for KG computation, including dependent state from the associated Gaussian Process (which arrives as part of the kg_evaluator). .. WARNING:: This object is invalidated if the associated kg_evaluator is mutated. SetupState() should be called to reset. .. WARNING:: Using this object to compute gradients when configure_for_gradients := false results in UNDEFINED BEHAVIOR. :kg_evaluator knowledge gradient evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: points at which to evaluate KG and/or its gradient to check their value in future experiments (i.e., test points for GP predictions) :points_being_sampled[dim][num_being_sampled]: points being sampled in concurrent experiments :num_to_sample: number of potential future samples; gradients are evaluated wrt these points (i.e., the \"q\" in q,p-KG) :num_being_sampled: number of points being sampled in concurrent experiments (i.e., the \"p\" in q,p-KG) :configure_for_gradients: true if this object will be used to compute gradients, false otherwise :normal_rng[1]: pointer to a properly initialized* NormalRNG object .. NOTE:: The NormalRNG object must already be seeded. If multithreaded computation is used for KG, then every state object must have a different NormalRNG (different seeds, not just different objects). \\endrst Declaration optimal_learning::KnowledgeGradientState<DomainType>::KnowledgeGradientState(const EvaluatorType&kg_evaluator, double const *restrict points_to_sample, double const *restrict points_being_sampled, int num_to_sample_in, int num_being_sampled_in, int, int const *restrict gradients_in, int num_gradients_in, bool configure_for_gradients, NormalRNGInterface *normal_rng_in) KnowledgeGradientState() Declaration optimal_learning::KnowledgeGradientState<DomainType>::KnowledgeGradientState(KnowledgeGradientState&&other) Methods SubsetData() Declaration std::vector<double>optimal_learning::KnowledgeGradientState<DomainType>::SubsetData(double const *restrict union_of_points_in, int num_union_in, int num_fidelity) noexcept OL_WARN_UNUSED_RESULT GetProblemSize() Declaration int optimal_learning::KnowledgeGradientState<DomainType>::GetProblemSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT GetCurrentPoint() \\rst Get the points_to_sample: potential future samples whose KG (and/or gradients) are being evaluated \\output :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::KnowledgeGradientState<DomainType>::GetCurrentPoint(double *restrict points_to_sample) const noexcept OL_NONNULL_POINTERS SetCurrentPoint() \\rst Change the potential samples whose KG (and/or gradient) are being evaluated. Update the state's derived quantities to be consistent with the new points. :kg_evaluator expected improvement evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::KnowledgeGradientState<DomainType>::SetCurrentPoint(const EvaluatorType&kg_evaluator, double const *restrict points_to_sample) OL_NONNULL_POINTERS SetupState() \\rst Configures this state object with new points_to_sample, the location of the potential samples whose KG is to be evaluated. Ensures all state variables & temporaries are properly sized. Properly sets all dependent state variables (e.g., GaussianProcess's state) for KG evaluation. .. WARNING:: This object's state is INVALIDATED if the kg_evaluator (including the GaussianProcess it depends on) used in SetupState is mutated! SetupState() should be called again in such a situation. :kg_evaluator knowledge gradient evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::KnowledgeGradientState<DomainType>::SetupState(const EvaluatorType&kg_evaluator, double const *restrict points_to_sample) PreCompute() \\rst Pre-compute to_sample_mean_, and cholesky_to_sample_var \\endrst Declaration void optimal_learning::KnowledgeGradientState<DomainType>::PreCompute(const EvaluatorType&kg_evaluator, double const *restrict) OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::KnowledgeGradientState<DomainType>::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(KnowledgeGradientState) BuildUnionOfPoints() \\rst Create a vector with the union of points_to_sample and points_being_sampled (the latter is appended to the former). Note the l-value return. Assigning the return to a std::vector or passing it as an argument to the ctor will result in copy-elision or move semantics; no copying/performance loss. :points_to_sample[dim][num_to_sample]: points at which to evaluate KG and/or its gradient to check their value in future experiments (i.e., test points for GP predictions) :points_being_sampled[dim][num_being_sampled]: points being sampled in concurrent experiments :num_to_sample: number of potential future samples; gradients are evaluated wrt these points (i.e., the \"q\" in q,p-KG) :num_being_sampled: number of points being sampled in concurrent experiments (i.e., the \"p\" in q,p-KG) :dim: the number of spatial dimensions of each point array std::vector with the union of the input arrays: points_being_sampled is appended to points_to_sample \\endrst Declaration static std::vector<double>optimal_learning::KnowledgeGradientState<DomainType>::BuildUnionOfPoints(double const *restrict points_to_sample, double const *restrict points_being_sampled, int num_to_sample, int num_being_sampled, int dim) noexcept OL_WARN_UNUSED_RESULT"
  },
  "api/optimal/learning/log-marginal-likelihood-evaluator.html": {
    "href": "api/optimal/learning/log-marginal-likelihood-evaluator.html",
    "title": "Class optimal_learning::LogMarginalLikelihoodEvaluator | qiotoolkit",
    "keywords": "Class optimal_learning::LogMarginalLikelihoodEvaluator \\rst This serves as a quick summary of the Log Marginal Likelihood (LML). Please see the file comments here and in the corresponding .cpp file for further details. Class for computing the Log Marginal Likelihood. Given a particular covariance function (including hyperparameters) and training data ((point, function value, measurement noise) tuples), the log marginal likelihood is the log probability that the data were observed from a Gaussian Process would have generated the observed function values at the given measurement points. So log marginal likelihood tells us \"the probability of the observations given the assumptions of the model.\" Log marginal sits well with the Bayesian Inference camp. (Rasmussen & Williams p118) This quantity primarily deals with the trade-off between model fit and model complexity. Handling this trade-off is automatic in the log marginal likelihood calculation. See Rasmussen & Williams 5.2 and 5.4.1 for more details. We can use the log marginal likelihood to determine how good our model is. Additionally, we can maximize it by varying hyperparameters (or even changing covariance functions) to improve our model quality. Hence this class provides access to functions for computing log marginal likelihood and its hyperparameter gradients. .. Note:: These class comments are duplicated in Python: cpp_wrappers.log_likelihood.LogMarginalLikelihood \\endrst Inheritance optimal_learning::LogMarginalLikelihoodEvaluator Constructors LogMarginalLikelihoodEvaluator() \\rst Constructs a LogMarginalLikelihoodEvaluator object. All inputs are required; no default constructor nor copy/assignment are allowed. :covariance the CovarianceFunction object encoding assumptions about the GP's behavior on our data :points_sampled[dim][num_sampled]: points that have already been sampled :points_sampled_value[num_derivatives+1][num_sampled]: values of the already-sampled points :noise_variance[num_sampled]: the \\sigma_n^2 (noise variance) associated w/observation, points_sampled_value :dim: the spatial dimension of a point (i.e., number of independent params in experiment) :num_sampled: number of already-sampled points \\endrst Declaration optimal_learning::LogMarginalLikelihoodEvaluator::LogMarginalLikelihoodEvaluator(double const *restrict points_sampled_in, double const *restrict points_sampled_value_in, int const *derivatives_in, int num_derivatives_in, int dim_in, int num_sampled_in) OL_NONNULL_POINTERS Methods dim() Declaration int optimal_learning::LogMarginalLikelihoodEvaluator::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_sampled() Declaration int optimal_learning::LogMarginalLikelihoodEvaluator::num_sampled() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_derivatives() Declaration int optimal_learning::LogMarginalLikelihoodEvaluator::num_derivatives() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT ComputeObjectiveFunction() \\rst Wrapper for ComputeLogLikelihood(); see that function for details. \\endrst Declaration double optimal_learning::LogMarginalLikelihoodEvaluator::ComputeObjectiveFunction(StateType *log_likelihood_state) const noexcept OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradObjectiveFunction() \\rst Wrapper for ComputeGradLogLikelihood(); see that function for details. \\endrst Declaration void optimal_learning::LogMarginalLikelihoodEvaluator::ComputeGradObjectiveFunction(StateType *log_likelihood_state, double *restrict grad_log_marginal) const noexcept OL_NONNULL_POINTERS FillLogLikelihoodState() \\rst Wrapper for ComputeHessianLogLikelihood(); see that function for details. \\endrst \\rst Sets up the LogMarginalLikelihoodState object so that it can be used to compute log marginal and its gradients. ASSUMES all needed space is ALREADY ALLOCATED. This function should not be called directly; instead use LogMarginalLikelihoodState::SetupState. :log_likelihood_state[1] constructed state object with appropriate sized allocations \\output :log_likelihood_state[1]: fully configured state object, ready for use by this class's member functions \\endrst Declaration void optimal_learning::LogMarginalLikelihoodEvaluator::FillLogLikelihoodState(StateType *log_likelihood_state) const OL_NONNULL_POINTERS ComputeLogLikelihood() \\rst Computes the log marginal likelihood, log(p(y | X, \\theta)). That is, the probability of observing the training values, y, given the training points, X, and hyperparameters (of the covariance function), \\theta. This is a measure of how likely it is that the observed values came from our Gaussian Process Prior. :log_likelihood_state properly configured state oboject natural log of the marginal likelihood of the GP model \\endrst \\rst .. NOTE:: These comments have been copied into the matching method of LogMarginalLikelihood in python_version/log_likelihood.py. log p(y | X, \\theta) = -\\frac{1}{2} * y^T * K^-1 * y - \\frac{1}{2} * \\log(det(K)) - \\frac{n}{2} * \\log(2*pi) where n is num_sampled, \\theta are the hyperparameters, and \\log is the natural logarithm. In the following, term1 = -\\frac{1}{2} * y^T * K^-1 * y term2 = -\\frac{1}{2} * \\log(det(K)) term3 = -\\frac{n}{2} * \\log(2*pi) For an SPD matrix K = L * L^T, det(K) = \\Pi_i L_ii^2 We could compute this directly and then take a logarithm. But we also know: \\log(det(K)) = 2 * \\sum_i \\log(L_ii) The latter method is (currently) preferred for computing \\log(det(K)) due to reduced chance for overflow and (possibly) better numerical conditioning. \\endrst Declaration double optimal_learning::LogMarginalLikelihoodEvaluator::ComputeLogLikelihood(const StateType&log_likelihood_state) const noexcept OL_WARN_UNUSED_RESULT ComputeGradLogLikelihood() \\rst Computes the (partial) derivatives of the log marginal likelihood with respect to each hyperparameter of our covariance function. Let n_hyper = covariance_ptr->GetNumberOfHyperparameters(); :log_likelihood_state[1] properly configured state oboject \\output :log_likelihood_state[1]: state with temporary storage modified :grad_log_marginal[n_hyper]: gradient of log marginal likelihood wrt each hyperparameter of covariance \\endrst Declaration void optimal_learning::LogMarginalLikelihoodEvaluator::ComputeGradLogLikelihood(StateType *log_likelihood_state, double *restrict grad_log_marginal) const noexcept OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() \\rst Constructs the Hessian matrix of the log marginal likelihood function. This matrix is symmetric. It is also negative definite near maxima of the log marginal. See HyperparameterHessianCovariance() docs in CovarianceInterface (gpp_covariance.hpp) for details on the structure of the Hessian matrix. :log_likelihood_state[1] properly configured state oboject \\output :log_likelihood_state[1]: state with temporary storage modified :hessian_log_marginal[n_hyper][n_hyper]: (i,j)-th entry is \\mixpderiv{LML}{\\theta_i}{\\theta_j}, where LML = log(p(y | X, \\theta)) \\endrst Declaration optimal_learning::LogMarginalLikelihoodEvaluator::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(LogMarginalLikelihoodEvaluator) BuildHyperparameterGradCovarianceMatrix() \\rst Constructs the tensor of gradients (wrt hyperparameters) of the covariance function at all pairs of points_sampled_. The result is stored in state->grad_hyperparameter_cov_matrix. So we are computing \\pderiv{cov(X_i, X_j)}{\\theta_k}. These data are ordered as: grad_hyperparameter_cov_matrix[i][j][k] (i.e., num_hyperparmeters matrices of size Square(num_sampled_)). .. Note:: grad_hyperparameter_cov_matrix[i][j][k] == grad_hyperparameter_cov_matrix[j][i][k] :log_likelihood_state[1] properly configured state object \\output :log_likelihood_state[1]: state with grad_hyperparameter_cov_matrix filled \\endrst Declaration void optimal_learning::LogMarginalLikelihoodEvaluator::BuildHyperparameterGradCovarianceMatrix(StateType *log_likelihood_state) const noexcept"
  },
  "api/optimal/learning/log-marginal-likelihood-state.html": {
    "href": "api/optimal/learning/log-marginal-likelihood-state.html",
    "title": "Struct optimal_learning::LogMarginalLikelihoodState | qiotoolkit",
    "keywords": "Struct optimal_learning::LogMarginalLikelihoodState \\rst State object for LogMarginalLikelihoodEvaluator. This object tracks the covariance object as well as derived quantities that (along with the training points/values in the Evaluator class) fully specify the log marginal likelihood. Since this is used to optimize the log marginal likelihood, the covariance's hyperparameters are variable. See general comments on State structs in gpp_common.hpp's header docs. \\endrst Constructors LogMarginalLikelihoodState() \\rst Constructs a LogMarginalLikelihoodState object with a specified covariance object (in particular, new hyperparameters). Ensures all state variables & temporaries are properly sized. Properly sets all state variables so that the Evaluator can be used to compute log marginal likelihood, gradients, etc. .. WARNING:: This object's state is INVALIDATED if the log_likelihood_eval used in construction is mutated! SetupState() should be called again in such a situation. :log_likelihood_eval LogMarginalLikelihoodEvaluator object that this state is being used with :covariance_in: the CovarianceFunction object encoding assumptions about the GP's behavior on our data \\endrst Declaration optimal_learning::LogMarginalLikelihoodState::LogMarginalLikelihoodState(const EvaluatorType&log_likelihood_eval, const CovarianceInterface&covariance_in, const std::vector<double>noise_variance_in) LogMarginalLikelihoodState() Declaration optimal_learning::LogMarginalLikelihoodState::LogMarginalLikelihoodState(LogMarginalLikelihoodState&&other) Methods GetProblemSize() Declaration int optimal_learning::LogMarginalLikelihoodState::GetProblemSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT SetCurrentPoint() Declaration void optimal_learning::LogMarginalLikelihoodState::SetCurrentPoint(const EvaluatorType&log_likelihood_eval, double const *restrict hyperparameters) OL_NONNULL_POINTERS GetCurrentPoint() Declaration void optimal_learning::LogMarginalLikelihoodState::GetCurrentPoint(double *restrict hyperparameters) OL_NONNULL_POINTERS GetHyperparameters() \\rst Get hyperparameters of underlying covariance function. \\output :hyperparameters[num_hyperparameters]: covariance's hyperparameters \\endrst Declaration void optimal_learning::LogMarginalLikelihoodState::GetHyperparameters(double *restrict hyperparameters) const noexcept OL_NONNULL_POINTERS SetHyperparameters() \\rst Change the hyperparameters of the underlying covariance function. Update the state's derived quantities to be consistent with the new hyperparameters. :log_likelihood_eval LogMarginalLikelihoodEvaluator object that this state is being used with :hyperparameters[num_hyperparameters]: hyperparameters to change to \\endrst \\rst Computes the Hessian matrix of the log (marginal) likelihood wrt the hyperparameters:: \\mixpderiv{log(p(y | X, \\theta_k))}{\\theta_i}{\\theta_j} = (-\\alpha * \\pderiv{K}{\\theta_i} * K^-1 * \\pderiv{K}{\\theta_j} * \\alpha) (\\alpha * \\mixpderiv{K}{\\theta_i}{\\theta_j} * \\alpha) 0.5 * tr(-K^-1 * \\pderiv{K}{\\theta_i} * K^-1 * \\pderiv{K}{\\theta_j} + K^-1 * \\mixpderiv{K}{\\theta_i}{\\theta_j}) Note that as usual, K is the covariance matrix (bearing its own two indices, say K_{k,l}) which are omitted here. This expression arises from differentating each entry of the gradient (see function comments for LogMarginalLikelihoodEvaluator::ComputeGradLogLikelihood for expression) of the log marginal wrt each hyperparameter. We use the identity: \\pderiv{K^-1}{X} = -K^-1 * \\pderiv{K}{X} * K^-1; as well as the fact that \\partial tr(A) = tr(\\partial A). That is, since trace is linear, the order can be interchanged with the differential operator; and the various symmetries of the gradient/hessians of K (see function declaration comments for details on symmetry). \\endrst Declaration void optimal_learning::LogMarginalLikelihoodState::SetHyperparameters(const EvaluatorType&log_likelihood_eval, double const *restrict hyperparameters) OL_NONNULL_POINTERS SetupState() \\rst Configures this state object with new hyperparameters. Ensures all state variables & temporaries are properly sized. Properly sets all state variables for log likelihood (+ gradient) evaluation. .. WARNING:: This object's state is INVALIDATED if the log_likelihood used in SetupState is mutated! SetupState() should be called again in such a situation. :log_likelihood_eval log likelihood evaluator object that describes the training/already-measured data :hyperparameters[num_hyperparameters]: hyperparameters to change to \\endrst Declaration void optimal_learning::LogMarginalLikelihoodState::SetupState(const EvaluatorType&log_likelihood_eval, double const *restrict hyperparameters) OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::LogMarginalLikelihoodState::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(LogMarginalLikelihoodState)"
  },
  "api/optimal/learning/lower-bound-exception.html": {
    "href": "api/optimal/learning/lower-bound-exception.html",
    "title": "Class optimal_learning::LowerBoundException | qiotoolkit",
    "keywords": "Class optimal_learning::LowerBoundException \\rst Exception to capture value < min_value. Simple subclass of BoundsException that sets the max argument to std::numeric_limits ::max() See BoundsException for what() message format. \\endrst Inheritance optimal_learning::BoundsException optimal_learning::LowerBoundException Inherited Members max value OL_DISALLOW_DEFAULT_AND_ASSIGN BoundsException min BoundsException OptimalLearningException OptimalLearningException what AppendCustomMessageAndDebugInfo OptimalLearningException Constructors LowerBoundException() \\rst Constructs a LowerBoundException object with extra fields to flesh out the what() message. :line_info[] ptr to char array containing FILE and LINE info; e.g., from OL_STRINGIFY_FILE_AND_LINE :func_info[]: optional ptr to char array from OL_CURRENT_FUNCTION_NAME or similar :custom_message[]: optional ptr to char array with any additional text/info to print/log :value: the value that violates its min or max bound :min: the minimum bound for value \\endrst Declaration optimal_learning::LowerBoundException<ValueType>::LowerBoundException(char const *line_info, char const *func_info, char const *custom_message, ValueType value_in, ValueType min_in) Methods OL_DISALLOW_DEFAULT_AND_ASSIGN() Declaration optimal_learning::LowerBoundException<ValueType>::OL_DISALLOW_DEFAULT_AND_ASSIGN(LowerBoundException)"
  },
  "api/optimal/learning/matern-nu2p5.html": {
    "href": "api/optimal/learning/matern-nu2p5.html",
    "title": "Class optimal_learning::MaternNu2p5 | qiotoolkit",
    "keywords": "Class optimal_learning::MaternNu2p5 \\rst Implements a case of the Matern class of covariance functions with \\nu = 5/2 (smoothness parameter). See docs for MaternNu1p5 for more details on the Matern class of covariance fucntions. cov_{\\nu=5/2}(r) = (1 + \\sqrt{5}\\frac{r}[l} + \\frac{5}{3}\\frac{r^2}{l^2})\\exp(-\\sqrt{5}\\frac{r}{l}) We also implement the augmented kernel function with the gradient obervations. See CovarianceInterface for descriptions of the virtual functions. \\endrst Inheritance optimal_learning::CovarianceInterface optimal_learning::MaternNu2p5 Inherited Members ~CovarianceInterface Constructors MaternNu2p5() \\rst Constructs a MaternNu2p5 object with constant length-scale across all dimensions. :dim the number of spatial dimensions :alpha: the hyperparameter \\alpha (e.g., signal variance, \\sigma_f^2) :length: the constant length scale to use for all hyperparameter length scales \\endrst Declaration optimal_learning::MaternNu2p5::MaternNu2p5(int dim, double alpha, double length) MaternNu2p5() \\rst Constructs a MaternNu2p5 object with the specified hyperparameters. :dim the number of spatial dimensions :alpha: the hyperparameter \\alpha, (e.g., signal variance, \\sigma_f^2) :lengths[dim]: the hyperparameter length scales, one per spatial dimension \\endrst Declaration optimal_learning::MaternNu2p5::MaternNu2p5(int dim, double alpha, double const *restrict lengths) OL_NONNULL_POINTERS MaternNu2p5() \\rst Constructs a MaternNu2p5 object with the specified hyperparameters. :dim the number of spatial dimensions :alpha: the hyperparameter \\alpha, (e.g., signal variance, \\sigma_f^2) :lengths: the hyperparameter length scales, one per spatial dimension \\endrst Declaration optimal_learning::MaternNu2p5::MaternNu2p5(int dim, double alpha, std::vector<double>lengths) MaternNu2p5() Declaration optimal_learning::MaternNu2p5::MaternNu2p5(const MaternNu2p5&source) Methods Covariance() \\rst Computes the covariance function of the function values and their gradients of two points, cov(point_one, point_two). Points must be arrays with length dim. The covariance function is guaranteed to be symmetric by definition: Covariance(x, y) = Covariance(y, x). This function is also positive definite by definition. :point_one[dim] first spatial coordinate :derivatives_one[dim]: which derivatives of point_one are available :num_derivatives_one: int, the number of derivatives of point one :point_two[dim]: second spatial coordinate :derivatives_two[dim]: which derivatives of point_two are available :num_derivatives_two: int, the number of derivatives of point two cov[1+num_derivatives_one][1+num_derivatives_two]: value of covariance between the function values and their gradients of the input points \\endrst Declaration void optimal_learning::MaternNu2p5::Covariance(double const *restrict point_one, int const *restrict derivatives_one, int length_one, double const *restrict point_two, int const *restrict derivatives_two, int length_two, double *restrict cov) const noexcept override OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT GradCovariance() \\rst Computes the gradient of this.Covariance(point_one, point_two) with respect to the FIRST argument, point_one. This distinction is important for maintaining the desired symmetry. Cov(x, y) = Cov(y, x). Additionally, \\pderiv{Cov(x, y)}{x} = \\pderiv{Cov(y, x)}{x}. However, in general, \\pderiv{Cov(x, y)}{x} != \\pderiv{Cov(y, x)}{y} (NOT equal! These may differ by a negative sign) Hence to avoid separate implementations for differentiating against first vs second argument, this function only handles differentiation against the first argument. If you need \\pderiv{Cov(y, x)}{x}, just swap points x and y. :point_one[dim] first spatial coordinate :derivatives_one[dim]: which derivatives of point_one are available :num_derivatives_one: int, the number of derivatives of point one :point_two[dim]: second spatial coordinate :derivatives_two[dim]: which derivatives of point_two are available :num_derivatives_two: int, the number of derivatives of point two \\output grad_cov[dim][1+num_derivatives_one][1+num_derivatives_two]: (i, j, k)-th entry is \\pderiv{cov(x_1, x_2)(j, k))}{x1_i} \\endrst Declaration void optimal_learning::MaternNu2p5::GradCovariance(double const *restrict point_one, int const *restrict derivatives_one, int length_one, double const *restrict point_two, int const *restrict derivatives_two, int length_two, double *restrict grad_cov) const noexcept override OL_NONNULL_POINTERS GetNumberOfHyperparameters() \\rst Returns the number of hyperparameters. This base class only allows for a maximum of dim + 1 hyperparameters but subclasses may implement additional ones. The number of hyperparameters. Return 0 to disable hyperparameter-related gradients, optimizations. \\endrst Declaration virtual int optimal_learning::MaternNu2p5::GetNumberOfHyperparameters() const noexcept override OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT HyperparameterGradCovariance() \\rst Similar to GradCovariance(), except gradients are computed w.r.t. the hyperparameters. Unlike GradCovariance(), the order of point_one and point_two is irrelevant here (since we are not differentiating against either of them). Thus the matrix of grad covariances (wrt hyperparameters) is symmetric. :point_one[dim] first spatial coordinate :derivatives_one[dim]: which derivatives of point_one are available :num_derivatives_one: int, the number of derivatives of point one :point_two[dim]: second spatial coordinate :derivatives_two[dim]: which derivatives of point_two are available :num_derivatives_two: int, the number of derivatives of point two \\output :grad_hyperparameter_cov[this.GetNumberOfHyperparameters()][1+num_derivatives_one][1+num_derivatives_two]: (i, j, k)-th entry is \\pderiv{cov(x_1, x_2)(j, k)}{\\theta_i} \\endrst Declaration void optimal_learning::MaternNu2p5::HyperparameterGradCovariance(double const *restrict point_one, int const *restrict derivatives_one, int length_one, double const *restrict point_two, int const *restrict derivatives_two, int length_two, double *restrict grad_hyperparameter_cov) const noexcept override OL_NONNULL_POINTERS SetHyperparameters() \\rst Sets the hyperparameters. Hyperparameter ordering is defined implicitly by GetHyperparameters: [alpha=\\sigma_f^2, length_0, ..., length_{n-1}] :hyperparameters[this.GetNumberOfHyperparameters()] hyperparameters to set \\endrst Declaration virtual void optimal_learning::MaternNu2p5::SetHyperparameters(double const *restrict hyperparameters) noexcept override OL_NONNULL_POINTERS GetHyperparameters() \\rst Gets the hyperparameters. Ordering is [alpha=\\sigma_f^2, length_0, ..., length_{n-1}] \\output :hyperparameters[this.GetNumberOfHyperparameters()]: values of current hyperparameters \\endrst Declaration virtual void optimal_learning::MaternNu2p5::GetHyperparameters(double *restrict hyperparameters) const noexcept override OL_NONNULL_POINTERS Clone() \\rst For implementing the virtual (copy) constructor idiom. :Pointer to a constructed object that is a subclass of CovarianceInterface \\endrst Declaration CovarianceInterface * optimal_learning::MaternNu2p5::Clone() const override Initialize() \\rst Validate and initialize class data members. \\endrst Declaration void optimal_learning::MaternNu2p5::Initialize() OL_DISALLOW_DEFAULT_AND_ASSIGN() Declaration optimal_learning::MaternNu2p5::OL_DISALLOW_DEFAULT_AND_ASSIGN(MaternNu2p5)"
  },
  "api/optimal/learning/mock-expected-improvement-environment.html": {
    "href": "api/optimal/learning/mock-expected-improvement-environment.html",
    "title": "Class optimal_learning::MockExpectedImprovementEnvironment | qiotoolkit",
    "keywords": "Class optimal_learning::MockExpectedImprovementEnvironment \\rst Class to conveniently hold and generate random data that are commonly needed for testing functions in gpp_math.cpp. In particular, this mock is used for testing GP mean, GP variance, and expected improvement (and their gradients). This class holds arrays: points_sampled, points_sampled_value, points_to_sample, and points_being_sampled which are sized according to the parameters specified in Initialize(), and filled with random numbers. TODO(GH-125): we currently generate the point sets by repeated calls to rand(). This is generally unwise since the distribution of points is not particularly random. Additionally, our current covariance functions are all stationary, so we would rather generate a random base point x, and then a random (direction, radius) pair so that y = x + direction*radius. We better cover the different behavioral regimes of our code in this case, since it's the radius value that actually correlates to results. \\endrst Inheritance optimal_learning::MockExpectedImprovementEnvironment Constructors MockExpectedImprovementEnvironment() \\rst Construct a MockExpectedImprovementEnvironment and set invalid values for all size parameters (so that Initialize must be called to do anything useful) and pre-allocate some space. \\endrst Declaration optimal_learning::MockExpectedImprovementEnvironment::MockExpectedImprovementEnvironment() Methods Initialize() \\rst (Re-)initializes the data data in this function: this includes space allocation and random number generation. If any of the size parameters are changed from their current values, space will be realloc'd. Then it re-draws another set of uniform random points (in [-5, 5]) for the member arrays points_sampled, points_sampled_value, points_to_sample, and points_being_sampled. :dim the spatial dimension of a point (i.e., number of independent params in experiment) :num_to_sample: number of points to be sampled in future experiments :num_being_sampled: number of points being sampled concurrently :num_sampled: number of already-sampled points \\endrst Declaration void optimal_learning::MockExpectedImprovementEnvironment::Initialize(int dim_in, int num_to_sample_in, int num_being_sampled_in, int num_sampled_in, int num_derivatives_in) Initialize() Declaration void optimal_learning::MockExpectedImprovementEnvironment::Initialize(int dim_in, int num_to_sample_in, int num_being_sampled_in, int num_sampled_in, int num_derivatives_in, UniformRandomGenerator *uniform_generator) points_sampled() Declaration double* optimal_learning::MockExpectedImprovementEnvironment::points_sampled() points_sampled_value() Declaration double* optimal_learning::MockExpectedImprovementEnvironment::points_sampled_value() points_to_sample() Declaration double* optimal_learning::MockExpectedImprovementEnvironment::points_to_sample() points_being_sampled() Declaration double* optimal_learning::MockExpectedImprovementEnvironment::points_being_sampled() OL_DISALLOW_COPY_AND_ASSIGN() Declaration optimal_learning::MockExpectedImprovementEnvironment::OL_DISALLOW_COPY_AND_ASSIGN(MockExpectedImprovementEnvironment)"
  },
  "api/optimal/learning/mock-gaussian-process-prior-data.html": {
    "href": "api/optimal/learning/mock-gaussian-process-prior-data.html",
    "title": "Struct optimal_learning::MockGaussianProcessPriorData | qiotoolkit",
    "keywords": "Struct optimal_learning::MockGaussianProcessPriorData \\rst Struct to generate data randomly from a GaussianProcess. This object contains the generated GaussianProcess as well as the inputs needed to generate it (e.g., hyperparameters, domain, etc). This struct is intended for convenience (so that test writers do not need to repeat these lines in every test that builds its input data from a GP). It has a fire-and-forget constructor that builds all fields randomly, but it also exposes all internal state/functions used by that ctor so that power users can customize their test scenarios further. Implementation: this object uses std::unique_ptr to hide complex object definitions in the corresponding cpp file \\endrst Constructors MockGaussianProcessPriorData() \\rst Construct an empty MockGaussianProcessPriorData. Member int, double, and vectors are initialized appropriately. covariance_ptr is cloned from covariance. BUT domain_ptr and gaussian_process_ptr ARE NOT initialized. Use this class's member functions to properly initialize these more complex data. :covariance the CovarianceInterface object encoding assumptions about the GP's behavior on our data :noise_variance: the \\sigma_n^2 (noise variance) associated w/observation, i-th entry will be associated with the i-th point generated by the GP :dim: the spatial dimension of a point (i.e., number of independent params in experiment) :num_sampled: number of already-sampled points (that we want the GP to hold) \\endrst Declaration optimal_learning::MockGaussianProcessPriorData<DomainType>::MockGaussianProcessPriorData(const CovarianceInterface&covariance, const std::vector<int>&derivatives_in, int num_derivatives_in, int dim_in, int num_sampled_in) MockGaussianProcessPriorData() \\rst Completely constructs a MockGaussianProcessPriorData, initializing all fields. Builds a GP based on a randomly generated domain and hyperparameters. :covariance the CovarianceInterface object encoding assumptions about the GP's behavior on our data :noise_variance: the \\sigma_n^2 (noise variance) associated w/observation, i-th entry will be associated with the i-th point generated by the GP :dim: the spatial dimension of a point (i.e., number of independent params in experiment) :num_sampled: number of already-sampled points (that we want the GP to hold) :uniform_double_domain_lower: [min, max] range from which to draw domain lower bounds :uniform_double_domain_upper: [min, max] range from which to draw domain upper bounds :uniform_double_hyperparameters: [min, max] range from which to draw hyperparameters :uniform_generator[1]: a UniformRandomGenerator object providing the random engine for uniform random numbers \\output :uniform_generator[1]: UniformRandomGenerator object will have its state changed due to random draws \\endrst Declaration optimal_learning::MockGaussianProcessPriorData<DomainType>::MockGaussianProcessPriorData(const CovarianceInterface&covariance, const std::vector<int>&derivatives_in, int num_derivatives_in, int dim_in, int num_sampled_in, const boost::uniform_real<double>&uniform_double_domain_lower, const boost::uniform_real<double>&uniform_double_domain_upper, const boost::uniform_real<double>&uniform_double_hyperparameters, UniformRandomGenerator *uniform_generator) Methods ~MockGaussianProcessPriorData() \\rst Prevent inline destructor: the dtor of std::unique_ptr needs access to T's dtor (b/c unique_ptr's dtor basically calls delete on T*). But we want to forward-declare all of our T objects, so the dtor must be defined in the cpp file where those defintions are visible. \\endrst Declaration optimal_learning::MockGaussianProcessPriorData<DomainType>::~MockGaussianProcessPriorData() InitializeHyperparameters() \\rst Sets hyperparameters of covariance with random draws from the specified interval. Modifies: hyperparameters, covariance_ptr :uniform_double_hyperparameters [min, max] range from which to draw hyperparameters :uniform_generator[1]: a UniformRandomGenerator object providing the random engine for uniform random numbers \\output :uniform_generator[1]: UniformRandomGenerator object will have its state changed due to random draws \\endrst Declaration void optimal_learning::MockGaussianProcessPriorData<DomainType>::InitializeHyperparameters(const boost::uniform_real<double>&uniform_double_hyperparameters, UniformRandomGenerator *uniform_generator) InitializeDomain() \\rst Sets the domain from which the GP's historical data will be generated. For each dimension, we draw [min, max] bounds (domain_bounds); then we construct a domain object. Modifies: domain_bounds, domain_ptr :uniform_double_domain_lower [min, max] range from which to draw domain lower bounds :uniform_double_domain_upper: [min, max] range from which to draw domain upper bounds :uniform_generator[1]: a UniformRandomGenerator object providing the random engine for uniform random numbers \\output :uniform_generator[1]: UniformRandomGenerator object will have its state changed due to random draws \\endrst Declaration void optimal_learning::MockGaussianProcessPriorData<DomainType>::InitializeDomain(const boost::uniform_real<double>&uniform_double_domain_lower, const boost::uniform_real<double>&uniform_double_domain_upper, UniformRandomGenerator *uniform_generator) InitializeGaussianProcess() \\rst Builds a GaussianProcess with num_sampled points (drawn randomly from the domain) whose values are drawn randomly from the GP (sampled one at a time and added to the prior). Users MUST call InitializeHyperparameters() and InitializeDomain() (or otherwise initialize hyperparameters and domain_ptr) before calling this function. Modifies: covariance_ptr, best_so_far, gaussian_procss_ptr :uniform_generator[1] a UniformRandomGenerator object providing the random engine for uniform random numbers \\output :uniform_generator[1]: UniformRandomGenerator object will have its state changed due to random draws \\endrst Declaration void optimal_learning::MockGaussianProcessPriorData<DomainType>::InitializeGaussianProcess(UniformRandomGenerator *uniform_generator)"
  },
  "api/optimal/learning/mock-knowledge-gradient-environment.html": {
    "href": "api/optimal/learning/mock-knowledge-gradient-environment.html",
    "title": "Class optimal_learning::MockKnowledgeGradientEnvironment | qiotoolkit",
    "keywords": "Class optimal_learning::MockKnowledgeGradientEnvironment \\rst Checks that multithreaded KG optimization behaves the same way that single threaded does. number of test failures: 0 if KG multi/single threaded optimization are consistent \\endrst \\rst Checks that KG optimization is working on tensor product or simplex domain using monte-carlo KG evaluation. :domain_type type of the domain to test on (e.g., tensor product, simplex) number of test failures: 0 if KG optimization is working properly \\endrst \\rst Checks that ComputeKGOptimalPointsToSample works on a tensor product domain. This test exercises the the code tested in: KnowledgeGradientOptimizationTest(kTensorProduct) for ei_mode = {kAnalytic, kMonteCarlo}. This test checks the generation of multiple, simultaneous experimental points to sample. number of test failures: 0 if KG optimization is working properly \\endrst \\rst Tests EvaluateKGAtPointList (computes KG at a specified list of points, multithreaded). Checks that the returned best point is in fact the best. Verifies multithreaded consistency. number of test failures: 0 if function evaluation is working properly \\endrst \\rst Class to conveniently hold and generate random data that are commonly needed for testing functions in gpp_math.cpp. In particular, this mock is used for testing GP mean, GP variance, and expected improvement (and their gradients). This class holds arrays: points_sampled, points_sampled_value, points_to_sample, and points_being_sampled which are sized according to the parameters specified in Initialize(), and filled with random numbers. TODO(GH-125): we currently generate the point sets by repeated calls to rand(). This is generally unwise since the distribution of points is not particularly random. Additionally, our current covariance functions are all stationary, so we would rather generate a random base point x, and then a random (direction, radius) pair so that y = x + direction*radius. We better cover the different behavioral regimes of our code in this case, since it's the radius value that actually correlates to results. \\endrst Inheritance optimal_learning::MockKnowledgeGradientEnvironment Constructors MockKnowledgeGradientEnvironment() \\rst Construct a MockExpectedImprovementEnvironment and set invalid values for all size parameters (so that Initialize must be called to do anything useful) and pre-allocate some space. \\endrst Declaration optimal_learning::MockKnowledgeGradientEnvironment::MockKnowledgeGradientEnvironment() Methods Initialize() \\rst (Re-)initializes the data data in this function: this includes space allocation and random number generation. If any of the size parameters are changed from their current values, space will be realloc'd. Then it re-draws another set of uniform random points (in [-5, 5]) for the member arrays points_sampled, points_sampled_value, points_to_sample, and points_being_sampled. :dim the spatial dimension of a point (i.e., number of independent params in experiment) :num_to_sample: number of points to be sampled in future experiments :num_being_sampled: number of points being sampled concurrently :num_sampled: number of already-sampled points \\endrst Declaration void optimal_learning::MockKnowledgeGradientEnvironment::Initialize(int dim_in, int num_to_sample_in, int num_being_sampled_in, int num_sampled_in, int num_pts_in, int num_derivatives_in) Initialize() Declaration void optimal_learning::MockKnowledgeGradientEnvironment::Initialize(int dim_in, int num_to_sample_in, int num_being_sampled_in, int num_sampled_in, int num_pts_in, int num_derivatives_in, UniformRandomGenerator *uniform_generator) points_sampled() Declaration double* optimal_learning::MockKnowledgeGradientEnvironment::points_sampled() points_sampled_value() Declaration double* optimal_learning::MockKnowledgeGradientEnvironment::points_sampled_value() points_to_sample() Declaration double* optimal_learning::MockKnowledgeGradientEnvironment::points_to_sample() points_being_sampled() Declaration double* optimal_learning::MockKnowledgeGradientEnvironment::points_being_sampled() discrete_pts() Declaration double* optimal_learning::MockKnowledgeGradientEnvironment::discrete_pts() OL_DISALLOW_COPY_AND_ASSIGN() Declaration optimal_learning::MockKnowledgeGradientEnvironment::OL_DISALLOW_COPY_AND_ASSIGN(MockKnowledgeGradientEnvironment)"
  },
  "api/optimal/learning/multistart-optimizer.html": {
    "href": "api/optimal/learning/multistart-optimizer.html",
    "title": "Class optimal_learning::MultistartOptimizer | qiotoolkit",
    "keywords": "Class optimal_learning::MultistartOptimizer \\rst This is a general, template class for multistart optimization. It is designed to be used with the various Optimizer classes in this file (e.g., NullOptimizer, GradientDescentOptimizer, NewtonOptimizer). The multistart process is multithreaded using OpenMP so that we can start from multiple initial guesses across multiple threads simultaneously. See section 2c) and 3b, iii) in the header docs at the top of the file for more details. The use with GradientDescentOptimizer, NewtonOptimizer, etc. are standard practice in nonlinear optimization. In particular, without special properties like convexity, single-start optimizers can converge to local optima. In general, a nonlinear function can have many local optima, so the only way to improve* your chances of finding the global optimum is to start from many different locations. This will be the typical use case for MultistartOptimizer<...>::MultistartOptimize(). Improve is intentional here. In the general case, you are not guaranteed (in finite time) to find the global optimum. Use with NullOptimizer requires special mention here as it might seem silly. This case reduces to evaluating the objective function at every point of initial_guesses. Through function_values, you can get the objective value at each of point of initial_guesses too (e.g., for plotting). So use MultistartOptimize with NullOptimzer to perform a 'dumb' search (e.g., initial_guesses can be obtained from a grid, random sampling, etc.). NullOptimizer allows 'dumb' search to use the same code as multistart optimization. 'Dumb' search is inaccurate but it never fails, so we often use it as a fall-back when more advanced (e.g., gradient descent) techniques fail. This class provides just one method (for now), MultistartOptimize(); see below. .. Note:: comments copied to MultistartOptimizer in python_version/optimization.py. \\endrst Inheritance optimal_learning::MultistartOptimizer Constructors MultistartOptimizer() Declaration optimal_learning::MultistartOptimizer<Optimizer_>::MultistartOptimizer()=default Methods MultistartOptimize() \\rst Performs multistart optimization with the specified Optimizer (class template parameter) to optimize the specified ObjectiveFunctionEvaluator over the specified DomainType. Optimizer behavior is controlled by the specified ParameterStruct. See class docs and header docs of this file, section 2c and 3b, iii), for more information. The method allows you to specify what the current best is, so that if optimization cannot beat it, no improvement will be reported. It will otherwise report the overall best improvement (through io_container) as well as the result of every individual multistart run if desired (through function_values). .. Note:: comments copied to MultistartOptimizer.optimize() in python_version/optimization.py. Generally, you will not call this function directly. Instead, it is intended to be used in wrappers that set up state, thread_schedule, etc. for the specific optimization problem at hand. For examples with Expected Improvement (EI), see gpp_math: EvaluateEIAtPointList() ComputeOptimalPointsToSampleViaMultistartGradientDescent() or gpp_model_selection: EvaluateLogLikelihoodAtPointList() MultistartGradientDescentHyperparameterOptimization() MultistartNewtonHyperparameterOptimization() problem_size refers to objective_state->GetProblemSize(), the number of dimensions in a \"point\" aka the number of variables being optimized. (This might be the spatial dimension for EI or the number of hyperparameters for log likelihood.) :optimizer object with the desired Optimize() functionality (e.g., do nothing for 'dumb' search, gradient descent, etc.) :objective_evaluator: reference to object that can compute the objective function, its gradient, and/or its hessian, depending on the needs of optimizer :optimizer_parameters: Optimizer::ParameterStruct object that describes the parameters for optimization (e.g., number of iterations, tolerances, scale factors, etc.) :domain: object specifying the domain to optimize over (see gpp_domain.hpp) :thread_schedule: struct instructing OpenMP on how to schedule threads; i.e., max_num_threads, schedule type, chunk_size :initial_guesses[problem_size][num_multistarts]: list of points at which to start optimization runs; all points must lie INSIDE the specified domain :num_multistarts: number of random points to use from initial guesses :objective_state_vector[thread_schedule.max_num_threads]: properly constructed/configured ObjectiveFunctionEvaluator::State objects, at least one per thread objective_state.GetCurrentPoint() will be used to obtain the initial guess :io_container[1]: object with best_objective_value_so_far and corresponding best_point properly initialized. See struct docs in gpp_optimization.hpp for details. \\output :objective_state_vector[thread_schedule.max_num_threads]: internal states of state objects may be modified :function_values[num_multistarts]: objective fcn value at the end of each optimization run, in the same order as initial_guesses. Can be used to check what each optimization run converged to. More commonly used only with NullOptimizer to get a list of objective values at each point of initial_guesses. Never dereferenced if nullptr. :io_container[1]: object container new best_objective_value_so_far and corresponding best_point IF found_flag is true. Unchanged from input otherwise. See struct docs in gpp_optimization.hpp for details. \\raise if any of objective_state_vector->SetCurrentPoint(), optimizer.Optimize(), or objective_evaluator.ComputeObjectiveFunction() throws, the exception (or one of the exceptions in the event of multiple throws due to threading, usually the first temporally) will be saved and rethrown by this function. io_container will be in a valid state; function_values may not. \\endrst Declaration void optimal_learning::MultistartOptimizer<Optimizer_>::MultistartOptimize(const Optimizer&optimizer, const ObjectiveFunctionEvaluator&objective_evaluator, const ParameterStruct&optimizer_parameters, const DomainType&domain, const ThreadSchedule&thread_schedule, double const *restrict initial_guesses, int num_multistarts, typename ObjectiveFunctionEvaluator::StateType *objective_state_vector, double *restrict function_values, OptimizationIOContainer *restrict io_container) OL_DISALLOW_COPY_AND_ASSIGN() Declaration optimal_learning::MultistartOptimizer<Optimizer_>::OL_DISALLOW_COPY_AND_ASSIGN(MultistartOptimizer)"
  },
  "api/optimal/learning/newton-optimizer.html": {
    "href": "api/optimal/learning/newton-optimizer.html",
    "title": "Class optimal_learning::NewtonOptimizer | qiotoolkit",
    "keywords": "Class optimal_learning::NewtonOptimizer \\rst Newton optimization. This class optimizes using Newton's method with a refinement step (see comments on the Optimize()) function. \\endrst Inheritance optimal_learning::NewtonOptimizer Constructors NewtonOptimizer() Declaration optimal_learning::NewtonOptimizer<ObjectiveFunctionEvaluator_, DomainType_>::NewtonOptimizer()=default Methods Optimize() \\rst Uses Newton's Method to optimize the value of an objective function, f (e.g., log marginal likelihood). .. NOTE:: this function wraps NewtonOptimization(), see above. It first calls that function directly, then calls it again with a modified newton_parameters struct: the param struct is modified to run newton with a small number of iterations at a huge time_factor (to remove the diagonal dominance adjustment entirely). We do this to ensure that Newton has converged. See section 2b) and 3b, ii) in the header docs and the docs for NewtonOptimization() for more details. Solution is guaranteed to lie within the region specified by \"domain\"; note that this may not be a true optima (i.e., the gradient may be substantially nonzero). problem_size refers to objective_state->GetProblemSize(), the number of dimensions in a \"point\" aka the number of variables being optimized. (This might be the spatial dimension for EI or the number of hyperparameters for log likelihood.) :objective_evaluator reference to object that can compute the objective function and its gradient :newton_parameters: NewtonParameters object that describes the parameters newton optimization (e.g., number of iterations, tolerances, additional diagonal dominance) :domain: object specifying the domain to optimize over (see gpp_domain.hpp) :objective_state[1]: a properly configured state object for the ObjectiveFunctionEvaluator template parameter objective_state.GetCurrentPoint() will be used to obtain the initial guess \\output :objective_state[1]: a state object whose temporary data members may have been modified objective_state.GetCurrentPoint() will return the point yielding the best objective function value according to newton number of errors \\endrst Declaration int optimal_learning::NewtonOptimizer<ObjectiveFunctionEvaluator_, DomainType_>::Optimize(const ObjectiveFunctionEvaluator&objective_evaluator, const ParameterStruct&newton_parameters, const DomainType&domain, typename ObjectiveFunctionEvaluator::StateType *objective_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT OL_DISALLOW_COPY_AND_ASSIGN() Declaration optimal_learning::NewtonOptimizer<ObjectiveFunctionEvaluator_, DomainType_>::OL_DISALLOW_COPY_AND_ASSIGN(NewtonOptimizer)"
  },
  "api/optimal/learning/newton-parameters.html": {
    "href": "api/optimal/learning/newton-parameters.html",
    "title": "Struct optimal_learning::NewtonParameters | qiotoolkit",
    "keywords": "Struct optimal_learning::NewtonParameters \\rst Container to hold parameters that specify the behavior of Newton. .. Note:: these comments are copied in build_newton_parameters() in cpp_wrappers/optimizer_parameters.py. That function wraps this struct's ctor. Diagonal dominance control: gamma and time_factor** On i-th newton iteration, we add 1/(time_factor*gamma^{i+1}) * I to the Hessian to improve robustness Choosing a small gamma (e.g., 1.0 < gamma <= 1.01) and time_factor (e.g., 0 < time_factor <= 1.0e-3) leads to more consistent/stable convergence at the cost of slower performance (and in fact for gamma or time_factor too small, gradient descent is preferred). Conversely, choosing more aggressive values may lead to very fast convergence at the cost of more cases failing to converge. gamma = 1.01, time_factor = 1.0e-3 should lead to good robustness at reasonable speed. This should be a fairly safe default. gamma = 1.05, time_factor = 1.0e-1 will be several times faster but not as robust. for \"easy\" problems, these can be much more aggressive, e.g., gamma = 2.0, time_factor = 1.0e1 or more. \\endrst Constructors NewtonParameters() Declaration optimal_learning::NewtonParameters::NewtonParameters()=delete NewtonParameters() \\rst Construct a NewtonParameters object. Default, copy, and assignment constructor are disallowed. INPUTS: See member declarations below for a description of each parameter. \\endrst Declaration optimal_learning::NewtonParameters::NewtonParameters(int num_multistarts_in, int max_num_steps_in, double gamma_in, double time_factor_in, double max_relative_change_in, double tolerance_in) NewtonParameters() Declaration optimal_learning::NewtonParameters::NewtonParameters(NewtonParameters&&OL_UNUSED(other))=default"
  },
  "api/optimal/learning/normal-rng.html": {
    "href": "api/optimal/learning/normal-rng.html",
    "title": "Class optimal_learning::NormalRNG | qiotoolkit",
    "keywords": "Class optimal_learning::NormalRNG \\rst Functor for computing normally distributed (N(0, 1)) random numbers. Uses/maintains an uniform RNG (currently UniformRandomGenerator) and transforms the output to be distributed ~ N(0, 1). .. Note:: seed values take type EngineType::result_type. Do not pass in a wider integer type! .. WARNING:: this class is NOT THREAD-SAFE. You must construct one object per thread (and ensure that the seeds are different for practical computations). \\endrst Inheritance optimal_learning::NormalRNGInterface optimal_learning::NormalRNG Inherited Members ~NormalRNGInterface Constructors NormalRNG() \\rst Default-constructs a NormalRNG, seeding with kDefaultSeed. \\endrst Declaration optimal_learning::NormalRNG::NormalRNG() noexcept NormalRNG() \\rst Construct a NormalRNG, seeding with the specified seed. See NormalRNG::SetExplicitSeed for details. :seed new seed to set \\endrst Declaration optimal_learning::NormalRNG::NormalRNG(EngineType::result_type seed) noexcept NormalRNG() \\rst Construct a NormalRNG, seeding with an automatically selected seed based on time, thread_id, etc. See NormalRNG::SetRandomizedSeed for details. :base_seed base value for the new seed :thread_id: id of the thread using this object \\endrst Declaration optimal_learning::NormalRNG::NormalRNG(EngineType::result_type seed, int thread_id) noexcept Methods GetEngine() \\rst Get a reference to the RNG engine used by this class. reference to the underlying RNG engine \\endrst Declaration EngineType&optimal_learning::NormalRNG::GetEngine() noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT operator()() \\rst Generate a random number from standard normal distribution. a random number from a standard (N(0, 1)) normal distribution \\endrst Declaration double optimal_learning::NormalRNG::operator()() last_seed() Declaration EngineType::result_type optimal_learning::NormalRNG::last_seed() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT ResetGenerator() \\rst Clears state of normal_distribution_ so that future uses do not depend on any previous actions. This is important: the underlying normal distribution likely generates numbers \\emph{two} at a time. So re-seeding the engine WITHOUT resetting can lead to surprising behavior. \\endrst Declaration void optimal_learning::NormalRNG::ResetGenerator() noexcept SetExplicitSeed() \\rst Seed the random number generator with the input value. See UniformRandomGenerator::SetExplicitSeed() for more information. :seed new seed to set \\endrst Declaration void optimal_learning::NormalRNG::SetExplicitSeed(EngineType::result_type seed) noexcept SetRandomizedSeed() \\rst Set a new seed for the random number generator. A \"random\" seed is selected based on the input seed value, the current time, and the thread_id. See UniformRandomGenerator::SetExplicitSeed() for more information. :seed base value for the new seed :thread_id: id of the thread using this object \\endrst Declaration void optimal_learning::NormalRNG::SetRandomizedSeed(EngineType::result_type seed, int thread_id) noexcept ResetToMostRecentSeed() \\rst Reseeds the generator with its most recently specified seed value. Useful for testinge.g., can conduct multiple runs with the same initial conditions \\endrst Declaration void optimal_learning::NormalRNG::ResetToMostRecentSeed() noexcept PrintState() \\rst Prints the state of the generator to specified ostream. For testing. :out_stream[1] a std::ostream object ready for operator<< use \\output :out_stream[1]: std::ostream with engine state <<'d to it \\endrst Declaration void optimal_learning::NormalRNG::PrintState(std::ostream *out_stream) const OL_NONNULL_POINTERS"
  },
  "api/optimal/learning/normal-rnginterface.html": {
    "href": "api/optimal/learning/normal-rnginterface.html",
    "title": "Class optimal_learning::NormalRNGInterface | qiotoolkit",
    "keywords": "Class optimal_learning::NormalRNGInterface \\rst Abstract class for a functor for generating random numbers distributed ~ N(0, 1) (i.e., standard normal). This interface currently does not specify many facilities for seeding the underlying RNG as these (particularly variable width) can vary by implementation. This class only has pure virtual functions. \\endrst Inheritance optimal_learning::NormalRNGInterface optimal_learning::NormalRNG optimal_learning::NormalRNGSimulator Methods operator()() \\rst Generate a random number from standard normal distribution. a random number from a standard (N(0, 1)) normal distribution \\endrst Declaration virtual double optimal_learning::NormalRNGInterface::operator()()=0 ResetToMostRecentSeed() \\rst Reseeds the generator with its most recently specified seed value. Useful for testinge.g., can conduct multiple runs with the same initial conditions \\endrst Declaration virtual void optimal_learning::NormalRNGInterface::ResetToMostRecentSeed() noexcept=0 ~NormalRNGInterface() Declaration virtual optimal_learning::NormalRNGInterface::~NormalRNGInterface()=default"
  },
  "api/optimal/learning/normal-rngsimulator.html": {
    "href": "api/optimal/learning/normal-rngsimulator.html",
    "title": "Class optimal_learning::NormalRNGSimulator | qiotoolkit",
    "keywords": "Class optimal_learning::NormalRNGSimulator \\rst RNG that generates normally distributed (N(0,1)) random numbers simply by reading random numbers stored in its \"random_number_table\", a data member in this class. .. Note:: this class is used in unit test only, and you have to be careful to ensure the total number of random numbers generated from last reset must be smaller than size of \"random_number_table\", otherwise exception will be thrown. .. Warning:: this class is NOT THREAD-SAFE. You must construct one object per thread. \\endrst Inheritance optimal_learning::NormalRNGInterface optimal_learning::NormalRNGSimulator Inherited Members ~NormalRNGInterface Constructors NormalRNGSimulator() \\rst Construct a NormalRNGSimulator by providing table storing random numbers, and size of this random table. :random_number_table_in pointer to the table storing random numbers :size_of_table_in: size of the random table \\endrst Declaration optimal_learning::NormalRNGSimulator::NormalRNGSimulator(const std::vector<double>&random_number_table_in) Methods operator()() \\rst Generate a random number from standard normal distribution. a random number from a standard (N(0, 1)) normal distribution \\endrst Declaration double optimal_learning::NormalRNGSimulator::operator()() ResetToMostRecentSeed() \\rst Reseeds the generator with its most recently specified seed value. Useful for testinge.g., can conduct multiple runs with the same initial conditions \\endrst Declaration void optimal_learning::NormalRNGSimulator::ResetToMostRecentSeed() noexcept index() Declaration int optimal_learning::NormalRNGSimulator::index() const OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::NormalRNGSimulator::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(NormalRNGSimulator)"
  },
  "api/optimal/learning/null-optimizer.html": {
    "href": "api/optimal/learning/null-optimizer.html",
    "title": "Class optimal_learning::NullOptimizer | qiotoolkit",
    "keywords": "Class optimal_learning::NullOptimizer \\rst The \"null\" or identity optimizer: it does nothing, giving the same output its inputs This is useful to allow the multistart optimizer template to be reused for 'dumb' searches and nontrivial optimization. In the former, we just need to evaluate the objective at each initial guess, so there is no optimization to be done at each point (hence null optimizer). In the latter, we kick off an optimization run (e.g., gradient descent, newton) at each initial guess. \\endrst Inheritance optimal_learning::NullOptimizer Constructors NullOptimizer() Declaration optimal_learning::NullOptimizer<ObjectiveFunctionEvaluator_, DomainType_>::NullOptimizer()=default Methods Optimize() \\rst Perform a null optimization: this does nothing. :objective_state[1] a properly configured state object for the ObjectiveFunctionEvaluator template parameter objective_state.GetCurrentPoint() will be used to obtain the initial guess \\output :objective_state[1]: a state object whose temporary data members may have been modified objective_state.GetCurrentPoint() will return the point as the intial guess number of errors, always 0 \\endrst Declaration int optimal_learning::NullOptimizer<ObjectiveFunctionEvaluator_, DomainType_>::Optimize(const ObjectiveFunctionEvaluator&OL_UNUSED(objective_evaluator), const ParameterStruct&OL_UNUSED(parameters), const DomainType&OL_UNUSED(domain), typename ObjectiveFunctionEvaluator::StateType *OL_UNUSED(objective_state)) const noexcept OL_NONNULL_POINTERS OL_PURE_FUNCTION OL_DISALLOW_COPY_AND_ASSIGN() Declaration optimal_learning::NullOptimizer<ObjectiveFunctionEvaluator_, DomainType_>::OL_DISALLOW_COPY_AND_ASSIGN(NullOptimizer)"
  },
  "api/optimal/learning/null-parameters.html": {
    "href": "api/optimal/learning/null-parameters.html",
    "title": "Struct optimal_learning::NullParameters | qiotoolkit",
    "keywords": "Struct optimal_learning::NullParameters \\rst Empty container for optimizers that do not require any parameters (e.g., the null optimizer). \\endrst"
  },
  "api/optimal/learning/one-potential-sample-expected-improvement-evaluator.html": {
    "href": "api/optimal/learning/one-potential-sample-expected-improvement-evaluator.html",
    "title": "Class optimal_learning::OnePotentialSampleExpectedImprovementEvaluator | qiotoolkit",
    "keywords": "Class optimal_learning::OnePotentialSampleExpectedImprovementEvaluator \\rst This is a specialization of the ExpectedImprovementEvaluator class for when the number of potential samples is 1; i.e., num_to_sample == 1 and the number of concurrent samples is 0; i.e. num_being_sampled == 0. In other words, this class only supports the computation of 1,0-EI. In this case, we have analytic formulas for computing EI and its gradient. Thus this class does not perform any explicit numerical integration, nor do its EI functions require access to a random number generator. This class's methods have some parameters that are unused or redundant. This is so that the interface matches that of the more general ExpectedImprovementEvaluator. For other details, see ExpectedImprovementEvaluator for more complete description of what EI is and the outputs of EI and grad EI computations. \\endrst Inheritance optimal_learning::OnePotentialSampleExpectedImprovementEvaluator Constructors OnePotentialSampleExpectedImprovementEvaluator() \\rst Constructs a OnePotentialSampleExpectedImprovementEvaluator object. All inputs are required; no default constructor nor copy/assignment are allowed. :gaussian_process GaussianProcess object (holds points_sampled, values, noise_variance, derived quantities) that describes the underlying GP :best_so_far: best (minimum) objective function value (in points_sampled_value) \\endrst Declaration optimal_learning::OnePotentialSampleExpectedImprovementEvaluator::OnePotentialSampleExpectedImprovementEvaluator(const GaussianProcess&gaussian_process_in, double best_so_far) OnePotentialSampleExpectedImprovementEvaluator() Declaration optimal_learning::OnePotentialSampleExpectedImprovementEvaluator::OnePotentialSampleExpectedImprovementEvaluator(OnePotentialSampleExpectedImprovementEvaluator&&other) Methods dim() Declaration int optimal_learning::OnePotentialSampleExpectedImprovementEvaluator::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT best_so_far() Declaration double optimal_learning::OnePotentialSampleExpectedImprovementEvaluator::best_so_far() noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT gaussian_process() Declaration const GaussianProcess* optimal_learning::OnePotentialSampleExpectedImprovementEvaluator::gaussian_process() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT ComputeObjectiveFunction() \\rst Wrapper for ComputeExpectedImprovement(); see that function for details. \\endrst Declaration double optimal_learning::OnePotentialSampleExpectedImprovementEvaluator::ComputeObjectiveFunction(StateType *ei_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradObjectiveFunction() \\rst Wrapper for ComputeGradExpectedImprovement(); see that function for details. \\endrst Declaration void optimal_learning::OnePotentialSampleExpectedImprovementEvaluator::ComputeGradObjectiveFunction(StateType *ei_state, double *restrict grad_EI) const OL_NONNULL_POINTERS ComputeExpectedImprovement() \\rst Computes the expected improvement EI(Xs) = E_n[[f^*_n(X) - min(f(Xs_1),...,f(Xs_m))]^+] Uses analytic formulas to evaluate the expected improvement. :ei_state[1] properly configured state object \\output :ei_state[1]: state with temporary storage modified the expected improvement from sampling point_to_sample \\endrst Declaration double optimal_learning::OnePotentialSampleExpectedImprovementEvaluator::ComputeExpectedImprovement(StateType *ei_state) const ComputeGradExpectedImprovement() \\rst Computes the (partial) derivatives of the expected improvement with respect to the point to sample. Uses analytic formulas to evaluate the spatial gradient of the expected improvement. :ei_state[1] properly configured state object \\output :ei_state[1]: state with temporary storage modified :grad_EI[dim]: gradient of EI, \\pderiv{EI(x)}{x_d}, where x is points_to_sample \\endrst Declaration void optimal_learning::OnePotentialSampleExpectedImprovementEvaluator::ComputeGradExpectedImprovement(StateType *ei_state, double *restrict grad_EI) const OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::OnePotentialSampleExpectedImprovementEvaluator::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(OnePotentialSampleExpectedImprovementEvaluator)"
  },
  "api/optimal/learning/one-potential-sample-expected-improvement-mcmcevaluator.html": {
    "href": "api/optimal/learning/one-potential-sample-expected-improvement-mcmcevaluator.html",
    "title": "Class optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator | qiotoolkit",
    "keywords": "Class optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator \\rst A class to encapsulate the computation of knowledge gradient and its spatial gradient. This class handles the general KG computation case using monte carlo integration; it can support q,p-KG optimization. It is designed to work with any GaussianProcess. Additionally, this class has no state and within the context of KG optimization, it is meant to be accessed by const reference only. The random numbers needed for KG computation will be passed as parameters instead of contained as members to make multithreading more straightforward. \\endrst Inheritance optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator Constructors OnePotentialSampleExpectedImprovementMCMCEvaluator() \\rst Constructs a KnowledgeGradientEvaluator object. All inputs are required; no default constructor nor copy/assignment are allowed. :gaussian_process GaussianProcess object (holds points_sampled, values, noise_variance, derived quantities) that describes the underlying GP :discrete_pts[dim][num_pts]: the set of points to approximate the KG factor :num_pts: number of points in discrete_pts :num_mc_iterations: number of monte carlo iterations :best_so_far: best (minimum) objective function value (in points_sampled_value) \\endrst Declaration optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator::OnePotentialSampleExpectedImprovementMCMCEvaluator(const GaussianProcessMCMC&gaussian_process_mcmc, double const *best_so_far, std::vector<typename OnePotentialSampleExpectedImprovementState::EvaluatorType>*evaluator_vector) Methods dim() Declaration int optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_mcmc() Declaration int optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator::num_mcmc() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT expected_improvement_evaluator_list() Declaration std::vector<OnePotentialSampleExpectedImprovementEvaluator>* optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator::expected_improvement_evaluator_list() const noexcept OL_WARN_UNUSED_RESULT best_so_far_list() Declaration std::vector<double>optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator::best_so_far_list(double const *best_so_far) const noexcept OL_WARN_UNUSED_RESULT ComputeObjectiveFunction() \\rst Wrapper for ComputeKnowledgeGradient(); see that function for details. \\endrst Declaration double optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator::ComputeObjectiveFunction(StateType *ei_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradObjectiveFunction() \\rst Wrapper for ComputeGradKnowledgeGradient(); see that function for details. \\endrst Declaration void optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator::ComputeGradObjectiveFunction(StateType *ei_state, double *restrict grad_EI) const OL_NONNULL_POINTERS ComputeExpectedImprovement() \\rst Computes the knowledge gradient :kg_state[1] properly configured state object \\output :kg_state[1]: state with temporary storage modified; normal_rng modified the knowledge gradient from sampling points_to_sample with points_being_sampled concurrent experiments \\endrst \\rst Compute Knowledge Gradient This version requires the discretization of A (the feasibe domain). The discretization usually is: some set + points previous sampled + points being sampled + points to sample \\endrst Declaration double optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator::ComputeExpectedImprovement(StateType *ei_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradExpectedImprovement() \\rst Computes the (partial) derivatives of the knowledge gradient with respect to each point of points_to_sample. As with ComputeKnowledgeGradient(), this computation accounts for the effect of points_being_sampled concurrent experiments. points_to_sample is the \"q\" and points_being_sampled is the \"p\" in q,p-KG. :kg_state[1] properly configured state object \\output :kg_state[1]: state with temporary storage modified; normal_rng modified :grad_KG[dim][num_to_sample]: gradient of KG, \\pderiv{KG(Xq \\cup Xp)}{Xq_{d,i}} where Xq is points_to_sample and Xp is points_being_sampled (grad KG from sampling points_to_sample with points_being_sampled concurrent experiments wrt each dimension of the points in points_to_sample) \\endrst \\rst Computes gradient of KG (see KnowledgeGradientEvaluator::ComputeGradKnowledgeGradient) wrt points_to_sample (stored in union_of_points[0:num_to_sample]). Mechanism is similar to the computation of KG, where points' contributions to the gradient are thrown out of their corresponding improvement <= 0.0. Thus \\nabla(\\mu) only contributes when the winner (point w/best improvement this iteration) is the current point. That is, the gradient of \\mu at x_i wrt x_j is 0 unless i == j (and only this result is stored in kg_state->grad_mu). The interaction with kg_state->grad_chol_decomp is harder to know a priori (like with grad_mu) and has a more complex structure (rank 3 tensor), so the derivative wrt x_j is computed fully, and the relevant submatrix (indexed by the current winner) is accessed each iteration. .. Note:: comments here are copied to _compute_grad_knowledge_gradient_monte_carlo() in python_version/knowledge_gradient.py \\endrst Declaration void optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator::ComputeGradExpectedImprovement(StateType *ei_state, double *restrict grad_EI) const OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::OnePotentialSampleExpectedImprovementMCMCEvaluator::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(OnePotentialSampleExpectedImprovementMCMCEvaluator)"
  },
  "api/optimal/learning/one-potential-sample-expected-improvement-mcmcstate.html": {
    "href": "api/optimal/learning/one-potential-sample-expected-improvement-mcmcstate.html",
    "title": "Struct optimal_learning::OnePotentialSampleExpectedImprovementMCMCState | qiotoolkit",
    "keywords": "Struct optimal_learning::OnePotentialSampleExpectedImprovementMCMCState \\rst State object for KnowledgeGradientEvaluator. This tracks the points being sampled in concurrent experiments (points_being_sampled) ALONG with the points currently being evaluated via knowledge gradient for future experiments (called points_to_sample); these are the p and q of q,p-KG, respectively. points_to_sample joined with points_being_sampled is stored in union_of_points in that order. This struct also tracks the state of the GaussianProcess that underlies the knowledge gradient computation: the GP state is built to handle the initial union_of_points, and subsequent updates to points_to_sample in this object also update the GP state. This struct also holds a pointer to a random number generator needed for Monte Carlo integrated KG computations. .. WARNING:: Users MUST guarantee that multiple state objects DO NOT point to the same RNG (in a multithreaded env). See general comments on State structs in gpp_common.hpp's header docs. \\endrst Constructors OnePotentialSampleExpectedImprovementMCMCState() \\rst Constructs an KnowledgeGradientMCMCState object with a specified source of randomness for the purpose of computing KG (and its gradient) over the specified set of points to sample. This establishes properly sized/initialized temporaries for KG computation, including dependent state from the associated Gaussian Process (which arrives as part of the kg_evaluator). .. WARNING:: This object is invalidated if the associated kg_evaluator is mutated. SetupState() should be called to reset. .. WARNING:: Using this object to compute gradients when configure_for_gradients := false results in UNDEFINED BEHAVIOR. :kg_evaluator knowledge gradient evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: points at which to evaluate KG and/or its gradient to check their value in future experiments (i.e., test points for GP predictions) :points_being_sampled[dim][num_being_sampled]: points being sampled in concurrent experiments :num_to_sample: number of potential future samples; gradients are evaluated wrt these points (i.e., the \"q\" in q,p-KG) :num_being_sampled: number of points being sampled in concurrent experiments (i.e., the \"p\" in q,p-KG) :configure_for_gradients: true if this object will be used to compute gradients, false otherwise :normal_rng[1]: pointer to a properly initialized* NormalRNG object .. NOTE:: The NormalRNG object must already be seeded. If multithreaded computation is used for KG, then every state object must have a different NormalRNG (different seeds, not just different objects). \\endrst Declaration optimal_learning::OnePotentialSampleExpectedImprovementMCMCState::OnePotentialSampleExpectedImprovementMCMCState(const EvaluatorType&ei_evaluator, double const *restrict point_to_sample, double const *restrict OL_UNUSED(points_being_sampled), int OL_UNUSED(num_to_sample_in), int OL_UNUSED(num_being_sampled_in), bool configure_for_gradients, NormalRNGInterface *OL_UNUSED(normal_rng_in), std::vector<typename OnePotentialSampleExpectedImprovementEvaluator::StateType>*ei_state_vector) OnePotentialSampleExpectedImprovementMCMCState() Declaration optimal_learning::OnePotentialSampleExpectedImprovementMCMCState::OnePotentialSampleExpectedImprovementMCMCState(OnePotentialSampleExpectedImprovementMCMCState&&other) Methods GetProblemSize() Declaration int optimal_learning::OnePotentialSampleExpectedImprovementMCMCState::GetProblemSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT GetCurrentPoint() \\rst Get the points_to_sample: potential future samples whose KG (and/or gradients) are being evaluated \\output :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::OnePotentialSampleExpectedImprovementMCMCState::GetCurrentPoint(double *restrict points_to_sample) const noexcept OL_NONNULL_POINTERS SetCurrentPoint() \\rst Change the potential samples whose KG (and/or gradient) are being evaluated. Update the state's derived quantities to be consistent with the new points. :kg_evaluator expected improvement evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::OnePotentialSampleExpectedImprovementMCMCState::SetCurrentPoint(const EvaluatorType&kg_evaluator, double const *restrict points_to_sample_in) OL_NONNULL_POINTERS SetupState() \\rst Configures this state object with new points_to_sample, the location of the potential samples whose KG is to be evaluated. Ensures all state variables & temporaries are properly sized. Properly sets all dependent state variables (e.g., GaussianProcess's state) for KG evaluation. .. WARNING:: This object's state is INVALIDATED if the kg_evaluator (including the GaussianProcess it depends on) used in SetupState is mutated! SetupState() should be called again in such a situation. :kg_evaluator knowledge gradient evaluator object that specifies the parameters & GP for KG evaluation :points_to_sample[dim][num_to_sample]: potential future samples whose KG (and/or gradients) are being evaluated \\endrst Declaration void optimal_learning::OnePotentialSampleExpectedImprovementMCMCState::SetupState(const EvaluatorType&ei_evaluator, double const *restrict points_to_sample) OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::OnePotentialSampleExpectedImprovementMCMCState::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(OnePotentialSampleExpectedImprovementMCMCState)"
  },
  "api/optimal/learning/one-potential-sample-expected-improvement-state.html": {
    "href": "api/optimal/learning/one-potential-sample-expected-improvement-state.html",
    "title": "Struct optimal_learning::OnePotentialSampleExpectedImprovementState | qiotoolkit",
    "keywords": "Struct optimal_learning::OnePotentialSampleExpectedImprovementState \\rst State object for OnePotentialSampleExpectedImprovementEvaluator. This tracks the ONE point_to_sample being evaluated via expected improvement. This is just a special case of ExpectedImprovementState; see those class docs for more details. See general comments on State structs in gpp_common.hpp's header docs. \\endrst Constructors OnePotentialSampleExpectedImprovementState() \\rst Constructs an OnePotentialSampleExpectedImprovementState object for the purpose of computing EI (and its gradient) over the specified point to sample. This establishes properly sized/initialized temporaries for EI computation, including dependent state from the associated Gaussian Process (which arrives as part of the ei_evaluator). .. WARNING:: This object is invalidated if the associated ei_evaluator is mutated. SetupState() should be called to reset. .. WARNING:: Using this object to compute gradients when configure_for_gradients := false results in UNDEFINED BEHAVIOR. :ei_evaluator expected improvement evaluator object that specifies the parameters & GP for EI evaluation :point_to_sample[dim]: point at which to evaluate EI and/or its gradient to check their value in future experiments (i.e., test point for GP predictions) :configure_for_gradients: true if this object will be used to compute gradients, false otherwise \\endrst Declaration optimal_learning::OnePotentialSampleExpectedImprovementState::OnePotentialSampleExpectedImprovementState(const EvaluatorType&ei_evaluator, double const *restrict point_to_sample_in, bool configure_for_gradients) OnePotentialSampleExpectedImprovementState() \\rst Constructor wrapper to match the signature of the ctor for ExpectedImprovementState(). \\endrst Declaration optimal_learning::OnePotentialSampleExpectedImprovementState::OnePotentialSampleExpectedImprovementState(const EvaluatorType&ei_evaluator, double const *restrict points_to_sample, double const *restrict OL_UNUSED(points_being_sampled), int OL_UNUSED(num_to_sample_in), int OL_UNUSED(num_being_sampled_in), bool configure_for_gradients, NormalRNGInterface *OL_UNUSED(normal_rng_in)) OnePotentialSampleExpectedImprovementState() Declaration optimal_learning::OnePotentialSampleExpectedImprovementState::OnePotentialSampleExpectedImprovementState(OnePotentialSampleExpectedImprovementState&&other) Methods GetProblemSize() Declaration int optimal_learning::OnePotentialSampleExpectedImprovementState::GetProblemSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT GetCurrentPoint() \\rst Get point_to_sample: the potential future sample whose EI (and/or gradients) is being evaluated \\output :point_to_sample[dim]: potential sample whose EI is being evaluted \\endrst Declaration void optimal_learning::OnePotentialSampleExpectedImprovementState::GetCurrentPoint(double *restrict point_to_sample_out) const noexcept OL_NONNULL_POINTERS SetCurrentPoint() \\rst Change the potential sample whose EI (and/or gradient) is being evaluated. Update the state's derived quantities to be consistent with the new point. :ei_evaluator expected improvement evaluator object that specifies the parameters & GP for EI evaluation :point_to_sample[dim]: potential future sample whose EI (and/or gradients) is being evaluated \\endrst Declaration void optimal_learning::OnePotentialSampleExpectedImprovementState::SetCurrentPoint(const EvaluatorType&ei_evaluator, double const *restrict point_to_sample_in) OL_NONNULL_POINTERS SetupState() \\rst Configures this state object with a new point_to_sample, the location of the potential sample whose EI is to be evaluated. Ensures all state variables & temporaries are properly sized. Properly sets all dependent state variables (e.g., GaussianProcess's state) for EI evaluation. .. WARNING:: This object's state is INVALIDATED if the ei_evaluator (including the GaussianProcess it depends on) used in SetupState is mutated! SetupState() should be called again in such a situation. :ei_evaluator expected improvement evaluator object that specifies the parameters & GP for EI evaluation :point_to_sample[dim]: potential future sample whose EI (and/or gradients) is being evaluated \\endrst Declaration void optimal_learning::OnePotentialSampleExpectedImprovementState::SetupState(const EvaluatorType&ei_evaluator, double const *restrict point_to_sample_in) OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::OnePotentialSampleExpectedImprovementState::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(OnePotentialSampleExpectedImprovementState)"
  },
  "api/optimal/learning/optimal-learning-exception.html": {
    "href": "api/optimal/learning/optimal-learning-exception.html",
    "title": "Class optimal_learning::OptimalLearningException | qiotoolkit",
    "keywords": "Class optimal_learning::OptimalLearningException \\rst Overview** Exception to handle general runtime errors (e.g., not fitting into other exception types). Subclasses std::exception. Serves as the superclass for all other custom exceptions in the optimal_learning library. This class is essentially the same as std::runtime_error but it includes a ctor with some extra logic for formatting the error message. Holds only a std::string containing the message produced by what(). .. Note: exceptions from std::string operations (e.g., std::bad_alloc) will cause std::terminate(). Message Format** The what() message is formatted in the class ctor (capitals indicate variable information):: R\"%%( OptimalLearningException: CUSTOM_MESSAGE FUNCTION_NAME FILE_LINE_INFO )%%\" This format should be overriden by subclasses (at the minimum showing a different exception name). \\endrst Inheritance optimal_learning::OptimalLearningException optimal_learning::BoundsException optimal_learning::InvalidValueException optimal_learning::SingularMatrixException Constructors OptimalLearningException() \\rst Constructs a OptimalLearningException with the specified message. :line_info[] ptr to char array containing FILE and LINE info; e.g., from OL_STRINGIFY_FILE_AND_LINE :func_info[]: optional ptr to char array from OL_CURRENT_FUNCTION_NAME or similar :custom_message[]: optional ptr to char array with any additional text/info to print/log \\endrst Declaration optimal_learning::OptimalLearningException::OptimalLearningException(char const *line_info, char const *func_info, char const *custom_message) OptimalLearningException() Declaration optimal_learning::OptimalLearningException::OptimalLearningException()=delete OptimalLearningException() \\rst Constructs a OptimalLearningException with the specified name. This is used by subclasses to override the class name in the message text. :name[] the exception name to write into the message \\endrst Declaration optimal_learning::OptimalLearningException::OptimalLearningException(char const *name) Methods what() \\rst Provides a C-string containing information about the conditions of the exception. See: http://en.cppreference.com/w/cpp/error/exception C-style char string describing the exception. \\endrst Declaration virtual const char* optimal_learning::OptimalLearningException::what() const noexcept override OL_WARN_UNUSED_RESULT AppendCustomMessageAndDebugInfo() \\rst Utility function to append some additional info (file/line number, function name, and/or a custom message) to a specified string. This is meant to be used for constructing what() messages for the exception classes in gpp_exception.hpp. :line_info[] ptr to char array containing FILE and LINE info; e.g., from OL_STRINGIFY_FILE_AND_LINE :func_info[]: optional ptr to char array from OL_CURRENT_FUNCTION_NAME or similar :custom_message[]: optional ptr to char array with any additional text/info to print/log \\endrst Declaration void optimal_learning::OptimalLearningException::AppendCustomMessageAndDebugInfo(char const *line_info, char const *func_info, char const *custom_message)"
  },
  "api/optimal/learning/optimization-iocontainer.html": {
    "href": "api/optimal/learning/optimization-iocontainer.html",
    "title": "Struct optimal_learning::OptimizationIOContainer | qiotoolkit",
    "keywords": "Struct optimal_learning::OptimizationIOContainer \\rst This object holds the input/output fields for optimizers (maximization). On input, this can be used to specify the current best known point (i.e., the optimizer will indicate no new optima found if it cannot beat this value). Upon completion, this struct should be read to determine the result of optimization. Since this object is used to communicate some inputs/outputs to the various optimization functions, any function using this object MUST obey its contract. The contract: On input, the optimizer will read best_objective_value_so_far. IF optimization results in a LARGER objective value, then: best_objective_value_so_far will be set to that new larger value best_point will be set to the point producing this new larger objective value found_flag will be SET to true ELSE: best_objective_value_so_far will be unmodified best_point will be unmodified found_flag will be SET to false The idea is for the user to be able to indicate what an improvement is. For example, to optimize log likelihood as a function of hyperparameters, we could do: best_point = argmax_{x \\in initial_guesses} f(x) best_objective_value = f(best_point) And then call multistart gradient descent (MGD). Now, MGD will only change the best point/value if it converges to a better solution. If convergence fails or MGD settles on a worse local maxima, found_flag will be SET to false, and the other fields of IOContainer will be unmodified. If it finds a better solution, then found_flag will be SET to true and the other fields will report the new solution. \\endrst Constructors OptimizationIOContainer() \\rst Build an empty OptimizationIOContainer. best_objective_value and best_point are initialized to zero; THIS MAY BE AN INVALID STATE. See class docs for details. :problem_size number of dimensions in the optimization problem (e.g., size of best_point) \\endrst Declaration optimal_learning::OptimizationIOContainer::OptimizationIOContainer(int problem_size_in) OptimizationIOContainer() \\rst Build and fully initialize a OptimizationIOContainer. See class docs for details. :problem_size number of dimensions in the optimization problem (e.g., size of best_point) :best_objective_value: the best objective function value seen so far :best_point: the point to associate with best_objective_value \\endrst Declaration optimal_learning::OptimizationIOContainer::OptimizationIOContainer(int problem_size_in, double best_objective_value, double const *restrict best_point_in) OptimizationIOContainer() Declaration optimal_learning::OptimizationIOContainer::OptimizationIOContainer(OptimizationIOContainer&&OL_UNUSED(other))=default Methods OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::OptimizationIOContainer::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(OptimizationIOContainer)"
  },
  "api/optimal/learning/pingable-matrix-input-vector-output-interface.html": {
    "href": "api/optimal/learning/pingable-matrix-input-vector-output-interface.html",
    "title": "Class optimal_learning::PingableMatrixInputVectorOutputInterface | qiotoolkit",
    "keywords": "Class optimal_learning::PingableMatrixInputVectorOutputInterface \\rst Class to enable numerical and analytic differentiation of functions of the form: f_{k} = f(X_{d,i}) with derivatives taken wrt each member of X_{d,i}, gradf_{k,d,i} = \\frac{\\partial f_k}{\\partial X_{d,i}} In the nomenclature used in the class: d indexes over num_rows (set in GetInputSizes()) i indexes over num_cols (set in GetInputSizes()) k indexes over GetOutputSize() Typically d is the spatial_dimension of the problem. So if i ranges over 1 .. num_points, then X_{d,i} is a matrix of num_points points each with dimension spatial_dim. And k refers to num_outputs. X_{d,i} can of course be any arbitrary matrix; d, i need not refer to spatial dimension and num_points. But that is currently the most common use case. This class enables easy pinging of a multitude of f, X combinations. Since it abstracts away indexing, it does not limit how implementations store/compute f() and its gradient. Generally, usage goes as follows: Use GetInputSizes(), GetOutputSize(), and possibly GetGradientsSize() to inspect the dimensions of the problem EvaluateAndStoreAnalyticGradient(): compute and internally store the gradient evaluated at a given input* GetAnalyticGradient: returns the value of the analytic gradient for a given output (k), wrt a given point (d,i) EvaluateFunction: returns all outputs of the function for a given input It is not necessary to fully evaluate the gradient here. Instead, the input point can be stored and evaluation can happen on-the-fly in GetAnalyticGradient() if desired. So to ping a derivative, you can: f_p = EvaluateFunction(X + h), f_m = EvaluateFunction(X - h) Compare: (f_p - f_m)/(2h) to GetAnalyticGradient See PingDerivative() docs for more details. \\endrst Inheritance optimal_learning::PingableMatrixInputVectorOutputInterface Constructors PingableMatrixInputVectorOutputInterface() Declaration optimal_learning::PingableMatrixInputVectorOutputInterface::PingableMatrixInputVectorOutputInterface()=default Methods GetInputSizes() \\rst Number of rows and columns of the input, X_{d,i}, to f(). For example, the input might be a N_d X N_i matrix, points_to_sample, where N_d = spatial dimension (rows) and N_i = number of points (columns). \\output :num_rows[1]: the number of rows of the input matrix X :num_cols[1]: the number of columns of the input matrix X \\endrst Declaration virtual void optimal_learning::PingableMatrixInputVectorOutputInterface::GetInputSizes(int *num_rows, int *num_cols) const noexcept OL_NONNULL_POINTERS=0 GetOutputSize() \\rst Number of outputs of the function f_k = f(X_{d,i}); i.e., length(f_k) The number of entries in f_k aka number of outputs of f() \\endrst Declaration virtual int optimal_learning::PingableMatrixInputVectorOutputInterface::GetOutputSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT=0 GetGradientsSize() \\rst Number of entries in the gradient of the output wrt each entry of the input. This should generally not be used unless you require direct access to the analytic gradient. MUST be num_rows*num_cols*GetOutputSize() invalid memory read/writes may occur \\endrst Declaration virtual int optimal_learning::PingableMatrixInputVectorOutputInterface::GetGradientsSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT=0 EvaluateAndStoreAnalyticGradient() \\rst Setup so that GetAnalyticGradient(row, column, output) will be able to return gradf[row][column][output] evaluated at X, \"input_matrix.\" Typically this will entail computing and storing the analytic gradient. But the only thing that needs to be saved is the contents of input_matrix for later access. MUST BE CALLED before using GetAnalyticGradient! :input_matrix[num_rows][num_cols] the input, X_{d,i} \\output :gradients[num_rows][num_cols][num_outputs]: filled with the gradient evaluated at input_matrix. Ignored if nullptr. IMPLEMENTATION NOT REQUIRED. \\endrst Declaration virtual void optimal_learning::PingableMatrixInputVectorOutputInterface::EvaluateAndStoreAnalyticGradient(double const *restrict input_matrix, double *restrict gradients) noexcept OL_NONNULL_POINTERS_LIST(2)=0 GetAnalyticGradient() \\rst The gradients are indexed by: dA[input_row][input_column][output_index], where row, column index the input matrix and output_index indexes the output. Returns the gradient computed/stored by EvaluateAndStoreAnalyticGradient(). :row_index row_index (d) of the input to be differentiated with respect to :column_index: column_index (i) of the input to be differentiated with respect to :output_index: (flat) index into the output The [row_index][column_index][output_index]'th entry of the analytic gradient evaluated at input_matrix (where input matrix was specified in EvaluateAndStoreAnalyticGradient()). \\endrst Declaration virtual double optimal_learning::PingableMatrixInputVectorOutputInterface::GetAnalyticGradient(int row_index, int column_index, int output_index) const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT=0 EvaluateFunction() \\rst Evalutes f_k = f(X_{d,i}). X_{d,i} is the \"input_matrix\" and f_k is in \"function_values.\" :input_matrix[num_rows][num_cols] the matrix of inputs \\output :function_values[num_outputs]: vector of outputs of f() \\endrst Declaration virtual void optimal_learning::PingableMatrixInputVectorOutputInterface::EvaluateFunction(double const *restrict input_matrix, double *restrict function_values) const noexcept OL_NONNULL_POINTERS=0 OL_DISALLOW_COPY_AND_ASSIGN() Declaration optimal_learning::PingableMatrixInputVectorOutputInterface::OL_DISALLOW_COPY_AND_ASSIGN(PingableMatrixInputVectorOutputInterface) ~PingableMatrixInputVectorOutputInterface() Declaration virtual optimal_learning::PingableMatrixInputVectorOutputInterface::~PingableMatrixInputVectorOutputInterface()=default"
  },
  "api/optimal/learning/plane.html": {
    "href": "api/optimal/learning/plane.html",
    "title": "Struct optimal_learning::Plane | qiotoolkit",
    "keywords": "Struct optimal_learning::Plane \\rst We specify a plane in dim-space using the Hesse (or Hessian) Normal Form: http://mathworld.wolfram.com/HessianNormalForm.html The equation of plane requires dim + 1 real numbers: \\ms a_0 + \\sum_{i=0}^{dim} n_i x_i = 0\\me Hence we can describe any plane as a vector, \\ms [n_0, n_2, ..., n_{dim-1}]\\me, and a real number, \\ms a_0\\me. Let \\ms n_{vec} = [n_0, ..., n_{dim-1}]\\me be the (outward) unit normal vector. By convention, \\ms |n_{vec}|2 = 1\\me. \\ms a_0\\me is the signed distance to the origin. This is the distance from the plane to the origin in the direction of \\ms n{vec}\\me. Put another way, \\ms a_0\\me is positive if the origin is in the same half-space \"pointed to\" by \\ms n_{vec}\\me and negative otherwise. Note: \\ms a_0\\me is measured in units of \\ms |n_{vec}|\\me, so if it is not an unit vector, that is analogous to scaling \\ms a_0\\nme. As an example, let's consider 4 planes with dim = 2: \\ms a_0\\me = -1, and \\ms n_{vec}\\me = { 1.0, 0.0}: the plane x = 1 with rightward pointing normal. \\ms a_0\\me = -1, and \\ms n_{vec}\\me = {-1.0, 0.0}: the plane x = -1 with leftward pointing normal. \\ms a_0\\me = 1, and \\ms n_{vec}\\me = { 1.0, 0.0}: the plane x = -1 with rightward pointing normal. \\ms a_0\\me = 1, and \\ms n_{vec}\\me = {-1.0, 0.0}: the plane x = 1 with leftward pointing normal. Be careful with the signs. Another common way of specifying a plane is via a point \\ms x_0\\me and an unit normal, \\ms n_{vec}\\me. A point x is in the plane if and only if \\ms (x-x_0) \\cdot n_{vec} = 0\\me. Since \\ms x_0\\me is constant, we can precompute and store \\ms ms x_0 \\cdot n_{vec} = -a_0\\me, yielding: \\ms x \\cdot n_{vec} - x_0 \\cdot n_{vec} = x \\cdot n_{vec} + a_0\\me, which is our original equation of a plane. \\endrst Constructors Plane() Declaration optimal_learning::Plane::Plane()=delete Plane() \\rst Creates a zero-initialized plane object with enough space for dim-dimensions. .. NOTE:: This plane is invalid (unit_normal := zero is not a unit vector) and needs to have its members initialized. That said, no member functions will fail even without complete initialization. :dim the number of spatial dimensions \\endrst Declaration optimal_learning::Plane::Plane(int dim_in) Plane() \\rst Creates a plane in dim-dimensions with the specified unit normal (\\ms n_i\\me) and offset (\\ms a_0\\me): \\ms a_0 + \\sum_{i=0}^{dim} n_i * x_i = 0\\me .. NOTE:: Failure to specify a unit normal will result in surprising behavior. \\ms a_0\\me is really in units of \\ms|n_{vec}|\\me, so if \\ms|n_{vec}| = 3.5\\me, then the actual distance to the origin is \\ms 3.5 a_0\\me. :dim the number of spatial dimensions :unit_normal[dim]: the unit normal vector. VectorNorm(unit_normal, dim) must be 1.0 :offset: a_0, the signed distance to the origin (see class docs) \\endrst Declaration optimal_learning::Plane::Plane(double const *restrict unit_normal_in, double offset_in, int dim_in) OL_NONNULL_POINTERS Plane() \\rst Creates a plane in dim-dimensions that contains \"point,\" with the specified unit normal. :dim the number of spatial dimensions :unit_normal[dim]: the unit normal vector. VectorNorm(unit_normal, dim) must be 1.0 :point[dim]: a point contained in the plane \\endrst Declaration optimal_learning::Plane::Plane(double const *restrict unit_normal_in, double const *restrict point, int dim_in) OL_NONNULL_POINTERS Methods dim() \\rst the number of spatial dimensions (that this plane lives in) \\endrst Declaration int optimal_learning::Plane::dim() const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT OrthogonalDistanceToPoint() \\rst Computes the signed, shortest distance from this plane to point: positive means the point is in the half-space determined by the direction of unit_normal. .. Note:: if point is the origin, this yields precisely \\ms a_0\\me (offset). :point[dim] point to compute distance to signed, shortest distance from this plane to point, where positive means the point and normal are in the same half-space \\endrst Declaration double optimal_learning::Plane::OrthogonalDistanceToPoint(double const *restrict point) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT OrthogonalProjectionOntoPlane() \\rst Projects a point (orthogonally) onto a plane; i.e., finds the point on the plane that is closest to the input point. :point[dim] point to project onto plane \\output :point[dim]: point projected onto plane \\endrst Declaration void optimal_learning::Plane::OrthogonalProjectionOntoPlane(double *restrict point) const OL_NONNULL_POINTERS DistanceToPlaneAlongVector() \\rst Computes the signed distance from the specified point to this plane along the specified vector. This result is computed in units of \\ms|vector|_2\\me. That is, a distance of 3.14 means if we compute: new_point = 3.14*vector + point, then new_point will be on this plane. A negative distance means the plane is \"behind\" the ray. :point[dim] point to compute distance from :vector[dim]: vector to compute distance along Signed distance along the given vector; positive means the intersection is in the same direction as the vector. This result is in units of \\ms|vector|_2\\me; normalize vector if you want an actual distance. \\endrst Declaration double optimal_learning::Plane::DistanceToPlaneAlongVector(double const *restrict point, double const *restrict vector) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT"
  },
  "api/optimal/learning/points-to-sample-state.html": {
    "href": "api/optimal/learning/points-to-sample-state.html",
    "title": "Struct optimal_learning::PointsToSampleState | qiotoolkit",
    "keywords": "Struct optimal_learning::PointsToSampleState \\rst This object holds the state needed for a GaussianProcess object characterize the distribution of function values arising from sampling the GP at a list of points_to_sample. This object is required by the GaussianProcess to access functionality for computing the mean, variance, and spatial gradients thereof. The \"independent variables\" for this object are points_to_sample. These points are both the \"p\" and the \"q\" in q,p-EI; i.e., they are the parameters of both ongoing experiments and new predictions. Recall that in q,p-EI, the q points are called points_to_sample and the p points are called points_being_sampled. Here, we need to make predictions about both point sets with the GP, so we simply call the union of point sets points_to_sample. In GP computations, there is really no distinction between the \"q\" and \"p\" points from EI, points_to_sample and points_being_sampled, respectively. However, in EI optimization, we only need gradients of GP quantities wrt points_to_sample, so users should build PointsToSampleState() with num_derivatives = num_to_sample. Once constructed, this object provides the SetupState() function to update it for computations at different sets of potential points to sample. See general comments on State structs in gpp_common.hpp's header docs. \\endrst Constructors PointsToSampleState() \\rst Constructs a PointsToSampleState object with new points_to_sample. Ensures all state variables & temporaries are properly sized. Properly sets all state variables so that GaussianProcess's mean, variance (and gradients thereof) functions can be called. .. WARNING:: This object's state is INVALIDATED if the gaussian_process used in construction is mutated! SetupState() should be called again in such a situation. .. WARNING:: Using this object to compute gradients when num_derivatives := 0 results in UNDEFINED BEHAVIOR. :gaussian_process GaussianProcess object (holds points_sampled, values, noise_variance, derived quantities) that describes the underlying GP :points_to_sample[dim][num_to_sample]: points at which to compute GP-derived quantities (mean, variance, etc.) :num_to_sample: number of points being sampled concurrently :num_derivatives: configure this object to compute num_derivatives derivative terms wrt points_to_sample[:][0:num_derivatives]; 0 means no gradient computation will be performed. \\endrst Declaration optimal_learning::PointsToSampleState::PointsToSampleState(const GaussianProcess&gaussian_process, double const *restrict points_to_sample_in, int num_to_sample_in, int const *restrict gradients_in, int num_gradients_in, int num_derivatives_in, bool precomputed_in=true, bool precomputed_grad_K_inv_times_K_star_in=false) PointsToSampleState() Declaration optimal_learning::PointsToSampleState::PointsToSampleState(PointsToSampleState&&other) Methods SetupState() \\rst Configures this object with new points_to_sample. Ensures all state variables & temporaries are properly sized. Properly sets all state variables so that GaussianProcess's mean, variance (and gradients thereof) functions can be called. .. WARNING:: This object's state is INVALIDATED if the gaussian_process used in SetupState is mutated! SetupState() should be called again in such a situation. .. WARNING:: Using this object to compute gradients when num_derivatives := 0 results in UNDEFINED BEHAVIOR. :gaussian_process GaussianProcess object (holds points_sampled, values, noise_variance, derived quantities) that describes the underlying GP :points_to_sample[dim][num_to_sample]: points at which to compute GP-derived quantities (mean, variance, etc.) :num_to_sample: number of points being sampled concurrently :num_derivatives: configure this object to compute num_derivatives derivative terms wrt points_to_sample[:][0:num_derivatives]; 0 means no gradient computation will be performed. \\endrst Declaration void optimal_learning::PointsToSampleState::SetupState(const GaussianProcess&gaussian_process, double const *restrict points_to_sample_in, int num_to_sample_in, int num_gradients_in, int num_derivatives_in, bool precomputed_in=true, bool precomputed_grad_K_inv_times_K_star_in=false) OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() the gradient of covariance(x_1, x_2) wrt x_1 Declaration optimal_learning::PointsToSampleState::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(PointsToSampleState)"
  },
  "api/optimal/learning/posterior-mean-evaluator.html": {
    "href": "api/optimal/learning/posterior-mean-evaluator.html",
    "title": "Class optimal_learning::PosteriorMeanEvaluator | qiotoolkit",
    "keywords": "Class optimal_learning::PosteriorMeanEvaluator \\rst This is a specialization of the ExpectedImprovementEvaluator class for when the number of potential samples is 1; i.e., num_to_sample == 1 and the number of concurrent samples is 0; i.e. num_being_sampled == 0. In other words, this class only supports the computation of 1,0-EI. In this case, we have analytic formulas for computing EI and its gradient. Thus this class does not perform any explicit numerical integration, nor do its EI functions require access to a random number generator. This class's methods have some parameters that are unused or redundant. This is so that the interface matches that of the more general ExpectedImprovementEvaluator. For other details, see ExpectedImprovementEvaluator for more complete description of what EI is and the outputs of EI and grad EI computations. \\endrst Inheritance optimal_learning::PosteriorMeanEvaluator Constructors PosteriorMeanEvaluator() \\rst Constructs a OnePotentialSampleExpectedImprovementEvaluator object. All inputs are required; no default constructor nor copy/assignment are allowed. :gaussian_process GaussianProcess object (holds points_sampled, values, noise_variance, derived quantities) that describes the underlying GP :best_so_far: best (minimum) objective function value (in points_sampled_value) \\endrst Declaration optimal_learning::PosteriorMeanEvaluator::PosteriorMeanEvaluator(const GaussianProcess&gaussian_process_in) Methods dim() Declaration int optimal_learning::PosteriorMeanEvaluator::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT gaussian_process() Declaration const GaussianProcess* optimal_learning::PosteriorMeanEvaluator::gaussian_process() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT ComputeObjectiveFunction() \\rst Wrapper for ComputeExpectedImprovement(); see that function for details. \\endrst Declaration double optimal_learning::PosteriorMeanEvaluator::ComputeObjectiveFunction(StateType *ps_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT ComputeGradObjectiveFunction() \\rst Wrapper for ComputeGradExpectedImprovement(); see that function for details. \\endrst Declaration void optimal_learning::PosteriorMeanEvaluator::ComputeGradObjectiveFunction(StateType *ps_state, double *restrict grad_PS) const OL_NONNULL_POINTERS ComputePosteriorMean() \\rst Computes the expected improvement EI(Xs) = E_n[[f^*_n(X) - min(f(Xs_1),...,f(Xs_m))]^+] Uses analytic formulas to evaluate the expected improvement. :ei_state[1] properly configured state object \\output :ei_state[1]: state with temporary storage modified the expected improvement from sampling point_to_sample \\endrst \\rst Uses analytic formulas to compute EI when num_to_sample = 1 and num_being_sampled = 0 (occurs only in 1,0-EI). In this case, the single-parameter (posterior) GP is just a Gaussian. So the integral in EI (previously eval'd with MC) can be computed 'exactly' using high-accuracy routines for the pdf & cdf of a Gaussian random variable. See Ginsbourger, Le Riche, and Carraro. \\endrst Declaration double optimal_learning::PosteriorMeanEvaluator::ComputePosteriorMean(StateType *ps_state) const ComputeGradPosteriorMean() \\rst Computes the (partial) derivatives of the expected improvement with respect to the point to sample. Uses analytic formulas to evaluate the spatial gradient of the expected improvement. :ei_state[1] properly configured state object \\output :ei_state[1]: state with temporary storage modified :grad_EI[dim]: gradient of EI, \\pderiv{EI(x)}{x_d}, where x is points_to_sample \\endrst \\rst Differentiates OnePotentialSampleExpectedImprovementEvaluator::ComputeExpectedImprovement wrt points_to_sample (which is just ONE point; i.e., 1,0-EI). Again, this uses analytic formulas in terms of the pdf & cdf of a Gaussian since the integral in EI (and grad EI) can be evaluated exactly for this low dimensional case. See Ginsbourger, Le Riche, and Carraro. \\endrst Declaration void optimal_learning::PosteriorMeanEvaluator::ComputeGradPosteriorMean(StateType *ps_state, double *restrict grad_PS) const OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::PosteriorMeanEvaluator::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(PosteriorMeanEvaluator)"
  },
  "api/optimal/learning/posterior-mean-state.html": {
    "href": "api/optimal/learning/posterior-mean-state.html",
    "title": "Struct optimal_learning::PosteriorMeanState | qiotoolkit",
    "keywords": "Struct optimal_learning::PosteriorMeanState \\rst State object for OnePotentialSampleExpectedImprovementEvaluator. This tracks the ONE point_to_sample being evaluated via expected improvement. This is just a special case of ExpectedImprovementState; see those class docs for more details. See general comments on State structs in gpp_common.hpp's header docs. \\endrst Constructors PosteriorMeanState() \\rst Constructs an OnePotentialSampleExpectedImprovementState object for the purpose of computing EI (and its gradient) over the specified point to sample. This establishes properly sized/initialized temporaries for EI computation, including dependent state from the associated Gaussian Process (which arrives as part of the ei_evaluator). .. WARNING:: This object is invalidated if the associated ei_evaluator is mutated. SetupState() should be called to reset. .. WARNING:: Using this object to compute gradients when configure_for_gradients := false results in UNDEFINED BEHAVIOR. :ei_evaluator expected improvement evaluator object that specifies the parameters & GP for EI evaluation :point_to_sample[dim]: point at which to evaluate EI and/or its gradient to check their value in future experiments (i.e., test point for GP predictions) :configure_for_gradients: true if this object will be used to compute gradients, false otherwise \\endrst Declaration optimal_learning::PosteriorMeanState::PosteriorMeanState(const EvaluatorType&ps_evaluator, const int num_fidelity_in, double const *restrict point_to_sample_in, bool configure_for_gradients) PosteriorMeanState() Declaration optimal_learning::PosteriorMeanState::PosteriorMeanState(PosteriorMeanState&&other) Methods GetProblemSize() Declaration int optimal_learning::PosteriorMeanState::GetProblemSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT BuildUnionOfPoints() Declaration std::vector<double>optimal_learning::PosteriorMeanState::BuildUnionOfPoints(double const *restrict points_to_sample) noexcept OL_WARN_UNUSED_RESULT GetCurrentPoint() \\rst Get point_to_sample: the potential future sample whose EI (and/or gradients) is being evaluated \\output :point_to_sample[dim]: potential sample whose EI is being evaluted \\endrst Declaration void optimal_learning::PosteriorMeanState::GetCurrentPoint(double *restrict point_to_sample_out) const noexcept OL_NONNULL_POINTERS SetCurrentPoint() \\rst Change the potential sample whose EI (and/or gradient) is being evaluated. Update the state's derived quantities to be consistent with the new point. :ei_evaluator expected improvement evaluator object that specifies the parameters & GP for EI evaluation :point_to_sample[dim]: potential future sample whose EI (and/or gradients) is being evaluated \\endrst Declaration void optimal_learning::PosteriorMeanState::SetCurrentPoint(const EvaluatorType&ps_evaluator, double const *restrict point_to_sample_in) OL_NONNULL_POINTERS SetupState() \\rst Configures this state object with a new point_to_sample, the location of the potential sample whose EI is to be evaluated. Ensures all state variables & temporaries are properly sized. Properly sets all dependent state variables (e.g., GaussianProcess's state) for EI evaluation. .. WARNING:: This object's state is INVALIDATED if the ei_evaluator (including the GaussianProcess it depends on) used in SetupState is mutated! SetupState() should be called again in such a situation. :ei_evaluator expected improvement evaluator object that specifies the parameters & GP for EI evaluation :point_to_sample[dim]: potential future sample whose EI (and/or gradients) is being evaluated \\endrst Declaration void optimal_learning::PosteriorMeanState::SetupState(const EvaluatorType&ps_evaluator, double const *restrict point_to_sample_in) OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::PosteriorMeanState::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(PosteriorMeanState)"
  },
  "api/optimal/learning/repeated-domain.html": {
    "href": "api/optimal/learning/repeated-domain.html",
    "title": "Class optimal_learning::RepeatedDomain | qiotoolkit",
    "keywords": "Class optimal_learning::RepeatedDomain \\rst A generic domain type for simultaneously manipulating num_repeats points in a \"regular\" domain (the kernel). .. Note:: Comments in this class are copied to RepeatedDomain in optimal_learning/python/repated_domain.py. .. Note:: the kernel domain is not copied. Instead, the kernel functions are called num_repeats times in a loop. In some cases, data reordering is also necessary to preserve the output properties (e.g., uniform distribution). For some use cases (e.g., q,p-EI optimization with q > 1), we need to simultaneously manipulate several points within the same domain. To support this use case, we have the RepeatedDomain, a light-weight wrapper around any DomainType object that kernalizes that object's functionality. In general, kernel domain operations need be performed num_repeats times, once for each point. This class hides the looping logic so that use cases like various Optimizer implementations (gpp_optimization.hpp) do not need to be explicitly aware of whether they are optimizing 1 point or 50 points. Instead, an optimizable Evaluator/State pair provides GetProblemSize() and appropriately sized gradient information. Coupled with RepeatedDomain, Optimizers can remain oblivious. In simpler terms, say we want to solve 5,0-EI in a parameter-space of dimension 3. So we would have 5 points moving around in a 3D space. The 3D space, whatever it is, is the kernel domain. We \"repeat\" the kernel 5 times; in practice this mostly amounts to simple loops around kernel functions and sometimes data reordering is also needed. .. Note:: this operation is more complex than just working in a higher dimensional space. 3 points in a 2D simplex is not the same as 1 point in a 6D simplex; e.g., [(0.5, 0.5), (0.5, 0.5), (0.5, 0.5)] is valid in the first scenario but not in the second. Where the member domain takes kernel_input, this class's members take an array with of num_repeats data with the same size as kernel_input, ordered sequentially. So if we have kernel_input[dim][num_points], we now have repeated_input[dim][num_points][num_repeats]. The same is true for outputs. For example, CheckPointInside() calls the kernel domain's CheckPointInside() function num_repeats times, returning True only if all num_repeats input points are inside the kernel domain. \\endrst Inheritance optimal_learning::RepeatedDomain Constructors RepeatedDomain() Declaration optimal_learning::RepeatedDomain<DomainType_>::RepeatedDomain()=delete RepeatedDomain() \\rst Construct a RepeatedDomain object, which kernalizes and repeats an input DomainType object. .. Note:: this class maintains a pointer to the input domain. Do not let the domain object go out of scope before this object goes out of scope. :domain the domain to repeat :num_repeats: number of times to repeat the input domain \\endrst Declaration optimal_learning::RepeatedDomain<DomainType_>::RepeatedDomain(const DomainType&domain, int num_repeats_in) Methods dim() Declaration int optimal_learning::RepeatedDomain<DomainType_>::dim() const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT num_repeats() Declaration int optimal_learning::RepeatedDomain<DomainType_>::num_repeats() const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT CheckPointInside() \\rst Check if a point is inside the domain/on its domain or outside :point[dim][num_repeats] point to check true if point is inside the domain or on its boundary, false otherwise \\endrst Declaration bool optimal_learning::RepeatedDomain<DomainType_>::CheckPointInside(double const *restrict point) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT GeneratePointInDomain() \\rst Generates \"point\" such that CheckPointInside(point) returns true. May use rejection sampling so point generation may fail. :uniform_generator[1] a UniformRandomGenerator object providing the random engine for uniform random numbers :random_point[dim][num_repeats]: properly sized array \\output :uniform_generator[1]: UniformRandomGenerator object will have its state changed due to random draws :random_point[dim][num_repeats]: point with coordinates inside the domain (left in invalid state if fcn returns false) true if point generation succeeded \\endrst Declaration bool optimal_learning::RepeatedDomain<DomainType_>::GeneratePointInDomain(UniformRandomGenerator *uniform_generator, double *restrict random_point) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT GenerateUniformPointsInDomain() \\rst Generates AT MOST num_points points in the domain (i.e., such that CheckPointInside(point) returns true). The points will be uniformly distributed. May use rejection sampling so we are not guaranteed to generate num_points samples. :num_points number of random points to generate :uniform_generator[1]: a UniformRandomGenerator object providing the random engine for uniform random numbers :random_points[dim][num_repeats][num_points]: properly sized array \\output :uniform_generator[1]: UniformRandomGenerator object will have its state changed due to random draws :random_points[dim][num_repeats][num_points]: point with coordinates inside the domain number of points actually generated \\endrst Declaration int optimal_learning::RepeatedDomain<DomainType_>::GenerateUniformPointsInDomain(int num_points, UniformRandomGenerator *uniform_generator, double *restrict random_points) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT LimitUpdate() \\rst Changes update_vector so that: point_new = point + update_vector has coordinates such that CheckPointInside(point_new) returns true. update_vector is UNMODIFIED if point_new is already inside the domain. .. Note:: we modify update_vector (instead of returning point_new) so that further update limiting/testing may be performed. :max_relative_change max change allowed per update (as a relative fraction of current distance to boundary) :current_point[dim][num_repeats]: starting point :update_vector[dim][num_repeats]: proposed update \\output :update_vector[dim][num_repeats]: modified update so that the final point remains inside the domain \\endrst Declaration void optimal_learning::RepeatedDomain<DomainType_>::LimitUpdate(double max_relative_change, double const *restrict current_point, double *restrict update_vector) const OL_NONNULL_POINTERS"
  },
  "api/optimal/learning/simple-objective-function-evaluator.html": {
    "href": "api/optimal/learning/simple-objective-function-evaluator.html",
    "title": "Class optimal_learning::SimpleObjectiveFunctionEvaluator | qiotoolkit",
    "keywords": "Class optimal_learning::SimpleObjectiveFunctionEvaluator \\rst Class to evaluate the function f(x_1,...,x_{dim}) = -\\sum_i (x_i - s_i)^2, i = 1..dim. This is a simple quadratic form with maxima at (s_1, ..., s_{dim}). \\endrst Inheritance optimal_learning::SimpleObjectiveFunctionEvaluator Constructors SimpleObjectiveFunctionEvaluator() Declaration optimal_learning::SimpleObjectiveFunctionEvaluator::SimpleObjectiveFunctionEvaluator()=default Methods ~SimpleObjectiveFunctionEvaluator() Declaration virtual optimal_learning::SimpleObjectiveFunctionEvaluator::~SimpleObjectiveFunctionEvaluator()=default dim() Declaration virtual int optimal_learning::SimpleObjectiveFunctionEvaluator::dim() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT=0 GetOptimumValue() \\rst Helpful for testing so we know what the optimum is. This value should be the result of:: GetOptimumPoint(point); state.SetCurrentPoint(point); optimum_value = ComputeObjectiveFunction(state); Then optimum_value ==[ GetOptimumValue()](xref:classoptimal__learning_1_1SimpleObjectiveFunctionEvaluator_1abfebb38321e12587a44e243d0a1d1f30). the optimum value of the polynomial. \\endrst Declaration virtual double optimal_learning::SimpleObjectiveFunctionEvaluator::GetOptimumValue() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT=0 GetOptimumPoint() \\rst Helpful for testing so we know where the optimum (value returned by GetOptimumValue) occurs. .. NOTE:: if the optimal point is not unique, this function may return one arbitrarily. \\input :point[dim]: space to write the output OUTPUTS: :point[dim]: the point at which the polynomial obtains its optimum value \\endrst Declaration virtual void optimal_learning::SimpleObjectiveFunctionEvaluator::GetOptimumPoint(double *restrict point) const noexcept OL_NONNULL_POINTERS=0 ComputeObjectiveFunction() \\rst Compute the quadratic objective function: f(x_1,...,x_{dim}) = -\\sum_i (x_i - s_i)^2. quadratic_dummy_state[1] ptr to a FULLY CONFIGURED StateType (e.g., SimpleObjectiveFunctionState) \\output quadratic_dummy_state[1]: ptr to a FULLY CONFIGURED StateType; only temporary state may be mutated the value of the objective at quadratic_dummy_state.GetCurrentPoint() \\endrst Declaration virtual double optimal_learning::SimpleObjectiveFunctionEvaluator::ComputeObjectiveFunction(StateType *quadratic_dummy_state) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT=0 ComputeGradObjectiveFunction() \\rst Compute the gradient of the objective function: f'(x_1,...,x_{dim})_i = -2 * (x_i - s_i). quadratic_dummy_state[1] ptr to a FULLY CONFIGURED StateType (e.g., SimpleObjectiveFunctionState) \\output quadratic_dummy_state[1]: ptr to a FULLY CONFIGURED StateType; only temporary state may be mutated grad_polynomial[dim]: gradient of the objective \\endrst Declaration virtual void optimal_learning::SimpleObjectiveFunctionEvaluator::ComputeGradObjectiveFunction(StateType *quadratic_dummy_state, double *restrict grad_polynomial) const OL_NONNULL_POINTERS=0 ComputeHessianObjectiveFunction() \\rst Compute the gradient of the objective function: f''(x_1,...,x_{dim})_{i,j} = -2 * \\delta_{i,j}. quadratic_dummy_state[1] ptr to a FULLY CONFIGURED StateType (e.g., SimpleObjectiveFunctionState) \\output quadratic_dummy_state[1]: ptr to a FULLY CONFIGURED StateType; only temporary state may be mutated hessian_polynomial[dim][dim]: hessian of the objective \\endrst Declaration virtual void optimal_learning::SimpleObjectiveFunctionEvaluator::ComputeHessianObjectiveFunction(StateType *quadratic_dummy_state, double *restrict hessian_polynomial) const OL_NONNULL_POINTERS=0 OL_DISALLOW_COPY_AND_ASSIGN() Declaration optimal_learning::SimpleObjectiveFunctionEvaluator::OL_DISALLOW_COPY_AND_ASSIGN(SimpleObjectiveFunctionEvaluator)"
  },
  "api/optimal/learning/simple-objective-function-state.html": {
    "href": "api/optimal/learning/simple-objective-function-state.html",
    "title": "Struct optimal_learning::SimpleObjectiveFunctionState | qiotoolkit",
    "keywords": "Struct optimal_learning::SimpleObjectiveFunctionState Constructors SimpleObjectiveFunctionState() Declaration optimal_learning::SimpleObjectiveFunctionState::SimpleObjectiveFunctionState(const EvaluatorType&quadratic_eval, double const *restrict current_point_in) SimpleObjectiveFunctionState() Declaration optimal_learning::SimpleObjectiveFunctionState::SimpleObjectiveFunctionState(SimpleObjectiveFunctionState&&OL_UNUSED(other))=default Methods GetProblemSize() Declaration int optimal_learning::SimpleObjectiveFunctionState::GetProblemSize() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT GetCurrentPoint() Declaration void optimal_learning::SimpleObjectiveFunctionState::GetCurrentPoint(double *restrict current_point_in) const noexcept OL_NONNULL_POINTERS SetCurrentPoint() Declaration void optimal_learning::SimpleObjectiveFunctionState::SetCurrentPoint(const EvaluatorType&OL_UNUSED(ei_eval), double const *restrict current_point_in) noexcept OL_NONNULL_POINTERS OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN() Declaration optimal_learning::SimpleObjectiveFunctionState::OL_DISALLOW_DEFAULT_AND_COPY_AND_ASSIGN(SimpleObjectiveFunctionState)"
  },
  "api/optimal/learning/simplex-intersect-tensor-product-domain.html": {
    "href": "api/optimal/learning/simplex-intersect-tensor-product-domain.html",
    "title": "Class optimal_learning::SimplexIntersectTensorProductDomain | qiotoolkit",
    "keywords": "Class optimal_learning::SimplexIntersectTensorProductDomain \\rst Domain class for the intersection of the unit simplex with an arbitrary tensor product domain. To that end, this object has a TensorProductDomain object as a data member and uses its functions when possible. See TensorProductDomain for what that means. The unit d-simplex is defined as the set of x_i such that: x_i >= 0 \\forall i (i ranging over dimension) \\sum_i x_i <= 1 (Implying that x_i <= 1 \\forall i) ASSUMPTION: most of the volume of the tensor product region lies inside the simplex region. \\endrst Inheritance optimal_learning::SimplexIntersectTensorProductDomain Constructors SimplexIntersectTensorProductDomain() Declaration optimal_learning::SimplexIntersectTensorProductDomain::SimplexIntersectTensorProductDomain()=delete SimplexIntersectTensorProductDomain() \\rst Constructs a SimplexIntersectTensorProductDomain. The bounds of the tensor product region are specified through the \"domain\" input, just as with TensorProductDomain. :domain[dim] array of ClosedInterval specifying the boundaries of a dim-dimensional tensor-product domain. :dim_in: number of spatial dimensions \\endrst Declaration optimal_learning::SimplexIntersectTensorProductDomain::SimplexIntersectTensorProductDomain(ClosedInterval const *restrict domain, int dim_in) Methods dim() Declaration int optimal_learning::SimplexIntersectTensorProductDomain::dim() const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT GetMaxNumberOfBoundaryPlanes() \\rst Maximum number of planes that define the boundary of this domain. Used for testing. This result is NOT exact. max number of planes defining the boundary of this domain \\endrst Declaration int optimal_learning::SimplexIntersectTensorProductDomain::GetMaxNumberOfBoundaryPlanes() const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT GetBoundaryPlanes() \\rst Fills an input array with all bounding planes of this domain. See struct Plane in gpp_geometry.hpp for how to specify a plane. Used for testing. Let max_num_bound = GetMaxNumberOfBoundaryPlanes() :planes[max_num_bound] properly allocated space: max_num_bound Plane objects in dim spatial dimensions \\output :planes[max_num_bound]: array of planes of this domain \\endrst Declaration void optimal_learning::SimplexIntersectTensorProductDomain::GetBoundaryPlanes(Plane *restrict planes) const OL_NONNULL_POINTERS CheckPointInside() \\rst Check if a point is inside the domain/on its domain or outside :point[dim] point to check true if point is inside the domain or on its boundary, false otherwise \\endrst Declaration bool optimal_learning::SimplexIntersectTensorProductDomain::CheckPointInside(double const *restrict point) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT GeneratePointInDomain() \\rst Generates \"point\" such that CheckPointInside(point) returns true. Uses rejection sampling so point generation may fail. :uniform_generator[1] a UniformRandomGenerator object providing the random engine for uniform random numbers :random_point[dim]: properly sized array \\output :uniform_generator[1]: UniformRandomGenerator object will have its state changed due to random draws :random_point[dim]: point with coordinates inside the domain (left in invalid state if fcn returns false) true if point generation succeeded \\endrst Declaration bool optimal_learning::SimplexIntersectTensorProductDomain::GeneratePointInDomain(UniformRandomGenerator *uniform_generator, double *restrict random_point) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT GenerateUniformPointsInDomain() \\rst Generates AT MOST num_points points in the domain (i.e., such that CheckPointInside(point) returns true). The points will be uniformly distributed. Uses rejection sampling so we are not guaranteed to generate num_points samples. :num_points number of random points to generate :uniform_generator[1]: a UniformRandomGenerator object providing the random engine for uniform random numbers :random_points[dim][num_points]: properly sized array \\output :uniform_generator[1]: UniformRandomGenerator object will have its state changed due to random draws :random_points[dim][num_points]: point with coordinates inside the domain number of points actually generated \\endrst Declaration int optimal_learning::SimplexIntersectTensorProductDomain::GenerateUniformPointsInDomain(int num_points, UniformRandomGenerator *uniform_generator, double *restrict random_points) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT LimitUpdate() \\rst Changes update_vector so that: point_new = point + update_vector has coordinates such that CheckPointInside(point_new) returns true. update_vector is UNMODIFIED if point_new is already inside the domain. .. Note:: we modify update_vector (instead of returning point_new) so that further update limiting/testing may be performed. :max_relative_change max change allowed per update (as a relative fraction of current distance to boundary) :current_point[dim]: starting point :update_vector[dim]: proposed update \\output :update_vector[dim]: modified update so that the final point remains inside the domain \\endrst Declaration void optimal_learning::SimplexIntersectTensorProductDomain::LimitUpdate(double max_relative_change, double const *restrict current_point, double *restrict update_vector) const OL_NONNULL_POINTERS"
  },
  "api/optimal/learning/singular-matrix-exception.html": {
    "href": "api/optimal/learning/singular-matrix-exception.html",
    "title": "Class optimal_learning::SingularMatrixException | qiotoolkit",
    "keywords": "Class optimal_learning::SingularMatrixException \\rst Overview** Exception to capture when a square matrix A (\\in R^{m x m}) is singular. Stores the matrix (in a std::vector) and its dimensions along with the index of the leading minor that is non-SPD. .. Note:: std::vector ctor can throw and cause std::terminate(). Message Format** The what() message is formatted in the class ctor (capitals indicate variable information):: R\"%%( SingularMatrixException: M x M matrix is singular; i-th leading minor is not SPD. CUSTOM_MESSAGE FUNCTION_NAME FILE_LINE_INFO )%%\" .. Note:: this exception currently does not print the full matrix. Use a debugger and call PrintMatrix() (gpp_logging.hpp) or catch the exception and proecss the matrix. \\endrst Inheritance optimal_learning::OptimalLearningException optimal_learning::SingularMatrixException Inherited Members OptimalLearningException OptimalLearningException what AppendCustomMessageAndDebugInfo OptimalLearningException Constructors SingularMatrixException() \\rst Constructs a SingularMatrixException object with extra fields to flesh out the what() message. :line_info[] ptr to char array containing FILE and LINE info; e.g., from OL_STRINGIFY_FILE_AND_LINE :func_info[]: optional ptr to char array from OL_CURRENT_FUNCTION_NAME or similar :custom_message[]: optional ptr to char array with any additional text/info to print/log :matrix[num_rows][num_cols]: the singular matrix :num_rows: number of rows (= number of columns) in the matrix :leading_minor_index: index of the first non-positive definite (principal) leading minor \\endrst Declaration optimal_learning::SingularMatrixException::SingularMatrixException(char const *line_info, char const *func_info, char const *custom_message, double const *matrix_in, int num_rows_in, int leading_minor_index_in) Methods num_rows() Declaration int optimal_learning::SingularMatrixException::num_rows() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT leading_minor_index() Declaration int optimal_learning::SingularMatrixException::leading_minor_index() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT matrix() Declaration const std::vector<double>&optimal_learning::SingularMatrixException::matrix() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT OL_DISALLOW_DEFAULT_AND_ASSIGN() Declaration optimal_learning::SingularMatrixException::OL_DISALLOW_DEFAULT_AND_ASSIGN(SingularMatrixException)"
  },
  "api/optimal/learning/square-exponential.html": {
    "href": "api/optimal/learning/square-exponential.html",
    "title": "Class optimal_learning::SquareExponential | qiotoolkit",
    "keywords": "Class optimal_learning::SquareExponential \\rst Implements the square exponential covariance function: cov(x_1, x_2) = \\alpha * \\exp(-1/2 * ((x_1 - x_2)^T * L * (x_1 - x_2)) ) where L is the diagonal matrix with i-th diagonal entry 1/lengths[i]/lengths[i] We also implement the augmented kernel function with the gradient obervations. This covariance object has dim+1 hyperparameters: \\alpha, lengths_i See CovarianceInterface for descriptions of the virtual functions. \\endrst Inheritance optimal_learning::CovarianceInterface optimal_learning::SquareExponential Inherited Members ~CovarianceInterface Constructors SquareExponential() \\rst Constructs a SquareExponential object with constant length-scale across all dimensions. :dim the number of spatial dimensions :alpha: the hyperparameter \\alpha (e.g., signal variance, \\sigma_f^2) :length: the constant length scale to use for all hyperparameter length scales \\endrst Declaration optimal_learning::SquareExponential::SquareExponential(int dim, double alpha, double length) SquareExponential() \\rst Constructs a SquareExponential object with the specified hyperparameters. :dim the number of spatial dimensions :alpha: the hyperparameter \\alpha, (e.g., signal variance, \\sigma_f^2) :lengths[dim]: the hyperparameter length scales, one per spatial dimension \\endrst Declaration optimal_learning::SquareExponential::SquareExponential(int dim, double alpha, double const *restrict lengths) OL_NONNULL_POINTERS SquareExponential() \\rst Constructs a SquareExponential object with the specified hyperparameters. :dim the number of spatial dimensions :alpha: the hyperparameter \\alpha, (e.g., signal variance, \\sigma_f^2) :lengths: the hyperparameter length scales, one per spatial dimension \\endrst Declaration optimal_learning::SquareExponential::SquareExponential(int dim, double alpha, std::vector<double>lengths) SquareExponential() Declaration optimal_learning::SquareExponential::SquareExponential(const SquareExponential&source) Methods Covariance() \\rst Computes the covariance function of the function values and their gradients of two points, cov(point_one, point_two). Points must be arrays with length dim. The covariance function is guaranteed to be symmetric by definition: Covariance(x, y) = Covariance(y, x). This function is also positive definite by definition. :point_one[dim] first spatial coordinate :derivatives_one[dim]: which derivatives of point_one are available :num_derivatives_one: int, the number of derivatives of point one :point_two[dim]: second spatial coordinate :derivatives_two[dim]: which derivatives of point_two are available :num_derivatives_two: int, the number of derivatives of point two cov[1+num_derivatives_one][1+num_derivatives_two]: value of covariance between the function values and their gradients of the input points \\endrst Declaration void optimal_learning::SquareExponential::Covariance(double const *restrict point_one, int const *restrict derivatives_one, int num_derivatives_one, double const *restrict point_two, int const *restrict derivatives_two, int num_derivatives_two, double *restrict cov) const noexcept override OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT GradCovariance() \\rst Computes the gradient of this.Covariance(point_one, point_two) with respect to the FIRST argument, point_one. This distinction is important for maintaining the desired symmetry. Cov(x, y) = Cov(y, x). Additionally, \\pderiv{Cov(x, y)}{x} = \\pderiv{Cov(y, x)}{x}. However, in general, \\pderiv{Cov(x, y)}{x} != \\pderiv{Cov(y, x)}{y} (NOT equal! These may differ by a negative sign) Hence to avoid separate implementations for differentiating against first vs second argument, this function only handles differentiation against the first argument. If you need \\pderiv{Cov(y, x)}{x}, just swap points x and y. :point_one[dim] first spatial coordinate :derivatives_one[dim]: which derivatives of point_one are available :num_derivatives_one: int, the number of derivatives of point one :point_two[dim]: second spatial coordinate :derivatives_two[dim]: which derivatives of point_two are available :num_derivatives_two: int, the number of derivatives of point two \\output grad_cov[dim][1+num_derivatives_one][1+num_derivatives_two]: (i, j, k)-th entry is \\pderiv{cov(x_1, x_2)(j, k))}{x1_i} \\endrst Declaration void optimal_learning::SquareExponential::GradCovariance(double const *restrict point_one, int const *restrict derivatives_one, int num_derivatives_one, double const *restrict point_two, int const *restrict derivatives_two, int num_derivatives_two, double *restrict grad_cov) const noexcept override OL_NONNULL_POINTERS GetNumberOfHyperparameters() \\rst Returns the number of hyperparameters. This base class only allows for a maximum of dim + 1 hyperparameters but subclasses may implement additional ones. The number of hyperparameters. Return 0 to disable hyperparameter-related gradients, optimizations. \\endrst Declaration virtual int optimal_learning::SquareExponential::GetNumberOfHyperparameters() const noexcept override OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT HyperparameterGradCovariance() \\rst Similar to GradCovariance(), except gradients are computed w.r.t. the hyperparameters. Unlike GradCovariance(), the order of point_one and point_two is irrelevant here (since we are not differentiating against either of them). Thus the matrix of grad covariances (wrt hyperparameters) is symmetric. :point_one[dim] first spatial coordinate :derivatives_one[dim]: which derivatives of point_one are available :num_derivatives_one: int, the number of derivatives of point one :point_two[dim]: second spatial coordinate :derivatives_two[dim]: which derivatives of point_two are available :num_derivatives_two: int, the number of derivatives of point two \\output :grad_hyperparameter_cov[this.GetNumberOfHyperparameters()][1+num_derivatives_one][1+num_derivatives_two]: (i, j, k)-th entry is \\pderiv{cov(x_1, x_2)(j, k)}{\\theta_i} \\endrst Declaration void optimal_learning::SquareExponential::HyperparameterGradCovariance(double const *restrict point_one, int const *restrict derivatives_one, int num_derivatives_one, double const *restrict point_two, int const *restrict derivatives_two, int num_derivatives_two, double *restrict grad_hyperparameter_cov) const noexcept override OL_NONNULL_POINTERS SetHyperparameters() \\rst Sets the hyperparameters. Hyperparameter ordering is defined implicitly by GetHyperparameters: [alpha=\\sigma_f^2, length_0, ..., length_{n-1}] :hyperparameters[this.GetNumberOfHyperparameters()] hyperparameters to set \\endrst Declaration virtual void optimal_learning::SquareExponential::SetHyperparameters(double const *restrict hyperparameters) noexcept override OL_NONNULL_POINTERS GetHyperparameters() \\rst Gets the hyperparameters. Ordering is [alpha=\\sigma_f^2, length_0, ..., length_{n-1}] \\output :hyperparameters[this.GetNumberOfHyperparameters()]: values of current hyperparameters \\endrst Declaration virtual void optimal_learning::SquareExponential::GetHyperparameters(double *restrict hyperparameters) const noexcept override OL_NONNULL_POINTERS Clone() \\rst For implementing the virtual (copy) constructor idiom. :Pointer to a constructed object that is a subclass of CovarianceInterface \\endrst Declaration CovarianceInterface * optimal_learning::SquareExponential::Clone() const override OL_WARN_UNUSED_RESULT OL_DISALLOW_DEFAULT_AND_ASSIGN() Declaration optimal_learning::SquareExponential::OL_DISALLOW_DEFAULT_AND_ASSIGN(SquareExponential) Initialize() \\rst Validate and initialize class data members. \\endrst Declaration void optimal_learning::SquareExponential::Initialize()"
  },
  "api/optimal/learning/tensor-product-domain.html": {
    "href": "api/optimal/learning/tensor-product-domain.html",
    "title": "Class optimal_learning::TensorProductDomain | qiotoolkit",
    "keywords": "Class optimal_learning::TensorProductDomain \\rst Domain type for a tensor product domain. A d-dimensional tensor product domain is D = [x_0_{min}, x_0_{max}] X [x_1_{min}, x_1_{max}] X ... X [x_d_{min}, x_d_{max}] \\endrst Inheritance optimal_learning::TensorProductDomain Constructors TensorProductDomain() Declaration optimal_learning::TensorProductDomain::TensorProductDomain()=delete TensorProductDomain() \\rst Constructs a TensorProductDomain. :domain[dim] array of ClosedInterval specifying the boundaries of a dim-dimensional tensor-product domain. :dim_in: number of spatial dimensions \\endrst Declaration optimal_learning::TensorProductDomain::TensorProductDomain(ClosedInterval const *restrict domain, int dim_in) Methods dim() Declaration int optimal_learning::TensorProductDomain::dim() const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT SetDomain() \\rst Explicitly set the domain boundaries. Assumes specified domain is non-empty. :domain[dim] array of ClosedInterval specifying the boundaries of a dim-dimensional tensor-product domain. \\endrst Declaration void optimal_learning::TensorProductDomain::SetDomain(ClosedInterval const *restrict domain) OL_NONNULL_POINTERS GetMaxNumberOfBoundaryPlanes() \\rst Maximum number of planes that define the boundary of this domain. Used for testing. This result is exact. max number of planes defining the boundary of this domain \\endrst Declaration int optimal_learning::TensorProductDomain::GetMaxNumberOfBoundaryPlanes() const OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT GetBoundaryPlanes() \\rst Fills an input array with all bounding planes of this domain. See struct Plane in gpp_geometry.hpp for how to specify a plane. Used for testing. Let max_num_bound = GetMaxNumberOfBoundaryPlanes() :planes[max_num_bound] properly allocated space: max_num_bound Plane objects in dim spatial dimensions \\output :planes[max_num_bound]: array of planes of this domain \\endrst Declaration void optimal_learning::TensorProductDomain::GetBoundaryPlanes(Plane *restrict planes) const OL_NONNULL_POINTERS CheckPointInside() \\rst Check if a point is inside the domain/on its boundary or outside. :point[dim] point to check true if point is inside the domain or on its boundary, false otherwise \\endrst Declaration bool optimal_learning::TensorProductDomain::CheckPointInside(double const *restrict point) const OL_NONNULL_POINTERS OL_WARN_UNUSED_RESULT GeneratePointInDomain() \\rst Generates \"point\" such that CheckPointInside(point) returns true. :uniform_generator[1] a UniformRandomGenerator object providing the random engine for uniform random numbers :random_point[dim]: properly sized array \\output :uniform_generator[1]: UniformRandomGenerator object will have its state changed due to random draws :random_point[dim]: point with coordinates inside the domain (left in invalid state if fcn returns false) true if point generation succeeded \\endrst Declaration bool optimal_learning::TensorProductDomain::GeneratePointInDomain(UniformRandomGenerator *uniform_generator, double *restrict random_point) const OL_NONNULL_POINTERS GenerateUniformPointsInDomain() \\rst Generates num_points points in the domain (i.e., such that CheckPointInside(point) returns true). The points will be uniformly distributed. :num_points number of random points to generate :uniform_generator[1]: a UniformRandomGenerator object providing the random engine for uniform random numbers :random_points[dim][num_points]: properly sized array \\output :uniform_generator[1]: UniformRandomGenerator object will have its state changed due to random draws :random_points[dim][num_points]: point with coordinates inside the domain number of points generated (always num_points; ok to not use this result) \\endrst Declaration int optimal_learning::TensorProductDomain::GenerateUniformPointsInDomain(int num_points, UniformRandomGenerator *uniform_generator, double *restrict random_points) const OL_NONNULL_POINTERS LimitUpdate() \\rst Changes update_vector so that: point_new = point + update_vector has coordinates such that CheckPointInside(point_new) returns true. update_vector is UNMODIFIED if point_new is already inside the domain. .. Note:: we modify update_vector (instead of returning point_new) so that further update limiting/testing may be performed. :max_relative_change max change allowed per update (as a relative fraction of current distance to boundary) :current_point[dim]: starting point :update_vector[dim]: proposed update \\output :update_vector[dim]: modified update so that the final point remains inside the domain \\endrst Declaration void optimal_learning::TensorProductDomain::LimitUpdate(double max_relative_change, double const *restrict current_point, double *restrict update_vector) const OL_NONNULL_POINTERS"
  },
  "api/optimal/learning/thread-schedule.html": {
    "href": "api/optimal/learning/thread-schedule.html",
    "title": "Struct optimal_learning::ThreadSchedule | qiotoolkit",
    "keywords": "Struct optimal_learning::ThreadSchedule \\rst Overview** When we ask openmp to parallelize a for loop, we can give it additional information on how to distribute the work. In particular, the overall work (N iterations) needs to be divided up amongst the threads. We have two major ways to affect how openmp structures the loop: schedule and chunk_size. chunk_size changes meaning depending on schedule. Here we list out the options for schedule as name (ENV_NAME, enum_name) where ENV_NAME is the corresponding value of OMP_SCHEDULE (not used by optimal_learning) and enum_name is the corresponding type from opm_sched_t in omp.h. Below, \"work\" refers to loop iterations (N total). Schedule Types** a. static (\"static\", omp_sched_static): Work is divided into N/chunk_size contiguous chunks (of chunk_size iterations) and distributed amongst the threads statically in a round-robin fashion. Use when you are confident all chunks will take the same amount of time. Low control overhead but high waste if one iteration is very slow (since the other threads will sit idle). Default chunk_size: N / number_of_threads. This schedule type is repeatable: repeated runs/calls (with the same work) will produce the same mapping of loop iterations to threads every time. b. dynamic (\"dynamic\", omp_sched_dynamic): Work is divided into N/chunk_size contiguous chunks (of chunk_size iterations) and distributed to threads as they complete their work, first-come first-serve. If there is a chunk that is very slow, the other threads can finish all remaining work instead of sitting idle. High control overhead, use when you have no idea how long each chunk will take. Default chunk_size: 1. This schedule type does not produce repeatable mappings of iterations to threads. c. guided (\"guided\", omp_sched_guided): Work is divided into progressively smaller chunks; chunk_size sets the minimum value. As with dynamic, chunks are assigned on a first-come, first-serve basis. Less overhead than dynamic (b/c chunk_size scale down). Useful when iteration times are similar but not identical. Less overhead than dynamic while guaranteeing the waste case of static doesn't arise. Default chunk_size: approximately N / number_of_threads. This schedule type does not produce repeatable mappings of iterations to threads. d. auto (\"auto\", omp_sched_auto): The compiler decides how to map iterations to threads; this mapping is not required to be one of the previous choices. chunk_size has no meaning when the schedule is auto. See: https://gcc.gnu.org/onlinedocs/libgomp/omp_005fset_005fschedule.html This schedule type is not guaranteed to be repeatable. Further documentation: http://openmp.org/mp-documents/OpenMP3.1-CCard.pdf https://software.intel.com/en-us/articles/openmp-loop-scheduling http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Fcompiler%2Fref%2Fruompfor.htm \\endrst Constructors ThreadSchedule() \\rst Construct a ThreadSchedule using the specified number of threads, schedule type, and chunk_size. :max_num_threads maximum number of threads for use by OpenMP (generally should be <= # cores) :schedule: static, dynamic, guided, or auto. See class comments for more details. :chunk_size: how to distribute work to threads; the precise meaning depends on schedule. Zero or negative chunk_size ask OpenMP to use its default behavior. See class comments for details. \\endrst Declaration optimal_learning::ThreadSchedule::ThreadSchedule(int max_num_threads_in, omp_sched_t schedule_in, int chunk_size_in) ThreadSchedule() \\rst Construct a ThreadSchedule using the specified number of threads and schedule type with default chunk_size. :max_num_threads maximum number of threads for use by OpenMP (generally should be <= # cores) :schedule: static, dynamic, guided, or auto. See class comments for more details. \\endrst Declaration optimal_learning::ThreadSchedule::ThreadSchedule(int max_num_threads_in, omp_sched_t schedule_in) ThreadSchedule() \\rst Construct a ThreadSchedule using the specified number of threads with default schedule type and chunk_size. :max_num_threads maximum number of threads for use by OpenMP (generally should be <= # cores) \\endrst Declaration optimal_learning::ThreadSchedule::ThreadSchedule(int max_num_threads_in) ThreadSchedule() \\rst Construct a ThreadSchedule using the default number of threads, schedule type, and chunk_size. \\endrst Declaration optimal_learning::ThreadSchedule::ThreadSchedule()"
  },
  "api/optimal/learning/uniform-random-generator.html": {
    "href": "api/optimal/learning/uniform-random-generator.html",
    "title": "Struct optimal_learning::UniformRandomGenerator | qiotoolkit",
    "keywords": "Struct optimal_learning::UniformRandomGenerator \\rst Container for an uniform random generator (e.g., mersenne twister). Member functions are for easy manipulation of seeds and have signatures matching corresponding members of NormalRNG. .. Note:: seed values take type EngineType::result_type. Do not pass in a wider integer type! .. WARNING:: this class is NOT THREAD-SAFE. You must construct one object per thread (and ensure that the seeds are different for practical computations). \\endrst Constructors UniformRandomGenerator() \\rst Default-constructs a UniformRandomGenerator, seeding with kDefaultSeed. \\endrst Declaration optimal_learning::UniformRandomGenerator::UniformRandomGenerator() noexcept UniformRandomGenerator() \\rst Construct a UniformRandomGenerator, seeding with the specified seed. See UniformRandomGenerator::SetExplicitSeed for details. :seed new seed to set \\endrst Declaration optimal_learning::UniformRandomGenerator::UniformRandomGenerator(EngineType::result_type seed) noexcept UniformRandomGenerator() \\rst Construct a UniformRandomGenerator, seeding with an automatically selected seed based on time, thread_id, etc. See UniformRandomGenerator::SetRandomizedSeed for details. :base_seed base value for the new seed :thread_id: id of the thread using this object \\endrst Declaration optimal_learning::UniformRandomGenerator::UniformRandomGenerator(EngineType::result_type seed, int thread_id) noexcept Methods GetEngine() \\rst Get a reference to the RNG engine used by this class. Not necessary for this class since engine is public but we expose this to maintain a uniform interface with NormalRNG. reference to the underlying RNG engine \\endrst Declaration EngineType&optimal_learning::UniformRandomGenerator::GetEngine() noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT last_seed() Declaration EngineType::result_type optimal_learning::UniformRandomGenerator::last_seed() const noexcept OL_PURE_FUNCTION OL_WARN_UNUSED_RESULT SetExplicitSeed() \\rst Seed the random number generator with the input value. The main purpose of this function is for testingto allow seeding the RNG with a known value for repeatability. :seed new seed to set \\endrst Declaration void optimal_learning::UniformRandomGenerator::SetExplicitSeed(EngineType::result_type seed) noexcept SetRandomizedSeed() \\rst Set a new seed for the random number generator. A \"random\" seed is selected based on the input seed value, the current time, and the thread_id. This function is meant to initialize unique UniformRandomGenerator objects for each computation thread:: std::vector uniform_generator_vector(num_threads); for (int i = 0; i < num_threads; ++i) { uniform_generator_vector.SetRandomizedSeed(base_seed, i); } This function is meant to generate seeds so that: this function can be called multiple times successively (e.g., in the above loop) with different thread_ids to initialize RNGs for multiple threads multiple runs of this code are unlikely to generate the same seed values Item 2. is important for minimizing the probability that we run EI computations (see gpp_math.hpp) with the \"same\" randomness. :base_seed base value for the new seed :thread_id: id of the thread using this object \\endrst Declaration void optimal_learning::UniformRandomGenerator::SetRandomizedSeed(EngineType::result_type base_seed, int thread_id) noexcept ResetToMostRecentSeed() \\rst Reseeds the generator with its most recently specified seed value. Useful for testinge.g., can conduct multiple runs with the same initial conditions \\endrst Declaration void optimal_learning::UniformRandomGenerator::ResetToMostRecentSeed() noexcept PrintState() \\rst Prints the state of the generator to specified ostream. For testing. :out_stream[1] a std::ostream object ready for operator<<`` use \\output :out_stream[1]: std::ostreamwith the engine state \"written\" to itsoperator<<` \\endrst Declaration void optimal_learning::UniformRandomGenerator::PrintState(std::ostream *out_stream) const OL_NONNULL_POINTERS operator==() Declaration bool optimal_learning::UniformRandomGenerator::operator==(const UniformRandomGenerator&other) const operator!=() Declaration bool optimal_learning::UniformRandomGenerator::operator!=(const UniformRandomGenerator&other) const"
  },
  "api/optimal/learning/upper-bound-exception.html": {
    "href": "api/optimal/learning/upper-bound-exception.html",
    "title": "Class optimal_learning::UpperBoundException | qiotoolkit",
    "keywords": "Class optimal_learning::UpperBoundException \\rst Exception to capture value > max_value. Simple subclass of BoundsException that sets the min argument to std::numeric_limits ::lowest() See BoundsException for what() message format. \\endrst Inheritance optimal_learning::BoundsException optimal_learning::UpperBoundException Inherited Members max value OL_DISALLOW_DEFAULT_AND_ASSIGN BoundsException min BoundsException OptimalLearningException OptimalLearningException what AppendCustomMessageAndDebugInfo OptimalLearningException Constructors UpperBoundException() \\rst Constructs an UpperBoundException object with extra fields to flesh out the what() message. :line_info[] ptr to char array containing FILE and LINE info; e.g., from OL_STRINGIFY_FILE_AND_LINE :func_info[]: optional ptr to char array from OL_CURRENT_FUNCTION_NAME or similar :custom_message[]: optional ptr to char array with any additional text/info to print/log :value: the value that violates its min or max bound :max: the maximum bound for value \\endrst Declaration optimal_learning::UpperBoundException<ValueType>::UpperBoundException(char const *line_info, char const *func_info, char const *custom_message, ValueType value_in, ValueType max_in) Methods OL_DISALLOW_DEFAULT_AND_ASSIGN() Declaration optimal_learning::UpperBoundException<ValueType>::OL_DISALLOW_DEFAULT_AND_ASSIGN(UpperBoundException)"
  },
  "api/parse-result.html": {
    "href": "api/parse-result.html",
    "title": "Struct ParseResult | qiotoolkit",
    "keywords": "Struct ParseResult Result of parsing (wraps ParseErrorCode) Document doc; ParseResult ok = doc.Parse(\"[42]\"); if (!ok) { fprintf(stderr, \"JSON parse error: %s (%u)\", GetParseError_En(ok.Code()), ok.Offset()); exit(EXIT_FAILURE); } GenericReader::Parse, GenericDocument::Parse Constructors ParseResult() Default constructor, no error. Declaration ParseResult::ParseResult() ParseResult() Constructor to set an error. Declaration ParseResult::ParseResult(ParseErrorCode code, size_t offset) Methods Code() Get the error code. Declaration ParseErrorCode ParseResult::Code() const Offset() Get the error offset, if IsError(), 0 otherwise. Declaration size_t ParseResult::Offset() const operator BooleanType() Explicit conversion to bool, returns true, iff . Declaration ParseResult::operator BooleanType() const IsError() Whether the result is an error. Declaration bool ParseResult::IsError() const operator==() Declaration bool ParseResult::operator==(const ParseResult&that) const operator==() Declaration bool ParseResult::operator==(ParseErrorCode code) const operator!=() Declaration bool ParseResult::operator!=(const ParseResult&that) const operator!=() Declaration bool ParseResult::operator!=(ParseErrorCode code) const Clear() Reset error code. Declaration void ParseResult::Clear() Set() Update error code and offset. Declaration void ParseResult::Set(ParseErrorCode code, size_t offset=0)"
  },
  "api/pcg/detail/cheap/multiplier/3/01pcg128/t/01/4.html": {
    "href": "api/pcg/detail/cheap/multiplier/3/01pcg128/t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods multiplier() Declaration static constexpr uint64_t pcg_detail::cheap_multiplier<pcg128_t>::multiplier()"
  },
  "api/pcg/detail/default/increment.html": {
    "href": "api/pcg/detail/default/increment.html",
    "title": "Struct pcg_detail::default_increment | qiotoolkit",
    "keywords": "Struct pcg_detail::default_increment"
  },
  "api/pcg/detail/default/multiplier.html": {
    "href": "api/pcg/detail/default/multiplier.html",
    "title": "Struct pcg_detail::default_multiplier | qiotoolkit",
    "keywords": "Struct pcg_detail::default_multiplier"
  },
  "api/pcg/detail/dxsm/mixin.html": {
    "href": "api/pcg/detail/dxsm/mixin.html",
    "title": "Struct pcg_detail::dxsm_mixin | qiotoolkit",
    "keywords": "Struct pcg_detail::dxsm_mixin Methods output() Declaration xtype pcg_detail::dxsm_mixin<xtype, itype>::output(itype internal)"
  },
  "api/pcg/detail/engine.html": {
    "href": "api/pcg/detail/engine.html",
    "title": "Class pcg_detail::engine | qiotoolkit",
    "keywords": "Class pcg_detail::engine Inheritance pcg_detail::oneseq_stream pcg_detail::default_multiplier pcg_detail::engine Inherited Members set_stream oneseq_stream stream streams_pow2 Constructors engine() Declaration pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::engine(itype state=itype(0xcafef00dd15ea5e5ULL)) engine() Declaration pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::engine(itype state, typename sm::stream_state stream_seed) engine() Declaration pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::engine(SeedSeq&&seedSeq, typename std::enable_if<!stream_mixin::can_specify_stream&&!std::is_convertible<SeedSeq, itype>::value&&!std::is_convertible<SeedSeq, engine>::value, no_specifiable_stream_tag>::type={}) engine() Declaration pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::engine(SeedSeq&&seedSeq, typename std::enable_if<stream_mixin::can_specify_stream&&!std::is_convertible<SeedSeq, itype>::value&&!std::is_convertible<SeedSeq, engine>::value, can_specify_stream_tag>::type={}) Methods period_pow2() Declaration static constexpr size_t pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::period_pow2() min() Declaration static constexpr result_type pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::min() max() Declaration static constexpr result_type pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::max() bump() Declaration itype pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::bump(itype state) base_generate() Declaration itype pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::base_generate() base_generate0() Declaration itype pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::base_generate0() distance() Declaration itype pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::distance(itype newstate, itype mask=itype(~itype(0U))) const operator()() Declaration result_type pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::operator()() operator()() Declaration result_type pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::operator()(result_type upper_bound) advance() Declaration void pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::advance(itype delta) backstep() Declaration void pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::backstep(itype delta) discard() Declaration void pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::discard(itype delta) wrapped() Declaration bool pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::wrapped() seed() Declaration void pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::seed(Args&&... args) advance() Declaration itype pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::advance(itype state, itype delta, itype cur_mult, itype cur_plus) distance() Declaration itype pcg_detail::engine<xtype, itype, output_mixin, output_previous, stream_mixin, multiplier_mixin>::distance(itype cur_state, itype newstate, itype cur_mult, itype cur_plus, itype mask=~itype(0U))"
  },
  "api/pcg/detail/engine/can/specify/stream/tag.html": {
    "href": "api/pcg/detail/engine/can/specify/stream/tag.html",
    "title": "Struct pcg_detail::engine::can_specify_stream_tag | qiotoolkit",
    "keywords": "Struct pcg_detail::engine::can_specify_stream_tag"
  },
  "api/pcg/detail/engine/no/specifiable/stream/tag.html": {
    "href": "api/pcg/detail/engine/no/specifiable/stream/tag.html",
    "title": "Struct pcg_detail::engine::no_specifiable_stream_tag | qiotoolkit",
    "keywords": "Struct pcg_detail::engine::no_specifiable_stream_tag"
  },
  "api/pcg/detail/extended.html": {
    "href": "api/pcg/detail/extended.html",
    "title": "Class pcg_detail::extended | qiotoolkit",
    "keywords": "Class pcg_detail::extended Inheritance pcg_detail::extended Constructors extended() Declaration pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::extended(const result_type *data) extended() Declaration pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::extended(const result_type *data, state_type seed) extended() Declaration pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::extended(const result_type *data, state_type seed, typename bc::stream_state stream_seed) extended() Declaration pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::extended() extended() Declaration pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::extended(state_type seed) extended() Declaration pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::extended(state_type seed, typename bc::stream_state stream_seed) extended() Declaration pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::extended(SeedSeq&&seedSeq) Methods advance_table() Declaration void pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::advance_table() advance_table() Declaration void pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::advance_table(state_type delta, bool isForwards=true) get_extended_value() Declaration result_type&pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::get_extended_value() selfinit() Declaration void pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::selfinit() datainit() Declaration void pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::datainit(const result_type *data) period_pow2() Declaration static constexpr size_t pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::period_pow2() operator()() Declaration PCG_ALWAYS_INLINE result_type pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::operator()() operator()() Declaration result_type pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::operator()(result_type upper_bound) set() Declaration void pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::set(result_type wanted) advance() Declaration void pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::advance(state_type distance, bool forwards=true) backstep() Declaration void pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::backstep(state_type distance) seed() Declaration void pcg_detail::extended<table_pow2, advance_pow2, baseclass, extvalclass, kdd>::seed(Args&&... args)"
  },
  "api/pcg/detail/halfsize/trait.html": {
    "href": "api/pcg/detail/halfsize/trait.html",
    "title": "Struct pcg_detail::halfsize_trait | qiotoolkit",
    "keywords": "Struct pcg_detail::halfsize_trait"
  },
  "api/pcg/detail/halfsize/trait/3/01pcg128/t/01/4.html": {
    "href": "api/pcg/detail/halfsize/trait/3/01pcg128/t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/pcg/detail/halfsize/trait/3/01uint16/t/01/4.html": {
    "href": "api/pcg/detail/halfsize/trait/3/01uint16/t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/pcg/detail/halfsize/trait/3/01uint32/t/01/4.html": {
    "href": "api/pcg/detail/halfsize/trait/3/01uint32/t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/pcg/detail/halfsize/trait/3/01uint64/t/01/4.html": {
    "href": "api/pcg/detail/halfsize/trait/3/01uint64/t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/pcg/detail/inside/out.html": {
    "href": "api/pcg/detail/inside/out.html",
    "title": "Struct pcg_detail::inside_out | qiotoolkit",
    "keywords": "Struct pcg_detail::inside_out Constructors inside_out() Declaration pcg_detail::inside_out<baseclass>::inside_out()=delete Methods external_step() Declaration static bool pcg_detail::inside_out<baseclass>::external_step(result_type&randval, size_t i) external_advance() Declaration static bool pcg_detail::inside_out<baseclass>::external_advance(result_type&randval, size_t i, result_type delta, bool forwards=true)"
  },
  "api/pcg/detail/mcg/multiplier.html": {
    "href": "api/pcg/detail/mcg/multiplier.html",
    "title": "Struct pcg_detail::mcg_multiplier | qiotoolkit",
    "keywords": "Struct pcg_detail::mcg_multiplier"
  },
  "api/pcg/detail/mcg/unmultiplier.html": {
    "href": "api/pcg/detail/mcg/unmultiplier.html",
    "title": "Struct pcg_detail::mcg_unmultiplier | qiotoolkit",
    "keywords": "Struct pcg_detail::mcg_unmultiplier"
  },
  "api/pcg/detail/no/stream.html": {
    "href": "api/pcg/detail/no/stream.html",
    "title": "Class pcg_detail::no_stream | qiotoolkit",
    "keywords": "Class pcg_detail::no_stream Inheritance pcg_detail::no_stream Constructors no_stream() Declaration constexpr pcg_detail::no_stream<itype>::no_stream()=default Methods set_stream() Declaration void pcg_detail::no_stream<itype>::set_stream(...) increment() Declaration static constexpr itype pcg_detail::no_stream<itype>::increment() streams_pow2() Declaration static constexpr size_t pcg_detail::no_stream<itype>::streams_pow2()"
  },
  "api/pcg/detail/oneseq/stream.html": {
    "href": "api/pcg/detail/oneseq/stream.html",
    "title": "Class pcg_detail::oneseq_stream | qiotoolkit",
    "keywords": "Class pcg_detail::oneseq_stream Inheritance pcg_detail::default_increment pcg_detail::oneseq_stream pcg_detail::engine Constructors oneseq_stream() Declaration constexpr pcg_detail::oneseq_stream<itype>::oneseq_stream()=default Methods set_stream() Declaration void pcg_detail::oneseq_stream<itype>::set_stream(...) stream() Declaration static constexpr itype pcg_detail::oneseq_stream<itype>::stream() streams_pow2() Declaration static constexpr size_t pcg_detail::oneseq_stream<itype>::streams_pow2()"
  },
  "api/pcg/detail/rxs/m/mixin.html": {
    "href": "api/pcg/detail/rxs/m/mixin.html",
    "title": "Struct pcg_detail::rxs_m_mixin | qiotoolkit",
    "keywords": "Struct pcg_detail::rxs_m_mixin Methods output() Declaration static xtype pcg_detail::rxs_m_mixin<xtype, itype>::output(itype internal)"
  },
  "api/pcg/detail/rxs/m/xs/mixin.html": {
    "href": "api/pcg/detail/rxs/m/xs/mixin.html",
    "title": "Struct pcg_detail::rxs_m_xs_mixin | qiotoolkit",
    "keywords": "Struct pcg_detail::rxs_m_xs_mixin Methods output() Declaration static xtype pcg_detail::rxs_m_xs_mixin::output(itype internal) unoutput() Declaration static itype pcg_detail::rxs_m_xs_mixin::unoutput(itype internal)"
  },
  "api/pcg/detail/rxs/mixin.html": {
    "href": "api/pcg/detail/rxs/mixin.html",
    "title": "Struct pcg_detail::rxs_mixin | qiotoolkit",
    "keywords": "Struct pcg_detail::rxs_mixin Methods output_rxs() Declaration static xtype pcg_detail::rxs_mixin<xtype, itype>::output_rxs(itype internal)"
  },
  "api/pcg/detail/specific/stream.html": {
    "href": "api/pcg/detail/specific/stream.html",
    "title": "Class pcg_detail::specific_stream | qiotoolkit",
    "keywords": "Class pcg_detail::specific_stream Inheritance pcg_detail::specific_stream Constructors specific_stream() Declaration pcg_detail::specific_stream<itype>::specific_stream()=default specific_stream() Declaration pcg_detail::specific_stream<itype>::specific_stream(itype specific_seq) Methods increment() Declaration constexpr itype pcg_detail::specific_stream<itype>::increment() const stream() Declaration itype pcg_detail::specific_stream<itype>::stream() set_stream() Declaration void pcg_detail::specific_stream<itype>::set_stream(itype specific_seq) streams_pow2() Declaration static constexpr size_t pcg_detail::specific_stream<itype>::streams_pow2()"
  },
  "api/pcg/detail/unique/stream.html": {
    "href": "api/pcg/detail/unique/stream.html",
    "title": "Class pcg_detail::unique_stream | qiotoolkit",
    "keywords": "Class pcg_detail::unique_stream Inheritance pcg_detail::unique_stream Constructors unique_stream() Declaration constexpr pcg_detail::unique_stream<itype>::unique_stream()=default Methods set_stream() Declaration void pcg_detail::unique_stream<itype>::set_stream(...) increment() Declaration constexpr itype pcg_detail::unique_stream<itype>::increment() const stream() Declaration constexpr itype pcg_detail::unique_stream<itype>::stream() const streams_pow2() Declaration static constexpr size_t pcg_detail::unique_stream<itype>::streams_pow2()"
  },
  "api/pcg/detail/xsh/mixin.html": {
    "href": "api/pcg/detail/xsh/mixin.html",
    "title": "Struct pcg_detail::xsh_mixin | qiotoolkit",
    "keywords": "Struct pcg_detail::xsh_mixin Methods output() Declaration static xtype pcg_detail::xsh_mixin<xtype, itype>::output(itype internal)"
  },
  "api/pcg/detail/xsh/rr/mixin.html": {
    "href": "api/pcg/detail/xsh/rr/mixin.html",
    "title": "Struct pcg_detail::xsh_rr_mixin | qiotoolkit",
    "keywords": "Struct pcg_detail::xsh_rr_mixin Methods output() Declaration static xtype pcg_detail::xsh_rr_mixin<xtype, itype>::output(itype internal)"
  },
  "api/pcg/detail/xsh/rs/mixin.html": {
    "href": "api/pcg/detail/xsh/rs/mixin.html",
    "title": "Struct pcg_detail::xsh_rs_mixin | qiotoolkit",
    "keywords": "Struct pcg_detail::xsh_rs_mixin Methods output() Declaration static xtype pcg_detail::xsh_rs_mixin<xtype, itype>::output(itype internal)"
  },
  "api/pcg/detail/xsl/mixin.html": {
    "href": "api/pcg/detail/xsl/mixin.html",
    "title": "Struct pcg_detail::xsl_mixin | qiotoolkit",
    "keywords": "Struct pcg_detail::xsl_mixin Methods output() Declaration xtype pcg_detail::xsl_mixin<xtype, itype>::output(itype internal)"
  },
  "api/pcg/detail/xsl/rr/mixin.html": {
    "href": "api/pcg/detail/xsl/rr/mixin.html",
    "title": "Struct pcg_detail::xsl_rr_mixin | qiotoolkit",
    "keywords": "Struct pcg_detail::xsl_rr_mixin Methods output() Declaration static xtype pcg_detail::xsl_rr_mixin<xtype, itype>::output(itype internal)"
  },
  "api/pcg/detail/xsl/rr/rr/mixin.html": {
    "href": "api/pcg/detail/xsl/rr/rr/mixin.html",
    "title": "Struct pcg_detail::xsl_rr_rr_mixin | qiotoolkit",
    "keywords": "Struct pcg_detail::xsl_rr_rr_mixin Methods output() Declaration static itype pcg_detail::xsl_rr_rr_mixin<xtype, itype>::output(itype internal)"
  },
  "api/pcg/extras/seed/seq/from.html": {
    "href": "api/pcg/extras/seed/seq/from.html",
    "title": "Class pcg_extras::seed_seq_from | qiotoolkit",
    "keywords": "Class pcg_extras::seed_seq_from Inheritance pcg_extras::seed_seq_from Constructors seed_seq_from() Declaration pcg_extras::seed_seq_from<RngType>::seed_seq_from(Args&&... args) Methods generate() Declaration void pcg_extras::seed_seq_from<RngType>::generate(Iter start, Iter finish) size() Declaration constexpr size_t pcg_extras::seed_seq_from<RngType>::size() const"
  },
  "api/pcg/extras/static/arbitrary/seed.html": {
    "href": "api/pcg/extras/static/arbitrary/seed.html",
    "title": "Struct pcg_extras::static_arbitrary_seed | qiotoolkit",
    "keywords": "Struct pcg_extras::static_arbitrary_seed Methods fnv() Declaration static constexpr IntType pcg_extras::static_arbitrary_seed<IntType>::fnv(IntType hash, const char *pos)"
  },
  "api/pcg/extras/uint/x4.html": {
    "href": "api/pcg/extras/uint/x4.html",
    "title": "Class pcg_extras::uint_x4 | qiotoolkit",
    "keywords": "Class pcg_extras::uint_x4 Inheritance pcg_extras::uint_x4 Constructors uint_x4() Declaration pcg_extras::uint_x4<UInt, UIntX2>::uint_x4()=default uint_x4() Declaration constexpr pcg_extras::uint_x4<UInt, UIntX2>::uint_x4(UInt v3, UInt v2, UInt v1, UInt v0) uint_x4() Declaration constexpr pcg_extras::uint_x4<UInt, UIntX2>::uint_x4(UIntX2 v23, UIntX2 v01) uint_x4() Declaration constexpr pcg_extras::uint_x4<UInt, UIntX2>::uint_x4(UIntX2 v01) uint_x4() Declaration constexpr pcg_extras::uint_x4<UInt, UIntX2>::uint_x4(Integral v01) Methods operator UIntX2() Declaration constexpr pcg_extras::uint_x4<UInt, UIntX2>::operator UIntX2() const operator Integral() Declaration constexpr pcg_extras::uint_x4<UInt, UIntX2>::operator Integral() const operator bool() Declaration constexpr pcg_extras::uint_x4<UInt, UIntX2>::operator bool() const operator*=() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator*=(const uint_x4&rhs) operator*=() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator*=(UIntX2 rhs) operator/=() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator/=(const uint_x4&rhs) operator%=() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator%=(const uint_x4&rhs) operator+=() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator+=(const uint_x4&rhs) operator-=() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator-=(const uint_x4&rhs) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator&=(const uint_x4&rhs) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator&=(const uint_x4&rhs) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator&=(const uint_x4&rhs) operator|=() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator|=(const uint_x4&rhs) operator^=() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator^=(const uint_x4&rhs) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator>>=(bitcount_t shift) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator>>=(bitcount_t shift) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator>>=(bitcount_t shift) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator>>=(bitcount_t shift) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator<<=(bitcount_t shift) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator<<=(bitcount_t shift) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator<<=(bitcount_t shift) =() Declaration uint_x4&pcg_extras::uint_x4<UInt, UIntX2>::operator<<=(bitcount_t shift)"
  },
  "api/person.html": {
    "href": "api/person.html",
    "title": "Class Person | qiotoolkit",
    "keywords": "Class Person Inheritance Person Dependent Employee Constructors Person() Declaration Person::Person(const std::string&name, unsigned age) Person() Declaration Person::Person(const Person&rhs) Methods ~Person() Declaration Person::~Person() operator=() Declaration Person&Person::operator=(const Person&rhs) Serialize() Declaration void Person::Serialize(Writer&writer) const"
  },
  "api/pre-calculated-prime-table.html": {
    "href": "api/pre-calculated-prime-table.html",
    "title": "Class PreCalculatedPrimeTable | qiotoolkit",
    "keywords": "Class PreCalculatedPrimeTable Inheritance PrimeTable PreCalculatedPrimeTable Inherited Members ~PrimeTable Constructors PreCalculatedPrimeTable() Declaration PreCalculatedPrimeTable::PreCalculatedPrimeTable(int max) PreCalculatedPrimeTable() Declaration PreCalculatedPrimeTable::PreCalculatedPrimeTable(int max) Methods ~PreCalculatedPrimeTable() Declaration PreCalculatedPrimeTable::~PreCalculatedPrimeTable() override IsPrime() Declaration bool PreCalculatedPrimeTable::IsPrime(int n) const override GetNextPrime() Declaration int PreCalculatedPrimeTable::GetNextPrime(int p) const override ~PreCalculatedPrimeTable() Declaration virtual PreCalculatedPrimeTable::~PreCalculatedPrimeTable() IsPrime() Declaration virtual bool PreCalculatedPrimeTable::IsPrime(int n) const GetNextPrime() Declaration virtual int PreCalculatedPrimeTable::GetNextPrime(int p) const CalculatePrimesUpTo() Declaration void PreCalculatedPrimeTable::CalculatePrimesUpTo(int max) operator=() Declaration void PreCalculatedPrimeTable::operator=(const PreCalculatedPrimeTable&rhs) CalculatePrimesUpTo() Declaration void PreCalculatedPrimeTable::CalculatePrimesUpTo(int max) operator=() Declaration void PreCalculatedPrimeTable::operator=(const PreCalculatedPrimeTable&rhs)"
  },
  "api/pretty-writer.html": {
    "href": "api/pretty-writer.html",
    "title": "Class PrettyWriter | qiotoolkit",
    "keywords": "Class PrettyWriter Writer with indentation and spacing. OutputStream Type of output os. SourceEncoding Encoding of source string. TargetEncoding Encoding of output stream. StackAllocator Type of allocator for allocating memory of stack. Inheritance PrettyWriter Constructors PrettyWriter() Declaration PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::PrettyWriter(const PrettyWriter&) PrettyWriter() Constructor. os Output stream. allocator User supplied allocator. If it is null, it will create a private one. levelDepth Initial capacity of stack. Declaration PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::PrettyWriter(OutputStream&os, StackAllocator *allocator=0, size_t levelDepth=Base::kDefaultLevelDepth) PrettyWriter() Declaration PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::PrettyWriter(StackAllocator *allocator=0, size_t levelDepth=Base::kDefaultLevelDepth) Methods Null() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Null() Bool() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Bool(bool b) Int() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Int(int i) Uint() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Uint(unsigned u) Int64() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Int64(int64_t i64) Uint64() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Uint64(uint64_t u64) Double() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Double(double d) RawNumber() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::RawNumber(const Ch *str, SizeType length, bool copy=false) String() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::String(const Ch *str, SizeType length, bool copy=false) StartObject() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::StartObject() Key() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Key(const Ch *str, SizeType length, bool copy=false) EndObject() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::EndObject(SizeType memberCount=0) StartArray() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::StartArray() EndArray() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::EndArray(SizeType memberCount=0) String() Simpler but slower overload. Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::String(const Ch *str) Key() Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Key(const Ch *str) RawValue() Write a raw JSON value. For user to write a stringified JSON as a value. json A well-formed JSON value. It should not contain null character within [0, length - 1] range. length Length of the json. type Type of the root of json. When using PrettyWriter::RawValue(), the result json may not be indented correctly. Declaration bool PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::RawValue(const Ch *json, size_t length, Type type) PrettyPrefix() Declaration void PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::PrettyPrefix(Type type) WriteIndent() Declaration void PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteIndent() operator=() Declaration PrettyWriter&PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::operator=(const PrettyWriter&) SetIndent() Set custom indentation. indentChar Character for indentation. Must be whitespace character (' ', '\\t', '\\n', '\\r'). indentCharCount Number of indent characters for each indentation level. The default indentation is 4 spaces. Declaration PrettyWriter&PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::SetIndent(Ch indentChar, unsigned indentCharCount) SetFormatOptions() Set pretty writer formatting options. options Formatting options. Declaration PrettyWriter&PrettyWriter<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::SetFormatOptions(PrettyFormatOptions options)"
  },
  "api/prime-table.html": {
    "href": "api/prime-table.html",
    "title": "Class PrimeTable | qiotoolkit",
    "keywords": "Class PrimeTable Inheritance PrimeTable OnTheFlyPrimeTable PreCalculatedPrimeTable Methods ~PrimeTable() Declaration virtual PrimeTable::~PrimeTable() IsPrime() Declaration virtual bool PrimeTable::IsPrime(int n) const =0 GetNextPrime() Declaration virtual int PrimeTable::GetNextPrime(int p) const =0 ~PrimeTable() Declaration virtual PrimeTable::~PrimeTable() IsPrime() Declaration virtual bool PrimeTable::IsPrime(int n) const =0 GetNextPrime() Declaration virtual int PrimeTable::GetNextPrime(int p) const =0"
  },
  "api/pump/code-node.html": {
    "href": "api/pump/code-node.html",
    "title": "Class pump::CodeNode | qiotoolkit",
    "keywords": "Class pump::CodeNode Inheritance pump::CodeNode Methods __init__() Declaration def pump.CodeNode.__init__(self, atomic_code_list=None) __init__() Declaration def pump.CodeNode.__init__(self, atomic_code_list=None)"
  },
  "api/pump/cursor.html": {
    "href": "api/pump/cursor.html",
    "title": "Class pump::Cursor | qiotoolkit",
    "keywords": "Class pump::Cursor Represents a position (line and column) in a text file. Inheritance pump::Cursor Methods __init__() Declaration def pump.Cursor.__init__(self, line=-1, column=-1) __eq__() Declaration def pump.Cursor.__eq__(self, rhs) __ne__() Declaration def pump.Cursor.__ne__(self, rhs) __lt__() Declaration def pump.Cursor.__lt__(self, rhs) __le__() Declaration def pump.Cursor.__le__(self, rhs) __gt__() Declaration def pump.Cursor.__gt__(self, rhs) __ge__() Declaration def pump.Cursor.__ge__(self, rhs) __str__() Declaration def pump.Cursor.__str__(self) __add__() Declaration def pump.Cursor.__add__(self, offset) __sub__() Declaration def pump.Cursor.__sub__(self, offset) Clone() Returns a copy of self. Declaration def pump.Cursor.Clone(self) __init__() Declaration def pump.Cursor.__init__(self, line=-1, column=-1) __eq__() Declaration def pump.Cursor.__eq__(self, rhs) __ne__() Declaration def pump.Cursor.__ne__(self, rhs) __lt__() Declaration def pump.Cursor.__lt__(self, rhs) __le__() Declaration def pump.Cursor.__le__(self, rhs) __gt__() Declaration def pump.Cursor.__gt__(self, rhs) __ge__() Declaration def pump.Cursor.__ge__(self, rhs) __str__() Declaration def pump.Cursor.__str__(self) __add__() Declaration def pump.Cursor.__add__(self, offset) __sub__() Declaration def pump.Cursor.__sub__(self, offset) Clone() Returns a copy of self. Declaration def pump.Cursor.Clone(self)"
  },
  "api/pump/else-node.html": {
    "href": "api/pump/else-node.html",
    "title": "Class pump::ElseNode | qiotoolkit",
    "keywords": "Class pump::ElseNode Inheritance pump::ElseNode Methods __init__() Declaration def pump.ElseNode.__init__(self, else_branch=None) __init__() Declaration def pump.ElseNode.__init__(self, else_branch=None)"
  },
  "api/pump/env.html": {
    "href": "api/pump/env.html",
    "title": "Class pump::Env | qiotoolkit",
    "keywords": "Class pump::Env Inheritance pump::Env Methods __init__() Declaration def pump.Env.__init__(self) Clone() Declaration def pump.Env.Clone(self) PushVariable() Declaration def pump.Env.PushVariable(self, var, value) PopVariable() Declaration def pump.Env.PopVariable(self) PushRange() Declaration def pump.Env.PushRange(self, var, lower, upper) PopRange() Declaration def pump.Env.PopRange(self) GetValue() Declaration def pump.Env.GetValue(self, identifier) EvalExp() Declaration def pump.Env.EvalExp(self, exp) GetRange() Declaration def pump.Env.GetRange(self, identifier) __init__() Declaration def pump.Env.__init__(self) Clone() Declaration def pump.Env.Clone(self) PushVariable() Declaration def pump.Env.PushVariable(self, var, value) PopVariable() Declaration def pump.Env.PopVariable(self) PushRange() Declaration def pump.Env.PushRange(self, var, lower, upper) PopRange() Declaration def pump.Env.PopRange(self) GetValue() Declaration def pump.Env.GetValue(self, identifier) EvalExp() Declaration def pump.Env.EvalExp(self, exp) GetRange() Declaration def pump.Env.GetRange(self, identifier)"
  },
  "api/pump/exp-node.html": {
    "href": "api/pump/exp-node.html",
    "title": "Class pump::ExpNode | qiotoolkit",
    "keywords": "Class pump::ExpNode Inheritance pump::ExpNode Methods __init__() Declaration def pump.ExpNode.__init__(self, token, python_exp) __init__() Declaration def pump.ExpNode.__init__(self, token, python_exp)"
  },
  "api/pump/for-node.html": {
    "href": "api/pump/for-node.html",
    "title": "Class pump::ForNode | qiotoolkit",
    "keywords": "Class pump::ForNode Inheritance pump::ForNode Methods __init__() Declaration def pump.ForNode.__init__(self, identifier=None, sep=None, code=None) __init__() Declaration def pump.ForNode.__init__(self, identifier=None, sep=None, code=None)"
  },
  "api/pump/if-node.html": {
    "href": "api/pump/if-node.html",
    "title": "Class pump::IfNode | qiotoolkit",
    "keywords": "Class pump::IfNode Inheritance pump::IfNode Methods __init__() Declaration def pump.IfNode.__init__(self, exp=None, then_branch=None, else_branch=None) __init__() Declaration def pump.IfNode.__init__(self, exp=None, then_branch=None, else_branch=None)"
  },
  "api/pump/literal-dollar-node.html": {
    "href": "api/pump/literal-dollar-node.html",
    "title": "Class pump::LiteralDollarNode | qiotoolkit",
    "keywords": "Class pump::LiteralDollarNode Inheritance pump::LiteralDollarNode Methods __init__() Declaration def pump.LiteralDollarNode.__init__(self, token) __init__() Declaration def pump.LiteralDollarNode.__init__(self, token)"
  },
  "api/pump/output.html": {
    "href": "api/pump/output.html",
    "title": "Class pump::Output | qiotoolkit",
    "keywords": "Class pump::Output Inheritance pump::Output Methods __init__() Declaration def pump.Output.__init__(self) GetLastLine() Declaration def pump.Output.GetLastLine(self) Append() Declaration def pump.Output.Append(self, s) __init__() Declaration def pump.Output.__init__(self) GetLastLine() Declaration def pump.Output.GetLastLine(self) Append() Declaration def pump.Output.Append(self, s)"
  },
  "api/pump/range-node.html": {
    "href": "api/pump/range-node.html",
    "title": "Class pump::RangeNode | qiotoolkit",
    "keywords": "Class pump::RangeNode Inheritance pump::RangeNode Methods __init__() Declaration def pump.RangeNode.__init__(self, identifier=None, exp1=None, exp2=None) __init__() Declaration def pump.RangeNode.__init__(self, identifier=None, exp1=None, exp2=None)"
  },
  "api/pump/raw-code-node.html": {
    "href": "api/pump/raw-code-node.html",
    "title": "Class pump::RawCodeNode | qiotoolkit",
    "keywords": "Class pump::RawCodeNode Inheritance pump::RawCodeNode Methods __init__() Declaration def pump.RawCodeNode.__init__(self, token=None) __init__() Declaration def pump.RawCodeNode.__init__(self, token=None)"
  },
  "api/pump/token.html": {
    "href": "api/pump/token.html",
    "title": "Class pump::Token | qiotoolkit",
    "keywords": "Class pump::Token Represents a token in a Pump source file. Inheritance pump::Token Methods __init__() Declaration def pump.Token.__init__(self, start=None, end=None, value=None, token_type=None) __str__() Declaration def pump.Token.__str__(self) Clone() Returns a copy of self. Declaration def pump.Token.Clone(self) __init__() Declaration def pump.Token.__init__(self, start=None, end=None, value=None, token_type=None) __str__() Declaration def pump.Token.__str__(self) Clone() Returns a copy of self. Declaration def pump.Token.Clone(self)"
  },
  "api/pump/var-node.html": {
    "href": "api/pump/var-node.html",
    "title": "Class pump::VarNode | qiotoolkit",
    "keywords": "Class pump::VarNode Inheritance pump::VarNode Methods __init__() Declaration def pump.VarNode.__init__(self, identifier=None, atomic_code=None) __init__() Declaration def pump.VarNode.__init__(self, identifier=None, atomic_code=None)"
  },
  "api/quantum-util/problem-default-type-internal.html": {
    "href": "api/quantum-util/problem-default-type-internal.html",
    "title": "Struct QuantumUtil::ProblemDefaultTypeInternal | qiotoolkit",
    "keywords": "Struct QuantumUtil::ProblemDefaultTypeInternal Constructors ProblemDefaultTypeInternal() Declaration PROTOBUF_CONSTEXPR QuantumUtil::ProblemDefaultTypeInternal::ProblemDefaultTypeInternal() Methods ~ProblemDefaultTypeInternal() Declaration QuantumUtil::ProblemDefaultTypeInternal::~ProblemDefaultTypeInternal()"
  },
  "api/quantum-util/problem.html": {
    "href": "api/quantum-util/problem.html",
    "title": "Class QuantumUtil::Problem | qiotoolkit",
    "keywords": "Class QuantumUtil::Problem Inheritance QuantumUtil::Problem Constructors Problem() Declaration QuantumUtil::Problem::Problem() Problem() Declaration PROTOBUF_CONSTEXPR QuantumUtil::Problem::Problem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized) Problem() Declaration QuantumUtil::Problem::Problem(const Problem&from) Problem() Declaration QuantumUtil::Problem::Problem(Problem&&from) noexcept Problem() Declaration QuantumUtil::Problem::Problem(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned=false) Methods ~Problem() Declaration QuantumUtil::Problem::~Problem() override operator=() Declaration Problem&QuantumUtil::Problem::operator=(const Problem&from) operator=() Declaration Problem&QuantumUtil::Problem::operator=(Problem&&from) noexcept Swap() Declaration void QuantumUtil::Problem::Swap(Problem *other) UnsafeArenaSwap() Declaration void QuantumUtil::Problem::UnsafeArenaSwap(Problem *other) New() Declaration Problem* QuantumUtil::Problem::New(::PROTOBUF_NAMESPACE_ID::Arena *arena=nullptr) const final CopyFrom() Declaration void QuantumUtil::Problem::CopyFrom(const Problem&from) MergeFrom() Declaration void QuantumUtil::Problem::MergeFrom(const Problem&from) Clear() Declaration void QuantumUtil::Problem::Clear() final IsInitialized() Declaration bool QuantumUtil::Problem::IsInitialized() const final ByteSizeLong() Declaration size_t QuantumUtil::Problem::ByteSizeLong() const final _InternalParse() Declaration const char * QuantumUtil::Problem::_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final _InternalSerialize() Declaration uint8_t * QuantumUtil::Problem::_InternalSerialize(uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final GetCachedSize() Declaration int QuantumUtil::Problem::GetCachedSize() const final GetClassData() Declaration const ::PROTOBUF_NAMESPACE_ID::Message::ClassData * QuantumUtil::Problem::GetClassData() const final GetMetadata() Declaration PROTOBUF_NAMESPACE_ID::Metadata QuantumUtil::Problem::GetMetadata() const final has_cost_function() Declaration bool QuantumUtil::Problem::has_cost_function() const clear_cost_function() Declaration void QuantumUtil::Problem::clear_cost_function() cost_function() Declaration const ::QuantumUtil::Problem_CostFunction&QuantumUtil::Problem::cost_function() const release_cost_function() Declaration QuantumUtil::Problem_CostFunction * QuantumUtil::Problem::release_cost_function() mutable_cost_function() Declaration QuantumUtil::Problem_CostFunction * QuantumUtil::Problem::mutable_cost_function() set_allocated_cost_function() Declaration void QuantumUtil::Problem::set_allocated_cost_function(::QuantumUtil::Problem_CostFunction *cost_function) unsafe_arena_set_allocated_cost_function() Declaration void QuantumUtil::Problem::unsafe_arena_set_allocated_cost_function(::QuantumUtil::Problem_CostFunction *cost_function) unsafe_arena_release_cost_function() Declaration QuantumUtil::Problem_CostFunction * QuantumUtil::Problem::unsafe_arena_release_cost_function() has_metadata() Declaration bool QuantumUtil::Problem::has_metadata() const clear_metadata() Declaration void QuantumUtil::Problem::clear_metadata() metadata() Declaration const ::PROTOBUF_NAMESPACE_ID::Struct&QuantumUtil::Problem::metadata() const release_metadata() Declaration PROTOBUF_NAMESPACE_ID::Struct * QuantumUtil::Problem::release_metadata() mutable_metadata() Declaration PROTOBUF_NAMESPACE_ID::Struct * QuantumUtil::Problem::mutable_metadata() set_allocated_metadata() Declaration void QuantumUtil::Problem::set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct *metadata) unsafe_arena_set_allocated_metadata() Declaration void QuantumUtil::Problem::unsafe_arena_set_allocated_metadata(::PROTOBUF_NAMESPACE_ID::Struct *metadata) unsafe_arena_release_metadata() Declaration PROTOBUF_NAMESPACE_ID::Struct * QuantumUtil::Problem::unsafe_arena_release_metadata() descriptor() Declaration static const ::PROTOBUF_NAMESPACE_ID::Descriptor* QuantumUtil::Problem::descriptor() GetDescriptor() Declaration static const ::PROTOBUF_NAMESPACE_ID::Descriptor* QuantumUtil::Problem::GetDescriptor() GetReflection() Declaration static const ::PROTOBUF_NAMESPACE_ID::Reflection* QuantumUtil::Problem::GetReflection() default_instance() Declaration static const Problem&QuantumUtil::Problem::default_instance() internal_default_instance() Declaration static const Problem* QuantumUtil::Problem::internal_default_instance() ProblemType_IsValid() Declaration static bool QuantumUtil::Problem::ProblemType_IsValid(int value) ProblemType_descriptor() Declaration static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuantumUtil::Problem::ProblemType_descriptor() ProblemType_Name() Declaration static const std::string&QuantumUtil::Problem::ProblemType_Name(T enum_t_value) ProblemType_Parse() Declaration static bool QuantumUtil::Problem::ProblemType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProblemType *value) MergeImpl() Declaration void QuantumUtil::Problem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message *to, const ::PROTOBUF_NAMESPACE_ID::Message&from) FullMessageName() Declaration ::PROTOBUF_NAMESPACE_ID::StringPiece QuantumUtil::Problem::FullMessageName() SharedCtor() Declaration void QuantumUtil::Problem::SharedCtor() SharedDtor() Declaration void QuantumUtil::Problem::SharedDtor() SetCachedSize() Declaration void QuantumUtil::Problem::SetCachedSize(int size) const final InternalSwap() Declaration void QuantumUtil::Problem::InternalSwap(Problem *other) _internal_has_cost_function() Declaration bool QuantumUtil::Problem::_internal_has_cost_function() const _internal_cost_function() Declaration const ::QuantumUtil::Problem_CostFunction&QuantumUtil::Problem::_internal_cost_function() const _internal_mutable_cost_function() Declaration QuantumUtil::Problem_CostFunction * QuantumUtil::Problem::_internal_mutable_cost_function() _internal_has_metadata() Declaration bool QuantumUtil::Problem::_internal_has_metadata() const _internal_metadata() Declaration const ::PROTOBUF_NAMESPACE_ID::Struct&QuantumUtil::Problem::_internal_metadata() const _internal_mutable_metadata() Declaration PROTOBUF_NAMESPACE_ID::Struct * QuantumUtil::Problem::_internal_mutable_metadata()"
  },
  "api/quantum-util/problem/cost-function-default-type-internal.html": {
    "href": "api/quantum-util/problem/cost-function-default-type-internal.html",
    "title": "Struct QuantumUtil::Problem_CostFunctionDefaultTypeInternal | qiotoolkit",
    "keywords": "Struct QuantumUtil::Problem_CostFunctionDefaultTypeInternal Constructors Problem_CostFunctionDefaultTypeInternal() Declaration PROTOBUF_CONSTEXPR QuantumUtil::Problem_CostFunctionDefaultTypeInternal::Problem_CostFunctionDefaultTypeInternal() Methods ~Problem_CostFunctionDefaultTypeInternal() Declaration QuantumUtil::Problem_CostFunctionDefaultTypeInternal::~Problem_CostFunctionDefaultTypeInternal()"
  },
  "api/quantum-util/problem/cost-function.html": {
    "href": "api/quantum-util/problem/cost-function.html",
    "title": "Class QuantumUtil::Problem_CostFunction | qiotoolkit",
    "keywords": "Class QuantumUtil::Problem_CostFunction Inheritance QuantumUtil::Problem_CostFunction Constructors Problem_CostFunction() Declaration QuantumUtil::Problem_CostFunction::Problem_CostFunction() Problem_CostFunction() Declaration PROTOBUF_CONSTEXPR QuantumUtil::Problem_CostFunction::Problem_CostFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized) Problem_CostFunction() Declaration QuantumUtil::Problem_CostFunction::Problem_CostFunction(const Problem_CostFunction&from) Problem_CostFunction() Declaration QuantumUtil::Problem_CostFunction::Problem_CostFunction(Problem_CostFunction&&from) noexcept Problem_CostFunction() Declaration QuantumUtil::Problem_CostFunction::Problem_CostFunction(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned=false) Methods ~Problem_CostFunction() Declaration QuantumUtil::Problem_CostFunction::~Problem_CostFunction() override operator=() Declaration Problem_CostFunction&QuantumUtil::Problem_CostFunction::operator=(const Problem_CostFunction&from) operator=() Declaration Problem_CostFunction&QuantumUtil::Problem_CostFunction::operator=(Problem_CostFunction&&from) noexcept Swap() Declaration void QuantumUtil::Problem_CostFunction::Swap(Problem_CostFunction *other) UnsafeArenaSwap() Declaration void QuantumUtil::Problem_CostFunction::UnsafeArenaSwap(Problem_CostFunction *other) New() Declaration Problem_CostFunction* QuantumUtil::Problem_CostFunction::New(::PROTOBUF_NAMESPACE_ID::Arena *arena=nullptr) const final CopyFrom() Declaration void QuantumUtil::Problem_CostFunction::CopyFrom(const Problem_CostFunction&from) MergeFrom() Declaration void QuantumUtil::Problem_CostFunction::MergeFrom(const Problem_CostFunction&from) Clear() Declaration void QuantumUtil::Problem_CostFunction::Clear() final IsInitialized() Declaration bool QuantumUtil::Problem_CostFunction::IsInitialized() const final ByteSizeLong() Declaration size_t QuantumUtil::Problem_CostFunction::ByteSizeLong() const final _InternalParse() Declaration const char * QuantumUtil::Problem_CostFunction::_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final _InternalSerialize() Declaration uint8_t * QuantumUtil::Problem_CostFunction::_InternalSerialize(uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final GetCachedSize() Declaration int QuantumUtil::Problem_CostFunction::GetCachedSize() const final GetClassData() Declaration const ::PROTOBUF_NAMESPACE_ID::Message::ClassData * QuantumUtil::Problem_CostFunction::GetClassData() const final GetMetadata() Declaration PROTOBUF_NAMESPACE_ID::Metadata QuantumUtil::Problem_CostFunction::GetMetadata() const final terms_size() Declaration int QuantumUtil::Problem_CostFunction::terms_size() const clear_terms() Declaration void QuantumUtil::Problem_CostFunction::clear_terms() mutable_terms() Declaration QuantumUtil::Problem_Term * QuantumUtil::Problem_CostFunction::mutable_terms(int index) mutable_terms() Declaration PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::QuantumUtil::Problem_Term>* QuantumUtil::Problem_CostFunction::mutable_terms() terms() Declaration const ::QuantumUtil::Problem_Term&QuantumUtil::Problem_CostFunction::terms(int index) const add_terms() Declaration QuantumUtil::Problem_Term * QuantumUtil::Problem_CostFunction::add_terms() terms() Declaration const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::QuantumUtil::Problem_Term>&QuantumUtil::Problem_CostFunction::terms() const init_config_size() Declaration int QuantumUtil::Problem_CostFunction::init_config_size() const clear_init_config() Declaration void QuantumUtil::Problem_CostFunction::clear_init_config() init_config() Declaration const ::PROTOBUF_NAMESPACE_ID::Map<std::string, int64_t>&QuantumUtil::Problem_CostFunction::init_config() const mutable_init_config() Declaration PROTOBUF_NAMESPACE_ID::Map<std::string, int64_t>* QuantumUtil::Problem_CostFunction::mutable_init_config() clear_version() Declaration void QuantumUtil::Problem_CostFunction::clear_version() version() Declaration const std::string&QuantumUtil::Problem_CostFunction::version() const set_version() Declaration void QuantumUtil::Problem_CostFunction::set_version(ArgT0&&arg0, ArgT... args) mutable_version() Declaration std::string * QuantumUtil::Problem_CostFunction::mutable_version() release_version() Declaration std::string * QuantumUtil::Problem_CostFunction::release_version() set_allocated_version() Declaration void QuantumUtil::Problem_CostFunction::set_allocated_version(std::string *version) clear_type() Declaration void QuantumUtil::Problem_CostFunction::clear_type() type() Declaration QuantumUtil::Problem_ProblemType QuantumUtil::Problem_CostFunction::type() const set_type() Declaration void QuantumUtil::Problem_CostFunction::set_type(::QuantumUtil::Problem_ProblemType value) set_version() Declaration PROTOBUF_ALWAYS_INLINE void QuantumUtil::Problem_CostFunction::set_version(ArgT0&&arg0, ArgT... args) descriptor() Declaration static const ::PROTOBUF_NAMESPACE_ID::Descriptor* QuantumUtil::Problem_CostFunction::descriptor() GetDescriptor() Declaration static const ::PROTOBUF_NAMESPACE_ID::Descriptor* QuantumUtil::Problem_CostFunction::GetDescriptor() GetReflection() Declaration static const ::PROTOBUF_NAMESPACE_ID::Reflection* QuantumUtil::Problem_CostFunction::GetReflection() default_instance() Declaration static const Problem_CostFunction&QuantumUtil::Problem_CostFunction::default_instance() internal_default_instance() Declaration static const Problem_CostFunction* QuantumUtil::Problem_CostFunction::internal_default_instance() MergeImpl() Declaration void QuantumUtil::Problem_CostFunction::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message *to, const ::PROTOBUF_NAMESPACE_ID::Message&from) FullMessageName() Declaration ::PROTOBUF_NAMESPACE_ID::StringPiece QuantumUtil::Problem_CostFunction::FullMessageName() ArenaDtor() Declaration void QuantumUtil::Problem_CostFunction::ArenaDtor(void *object) SharedCtor() Declaration void QuantumUtil::Problem_CostFunction::SharedCtor() SharedDtor() Declaration void QuantumUtil::Problem_CostFunction::SharedDtor() SetCachedSize() Declaration void QuantumUtil::Problem_CostFunction::SetCachedSize(int size) const final InternalSwap() Declaration void QuantumUtil::Problem_CostFunction::InternalSwap(Problem_CostFunction *other) _internal_terms_size() Declaration int QuantumUtil::Problem_CostFunction::_internal_terms_size() const _internal_terms() Declaration const ::QuantumUtil::Problem_Term&QuantumUtil::Problem_CostFunction::_internal_terms(int index) const _internal_add_terms() Declaration QuantumUtil::Problem_Term * QuantumUtil::Problem_CostFunction::_internal_add_terms() _internal_init_config_size() Declaration int QuantumUtil::Problem_CostFunction::_internal_init_config_size() const _internal_init_config() Declaration const ::PROTOBUF_NAMESPACE_ID::Map<std::string, int64_t>&QuantumUtil::Problem_CostFunction::_internal_init_config() const _internal_mutable_init_config() Declaration PROTOBUF_NAMESPACE_ID::Map<std::string, int64_t>* QuantumUtil::Problem_CostFunction::_internal_mutable_init_config() _internal_version() Declaration const std::string&QuantumUtil::Problem_CostFunction::_internal_version() const _internal_set_version() Declaration void QuantumUtil::Problem_CostFunction::_internal_set_version(const std::string&value) _internal_mutable_version() Declaration std::string * QuantumUtil::Problem_CostFunction::_internal_mutable_version() _internal_type() Declaration QuantumUtil::Problem_ProblemType QuantumUtil::Problem_CostFunction::_internal_type() const _internal_set_type() Declaration void QuantumUtil::Problem_CostFunction::_internal_set_type(::QuantumUtil::Problem_ProblemType value)"
  },
  "api/quantum-util/problem/cost-function/init-config-entry/do-not-use-default-type-internal.html": {
    "href": "api/quantum-util/problem/cost-function/init-config-entry/do-not-use-default-type-internal.html",
    "title": "Struct QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUseDefaultTypeInternal | qiotoolkit",
    "keywords": "Struct QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUseDefaultTypeInternal Constructors Problem_CostFunction_InitConfigEntry_DoNotUseDefaultTypeInternal() Declaration PROTOBUF_CONSTEXPR QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUseDefaultTypeInternal::Problem_CostFunction_InitConfigEntry_DoNotUseDefaultTypeInternal() Methods ~Problem_CostFunction_InitConfigEntry_DoNotUseDefaultTypeInternal() Declaration QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUseDefaultTypeInternal::~Problem_CostFunction_InitConfigEntry_DoNotUseDefaultTypeInternal()"
  },
  "api/quantum-util/problem/cost-function/init-config-entry/do-not-use.html": {
    "href": "api/quantum-util/problem/cost-function/init-config-entry/do-not-use.html",
    "title": "Class QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse | qiotoolkit",
    "keywords": "Class QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse Inheritance QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse Constructors Problem_CostFunction_InitConfigEntry_DoNotUse() Declaration QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse::Problem_CostFunction_InitConfigEntry_DoNotUse() Problem_CostFunction_InitConfigEntry_DoNotUse() Declaration PROTOBUF_CONSTEXPR QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse::Problem_CostFunction_InitConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized) Problem_CostFunction_InitConfigEntry_DoNotUse() Declaration QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse::Problem_CostFunction_InitConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena *arena) Methods MergeFrom() Declaration void QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse::MergeFrom(const Problem_CostFunction_InitConfigEntry_DoNotUse&other) GetMetadata() Declaration PROTOBUF_NAMESPACE_ID::Metadata QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse::GetMetadata() const final internal_default_instance() Declaration static const Problem_CostFunction_InitConfigEntry_DoNotUse* QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse::internal_default_instance() ValidateKey() Declaration static bool QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse::ValidateKey(std::string *s) ValidateValue() Declaration static bool QuantumUtil::Problem_CostFunction_InitConfigEntry_DoNotUse::ValidateValue(void *)"
  },
  "api/quantum-util/problem/cost-function/internal.html": {
    "href": "api/quantum-util/problem/cost-function/internal.html",
    "title": "Class QuantumUtil::Problem_CostFunction::_Internal | qiotoolkit",
    "keywords": "Class QuantumUtil::Problem_CostFunction::_Internal Inheritance QuantumUtil::Problem_CostFunction::_Internal"
  },
  "api/quantum-util/problem/internal.html": {
    "href": "api/quantum-util/problem/internal.html",
    "title": "Class QuantumUtil::Problem::_Internal | qiotoolkit",
    "keywords": "Class QuantumUtil::Problem::_Internal Inheritance QuantumUtil::Problem::_Internal Methods cost_function() Declaration const ::QuantumUtil::Problem_CostFunction&QuantumUtil::Problem::_Internal::cost_function(const Problem *msg) metadata() Declaration const ::PROTOBUF_NAMESPACE_ID::Struct&QuantumUtil::Problem::_Internal::metadata(const Problem *msg)"
  },
  "api/quantum-util/problem/term-default-type-internal.html": {
    "href": "api/quantum-util/problem/term-default-type-internal.html",
    "title": "Struct QuantumUtil::Problem_TermDefaultTypeInternal | qiotoolkit",
    "keywords": "Struct QuantumUtil::Problem_TermDefaultTypeInternal Constructors Problem_TermDefaultTypeInternal() Declaration PROTOBUF_CONSTEXPR QuantumUtil::Problem_TermDefaultTypeInternal::Problem_TermDefaultTypeInternal() Methods ~Problem_TermDefaultTypeInternal() Declaration QuantumUtil::Problem_TermDefaultTypeInternal::~Problem_TermDefaultTypeInternal()"
  },
  "api/quantum-util/problem/term.html": {
    "href": "api/quantum-util/problem/term.html",
    "title": "Class QuantumUtil::Problem_Term | qiotoolkit",
    "keywords": "Class QuantumUtil::Problem_Term Inheritance QuantumUtil::Problem_Term Constructors Problem_Term() Declaration QuantumUtil::Problem_Term::Problem_Term() Problem_Term() Declaration PROTOBUF_CONSTEXPR QuantumUtil::Problem_Term::Problem_Term(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized) Problem_Term() Declaration QuantumUtil::Problem_Term::Problem_Term(const Problem_Term&from) Problem_Term() Declaration QuantumUtil::Problem_Term::Problem_Term(Problem_Term&&from) noexcept Problem_Term() Declaration QuantumUtil::Problem_Term::Problem_Term(::PROTOBUF_NAMESPACE_ID::Arena *arena, bool is_message_owned=false) Methods ~Problem_Term() Declaration QuantumUtil::Problem_Term::~Problem_Term() override operator=() Declaration Problem_Term&QuantumUtil::Problem_Term::operator=(const Problem_Term&from) operator=() Declaration Problem_Term&QuantumUtil::Problem_Term::operator=(Problem_Term&&from) noexcept Swap() Declaration void QuantumUtil::Problem_Term::Swap(Problem_Term *other) UnsafeArenaSwap() Declaration void QuantumUtil::Problem_Term::UnsafeArenaSwap(Problem_Term *other) New() Declaration Problem_Term* QuantumUtil::Problem_Term::New(::PROTOBUF_NAMESPACE_ID::Arena *arena=nullptr) const final CopyFrom() Declaration void QuantumUtil::Problem_Term::CopyFrom(const Problem_Term&from) MergeFrom() Declaration void QuantumUtil::Problem_Term::MergeFrom(const Problem_Term&from) Clear() Declaration void QuantumUtil::Problem_Term::Clear() final IsInitialized() Declaration bool QuantumUtil::Problem_Term::IsInitialized() const final ByteSizeLong() Declaration size_t QuantumUtil::Problem_Term::ByteSizeLong() const final _InternalParse() Declaration const char * QuantumUtil::Problem_Term::_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final _InternalSerialize() Declaration uint8_t * QuantumUtil::Problem_Term::_InternalSerialize(uint8_t *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final GetCachedSize() Declaration int QuantumUtil::Problem_Term::GetCachedSize() const final GetClassData() Declaration const ::PROTOBUF_NAMESPACE_ID::Message::ClassData * QuantumUtil::Problem_Term::GetClassData() const final GetMetadata() Declaration PROTOBUF_NAMESPACE_ID::Metadata QuantumUtil::Problem_Term::GetMetadata() const final ids_size() Declaration int QuantumUtil::Problem_Term::ids_size() const clear_ids() Declaration void QuantumUtil::Problem_Term::clear_ids() ids() Declaration int64_t QuantumUtil::Problem_Term::ids(int index) const set_ids() Declaration void QuantumUtil::Problem_Term::set_ids(int index, int64_t value) add_ids() Declaration void QuantumUtil::Problem_Term::add_ids(int64_t value) ids() Declaration const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>&QuantumUtil::Problem_Term::ids() const mutable_ids() Declaration PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* QuantumUtil::Problem_Term::mutable_ids() clear_c() Declaration void QuantumUtil::Problem_Term::clear_c() c() Declaration double QuantumUtil::Problem_Term::c() const set_c() Declaration void QuantumUtil::Problem_Term::set_c(double value) descriptor() Declaration static const ::PROTOBUF_NAMESPACE_ID::Descriptor* QuantumUtil::Problem_Term::descriptor() GetDescriptor() Declaration static const ::PROTOBUF_NAMESPACE_ID::Descriptor* QuantumUtil::Problem_Term::GetDescriptor() GetReflection() Declaration static const ::PROTOBUF_NAMESPACE_ID::Reflection* QuantumUtil::Problem_Term::GetReflection() default_instance() Declaration static const Problem_Term&QuantumUtil::Problem_Term::default_instance() internal_default_instance() Declaration static const Problem_Term* QuantumUtil::Problem_Term::internal_default_instance() MergeImpl() Declaration void QuantumUtil::Problem_Term::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message *to, const ::PROTOBUF_NAMESPACE_ID::Message&from) FullMessageName() Declaration ::PROTOBUF_NAMESPACE_ID::StringPiece QuantumUtil::Problem_Term::FullMessageName() SharedCtor() Declaration void QuantumUtil::Problem_Term::SharedCtor() SharedDtor() Declaration void QuantumUtil::Problem_Term::SharedDtor() SetCachedSize() Declaration void QuantumUtil::Problem_Term::SetCachedSize(int size) const final InternalSwap() Declaration void QuantumUtil::Problem_Term::InternalSwap(Problem_Term *other) _internal_ids_size() Declaration int QuantumUtil::Problem_Term::_internal_ids_size() const _internal_ids() Declaration int64_t QuantumUtil::Problem_Term::_internal_ids(int index) const _internal_ids() Declaration const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>&QuantumUtil::Problem_Term::_internal_ids() const _internal_add_ids() Declaration void QuantumUtil::Problem_Term::_internal_add_ids(int64_t value) _internal_mutable_ids() Declaration PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* QuantumUtil::Problem_Term::_internal_mutable_ids() _internal_c() Declaration double QuantumUtil::Problem_Term::_internal_c() const _internal_set_c() Declaration void QuantumUtil::Problem_Term::_internal_set_c(double value)"
  },
  "api/quantum-util/problem/term/internal.html": {
    "href": "api/quantum-util/problem/term/internal.html",
    "title": "Class QuantumUtil::Problem_Term::_Internal | qiotoolkit",
    "keywords": "Class QuantumUtil::Problem_Term::_Internal Inheritance QuantumUtil::Problem_Term::_Internal"
  },
  "api/queue-node.html": {
    "href": "api/queue-node.html",
    "title": "Class QueueNode | qiotoolkit",
    "keywords": "Class QueueNode Inheritance QueueNode Constructors QueueNode() Declaration QueueNode<E>::QueueNode(const E&an_element) QueueNode() Declaration QueueNode<E>::QueueNode(const QueueNode&) QueueNode() Declaration QueueNode<E>::QueueNode(const E&an_element) QueueNode() Declaration QueueNode<E>::QueueNode(const QueueNode&) Methods element() Declaration const E&QueueNode<E>::element() const next() Declaration QueueNode* QueueNode<E>::next() next() Declaration const QueueNode* QueueNode<E>::next() const element() Declaration const E&QueueNode<E>::element() const next() Declaration QueueNode* QueueNode<E>::next() next() Declaration const QueueNode* QueueNode<E>::next() const operator=() Declaration const QueueNode&QueueNode<E>::operator=(const QueueNode&) operator=() Declaration const QueueNode&QueueNode<E>::operator=(const QueueNode&)"
  },
  "api/queue.html": {
    "href": "api/queue.html",
    "title": "Class Queue | qiotoolkit",
    "keywords": "Class Queue Inheritance Queue Constructors Queue() Declaration Queue<E>::Queue() Queue() Declaration Queue<E>::Queue() Queue() Declaration Queue<E>::Queue(const Queue&) Queue() Declaration Queue<E>::Queue(const Queue&) Methods ~Queue() Declaration Queue<E>::~Queue() Clear() Declaration void Queue<E>::Clear() Size() Declaration size_t Queue<E>::Size() const Head() Declaration QueueNode<E>* Queue<E>::Head() Head() Declaration const QueueNode<E>* Queue<E>::Head() const Last() Declaration QueueNode<E>* Queue<E>::Last() Last() Declaration const QueueNode<E>* Queue<E>::Last() const Enqueue() Declaration void Queue<E>::Enqueue(const E&element) Dequeue() Declaration E* Queue<E>::Dequeue() Map() Declaration Queue* Queue<E>::Map(F function) const ~Queue() Declaration Queue<E>::~Queue() Clear() Declaration void Queue<E>::Clear() Size() Declaration size_t Queue<E>::Size() const Head() Declaration QueueNode<E>* Queue<E>::Head() Head() Declaration const QueueNode<E>* Queue<E>::Head() const Last() Declaration QueueNode<E>* Queue<E>::Last() Last() Declaration const QueueNode<E>* Queue<E>::Last() const Enqueue() Declaration void Queue<E>::Enqueue(const E&element) Dequeue() Declaration E* Queue<E>::Dequeue() Map() Declaration Queue* Queue<E>::Map(F function) const operator=() Declaration const Queue&Queue<E>::operator=(const Queue&) operator=() Declaration const Queue&Queue<E>::operator=(const Queue&)"
  },
  "api/rapidjson/allocator.html": {
    "href": "api/rapidjson/allocator.html",
    "title": "Class rapidjson::Allocator | qiotoolkit",
    "keywords": "Class rapidjson::Allocator Concept for allocating, resizing and freeing memory block. Note that Malloc() and Realloc() are non-static but Free() is static. So if an allocator need to support Free(), it needs to put its pointer in the header of memory block. concept Allocator { static const bool kNeedFree; //!< Whether this allocator needs to call Free(). // Allocate a memory block. // \\param size of the memory block in bytes. // \\returns pointer to the memory block. void* Malloc(size_t size); // Resize a memory block. // \\param originalPtr The pointer to current memory block. Null pointer is permitted. // \\param originalSize The current size in bytes. (Design issue: since some allocator may not book-keep this, explicitly pass to it can save memory.) // \\param newSize the new size in bytes. void* Realloc(void* originalPtr, size_t originalSize, size_t newSize); // Free a memory block. // \\param pointer to the memory block. Null pointer is permitted. static void Free(void *ptr); }; Inheritance rapidjson::Allocator"
  },
  "api/rapidjson/encoding.html": {
    "href": "api/rapidjson/encoding.html",
    "title": "Class rapidjson::Encoding | qiotoolkit",
    "keywords": "Class rapidjson::Encoding Concept for encoding of Unicode characters. concept Encoding { typename Ch; //! Type of character. A \"character\" is actually a code unit in unicode's definition. enum { supportUnicode = 1 }; // or 0 if not supporting unicode //! \\brief Encode a Unicode codepoint to an output stream. //! \\param os Output stream. //! \\param codepoint An unicode codepoint, ranging from 0x0 to 0x10FFFF inclusively. template<typename OutputStream> static void Encode(OutputStream& os, unsigned codepoint); //! \\brief Decode a Unicode codepoint from an input stream. //! \\param is Input stream. //! \\param codepoint Output of the unicode codepoint. //! \\return true if a valid codepoint can be decoded from the stream. template <typename InputStream> static bool Decode(InputStream& is, unsigned* codepoint); //! \\brief Validate one Unicode codepoint from an encoded stream. //! \\param is Input stream to obtain codepoint. //! \\param os Output for copying one codepoint. //! \\return true if it is valid. //! \\note This function just validating and copying the codepoint without actually decode it. template <typename InputStream, typename OutputStream> static bool Validate(InputStream& is, OutputStream& os); // The following functions are deal with byte streams. //! Take a character from input byte stream, skip BOM if exist. template <typename InputByteStream> static CharType TakeBOM(InputByteStream& is); //! Take a character from input byte stream. template <typename InputByteStream> static Ch Take(InputByteStream& is); //! Put BOM to output byte stream. template <typename OutputByteStream> static void PutBOM(OutputByteStream& os); //! Put a character to output byte stream. template <typename OutputByteStream> static void Put(OutputByteStream& os, Ch c); }; Inheritance rapidjson::Encoding"
  },
  "api/rapidjson/handler.html": {
    "href": "api/rapidjson/handler.html",
    "title": "Class rapidjson::Handler | qiotoolkit",
    "keywords": "Class rapidjson::Handler Concept for receiving events from GenericReader upon parsing. The functions return true if no error occurs. If they return false, the event publisher should terminate the process. concept Handler { typename Ch; bool Null(); bool Bool(bool b); bool Int(int i); bool Uint(unsigned i); bool Int64(int64_t i); bool Uint64(uint64_t i); bool Double(double d); /// enabled via kParseNumbersAsStringsFlag, string is not null-terminated (use length) bool RawNumber(const Ch* str, SizeType length, bool copy); bool String(const Ch* str, SizeType length, bool copy); bool StartObject(); bool Key(const Ch* str, SizeType length, bool copy); bool EndObject(SizeType memberCount); bool StartArray(); bool EndArray(SizeType elementCount); }; Inheritance rapidjson::Handler"
  },
  "api/rapidjson/stream.html": {
    "href": "api/rapidjson/stream.html",
    "title": "Class rapidjson::Stream | qiotoolkit",
    "keywords": "Class rapidjson::Stream Concept for reading and writing characters. For read-only stream, no need to implement PutBegin(), Put(), Flush() and PutEnd(). For write-only stream, only need to implement Put() and Flush(). concept Stream { typename Ch; //!< Character type of the stream. //! Read the current character from stream without moving the read cursor. Ch Peek() const; //! Read the current character from stream and moving the read cursor to next character. Ch Take(); //! Get the current read cursor. //! \\return Number of characters read from start. size_t Tell(); //! Begin writing operation at the current read pointer. //! \\return The begin writer pointer. Ch* PutBegin(); //! Write a character. void Put(Ch c); //! Flush the buffer. void Flush(); //! End the writing operation. //! \\param begin The begin write pointer returned by PutBegin(). //! \\return Number of characters written. size_t PutEnd(Ch* begin); } Inheritance rapidjson::Stream"
  },
  "api/release/docs/wiki-brancher.html": {
    "href": "api/release/docs/wiki-brancher.html",
    "title": "Class release_docs::WikiBrancher | qiotoolkit",
    "keywords": "Class release_docs::WikiBrancher Branches ... Inheritance release_docs::WikiBrancher Methods __init__() Declaration def release_docs.WikiBrancher.__init__(self, dot_version) GetFilesToBranch() Returns a list of .wiki file names that need to be branched. Declaration def release_docs.WikiBrancher.GetFilesToBranch(self) BranchFiles() Branches the .wiki files needed to be branched. Declaration def release_docs.WikiBrancher.BranchFiles(self) UpdateLinksInBranchedFiles() Declaration def release_docs.WikiBrancher.UpdateLinksInBranchedFiles(self) __init__() Declaration def release_docs.WikiBrancher.__init__(self, dot_version) GetFilesToBranch() Returns a list of .wiki file names that need to be branched. Declaration def release_docs.WikiBrancher.GetFilesToBranch(self) BranchFiles() Branches the .wiki files needed to be branched. Declaration def release_docs.WikiBrancher.BranchFiles(self) UpdateLinksInBranchedFiles() Declaration def release_docs.WikiBrancher.UpdateLinksInBranchedFiles(self)"
  },
  "api/schedule/constant.html": {
    "href": "api/schedule/constant.html",
    "title": "Class schedule::Constant | qiotoolkit",
    "keywords": "Class schedule::Constant Constant Schedule. The schedule (or schedule segment) has a constant value over the input range. If queried for values outside the input range, the same constant value is returned as well. Configuration Examples: Basic definition: \"schedule\": { \"type\": \"constant\", \"value\": 42.0 } Short-hand notation: \"schedule\": 42.0 With input range: \"schedule\": { \"type\": \"constant\", \"value\": 42.0, \"start\": 0, \"stop\": 13 } With count: \"schedule\": { \"type\": \"constant\", \"value\": 42.0, \"count\": 100 } Note Since the value of this generator is constant, the properties start, stop and count only affect how many times the value is repeated when used as a Segment or generating a discretized set. Inheritance schedule::ScheduleGenerator schedule::Constant Inherited Members get_count ScheduleGenerator get_stop ~ScheduleGenerator get_initial_value get_start set_stop has_count get_final_value has_stop has_start is_repeated ~Component Component get_status param get_class_name Constructors Constant() Declaration schedule::Constant::Constant(double value) Constant() Declaration schedule::Constant::Constant(const Constant&other) Constant() Declaration schedule::Constant::Constant()=default Methods get_progress_value() Get the value at a relative position in the input interval. Arguments: progress relative input position \\in [0..1] Returns: the (constant) value of the generator. Declaration double schedule::Constant::get_progress_value(double) const override configure() Configure the Constant generator from input. This expects either the long (object) or short (scalar) input format, as described in the class description. Declaration void schedule::Constant::configure(const utils::Json&json) override render() Return the config value for schedule. Declaration utils::Structure schedule::Constant::render() const override"
  },
  "api/schedule/geometric.html": {
    "href": "api/schedule/geometric.html",
    "title": "Class schedule::Geometric | qiotoolkit",
    "keywords": "Class schedule::Geometric Geometric Schedule. The schedule (or schedule segment) interpolates geometrically from initial to final value over the input interval. Configuration: Basic definition: \"schedule\": { \"type\": \"geometric\", \"initial\": 1.0, \"final\": 0.3 } With input range: \"schedule\": { \"type\": \"geometric\", \"initial\": 1.0, \"final\": 0.3 \"start\": 0, \"stop\": 10 } With count: \"schedule\": { \"type\": \"geometric\", \"initial\": 1.0, \"final\": 0.3 \"count\": 11 } Inheritance schedule::RangedGenerator schedule::Geometric Inherited Members RangedGenerator get_count ScheduleGenerator get_stop ~ScheduleGenerator get_initial_value get_start set_stop has_count get_final_value has_stop has_start is_repeated ~Component Component get_status param get_class_name Constructors Geometric() Declaration schedule::Geometric::Geometric() Geometric() Declaration schedule::Geometric::Geometric(double initial_value, double final_value) Methods get_progress_value() Get the value at a relative position in the input interval. Arguments: progress relative input position \\in [0..1] Returns: the interpolated value Declaration double schedule::Geometric::get_progress_value(double progress) const override configure() Configure the Geometric generator from input. This expects the initial and final value to interpolate. Declaration void schedule::Geometric::configure(const utils::Json&json) override render() Return the config value for schedule. Declaration utils::Structure schedule::Geometric::render() const override"
  },
  "api/schedule/linear.html": {
    "href": "api/schedule/linear.html",
    "title": "Class schedule::Linear | qiotoolkit",
    "keywords": "Class schedule::Linear Linear Schedule. The schedule (or schedule segment) interpolates linearly from initial to final value over the input interval. Configuration: Basic definition: \"schedule\": { \"type\": \"linear\", \"initial\": 1.0, \"final\": 0.3 } With input range: \"schedule\": { \"type\": \"linear\", \"initial\": 1.0, \"final\": 0.3 \"start\": 0, \"stop\": 10 } With count: \"schedule\": { \"type\": \"linear\", \"initial\": 1.0, \"final\": 0.3 \"count\": 11 } Inheritance schedule::RangedGenerator schedule::Linear Inherited Members RangedGenerator get_count ScheduleGenerator get_stop ~ScheduleGenerator get_initial_value get_start set_stop has_count get_final_value has_stop has_start is_repeated ~Component Component get_status param get_class_name Constructors Linear() Declaration schedule::Linear::Linear() Linear() Explicitly create an inverse linear schedule. This allows algorithms to explicitly create an inverse linear schedule from other input variants (i.e., beta_start, beta_stop). Declaration schedule::Linear::Linear(double initial_value, double final_value) Methods get_progress_value() Get the value at a relative position in the input interval. Arguments: progress relative input position \\in [0..1] Returns: the interpolated value Declaration double schedule::Linear::get_progress_value(double progress) const override configure() Configure the Linear generator from input. This expects the initial and final value to interpolate. Declaration void schedule::Linear::configure(const utils::Json&json) override render() Return the config value for schedule. Declaration utils::Structure schedule::Linear::render() const override"
  },
  "api/schedule/ranged-generator.html": {
    "href": "api/schedule/ranged-generator.html",
    "title": "Class schedule::RangedGenerator | qiotoolkit",
    "keywords": "Class schedule::RangedGenerator RangedGenerator base class. This is a shared interface for generators returning values in a configured range initial..final. Inheritance schedule::ScheduleGenerator schedule::RangedGenerator schedule::Geometric schedule::Linear Inherited Members get_count ScheduleGenerator get_stop ~ScheduleGenerator get_initial_value get_start set_stop has_count get_final_value get_progress_value has_stop has_start is_repeated render ~Component Component get_status param get_class_name Constructors RangedGenerator() Declaration schedule::RangedGenerator::RangedGenerator() Methods configure() Shared input format: Two numbers defining the range initial..final. Declaration void schedule::RangedGenerator::configure(const utils::Json&json) override"
  },
  "api/schedule/schedule-generator.html": {
    "href": "api/schedule/schedule-generator.html",
    "title": "Class schedule::ScheduleGenerator | qiotoolkit",
    "keywords": "Class schedule::ScheduleGenerator ScheduleGenerator interface. A schedule generator maps any input value in the progress interval [0..1] to an output value. Note The input is always in the range [0..1], because the mapping from the input interval to this progress interval is handled by the Schedule class. This ensures the input mapping logic is not duplicated in every generator. Inheritance utils::Component schedule::ScheduleGenerator schedule::Constant schedule::RangedGenerator schedule::Segments Inherited Members render ~Component Component get_status param get_class_name Constructors ScheduleGenerator() Declaration schedule::ScheduleGenerator::ScheduleGenerator() Methods ~ScheduleGenerator() Declaration virtual schedule::ScheduleGenerator::~ScheduleGenerator() get_progress_value() Return the value that progress is mapped to. Declaration virtual double schedule::ScheduleGenerator::get_progress_value(double progress) const =0 get_initial_value() Return the value at the beginning of the input interval. Declaration double schedule::ScheduleGenerator::get_initial_value() const get_final_value() Return the value at the end of the input interval. Declaration double schedule::ScheduleGenerator::get_final_value() const get_start() Get the start input value (first in the input interval). [This default to start=0 if not specified]. Declaration double schedule::ScheduleGenerator::get_start() const get_stop() Get the stop input value (last in the input interval). [This defaults to stop=1 if not specified]. Declaration double schedule::ScheduleGenerator::get_stop() const get_count() Get the number of equidistributed input values to use when generating a discretized set from this generator (without requesting a specific set size). The default value of count=1 means pick just one (the initial value) Declaration int schedule::ScheduleGenerator::get_count() const set_stop() Force the number of equidistributed values to pick. Declaration void schedule::ScheduleGenerator::set_stop(int stop) has_start() Query if the start value was explicitly configured. Declaration bool schedule::ScheduleGenerator::has_start() const has_stop() Query if the stop value was explicitly configured. Declaration bool schedule::ScheduleGenerator::has_stop() const has_count() Query if the count value was explicitly configured. Declaration bool schedule::ScheduleGenerator::has_count() const is_repeated() Should this schedule be repeated indefinitly outside the input interval? Declaration bool schedule::ScheduleGenerator::is_repeated() const configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void schedule::ScheduleGenerator::configure(const utils::Json&json) override"
  },
  "api/schedule/schedule.html": {
    "href": "api/schedule/schedule.html",
    "title": "Class schedule::Schedule | qiotoolkit",
    "keywords": "Class schedule::Schedule Schedule. A schedule maps an input interval to values for parametrization. This can be employed to, e.g., specify a temperature set or schedule (tempering, annealing) define how a parameter should evolve over time (substochastic MC) The schedule can be specified in different forms: constant value linear or geometric interpolation for a range initial..final By explicitly listing the temperatures as an array Examples: Geometric interpolation of the range inital to final: \"schedule\": { \"type\": \"geometric\", \"initial\": 1.0 \"final\": 0.3, } 20 steps with equal spacing from initial to final: \"schedule\": { \"type\": \"linear\", \"initial\": 1.0, \"final\": 3.0 \"count\": 20 } An explicit set of values: \"schedule\": [0.1, 0.2, 0.3, 0.4] Note Without a prior call to configure, an object of this class is uninitialized and will throw an access to nullptr exception. Inheritance utils::Component schedule::Schedule Inherited Members ~Component Component get_status param get_class_name Constructors Schedule() Declaration schedule::Schedule::Schedule() Schedule() Declaration schedule::Schedule::Schedule(const Schedule&copy) Methods ~Schedule() Declaration virtual schedule::Schedule::~Schedule() operator=() Declaration Schedule&schedule::Schedule::operator=(const Schedule&)=delete get_value() Assuming the simulation runs from [0 .. max_steps] (inclusive), returns the temperature to be used at step. Declaration double schedule::Schedule::get_value(double input) const get_discretized_values() Return a set of values for equidistributed inputs over the schedule. Declaration std::vector<double>schedule::Schedule::get_discretized_values(int count=-1) const get_start() Get the starting input value. Declaration double schedule::Schedule::get_start() const get_stop() Get the stopping input value. Declaration double schedule::Schedule::get_stop() const get_initial() Get the initial value (at start) Declaration double schedule::Schedule::get_initial() const get_final() Get the final value (at stop) Declaration double schedule::Schedule::get_final() const get_count() Query how many equidistributed inputs this schedule would \"naturally\" have (for an explicit set of values, this is the length of the array, for a generator it is derived from the (rounded) input range. Declaration int schedule::Schedule::get_count() const set_stop() Force a specific number of steps to be queried from the schedule. Declaration void schedule::Schedule::set_stop(int stop) configure() Serialization will instantiate the correct schedule_generator_ according to / the configuration it is passed. Declaration void schedule::Schedule::configure(const utils::Json&json) override make_linear() Manually create an linear schedule. Declaration void schedule::Schedule::make_linear(double initial_value, double final_value) make_geometric() Manually create an geometric schedule. Declaration void schedule::Schedule::make_geometric(double beta_start, double beta_stop) make_list() Declaration void schedule::Schedule::make_list(const std::vector<double>&values) make_constant() Declaration void schedule::Schedule::make_constant(double value) render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure schedule::Schedule::render() const override"
  },
  "api/schedule/segments.html": {
    "href": "api/schedule/segments.html",
    "title": "Class schedule::Segments | qiotoolkit",
    "keywords": "Class schedule::Segments Segments Schedule. Concatenate multiple schedules to a single schedule. Configuration: Basic definition: \"schedule\": { \"type\": \"segments\", \"segments\": [ { \"type\": \"constant\", \"value\": 3, \"count\": 100, }, { \"type\": \"linear\", \"initial\": 3, \"final\": 0.3, \"count\": 1000 }, { \"type\": \"constant\", \"value\": 0.3, \"count\": 500 } ] } From an array: \"schedule\": { \"type\": \"segments\", \"segments\": [1,2,3] } From an array, shorthand \"schedule\": [1,2,3] Note Unless otherwise specified, each segment is assumed to have a width of 1, with the start point coinciding with the stop of the previous segment. You can modify this default behavior by specifying the (absolute) stop point of the segment or by adjusting the width via count. Note Segments specified as an array of scalar values are presumed to be points of zero input range width spaced by 1. As a result, the total width of the array is mapped to 0..(size-1) and discretization with default count yields back the array. Input values between these points are interpolated linearly. Inheritance schedule::ScheduleGenerator schedule::Segments Inherited Members get_count ScheduleGenerator get_stop ~ScheduleGenerator get_initial_value get_start set_stop has_count get_final_value has_stop has_start is_repeated ~Component Component get_status param get_class_name Constructors Segments() Declaration schedule::Segments::Segments()=default Segments() Declaration schedule::Segments::Segments(const std::vector<double>&values) Methods get_progress_value() Get the value at a relative position in the input interval. Arguments: progress relative input position \\in [0..1] Returns: the value of the segment covering progress. Declaration double schedule::Segments::get_progress_value(double progress) const override configure() Configure the Segments generator from input. This expects the segments to be concatenated. Declaration void schedule::Segments::configure(const utils::Json&json) override adjust() Declaration void schedule::Segments::adjust() render() Return the config value for schedule. Declaration utils::Structure schedule::Segments::render() const override"
  },
  "api/schema-validating-reader.html": {
    "href": "api/schema-validating-reader.html",
    "title": "Class SchemaValidatingReader | qiotoolkit",
    "keywords": "Class SchemaValidatingReader A helper class for parsing with validation. This helper class is a functor, designed as a parameter of GenericDocument::Populate(). parseFlags Combination of ParseFlag. InputStream Type of input stream, implementing Stream concept. SourceEncoding Encoding of the input stream. SchemaDocumentType Type of schema document. StackAllocator Allocator type for stack. Inheritance SchemaValidatingReader Constructors SchemaValidatingReader() Constructor. is Input stream. sd Schema document. Declaration SchemaValidatingReader<parseFlags, InputStream, SourceEncoding, SchemaDocumentType, StackAllocator>::SchemaValidatingReader(InputStream&is, const SchemaDocumentType&sd) Methods operator()() Declaration bool SchemaValidatingReader<parseFlags, InputStream, SourceEncoding, SchemaDocumentType, StackAllocator>::operator()(Handler&handler) GetParseResult() Declaration const ParseResult&SchemaValidatingReader<parseFlags, InputStream, SourceEncoding, SchemaDocumentType, StackAllocator>::GetParseResult() const IsValid() Declaration bool SchemaValidatingReader<parseFlags, InputStream, SourceEncoding, SchemaDocumentType, StackAllocator>::IsValid() const GetInvalidSchemaPointer() Declaration const PointerType&SchemaValidatingReader<parseFlags, InputStream, SourceEncoding, SchemaDocumentType, StackAllocator>::GetInvalidSchemaPointer() const GetInvalidSchemaKeyword() Declaration const Ch* SchemaValidatingReader<parseFlags, InputStream, SourceEncoding, SchemaDocumentType, StackAllocator>::GetInvalidSchemaKeyword() const GetInvalidDocumentPointer() Declaration const PointerType&SchemaValidatingReader<parseFlags, InputStream, SourceEncoding, SchemaDocumentType, StackAllocator>::GetInvalidDocumentPointer() const GetError() Declaration const ValueType&SchemaValidatingReader<parseFlags, InputStream, SourceEncoding, SchemaDocumentType, StackAllocator>::GetError() const GetInvalidSchemaCode() Declaration ValidateErrorCode SchemaValidatingReader<parseFlags, InputStream, SourceEncoding, SchemaDocumentType, StackAllocator>::GetInvalidSchemaCode() const"
  },
  "api/shape.html": {
    "href": "api/shape.html",
    "title": "Class Shape | qiotoolkit",
    "keywords": "Class Shape Inheritance Shape Box Circle Constructors Shape() Declaration Shape::Shape() Shape() Declaration Shape::Shape(double x, double y) Methods ~Shape() Declaration virtual Shape::~Shape() GetType() Declaration virtual const char* Shape::GetType() const =0 Print() Declaration virtual void Shape::Print(std::ostream&os) const =0"
  },
  "api/solver/empty-model.html": {
    "href": "api/solver/empty-model.html",
    "title": "Class solver::EmptyModel | qiotoolkit",
    "keywords": "Class solver::EmptyModel Inheritance markov::Model solver::EmptyModel Inherited Members get_benchmark_properties estimate_max_cost_diff has_initial_configuration Model configure state_only_memory_estimate get_term_count get_sweep_size init get_initial_configuration_state render_state calculate_cost apply_transition estimate_min_cost_diff get_scale_factor is_empty set_step_limit is_rescaled state_memory_estimate rescale render calculate_cost_difference get_random_transition get_const_cost configure get_random_state match_version get_version ~BaseModel configure BaseModel get_identifier render ~Component Component get_status param get_class_name Methods create_state() Declaration EmptyState solver::EmptyModel::create_state(const std::vector<int>&) const get_spin_overlap() Declaration double solver::EmptyModel::get_spin_overlap(const EmptyState&, const EmptyState&) const get_term_overlap() Declaration double solver::EmptyModel::get_term_overlap(const EmptyState&, const EmptyState&) const create_parameter_change() Declaration int solver::EmptyModel::create_parameter_change(std::vector<double>&) const get_parameters() Declaration std::vector<std::string>solver::EmptyModel::get_parameters() const"
  },
  "api/solver/empty-state.html": {
    "href": "api/solver/empty-state.html",
    "title": "Class solver::EmptyState | qiotoolkit",
    "keywords": "Class solver::EmptyState Inheritance solver::EmptyState Methods copy_state_only() Declaration int solver::EmptyState::copy_state_only(EmptyState) const render() Declaration utils::Structure solver::EmptyState::render() const"
  },
  "api/solver/estimator.html": {
    "href": "api/solver/estimator.html",
    "title": "Class solver::Estimator | qiotoolkit",
    "keywords": "Class solver::Estimator Energy scale estimator. This estimator attempts to estimate the relevant energy range of the model it analyzes by collecting a histogram of transition costs in the random and quenched regime. The random regime is sampled from random initial positions. It is used as a proxy for the high temperature regime. The quenched regime is sampled from quenched states obtained by peforming several metropolis sweeps at T=0. From these histograms we can tune the temperature for expected boltzmann acceptance rates in either regime. This is expressed in terms of the portion of energy increasing transitions that would be accepted (transitions which don't change the energy are always accepted and the potion of energy-lowering transitions in the random regime depends on the model). Inheritance solver::Estimator Methods gather_statistics() Measure the current cost and samples of the cost of a random transition for the walker at its current state. For models derived from model::FacedGraphModel, an extra parameter for a cost object is necessary to communicate cached calculations. Declaration std::enable_if<std::is_base_of<model::FacedGraphModel<TS, TT>, TM>::value, void>::type solver::Estimator<Model>::gather_statistics(const Model&model, Walker&walker, double *cost, std::vector<double>*deltas) gather_statistics() Measure the current cost and samples of the cost of a random transition for the walker at its current state. For all other models, no extra cost parameter is needed. Declaration std::enable_if<!std::is_base_of<model::FacedGraphModel<TS, TT>, TM>::value, void>::type solver::Estimator<Model>::gather_statistics(const Model&model, Walker&walker, double *cost, std::vector<double>*deltas) quench() Declaration void solver::Estimator<Model>::quench(Walker&walker) estimate_accepted() Declaration double solver::Estimator<Model>::estimate_accepted(const std::vector<double>&deltas, double T) find_temperature() Declaration double solver::Estimator<Model>::find_temperature(const std::vector<double>&deltas, double target_acceptance) analyze() Declaration utils::Structure solver::Estimator<Model>::analyze(const Model&model, utils::RandomGenerator&rng)"
  },
  "api/solver/evaluation-counter.html": {
    "href": "api/solver/evaluation-counter.html",
    "title": "Class solver::EvaluationCounter | qiotoolkit",
    "keywords": "Class solver::EvaluationCounter Inheritance utils::Component solver::EvaluationCounter Inherited Members configure ~Component Component get_status param get_class_name Constructors EvaluationCounter() Declaration solver::EvaluationCounter::EvaluationCounter() EvaluationCounter() Declaration solver::EvaluationCounter::EvaluationCounter(const EvaluationCounter&other) Methods reset() Declaration void solver::EvaluationCounter::reset() operator+=() Declaration const EvaluationCounter&solver::EvaluationCounter::operator+=(const EvaluationCounter&other) operator-=() Declaration const EvaluationCounter&solver::EvaluationCounter::operator-=(const EvaluationCounter&other) operator=() Declaration EvaluationCounter&solver::EvaluationCounter::operator=(const EvaluationCounter&other)=default render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure solver::EvaluationCounter::render() const get_function_evaluation_count() Declaration uint64_t solver::EvaluationCounter::get_function_evaluation_count() const get_difference_evaluation_count() Declaration uint64_t solver::EvaluationCounter::get_difference_evaluation_count() const get_accepted_transition_count() Declaration uint64_t solver::EvaluationCounter::get_accepted_transition_count() const"
  },
  "api/solver/model-solver.html": {
    "href": "api/solver/model-solver.html",
    "title": "Class solver::ModelSolver | qiotoolkit",
    "keywords": "Class solver::ModelSolver Inheritance solver::Solver solver::ModelSolver solver::SteppingSolver Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label set_time_limit get_result run copy_limits get_solver_properties finalize get_identifier ~Solver get_benchmark get_max_threads get_thread_count init Solver set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors ModelSolver() Declaration solver::ModelSolver<Model_T>::ModelSolver() Methods ~ModelSolver() Declaration solver::ModelSolver<Model_T>::~ModelSolver() override configure() Check the identifier and version against the configuraiton. Declaration void solver::ModelSolver<Model_T>::configure(const utils::Json&json) override set_model() Declaration virtual void solver::ModelSolver<Model_T>::set_model(const Model_T *model) get_model_properties() Declaration utils::Structure solver::ModelSolver<Model_T>::get_model_properties() const override get_model_sweep_size() Declaration size_t solver::ModelSolver<Model_T>::get_model_sweep_size() const override get_model_term_size() Declaration size_t solver::ModelSolver<Model_T>::get_model_term_size() const get_lowest_cost() Declaration Cost_T solver::ModelSolver<Model_T>::get_lowest_cost() const get_solutions() Get the structured result description. Declaration utils::Structure solver::ModelSolver<Model_T>::get_solutions() const override init_memory_check_error_message() Declaration virtual std::string solver::ModelSolver<Model_T>::init_memory_check_error_message() const =0 target_number_of_states() Declaration virtual size_t solver::ModelSolver<Model_T>::target_number_of_states() const =0 init_memory_check() Declaration virtual void solver::ModelSolver<Model_T>::init_memory_check() copy_solutions_other() Declaration void solver::ModelSolver<Model_T>::copy_solutions_other(ModelSolver *other, unsigned solutions_to_return) const copy_lowest_state() Declaration void solver::ModelSolver<Model_T>::copy_lowest_state(ModelSolver *other) const count_solutions() Declaration size_t solver::ModelSolver<Model_T>::count_solutions() const is_empty() Declaration virtual bool solver::ModelSolver<Model_T>::is_empty() const get_model() Declaration virtual const Model_T&solver::ModelSolver<Model_T>::get_model() const max_replicas_of_state() Declaration virtual size_t solver::ModelSolver<Model_T>::max_replicas_of_state() const max_replicas_adjusted_state() Declaration virtual size_t solver::ModelSolver<Model_T>::max_replicas_adjusted_state(uint32_t max_replicas_mult) const adjust_states() Declaration virtual size_t solver::ModelSolver<Model_T>::adjust_states(double input_states, uint32_t max_replicas_mult) const update_lowest_cost() Declaration bool solver::ModelSolver<Model_T>::update_lowest_cost(Cost_T cost, const State_T&state) copy_solutions() Declaration void solver::ModelSolver<Model_T>::copy_solutions(std::vector<Walker_T>&walkers, unsigned solutions_to_return) copy_solutions() Declaration void solver::ModelSolver<Model_T>::copy_solutions(Population<Walker_T>&population, unsigned solutions_to_return) populate_solutions() Declaration void solver::ModelSolver<Model_T>::populate_solutions(Solutions_T&solutions) get_model_unconst() Declaration Model_T* solver::ModelSolver<Model_T>::get_model_unconst()"
  },
  "api/solver/murex.html": {
    "href": "api/solver/murex.html",
    "title": "Class solver::Murex | qiotoolkit",
    "keywords": "Class solver::Murex Multi-Objective Replica Exchange \"murex\". This solver implements a replica exchange approach whereby, in addition to the variables (\"spins\"), the parameters are at different quenched values at every node. As a result, the method explores the lowest cost value that can be achieved at different \"mixing rates\" of the parameters. The (currently hard-coded) arrangement of the nodes is in a triangle such that the temperature of nodes in each diagonal agrees, while the parameters x and y are swept from (1,0) to (0,1) in equal steps. position weights 5 j ( 0, 1) 2 4 ↖ ( 0, 1) (.5,.5) 0 1 3 (.5,.5) ( 1, 0) ( 1, 0) → i This setup is intended to analyze the effect of a multi-objective model with different weights assigned to each objective: \\mathcal{H} = -x\\mathcal{H}_x(\\vec{s}) -y\\mathcal{H}_y(\\vec{s}) Replica exchanges happen between neighboring nodes (vertically and horizontally) and take place at a rate which take into consideration that the cost of the swapped states are modified by virtue of being placed at a new node (and, thus, new set of parameters). Note The solver requires the model being simulated to support parameters and have exactly two parameters (which are selected as x and y). They do not necessarily need to split the cost function as described. [At the time of this writing, only \"poly\" supports this]. Inheritance solver::SteppingSolver solver::Murex Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits finalize ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors Murex() Declaration solver::Murex<Model_T>::Murex() Murex() Declaration solver::Murex<Model_T>::Murex(const Murex&)=delete Methods operator=() Declaration Murex&solver::Murex<Model_T>::operator=(const Murex&)=delete get_identifier() Get the identifier of this solver. This identifier is denoted as the target in the request. Declaration std::string solver::Murex<Model_T>::get_identifier() const override init_memory_check_error_message() Declaration std::string solver::Murex<Model_T>::init_memory_check_error_message() const override target_number_of_states() Declaration size_t solver::Murex<Model_T>::target_number_of_states() const override init() Initialize the solver. Initialization entails creating the graph of nodes and initializing a replica (a metropolis walker containing a state) at each node. The set of nodes is currently hard coded do consist of nT diagonals with 1..nT nodes, respectively. Each of them is assigned a set of mixing weights such that the starting point (on the x axis) is [1,0] and the end point on the y axis is [0,1], with linear interpolation of the mixing weights in between: position weights 5 j ( 0, 1) 2 4 ↖ ( 0, 1) (.5,.5) 0 1 3 (.5,.5) ( 1, 0) ( 1, 0) → i The temperature is highest in the lower left corner and decreases by one temperature step until the lowest on the furthest diagonal. We use the i index to refer to the diagonal and the j index for the position on that diagnoal. As such, the results for the pareto front are found on the last nT nodes in the node list, which represent the diagonal at i=nT-1, j=[0..nT]. Declaration void solver::Murex<Model_T>::init() override make_step() Make a step. A step constitutes performing individual metropolis updates on the nodes, followed by measurements and replica exchange moves. We update exchange moves from even (odd) diagonals in even (odd) steps and switch the direction every 2 steps. Declaration void solver::Murex<Model_T>::make_step(uint64_t step) override get_solutions() Return the solutions found. As the solution we return the lowest_cost found in the furthest diagonal (i.e., at lowest temperature) and the states corresponding to this lowest cost. Declaration utils::Structure solver::Murex<Model_T>::get_solutions() const override configure() Check the identifier and version against the configuraiton. Declaration void solver::Murex<Model_T>::configure(const utils::Json&json) override"
  },
  "api/solver/murex/node.html": {
    "href": "api/solver/murex/node.html",
    "title": "Class solver::Murex::Node | qiotoolkit",
    "keywords": "Class solver::Murex::Node Representation of a node in the replica exchange grid. Inheritance solver::Murex::Node Methods memory_estimate() Declaration static size_t solver::Murex<Model_T>::Node::memory_estimate(const Model_T&model)"
  },
  "api/solver/paparameter-free.html": {
    "href": "api/solver/paparameter-free.html",
    "title": "Class solver::PAParameterFree | qiotoolkit",
    "keywords": "Class solver::PAParameterFree PAParameterFree is the class which implements ParameterFreeAdapterInterface to fit in parameter free solver framework. And it is a child of PopulationAnnealing so that it immediately has the functionalities of PA. Inheritance solver::PopulationAnnealing solver::ParameterFreeAdapterInterface solver::PAParameterFree Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver get_solutions copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state is_friction_tensor resample finalize is_constant_culling target_number_of_states make_step is_energy_variance is_linear_schedule PopulationAnnealing PopulationAnnealing operator= init_population init find_delta_beta is_geometric_schedule expand_population get_identifier init_memory_check_error_message set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors PAParameterFree() Declaration solver::PAParameterFree<Model_T>::PAParameterFree() PAParameterFree() Declaration solver::PAParameterFree<Model_T>::PAParameterFree(const PAParameterFree&)=delete Methods operator=() Declaration PAParameterFree&solver::PAParameterFree<Model_T>::operator=(const PAParameterFree&)=delete configure() Check the identifier and version against the configuraiton. Declaration void solver::PAParameterFree<Model_T>::configure(const utils::Json&json) override update_parameters_linearly() Declaration void solver::PAParameterFree<Model_T>::update_parameters_linearly(std::vector<double>&parameters) const override parameter_dimensions() Declaration size_t solver::PAParameterFree<Model_T>::parameter_dimensions() const override parameter_ranges() Declaration std::vector<std::pair<double, double>>solver::PAParameterFree<Model_T>::parameter_ranges() const override get_initial_parameter_values() Declaration void solver::PAParameterFree<Model_T>::get_initial_parameter_values(std::vector<double>&initials) override update_parameters() Declaration void solver::PAParameterFree<Model_T>::update_parameters(const std::vector<double>&parameters, double left_over_time) override estimate_execution_cost() Declaration double solver::PAParameterFree<Model_T>::estimate_execution_cost() const override"
  },
  "api/solver/parallel-tempering.html": {
    "href": "api/solver/parallel-tempering.html",
    "title": "Class solver::ParallelTempering | qiotoolkit",
    "keywords": "Class solver::ParallelTempering Parallel Tempering algorithm. Run multiple metropolis simulating at separate temperatures, allowing exchange of configuration between neighboring replicas between sweeps. Note Use of the Metropolis Algorithm is currently hard-coded, but this could in principle be a template argument, provided that the alternative method implements the corresponding interfaces for exchange moves. Inheritance solver::SteppingSolver solver::ParallelTempering solver::PTParameterFree Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver get_solutions copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors ParallelTempering() Create an uninitialized Parallel Tempering instance. Declaration solver::ParallelTempering<Model_T>::ParallelTempering() ParallelTempering() Declaration solver::ParallelTempering<Model_T>::ParallelTempering(const ParallelTempering&)=delete Methods operator=() Declaration ParallelTempering&solver::ParallelTempering<Model_T>::operator=(const ParallelTempering&)=delete get_temperatures() Declaration std::vector<double>solver::ParallelTempering<Model_T>::get_temperatures() use_inverse_temperatures() Declaration bool solver::ParallelTempering<Model_T>::use_inverse_temperatures() get_identifier() Identifier of this solver (target in the request) Declaration std::string solver::ParallelTempering<Model_T>::get_identifier() const override init_memory_check_error_message() Declaration std::string solver::ParallelTempering<Model_T>::init_memory_check_error_message() const override target_number_of_states() Declaration size_t solver::ParallelTempering<Model_T>::target_number_of_states() const override init() Initialize each replica. Declaration void solver::ParallelTempering<Model_T>::init() override accept() Decide whether to accept an exchange move. Declaration double solver::ParallelTempering<Model_T>::accept(const markov::Metropolis<Model_T>&a, const markov::Metropolis<Model_T>&b) make_step() Perform discrete time step t. Declaration void solver::ParallelTempering<Model_T>::make_step(uint64_t step) override configure() Configure. Declaration void solver::ParallelTempering<Model_T>::configure(const utils::Json&json) override finalize() Declaration void solver::ParallelTempering<Model_T>::finalize() override"
  },
  "api/solver/parameter-free-adapter-interface-base.html": {
    "href": "api/solver/parameter-free-adapter-interface-base.html",
    "title": "Class solver::ParameterFreeAdapterInterfaceBase | qiotoolkit",
    "keywords": "Class solver::ParameterFreeAdapterInterfaceBase Interface classes for solver to fit in the parameter free framework. To be added in parameter freeEach solver must implement one of interface: ParameterFreeAdapterInterface or ParameterFreeLinearSearchAdapterInterface. Common interfaces Inheritance solver::ParameterFreeAdapterInterfaceBase solver::ParameterFreeAdapterInterface solver::ParameterFreeLinearSearchAdapterInterface Methods parameter_dimensions() Declaration virtual size_t solver::ParameterFreeAdapterInterfaceBase::parameter_dimensions() const =0 get_initial_parameter_values() Declaration virtual void solver::ParameterFreeAdapterInterfaceBase::get_initial_parameter_values(std::vector<double>&initials)=0 update_parameters() Declaration virtual void solver::ParameterFreeAdapterInterfaceBase::update_parameters(const std::vector<double>&parameters, double start_time)=0 update_parameters_linearly() Declaration virtual void solver::ParameterFreeAdapterInterfaceBase::update_parameters_linearly(std::vector<double>&parameters) const =0 estimate_execution_cost() Declaration virtual double solver::ParameterFreeAdapterInterfaceBase::estimate_execution_cost() const =0"
  },
  "api/solver/parameter-free-adapter-interface.html": {
    "href": "api/solver/parameter-free-adapter-interface.html",
    "title": "Class solver::ParameterFreeAdapterInterface | qiotoolkit",
    "keywords": "Class solver::ParameterFreeAdapterInterface Interface class for solver to use with Bayesian Global Optimization stategy. Inheritance solver::ParameterFreeAdapterInterfaceBase solver::ParameterFreeAdapterInterface solver::PAParameterFree solver::SSMCParameterFree Inherited Members update_parameters_linearly update_parameters parameter_dimensions estimate_execution_cost get_initial_parameter_values Methods parameter_ranges() Declaration virtual std::vector<std::pair<double, double>>solver::ParameterFreeAdapterInterface::parameter_ranges() const =0"
  },
  "api/solver/parameter-free-linear-search-adapter-interface.html": {
    "href": "api/solver/parameter-free-linear-search-adapter-interface.html",
    "title": "Class solver::ParameterFreeLinearSearchAdapterInterface | qiotoolkit",
    "keywords": "Class solver::ParameterFreeLinearSearchAdapterInterface Interface class for solver to use with Linear Search Global Optimization stategy. Inheritance solver::ParameterFreeAdapterInterfaceBase solver::ParameterFreeLinearSearchAdapterInterface solver::PTParameterFree solver::SAParameterFree solver::TabuParameterFree Inherited Members update_parameters parameter_dimensions estimate_execution_cost Methods parameter_ranges() Declaration virtual std::vector<int>solver::ParameterFreeLinearSearchAdapterInterface::parameter_ranges() const =0 update_parameters_linearly() Declaration void solver::ParameterFreeLinearSearchAdapterInterface::update_parameters_linearly(std::vector<double>&) const override get_initial_parameter_values() Declaration void solver::ParameterFreeLinearSearchAdapterInterface::get_initial_parameter_values(std::vector<double>&initials) override"
  },
  "api/solver/parameter-free-linear-search-solver.html": {
    "href": "api/solver/parameter-free-linear-search-solver.html",
    "title": "Class solver::ParameterFreeLinearSearchSolver | qiotoolkit",
    "keywords": "Class solver::ParameterFreeLinearSearchSolver Inheritance solver::ParameterFreeSolver solver::ParameterFreeLinearSearchSolver Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver get_solutions copy_lowest_state target_number_of_states copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state get_model_sweep_size init_memory_check_error_message is_empty get_lowest_cost adjust_states max_replicas_of_state get_identifier operator= set_model get_solver_properties get_model get_model_properties get_output_parameters finalize target_number_of_states configure ~ParameterFreeSolver make_step init ParameterFreeSolver init_memory_check_error_message update_best ParameterFreeSolver set_time_limit get_result copy_limits get_identifier ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors ParameterFreeLinearSearchSolver() Declaration solver::ParameterFreeLinearSearchSolver<Model_T, SolverAdapter>::ParameterFreeLinearSearchSolver() ParameterFreeLinearSearchSolver() Declaration solver::ParameterFreeLinearSearchSolver<Model_T, SolverAdapter>::ParameterFreeLinearSearchSolver(const ParameterFreeLinearSearchSolver&)=delete Methods operator=() Declaration ParameterFreeLinearSearchSolver&solver::ParameterFreeLinearSearchSolver<Model_T, SolverAdapter>::operator=(const ParameterFreeLinearSearchSolver&)=delete ~ParameterFreeLinearSearchSolver() Declaration solver::ParameterFreeLinearSearchSolver<Model_T, SolverAdapter>::~ParameterFreeLinearSearchSolver() training_parameters() Declaration void solver::ParameterFreeLinearSearchSolver<Model_T, SolverAdapter>::training_parameters(const utils::Json&) override"
  },
  "api/solver/parameter-free-solver.html": {
    "href": "api/solver/parameter-free-solver.html",
    "title": "Class solver::ParameterFreeSolver | qiotoolkit",
    "keywords": "Class solver::ParameterFreeSolver Inheritance solver::SteppingSolver solver::ParameterFreeSolver Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver get_solutions copy_lowest_state copy_solutions update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param ~Component Component get_status get_class_name Constructors ParameterFreeSolver() Declaration solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::ParameterFreeSolver() ParameterFreeSolver() Declaration solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::ParameterFreeSolver(const ParameterFreeSolver&)=delete Methods operator=() Declaration ParameterFreeSolver&solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::operator=(const ParameterFreeSolver&)=delete ~ParameterFreeSolver() Declaration solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::~ParameterFreeSolver() get_identifier() Identifier of this solver (target in the request) Declaration std::string solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::get_identifier() const override init() Initialize the solver. Declaration void solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::init() override init_memory_check_error_message() Declaration std::string solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::init_memory_check_error_message() const override target_number_of_states() Declaration virtual size_t solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::target_number_of_states() const override configure() Read the maximum number of steps from configuration. Declaration void solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::configure(const utils::Json&json) override make_step() Declaration void solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::make_step(uint64_t step) override finalize() Declaration void solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::finalize() override get_model_properties() Declaration utils::Structure solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::get_model_properties() const override get_solver_properties() Declaration utils::Structure solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::get_solver_properties() const override get_output_parameters() Get a structure containing all output_parameters. Declaration utils::Structure solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::get_output_parameters() const override get_model() Declaration const Model_T&solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::get_model() const override set_model() Declaration void solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::set_model(const Model_T *model) override training_parameters() Declaration virtual void solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::training_parameters(const utils::Json&parameters) update_best() Declaration void solver::ParameterFreeSolver<Model_T, SolverAdapter, StrategyType>::update_best(double objective, std::vector<double>&parameters, double estimated_execution_cost)"
  },
  "api/solver/population-annealing.html": {
    "href": "api/solver/population-annealing.html",
    "title": "Class solver::PopulationAnnealing | qiotoolkit",
    "keywords": "Class solver::PopulationAnnealing Population Annealing. Population based optimizer with variable beta stepping. PopulationAnnealing explores the configuration space using multiple Metropolis walkers subject to a birth-death process (depending on their relative cost-fitness within the population). Stepping method Population annealing supports three different resampling_strategys for dynamically selecting the next step in temperature space (delta_beta): friction_tensor: The stepping size is calculated from \\Delta\\beta = c_{FT} / \\sqrt\\zeta { 'target': 'populationannealing.cpu', 'version': '1.0', 'resampling_strategy': 'friction_tensor', 'friction_tensor_constant': 1 } energy_variance: Scale temperature stepping with the variance in the energy (cost): \\Delta\\beta = f_{culling} / \\sqrt\\sigma for this, the initial value for the culling fraction needs to be specified: { 'target': 'populationannealing.cpu', 'version': '1.0', 'resampling_strategy': 'energy_variance', 'initial_culling_fraction': 0.5 } constant_culling: The stepping size is chosen to keep the culling rate constant at culling_fraction (by estimating the expected death ratio and solving for delta_beta): { 'target': 'populationannealing.cpu', 'version': '1.0', 'resampling_strategy': 'constant_culling', 'culling_fraction': 0.1 } Inheritance solver::SteppingSolver solver::PopulationAnnealing solver::PAParameterFree Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver get_solutions copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors PopulationAnnealing() Declaration solver::PopulationAnnealing<Model_T>::PopulationAnnealing() PopulationAnnealing() Declaration solver::PopulationAnnealing<Model_T>::PopulationAnnealing(const PopulationAnnealing&)=delete Methods operator=() Declaration PopulationAnnealing&solver::PopulationAnnealing<Model_T>::operator=(const PopulationAnnealing&)=delete get_identifier() Identifier of this solver (target in the request) Declaration std::string solver::PopulationAnnealing<Model_T>::get_identifier() const override init_memory_check_error_message() Declaration std::string solver::PopulationAnnealing<Model_T>::init_memory_check_error_message() const override target_number_of_states() Declaration size_t solver::PopulationAnnealing<Model_T>::target_number_of_states() const override init() Initialize the solver. Declaration void solver::PopulationAnnealing<Model_T>::init() override init_population() Reset the population with size target_population Note This method is invoked both at the start of the simulation and whenever a restart/population increase is triggered. Declaration void solver::PopulationAnnealing<Model_T>::init_population() find_delta_beta() Adjust the stepping size delta_beta until the estimator returns an estimate of zero. NOTE: This is NOT a generic root finder, it makes several assumptions about the estimator being used. Declaration double solver::PopulationAnnealing<Model_T>::find_delta_beta(T&estimator) make_step() Declaration void solver::PopulationAnnealing<Model_T>::make_step(uint64_t step) override resample() Declaration void solver::PopulationAnnealing<Model_T>::resample(double delta_beta) configure() Check the identifier and version against the configuraiton. Declaration void solver::PopulationAnnealing<Model_T>::configure(const utils::Json&json) override finalize() Declaration void solver::PopulationAnnealing<Model_T>::finalize() override expand_population() expand the population to size target_population Note This method is called to expand population from current size to target_population Declaration void solver::PopulationAnnealing<Model_T>::expand_population() is_linear_schedule() Declaration bool solver::PopulationAnnealing<Model_T>::is_linear_schedule() const is_geometric_schedule() Declaration bool solver::PopulationAnnealing<Model_T>::is_geometric_schedule() const is_friction_tensor() Declaration bool solver::PopulationAnnealing<Model_T>::is_friction_tensor() const is_energy_variance() Declaration bool solver::PopulationAnnealing<Model_T>::is_energy_variance() const is_constant_culling() Declaration bool solver::PopulationAnnealing<Model_T>::is_constant_culling() const"
  },
  "api/solver/population-annealing/culling-estimator.html": {
    "href": "api/solver/population-annealing/culling-estimator.html",
    "title": "Class solver::PopulationAnnealing::CullingEstimator | qiotoolkit",
    "keywords": "Class solver::PopulationAnnealing::CullingEstimator The CullingEstimator is used to infer the expected culling ratio for a proposed temperature stepping delta_beta for the \"constant_culling\" stepping method. (It is used by the find_delta_beta method below to iteratively find the appropriate stepping to keep culling approximately constant). Inheritance solver::PopulationAnnealing::CullingEstimator Constructors CullingEstimator() Declaration solver::PopulationAnnealing<Model_T>::CullingEstimator::CullingEstimator(const std::vector<double>&costs, double epsilon0, size_t target_population, double scale_factor) CullingEstimator() Declaration solver::PopulationAnnealing<Model_T>::CullingEstimator::CullingEstimator(const CullingEstimator&)=delete Methods operator=() Declaration CullingEstimator&solver::PopulationAnnealing<Model_T>::CullingEstimator::operator=(const CullingEstimator&)=delete operator=() Declaration CullingEstimator&solver::PopulationAnnealing<Model_T>::CullingEstimator::operator=(CullingEstimator&&)=delete operator()() Declaration double solver::PopulationAnnealing<Model_T>::CullingEstimator::operator()(double delta_beta)"
  },
  "api/solver/population.html": {
    "href": "api/solver/population.html",
    "title": "Class solver::Population | qiotoolkit",
    "keywords": "Class solver::Population A population is a container for several instances of Content_T Each instance of Content_T is internally wrapped in a Citizen wrapper, which allows setting the desired duplicity count of the contained instance after resampling. These new counts are, however, only applied after a call to resample(). Example: Populationstd::string population; population.insert(\"foo\"); population.insert(\"bar\"); population.insert(\"baz\"); for (size_t i = 0; i < population.size(); i++) { auto& citizen = population[i]; if (citizen.content() == \"foo\") citizen.kill() if (citizen.content() == \"baz\") citizen.spawn(2) } // output before resampling: \"foobarbaz\" for (size_t i = 0; i < population.size(); i++) { std::cout << population[i].content(); } population.resample(); // output after resampling: \"bazbarbazbaz\" for (size_t i = 0; i < population.size(); i++) { std::cout << population[i].content(); } Inheritance utils::Component solver::Population Inherited Members configure render ~Component Component get_status param get_class_name Constructors Population() Declaration solver::Population<Content_T>::Population() Methods reserve() Declaration void solver::Population<Content_T>::reserve(size_t size) insert() Add content to the population (with a count of 1). Declaration void solver::Population<Content_T>::insert(Content_T content) resize() Declaration void solver::Population<Content_T>::resize(size_t new_count) size() Get the current number of citizens. This does not consider current counts set on the citizens, so it should be called after resample(), prior to any set_count() on the citizens. Declaration size_t solver::Population<Content_T>::size() const empty() Check if the population is empty. Declaration bool solver::Population<Content_T>::empty() operator[]() Positional access to citizens. They are in no particular order, but the order remains \"stable\" during resampling. Declaration const Citizen&solver::Population<Content_T>::operator[](size_t position) const operator[]() Declaration Citizen&solver::Population<Content_T>::operator[](size_t position) resample() Resample the population such that count_ copies of each citizen in the current population are present in the resampled one. Declaration void solver::Population<Content_T>::resample() get_families() Returns a map describing the sizes of the remaining families. Declaration const std::map<FamilyId, size_t>&solver::Population<Content_T>::get_families() partial_sort() Declaration void solver::Population<Content_T>::partial_sort(unsigned solutions_to_sort) clear() Declaration void solver::Population<Content_T>::clear() clear_cache_pool() Declaration void solver::Population<Content_T>::clear_cache_pool() do_census() Declaration void solver::Population<Content_T>::do_census() create_citizen() Declaration void solver::Population<Content_T>::create_citizen(std::unique_ptr<Citizen>&citizen, const Content_T&content) remove_citizen() Declaration void solver::Population<Content_T>::remove_citizen(std::unique_ptr<Citizen>&citizen)"
  },
  "api/solver/population/citizen.html": {
    "href": "api/solver/population/citizen.html",
    "title": "Class solver::Population::Citizen | qiotoolkit",
    "keywords": "Class solver::Population::Citizen Inheritance solver::Population::Citizen Constructors Citizen() Declaration solver::Population<Content_T>::Citizen::Citizen() Citizen() Declaration solver::Population<Content_T>::Citizen::Citizen(const Citizen&other)=delete Citizen() Declaration solver::Population<Content_T>::Citizen::Citizen(Content_T content) Methods get_count() Declaration size_t solver::Population<Content_T>::Citizen::get_count() const set_count() Declaration void solver::Population<Content_T>::Citizen::set_count(size_t count) kill() Declaration void solver::Population<Content_T>::Citizen::kill() spawn() Declaration void solver::Population<Content_T>::Citizen::spawn(size_t n) set_family() Declaration void solver::Population<Content_T>::Citizen::set_family(FamilyId family_id) get_family() Declaration FamilyId solver::Population<Content_T>::Citizen::get_family() const content() Declaration const Content_T&solver::Population<Content_T>::Citizen::content() const content() Declaration Content_T&solver::Population<Content_T>::Citizen::content() operator*() Declaration const Content_T&solver::Population<Content_T>::Citizen::operator*() const operator*() Declaration Content_T&solver::Population<Content_T>::Citizen::operator*() >() Declaration const Content_T* solver::Population<Content_T>::Citizen::operator->() const >() Declaration const Content_T* solver::Population<Content_T>::Citizen::operator->() const >() Declaration Content_T* solver::Population<Content_T>::Citizen::operator->() >() Declaration Content_T* solver::Population<Content_T>::Citizen::operator->() compare() Declaration static bool solver::Population<Content_T>::Citizen::compare(const std::unique_ptr<Citizen>&c1, const std::unique_ptr<Citizen>&c2) operator=() Declaration Citizen&solver::Population<Content_T>::Citizen::operator=(const Citizen&other)"
  },
  "api/solver/ptparameter-free.html": {
    "href": "api/solver/ptparameter-free.html",
    "title": "Class solver::PTParameterFree | qiotoolkit",
    "keywords": "Class solver::PTParameterFree PTParameterFree is the class which implements ParameterFreeAdapterInterface to fit in parameter free solver framework. And it is a child of ParallelTempering so that it immediately has the functionalities of PT. Inheritance solver::ParallelTempering solver::ParameterFreeLinearSearchAdapterInterface solver::PTParameterFree Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver get_solutions copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state target_number_of_states init ParallelTempering get_temperatures get_identifier use_inverse_temperatures ParallelTempering finalize operator= accept init_memory_check_error_message make_step get_initial_parameter_values update_parameters_linearly set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors PTParameterFree() Declaration solver::PTParameterFree<Model_T>::PTParameterFree() PTParameterFree() Declaration solver::PTParameterFree<Model_T>::PTParameterFree(const PTParameterFree&)=delete Methods operator=() Declaration PTParameterFree&solver::PTParameterFree<Model_T>::operator=(const PTParameterFree&)=delete configure() Configure. Declaration void solver::PTParameterFree<Model_T>::configure(const utils::Json&json) override parameter_dimensions() Declaration size_t solver::PTParameterFree<Model_T>::parameter_dimensions() const override parameter_ranges() Declaration std::vector<int>solver::PTParameterFree<Model_T>::parameter_ranges() const override update_parameters() Declaration void solver::PTParameterFree<Model_T>::update_parameters(const std::vector<double>&parameters, double left_over_time) override estimate_execution_cost() Declaration double solver::PTParameterFree<Model_T>::estimate_execution_cost() const override determine_all_betas_() Declaration void solver::PTParameterFree<Model_T>::determine_all_betas_(double lowest_beta, double highest_beta, size_t num_betas, std::vector<double>&betas)"
  },
  "api/solver/quantum-monte-carlo.html": {
    "href": "api/solver/quantum-monte-carlo.html",
    "title": "Class solver::QuantumMonteCarlo | qiotoolkit",
    "keywords": "Class solver::QuantumMonteCarlo Inheritance solver::SteppingSolver solver::QuantumMonteCarlo Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors QuantumMonteCarlo() Declaration solver::QuantumMonteCarlo<Model_T>::QuantumMonteCarlo() QuantumMonteCarlo() Declaration solver::QuantumMonteCarlo<Model_T>::QuantumMonteCarlo(const QuantumMonteCarlo&)=delete Methods operator=() Declaration QuantumMonteCarlo&solver::QuantumMonteCarlo<Model_T>::operator=(const QuantumMonteCarlo&)=delete get_identifier() Identifier of this solver (target in the request) Declaration std::string solver::QuantumMonteCarlo<Model_T>::get_identifier() const override init_memory_check_error_message() Declaration std::string solver::QuantumMonteCarlo<Model_T>::init_memory_check_error_message() const override target_number_of_states() Declaration size_t solver::QuantumMonteCarlo<Model_T>::target_number_of_states() const override init() Initialize the solver. Declaration void solver::QuantumMonteCarlo<Model_T>::init() override init_replicas() Declaration void solver::QuantumMonteCarlo<Model_T>::init_replicas() make_step() Declaration void solver::QuantumMonteCarlo<Model_T>::make_step(uint64_t step) override make_sweeps() Declaration void solver::QuantumMonteCarlo<Model_T>::make_sweeps(double beta, double bond_prob) get_solutions() Get the structured result description. Declaration utils::Structure solver::QuantumMonteCarlo<Model_T>::get_solutions() const override configure() Check the identifier and version against the configuraiton. Declaration void solver::QuantumMonteCarlo<Model_T>::configure(const utils::Json&json) override calc_beta() Declaration double solver::QuantumMonteCarlo<Model_T>::calc_beta(double beta) calc_bond_prob() Declaration double solver::QuantumMonteCarlo<Model_T>::calc_bond_prob(double transverse_field, double beta) finalize() Declaration void solver::QuantumMonteCarlo<Model_T>::finalize() override"
  },
  "api/solver/saparameter-free.html": {
    "href": "api/solver/saparameter-free.html",
    "title": "Class solver::SAParameterFree | qiotoolkit",
    "keywords": "Class solver::SAParameterFree SAParameterFree is the class which implements ParameterFreeAdapterInterface to fit in parameter free solver framework. And it is a child of SimulatedAnnealing so that it immediately has the functionalities of SA. Inheritance solver::SimulatedAnnealing solver::ParameterFreeLinearSearchAdapterInterface solver::SAParameterFree Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state get_initial_parameter_values update_parameters_linearly finalize target_number_of_states get_solutions make_step init get_identifier SimulatedAnnealing operator= init_memory_check_error_message use_inverse_temperature SimulatedAnnealing set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors SAParameterFree() Declaration solver::SAParameterFree<Model_T>::SAParameterFree() SAParameterFree() Declaration solver::SAParameterFree<Model_T>::SAParameterFree(const SAParameterFree&)=delete Methods operator=() Declaration SAParameterFree&solver::SAParameterFree<Model_T>::operator=(const SAParameterFree&)=delete configure() Check the identifier and version against the configuraiton. Declaration void solver::SAParameterFree<Model_T>::configure(const utils::Json&json) override parameter_dimensions() Declaration size_t solver::SAParameterFree<Model_T>::parameter_dimensions() const override parameter_ranges() Declaration std::vector<int>solver::SAParameterFree<Model_T>::parameter_ranges() const override update_parameters() Declaration void solver::SAParameterFree<Model_T>::update_parameters(const std::vector<double>&parameters, double left_over_time) override estimate_execution_cost() Declaration double solver::SAParameterFree<Model_T>::estimate_execution_cost() const override"
  },
  "api/solver/simulated-annealing.html": {
    "href": "api/solver/simulated-annealing.html",
    "title": "Class solver::SimulatedAnnealing | qiotoolkit",
    "keywords": "Class solver::SimulatedAnnealing Inheritance solver::SteppingSolver solver::SimulatedAnnealing solver::SAParameterFree Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors SimulatedAnnealing() Declaration solver::SimulatedAnnealing<Model_T>::SimulatedAnnealing() SimulatedAnnealing() Declaration solver::SimulatedAnnealing<Model_T>::SimulatedAnnealing(const SimulatedAnnealing&)=delete Methods operator=() Declaration SimulatedAnnealing&solver::SimulatedAnnealing<Model_T>::operator=(const SimulatedAnnealing&)=delete get_identifier() Identifier of this solver (target in the request) Declaration std::string solver::SimulatedAnnealing<Model_T>::get_identifier() const override init_memory_check_error_message() Declaration std::string solver::SimulatedAnnealing<Model_T>::init_memory_check_error_message() const override target_number_of_states() Declaration size_t solver::SimulatedAnnealing<Model_T>::target_number_of_states() const override init() Initialize the solver. Declaration void solver::SimulatedAnnealing<Model_T>::init() override make_step() Declaration void solver::SimulatedAnnealing<Model_T>::make_step(uint64_t step) override get_solutions() Get the structured result description. Declaration utils::Structure solver::SimulatedAnnealing<Model_T>::get_solutions() const override configure() Check the identifier and version against the configuraiton. Declaration void solver::SimulatedAnnealing<Model_T>::configure(const utils::Json&json) override use_inverse_temperature() Declaration bool solver::SimulatedAnnealing<Model_T>::use_inverse_temperature() const finalize() Declaration void solver::SimulatedAnnealing<Model_T>::finalize() override"
  },
  "api/solver/solver-registrar.html": {
    "href": "api/solver/solver-registrar.html",
    "title": "Struct solver::SolverRegistrar | qiotoolkit",
    "keywords": "Struct solver::SolverRegistrar Helper struct to statically fill the registry. Constructors SolverRegistrar() Declaration solver::SolverRegistrar<Solver_T>::SolverRegistrar(int)"
  },
  "api/solver/solver-registration.html": {
    "href": "api/solver/solver-registration.html",
    "title": "Class solver::SolverRegistration | qiotoolkit",
    "keywords": "Class solver::SolverRegistration Registration of a templateable solver. The registration carries only the identifier of the solver for now; the actual instantiation is handled by the templated create_solver method declared above. Inheritance solver::SolverRegistration Constructors SolverRegistration() Declaration solver::SolverRegistration::SolverRegistration(const std::string&identifier) Methods create_for_model() Method to forward solver instantiation to create_solver Declaration Solver* solver::SolverRegistration::create_for_model() const"
  },
  "api/solver/solver-registry.html": {
    "href": "api/solver/solver-registry.html",
    "title": "Class solver::SolverRegistry | qiotoolkit",
    "keywords": "Class solver::SolverRegistry Registry of available solvers. The solver registry allows the instantiation of each registered solver for a given model. Usage: Registering a new model: class MySolver : public [solver::Solver](xref:classsolver_1_1Solver) { public: // Must have a constructor without arguments MySolver() = default; // This is the identifier the solver is register with. std::string get_identifier() const override { return \"my_solver\"; } ... } [REGISTER_SOLVER(MySolver)](xref:solver__registry_8h_1a7f2e334b3ffcbd91a8d8c1275ff11ec5); ``` * Make sure the solver is included in `all_solver.h` and handled in the `create_solver<Model_T>` method. * Instantiating a solver for a specific model: ```c++ auto* my_solver = [solver::SolverRegistry::create_for_model<MyModel>](xref:classsolver_1_1SolverRegistry_1a7a4df54052a7e300382bec91d072d409)(\"my_solver\"); ``` Inheritance solver::SolverRegistry Constructors SolverRegistry() This is a singleton class. Declaration solver::SolverRegistry::SolverRegistry() Methods has() Check whether a solver with that identifier is registered. Declaration static bool solver::SolverRegistry::has(const std::string&identifier) get() Find and return the solver registration. Declaration static const SolverRegistration* solver::SolverRegistry::get(const std::string&identifier) create_for_model() Find the solver registration and create an instance for Model_T. Declaration static Solver* solver::SolverRegistry::create_for_model(const std::string&identifier) add() Add an entry to the solver registry. This is used by the SolverRegistrar in the REGISTER_SOLVER macro, you should not need to invoke it directly. Declaration static void solver::SolverRegistry::add(const std::string&identifier, std::unique_ptr<SolverRegistration>&&registration) instance() Access the singleton. Declaration static SolverRegistry&solver::SolverRegistry::instance()"
  },
  "api/solver/solver.html": {
    "href": "api/solver/solver.html",
    "title": "Class solver::Solver | qiotoolkit",
    "keywords": "Class solver::Solver Interface for a Solver. A solver is initialized, run and then asked to print a result. Inheritance observe::Observer solver::Solver solver::ModelSolver Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors Solver() Intanstiate an uninitialized Solver. Declaration solver::Solver::Solver() Methods ~Solver() Declaration virtual solver::Solver::~Solver() get_identifier() Get the identifier of this solver. This identifier is denoted as the target in the request. Declaration virtual std::string solver::Solver::get_identifier() const =0 init() Initialize the solver. Declaration virtual void solver::Solver::init()=0 run() Run the solver. SteppingSolver Declaration virtual void solver::Solver::run()=0 get_solutions() Get the structured result description. Declaration virtual utils::Structure solver::Solver::get_solutions() const =0 get_model_properties() Declaration virtual utils::Structure solver::Solver::get_model_properties() const get_solver_properties() Declaration virtual utils::Structure solver::Solver::get_solver_properties() const get_model_sweep_size() Declaration virtual size_t solver::Solver::get_model_sweep_size() const =0 get_benchmark() Declaration utils::Structure solver::Solver::get_benchmark() const get_result() Declaration utils::Structure solver::Solver::get_result() const configure() Check the identifier and version against the configuraiton. Declaration virtual void solver::Solver::configure(const utils::Json&json) get_thread_count() Return the number of threads which should be used in parallel sections of the solver. Declaration int solver::Solver::get_thread_count() const finalize() Declaration virtual void solver::Solver::finalize() copy_limits() Declaration void solver::Solver::copy_limits(Solver *other) const set_time_limit() Declaration void solver::Solver::set_time_limit(double value) get_max_threads() Return the maximum number of threads this solver can use. Declaration int solver::Solver::get_max_threads() const"
  },
  "api/solver/ssmcparameter-free.html": {
    "href": "api/solver/ssmcparameter-free.html",
    "title": "Class solver::SSMCParameterFree | qiotoolkit",
    "keywords": "Class solver::SSMCParameterFree SSMCParameterFree is the class which implements ParameterFreeAdapterInterface to fit in parameter free solver framework. And it is a child of SubstochasticMonteCarlo so that it immediately has the functionalities of SSMC. Inheritance solver::SubstochasticMonteCarlo solver::ParameterFreeAdapterInterface solver::SSMCParameterFree Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step make_step init_memory_check_error_message update_population_statistics finalize prepare_population operator= resample_population SubstochasticMonteCarlo get_identifier make_walker_steps SubstochasticMonteCarlo init get_solutions target_number_of_states set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors SSMCParameterFree() Declaration solver::SSMCParameterFree<Model_T>::SSMCParameterFree() SSMCParameterFree() Declaration solver::SSMCParameterFree<Model_T>::SSMCParameterFree(const SSMCParameterFree&)=delete Methods operator=() Declaration SSMCParameterFree&solver::SSMCParameterFree<Model_T>::operator=(const SSMCParameterFree&)=delete configure() Check the identifier and version against the configuraiton. Declaration void solver::SSMCParameterFree<Model_T>::configure(const utils::Json&json) override parameter_dimensions() Declaration size_t solver::SSMCParameterFree<Model_T>::parameter_dimensions() const override parameter_ranges() Declaration std::vector<std::pair<double, double>>solver::SSMCParameterFree<Model_T>::parameter_ranges() const override get_initial_parameter_values() Declaration void solver::SSMCParameterFree<Model_T>::get_initial_parameter_values(std::vector<double>&initials) override update_parameters() Declaration void solver::SSMCParameterFree<Model_T>::update_parameters(const std::vector<double>&parameters, double left_over_time) override update_parameters_linearly() Declaration void solver::SSMCParameterFree<Model_T>::update_parameters_linearly(std::vector<double>&parameters) const override estimate_execution_cost() Declaration double solver::SSMCParameterFree<Model_T>::estimate_execution_cost() const override"
  },
  "api/solver/stepping-solver.html": {
    "href": "api/solver/stepping-solver.html",
    "title": "Class solver::SteppingSolver | qiotoolkit",
    "keywords": "Class solver::SteppingSolver Optimization in discretized steps. This base class assumes the solver runs in discretized steps t and handles the configuration of step_limit, increments t and calls make_step() for every integer value [0, step_limit]. Inheritance solver::ModelSolver solver::SteppingSolver examples::Descent solver::Murex solver::ParallelTempering solver::ParameterFreeSolver solver::PopulationAnnealing solver::QuantumMonteCarlo solver::SimulatedAnnealing solver::SubstochasticMonteCarlo solver::Tabu Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver get_solutions copy_lowest_state target_number_of_states copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size init_memory_check_error_message is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits finalize get_identifier ~Solver get_benchmark get_max_threads get_thread_count Solver set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors SteppingSolver() Declaration solver::SteppingSolver<Model_T>::SteppingSolver() Methods ~SteppingSolver() Declaration solver::SteppingSolver<Model_T>::~SteppingSolver() override configure() Read the maximum number of steps from configuration. Declaration void solver::SteppingSolver<Model_T>::configure(const utils::Json&json) override init() Initialize the solver. Declaration virtual void solver::SteppingSolver<Model_T>::init() override=0 make_step() Declaration virtual void solver::SteppingSolver<Model_T>::make_step(uint64_t step)=0 get_cost_function_evaluation_count() Declaration uint64_t solver::SteppingSolver<Model_T>::get_cost_function_evaluation_count() const status() Declaration virtual void solver::SteppingSolver<Model_T>::status() const run() A stepping solver is run by invoking / make_step(t) for every value of t. Declaration void solver::SteppingSolver<Model_T>::run() override get_solver_properties() Declaration utils::Structure solver::SteppingSolver<Model_T>::get_solver_properties() const override get_runtime() Declaration double solver::SteppingSolver<Model_T>::get_runtime() const get_seed() Declaration unsigned int solver::SteppingSolver<Model_T>::get_seed() const current_steps() Declaration virtual uint64_t solver::SteppingSolver<Model_T>::current_steps() const update_accumulated_info() Declaration void solver::SteppingSolver<Model_T>::update_accumulated_info() fixed_step_per_tick() Declaration void solver::SteppingSolver<Model_T>::fixed_step_per_tick(uint64_t value) reset() Declaration void solver::SteppingSolver<Model_T>::reset(double left_over_time) handle_signals() Declaration bool solver::SteppingSolver<Model_T>::handle_signals() seconds_per_step() Declaration double solver::SteppingSolver<Model_T>::seconds_per_step() const"
  },
  "api/solver/substochastic-monte-carlo.html": {
    "href": "api/solver/substochastic-monte-carlo.html",
    "title": "Class solver::SubstochasticMonteCarlo | qiotoolkit",
    "keywords": "Class solver::SubstochasticMonteCarlo Inheritance solver::SteppingSolver solver::SubstochasticMonteCarlo solver::SSMCParameterFree Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors SubstochasticMonteCarlo() Declaration solver::SubstochasticMonteCarlo<Model_T>::SubstochasticMonteCarlo() SubstochasticMonteCarlo() Declaration solver::SubstochasticMonteCarlo<Model_T>::SubstochasticMonteCarlo(const SubstochasticMonteCarlo&)=delete Methods operator=() Declaration SubstochasticMonteCarlo&solver::SubstochasticMonteCarlo<Model_T>::operator=(const SubstochasticMonteCarlo&)=delete get_identifier() Identifier of this solver (target in the request) Declaration std::string solver::SubstochasticMonteCarlo<Model_T>::get_identifier() const override init_memory_check_error_message() Declaration std::string solver::SubstochasticMonteCarlo<Model_T>::init_memory_check_error_message() const override target_number_of_states() Declaration size_t solver::SubstochasticMonteCarlo<Model_T>::target_number_of_states() const override init() Initialize the solver. Declaration void solver::SubstochasticMonteCarlo<Model_T>::init() override make_step() Declaration void solver::SubstochasticMonteCarlo<Model_T>::make_step(uint64_t step) override make_walker_steps() Declaration void solver::SubstochasticMonteCarlo<Model_T>::make_walker_steps(double alpha) update_population_statistics() Declaration void solver::SubstochasticMonteCarlo<Model_T>::update_population_statistics() resample_population() Declaration void solver::SubstochasticMonteCarlo<Model_T>::resample_population(double beta) get_solutions() Get the structured result description. Declaration utils::Structure solver::SubstochasticMonteCarlo<Model_T>::get_solutions() const override configure() Read the maximum number of steps from configuration. Declaration void solver::SubstochasticMonteCarlo<Model_T>::configure(const utils::Json&json) override finalize() Declaration void solver::SubstochasticMonteCarlo<Model_T>::finalize() override prepare_population() prepare the population to size target_population Note This method is called to prepare population from current size to target_population Declaration void solver::SubstochasticMonteCarlo<Model_T>::prepare_population()"
  },
  "api/solver/tabu-parameter-free.html": {
    "href": "api/solver/tabu-parameter-free.html",
    "title": "Class solver::TabuParameterFree | qiotoolkit",
    "keywords": "Class solver::TabuParameterFree Defines a parameter-free tabu search solver. The parameter free solver uses the TabuSolver class and tunes the two parameters: tabu tenure and iterations (sweeps). Inheritance solver::Tabu solver::ParameterFreeLinearSearchAdapterInterface solver::TabuParameterFree Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state get_initial_parameter_values update_parameters_linearly set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step Tabu make_step finalize target_number_of_states get_solutions operator= get_identifier init_memory_check_error_message Tabu init set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors TabuParameterFree() Declaration solver::TabuParameterFree<Model_T>::TabuParameterFree() TabuParameterFree() Declaration solver::TabuParameterFree<Model_T>::TabuParameterFree(const TabuParameterFree&)=delete Methods operator=() Declaration TabuParameterFree&solver::TabuParameterFree<Model_T>::operator=(const TabuParameterFree&)=delete configure() Read the maximum number of steps from configuration. Declaration void solver::TabuParameterFree<Model_T>::configure(const utils::Json&json) override parameter_dimensions() Declaration size_t solver::TabuParameterFree<Model_T>::parameter_dimensions() const override parameter_ranges() Declaration std::vector<int>solver::TabuParameterFree<Model_T>::parameter_ranges() const override update_parameters() Declaration void solver::TabuParameterFree<Model_T>::update_parameters(const std::vector<double>&parameters, double left_over_time) override estimate_execution_cost() Declaration double solver::TabuParameterFree<Model_T>::estimate_execution_cost() const override get_optimal_tenures_number() Declaration size_t solver::TabuParameterFree<Model_T>::get_optimal_tenures_number() const determine_all_tenures_() Declaration std::vector<unsigned int>solver::TabuParameterFree<Model_T>::determine_all_tenures_(size_t n_tenures)"
  },
  "api/solver/tabu.html": {
    "href": "api/solver/tabu.html",
    "title": "Class solver::Tabu | qiotoolkit",
    "keywords": "Class solver::Tabu Defines a tabu search solver. We are implementing the simple tabu search found in the following papers: J.E Beasley's 1998 paper \"Heuristic algorithms for the unconstrained binary quadratic programming problem\" GINTARAS PALUBECKIS 2004 paper \"Multistart Tabu Search Strategies for the Unconstrained Binary Quadratic Optimization Problem\" with the following adjustments: local delta calculations (as opposed to full re-calculation of the cost function) different starting configurations running in parallel Inheritance solver::SteppingSolver solver::Tabu solver::TabuParameterFree Inherited Members clear_observable_label restart is_watching scoped_observable_label observe Observer render set_observable_label ~ModelSolver copy_lowest_state copy_solutions get_model_properties update_lowest_cost get_model_term_size init_memory_check count_solutions copy_solutions get_model get_model_unconst copy_solutions_other ModelSolver populate_solutions max_replicas_adjusted_state set_model get_model_sweep_size is_empty get_lowest_cost adjust_states max_replicas_of_state set_time_limit get_result copy_limits ~Solver get_benchmark get_max_threads get_thread_count Solver fixed_step_per_tick update_accumulated_info handle_signals run current_steps reset get_cost_function_evaluation_count SteppingSolver get_solver_properties status get_seed ~SteppingSolver get_runtime seconds_per_step set_output_parameter set_output_parameter param get_output_parameters ~Component Component get_status get_class_name Constructors Tabu() Declaration solver::Tabu<Model_T>::Tabu() Tabu() Declaration solver::Tabu<Model_T>::Tabu(const Tabu&)=delete Methods operator=() Declaration Tabu&solver::Tabu<Model_T>::operator=(const Tabu&)=delete get_identifier() Identifier of this solver (target in the request) Declaration std::string solver::Tabu<Model_T>::get_identifier() const override init_memory_check_error_message() Declaration std::string solver::Tabu<Model_T>::init_memory_check_error_message() const override target_number_of_states() Declaration size_t solver::Tabu<Model_T>::target_number_of_states() const override init() Initialize the solver. Declaration void solver::Tabu<Model_T>::init() override make_step() Declaration void solver::Tabu<Model_T>::make_step(uint64_t) override get_solutions() Get the structured result description. Declaration utils::Structure solver::Tabu<Model_T>::get_solutions() const override configure() Read the maximum number of steps from configuration. Declaration void solver::Tabu<Model_T>::configure(const utils::Json&json) override finalize() Declaration void solver::Tabu<Model_T>::finalize() override"
  },
  "api/std-allocator.html": {
    "href": "api/std-allocator.html",
    "title": "Class StdAllocator | qiotoolkit",
    "keywords": "Class StdAllocator Inheritance StdAllocator Constructors StdAllocator() Declaration StdAllocator<T, BaseAllocator>::StdAllocator() RAPIDJSON_NOEXCEPT StdAllocator() Declaration StdAllocator<T, BaseAllocator>::StdAllocator(const StdAllocator&rhs) RAPIDJSON_NOEXCEPT StdAllocator() Declaration StdAllocator<T, BaseAllocator>::StdAllocator(const StdAllocator<U, BaseAllocator>&rhs) RAPIDJSON_NOEXCEPT StdAllocator() Declaration StdAllocator<T, BaseAllocator>::StdAllocator(const BaseAllocator&allocator) RAPIDJSON_NOEXCEPT Methods ~StdAllocator() Declaration StdAllocator<T, BaseAllocator>::~StdAllocator() RAPIDJSON_NOEXCEPT address() Declaration pointer StdAllocator<T, BaseAllocator>::address(reference r) const RAPIDJSON_NOEXCEPT address() Declaration const_pointer StdAllocator<T, BaseAllocator>::address(const_reference r) const RAPIDJSON_NOEXCEPT max_size() Declaration size_type StdAllocator<T, BaseAllocator>::max_size() const RAPIDJSON_NOEXCEPT construct() Declaration void StdAllocator<T, BaseAllocator>::construct(pointer p, const_reference r) destroy() Declaration void StdAllocator<T, BaseAllocator>::destroy(pointer p) allocate() Declaration U* StdAllocator<T, BaseAllocator>::allocate(size_type n=1, const void *=0) deallocate() Declaration void StdAllocator<T, BaseAllocator>::deallocate(U *p, size_type n=1) allocate() Declaration pointer StdAllocator<T, BaseAllocator>::allocate(size_type n=1, const void *=0) deallocate() Declaration void StdAllocator<T, BaseAllocator>::deallocate(pointer p, size_type n=1) operator==() Declaration bool StdAllocator<T, BaseAllocator>::operator==(const StdAllocator<U, BaseAllocator>&rhs) const RAPIDJSON_NOEXCEPT operator!=() Declaration bool StdAllocator<T, BaseAllocator>::operator!=(const StdAllocator<U, BaseAllocator>&rhs) const RAPIDJSON_NOEXCEPT Malloc() Declaration void* StdAllocator<T, BaseAllocator>::Malloc(size_t size) Realloc() Declaration void* StdAllocator<T, BaseAllocator>::Realloc(void *originalPtr, size_t originalSize, size_t newSize) Free() Declaration static void StdAllocator<T, BaseAllocator>::Free(void *ptr) RAPIDJSON_NOEXCEPT"
  },
  "api/std-allocator/3/01void/00/01-base-allocator/01/4.html": {
    "href": "api/std-allocator/3/01void/00/01-base-allocator/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods StdAllocator() Declaration StdAllocator<void, BaseAllocator>::StdAllocator() RAPIDJSON_NOEXCEPT StdAllocator() Declaration StdAllocator<void, BaseAllocator>::StdAllocator(const StdAllocator&rhs) RAPIDJSON_NOEXCEPT StdAllocator() Declaration StdAllocator<void, BaseAllocator>::StdAllocator(const StdAllocator<U, BaseAllocator>&rhs) RAPIDJSON_NOEXCEPT StdAllocator() Declaration StdAllocator<void, BaseAllocator>::StdAllocator(const BaseAllocator&baseAllocator) RAPIDJSON_NOEXCEPT ~StdAllocator() Declaration StdAllocator<void, BaseAllocator>::~StdAllocator() RAPIDJSON_NOEXCEPT"
  },
  "api/std-allocator/3/01void/00/01-base-allocator/01/4/rebind.html": {
    "href": "api/std-allocator/3/01void/00/01-base-allocator/01/4/rebind.html",
    "title": "Struct ::rebind | qiotoolkit",
    "keywords": "Struct ::rebind"
  },
  "api/std-allocator/rebind.html": {
    "href": "api/std-allocator/rebind.html",
    "title": "Struct StdAllocator::rebind | qiotoolkit",
    "keywords": "Struct StdAllocator::rebind"
  },
  "api/std/hash/3/01examples/soft-spin-transition/01/4.html": {
    "href": "api/std/hash/3/01examples/soft-spin-transition/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods operator()() Declaration std::size_t std::hash<examples::SoftSpinTransition>::operator()(const examples::SoftSpinTransition&trans) const noexcept"
  },
  "api/std/hash/3/01model/blume-capel-transition/01/4.html": {
    "href": "api/std/hash/3/01model/blume-capel-transition/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods operator()() Declaration std::size_t std::hash<model::BlumeCapelTransition>::operator()(const model::BlumeCapelTransition&trans) const noexcept"
  },
  "api/std/hash/3/01model/clock-transition/01/4.html": {
    "href": "api/std/hash/3/01model/clock-transition/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods operator()() Declaration std::size_t std::hash<model::ClockTransition>::operator()(const model::ClockTransition&trans) const noexcept"
  },
  "api/std/hash/3/01model/tsp-transition/01/4.html": {
    "href": "api/std/hash/3/01model/tsp-transition/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods operator()() Declaration std::size_t std::hash<model::TspTransition>::operator()(const model::TspTransition&trans) const noexcept"
  },
  "api/std/tr/1gtest/internal/add-ref.html": {
    "href": "api/std/tr/1gtest/internal/add-ref.html",
    "title": "Struct std::tr1::gtest_internal::AddRef | qiotoolkit",
    "keywords": "Struct std::tr1::gtest_internal::AddRef"
  },
  "api/std/tr/1gtest/internal/add-ref/3/01-t/01/6/01/4.html": {
    "href": "api/std/tr/1gtest/internal/add-ref/3/01-t/01/6/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/by-ref.html": {
    "href": "api/std/tr/1gtest/internal/by-ref.html",
    "title": "Struct std::tr1::gtest_internal::ByRef | qiotoolkit",
    "keywords": "Struct std::tr1::gtest_internal::ByRef"
  },
  "api/std/tr/1gtest/internal/by-ref/3/01-t/01/6/01/4.html": {
    "href": "api/std/tr/1gtest/internal/by-ref/3/01-t/01/6/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/get.html": {
    "href": "api/std/tr/1gtest/internal/get.html",
    "title": "Class std::tr1::gtest_internal::Get | qiotoolkit",
    "keywords": "Class std::tr1::gtest_internal::Get Inheritance std::tr1::gtest_internal::Get"
  },
  "api/std/tr/1gtest/internal/get/3/010/01/4.html": {
    "href": "api/std/tr/1gtest/internal/get/3/010/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_ADD_REF_() Declaration static std::tr1::gtest_internal::Get<0>::GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(0, Tuple)) Field(Tuple&t) GTEST_BY_REF_() Declaration static std::tr1::gtest_internal::Get<0>::GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(0, Tuple)) ConstField(const Tuple&t)"
  },
  "api/std/tr/1gtest/internal/get/3/011/01/4.html": {
    "href": "api/std/tr/1gtest/internal/get/3/011/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_ADD_REF_() Declaration static std::tr1::gtest_internal::Get<1>::GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(1, Tuple)) Field(Tuple&t) GTEST_BY_REF_() Declaration static std::tr1::gtest_internal::Get<1>::GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(1, Tuple)) ConstField(const Tuple&t)"
  },
  "api/std/tr/1gtest/internal/get/3/012/01/4.html": {
    "href": "api/std/tr/1gtest/internal/get/3/012/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_ADD_REF_() Declaration static std::tr1::gtest_internal::Get<2>::GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(2, Tuple)) Field(Tuple&t) GTEST_BY_REF_() Declaration static std::tr1::gtest_internal::Get<2>::GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(2, Tuple)) ConstField(const Tuple&t)"
  },
  "api/std/tr/1gtest/internal/get/3/013/01/4.html": {
    "href": "api/std/tr/1gtest/internal/get/3/013/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_ADD_REF_() Declaration static std::tr1::gtest_internal::Get<3>::GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(3, Tuple)) Field(Tuple&t) GTEST_BY_REF_() Declaration static std::tr1::gtest_internal::Get<3>::GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(3, Tuple)) ConstField(const Tuple&t)"
  },
  "api/std/tr/1gtest/internal/get/3/014/01/4.html": {
    "href": "api/std/tr/1gtest/internal/get/3/014/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_ADD_REF_() Declaration static std::tr1::gtest_internal::Get<4>::GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(4, Tuple)) Field(Tuple&t) GTEST_BY_REF_() Declaration static std::tr1::gtest_internal::Get<4>::GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(4, Tuple)) ConstField(const Tuple&t)"
  },
  "api/std/tr/1gtest/internal/get/3/015/01/4.html": {
    "href": "api/std/tr/1gtest/internal/get/3/015/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_ADD_REF_() Declaration static std::tr1::gtest_internal::Get<5>::GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(5, Tuple)) Field(Tuple&t) GTEST_BY_REF_() Declaration static std::tr1::gtest_internal::Get<5>::GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(5, Tuple)) ConstField(const Tuple&t)"
  },
  "api/std/tr/1gtest/internal/get/3/016/01/4.html": {
    "href": "api/std/tr/1gtest/internal/get/3/016/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_ADD_REF_() Declaration static std::tr1::gtest_internal::Get<6>::GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(6, Tuple)) Field(Tuple&t) GTEST_BY_REF_() Declaration static std::tr1::gtest_internal::Get<6>::GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(6, Tuple)) ConstField(const Tuple&t)"
  },
  "api/std/tr/1gtest/internal/get/3/017/01/4.html": {
    "href": "api/std/tr/1gtest/internal/get/3/017/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_ADD_REF_() Declaration static std::tr1::gtest_internal::Get<7>::GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(7, Tuple)) Field(Tuple&t) GTEST_BY_REF_() Declaration static std::tr1::gtest_internal::Get<7>::GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(7, Tuple)) ConstField(const Tuple&t)"
  },
  "api/std/tr/1gtest/internal/get/3/018/01/4.html": {
    "href": "api/std/tr/1gtest/internal/get/3/018/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_ADD_REF_() Declaration static std::tr1::gtest_internal::Get<8>::GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(8, Tuple)) Field(Tuple&t) GTEST_BY_REF_() Declaration static std::tr1::gtest_internal::Get<8>::GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(8, Tuple)) ConstField(const Tuple&t)"
  },
  "api/std/tr/1gtest/internal/get/3/019/01/4.html": {
    "href": "api/std/tr/1gtest/internal/get/3/019/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_ADD_REF_() Declaration static std::tr1::gtest_internal::Get<9>::GTEST_ADD_REF_(GTEST_TUPLE_ELEMENT_(9, Tuple)) Field(Tuple&t) GTEST_BY_REF_() Declaration static std::tr1::gtest_internal::Get<9>::GTEST_BY_REF_(GTEST_TUPLE_ELEMENT_(9, Tuple)) ConstField(const Tuple&t)"
  },
  "api/std/tr/1gtest/internal/same-size-tuple-prefix-comparator.html": {
    "href": "api/std/tr/1gtest/internal/same-size-tuple-prefix-comparator.html",
    "title": "Struct std::tr1::gtest_internal::SameSizeTuplePrefixComparator | qiotoolkit",
    "keywords": "Struct std::tr1::gtest_internal::SameSizeTuplePrefixComparator"
  },
  "api/std/tr/1gtest/internal/same-size-tuple-prefix-comparator/3/010/00/010/01/4.html": {
    "href": "api/std/tr/1gtest/internal/same-size-tuple-prefix-comparator/3/010/00/010/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Eq() Declaration static bool std::tr1::gtest_internal::SameSizeTuplePrefixComparator<0, 0>::Eq(const Tuple1&, const Tuple2&)"
  },
  "api/std/tr/1gtest/internal/same-size-tuple-prefix-comparator/3/01k/00/01k/01/4.html": {
    "href": "api/std/tr/1gtest/internal/same-size-tuple-prefix-comparator/3/01k/00/01k/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Eq() Declaration static bool std::tr1::gtest_internal::SameSizeTuplePrefixComparator<k, k>::Eq(const Tuple1&t1, const Tuple2&t2)"
  },
  "api/std/tr/1gtest/internal/tuple-element.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element.html",
    "title": "Struct std::tr1::gtest_internal::TupleElement | qiotoolkit",
    "keywords": "Struct std::tr1::gtest_internal::TupleElement"
  },
  "api/std/tr/1gtest/internal/tuple-element/3/01true/00/010/00/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element/3/01true/00/010/00/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/tuple-element/3/01true/00/011/00/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element/3/01true/00/011/00/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/tuple-element/3/01true/00/012/00/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element/3/01true/00/012/00/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/tuple-element/3/01true/00/013/00/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element/3/01true/00/013/00/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/tuple-element/3/01true/00/014/00/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element/3/01true/00/014/00/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/tuple-element/3/01true/00/015/00/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element/3/01true/00/015/00/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/tuple-element/3/01true/00/016/00/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element/3/01true/00/016/00/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/tuple-element/3/01true/00/017/00/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element/3/01true/00/017/00/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/tuple-element/3/01true/00/018/00/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element/3/01true/00/018/00/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1gtest/internal/tuple-element/3/01true/00/019/00/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1gtest/internal/tuple-element/3/01true/00/019/00/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple.html": {
    "href": "api/std/tr/1tuple.html",
    "title": "Class std::tr1::tuple | qiotoolkit",
    "keywords": "Class std::tr1::tuple Inheritance std::tr1::tuple Constructors tuple() Declaration std::tr1::tuple<>::tuple() tuple() Declaration std::tr1::tuple<>::tuple(GTEST_BY_REF_(T0) f0, GTEST_BY_REF_(T1) f1, GTEST_BY_REF_(T2) f2, GTEST_BY_REF_(T3) f3, GTEST_BY_REF_(T4) f4, GTEST_BY_REF_(T5) f5, GTEST_BY_REF_(T6) f6, GTEST_BY_REF_(T7) f7, GTEST_BY_REF_(T8) f8, GTEST_BY_REF_(T9) f9) tuple() Declaration std::tr1::tuple<>::tuple(const tuple&t) tuple() Declaration std::tr1::tuple<>::tuple(const GTEST_10_TUPLE_(U)&t) Methods operator=() Declaration tuple&std::tr1::tuple<>::operator=(const tuple&t) operator=() Declaration tuple&std::tr1::tuple<>::operator=(const GTEST_10_TUPLE_(U)&t) CopyFrom() Declaration GTEST_DECLARE_TUPLE_AS_FRIEND_ tuple&std::tr1::tuple<>::CopyFrom(const GTEST_10_TUPLE_(U)&t)"
  },
  "api/std/tr/1tuple/3/4.html": {
    "href": "api/std/tr/1tuple/3/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods tuple() Declaration std::tr1::tuple<>::tuple() tuple() Declaration std::tr1::tuple<>::tuple(const tuple&) operator=() Declaration tuple&std::tr1::tuple<>::operator=(const tuple&)"
  },
  "api/std/tr/1tuple/element.html": {
    "href": "api/std/tr/1tuple/element.html",
    "title": "Struct std::tr1::tuple_element | qiotoolkit",
    "keywords": "Struct std::tr1::tuple_element"
  },
  "api/std/tr/1tuple/size.html": {
    "href": "api/std/tr/1tuple/size.html",
    "title": "Struct std::tr1::tuple_size | qiotoolkit",
    "keywords": "Struct std::tr1::tuple_size"
  },
  "api/std/tr/1tuple/size/3/01-gtest/0/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/0/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple/size/3/01-gtest/1/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/1/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple/size/3/01-gtest/10/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/10/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple/size/3/01-gtest/2/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/2/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple/size/3/01-gtest/3/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/3/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple/size/3/01-gtest/4/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/4/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple/size/3/01-gtest/5/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/5/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple/size/3/01-gtest/6/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/6/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple/size/3/01-gtest/7/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/7/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple/size/3/01-gtest/8/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/8/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/std/tr/1tuple/size/3/01-gtest/9/tuple/07-t/08/01/4.html": {
    "href": "api/std/tr/1tuple/size/3/01-gtest/9/tuple/07-t/08/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/strategy/base-opt.html": {
    "href": "api/strategy/base-opt.html",
    "title": "Class strategy::BaseOpt | qiotoolkit",
    "keywords": "Class strategy::BaseOpt Global Optimization stategy searching implementation. Inheritance utils::Component strategy::BaseOpt strategy::BayesianOpt strategy::LinearSearchOpt Inherited Members configure render ~Component Component get_status param get_class_name Constructors BaseOpt() Declaration strategy::BaseOpt::BaseOpt() BaseOpt() Declaration strategy::BaseOpt::BaseOpt(const BaseOpt&)=delete Methods operator=() Declaration BaseOpt&strategy::BaseOpt::operator=(const BaseOpt&)=delete recommend_parameter_values() Declaration virtual bool strategy::BaseOpt::recommend_parameter_values(std::vector<double>&parameters_new)=0 add_new_sample() Declaration virtual void strategy::BaseOpt::add_new_sample(std::vector<double>&parameters, double objective)=0 get_perf_metrics() Declaration void strategy::BaseOpt::get_perf_metrics(utils::Structure&perf) const log_parameters() Declaration void strategy::BaseOpt::log_parameters(const std::string&header, const std::vector<double>&parameters)"
  },
  "api/strategy/bayesian-opt.html": {
    "href": "api/strategy/bayesian-opt.html",
    "title": "Class strategy::BayesianOpt | qiotoolkit",
    "keywords": "Class strategy::BayesianOpt Bayesian Global Optimization stategy searching implementation. The BayesianOpt is a wrapper class for GPP library https://github.com/wujian16/Cornell-MOE The paper \"A Tutorial on Bayesian Optimization\" is a good introduction of bayesian optimization. Inheritance strategy::BaseOpt strategy::BayesianOpt Inherited Members BaseOpt operator= BaseOpt get_perf_metrics log_parameters configure render ~Component Component get_status param get_class_name Constructors BayesianOpt() Declaration strategy::BayesianOpt::BayesianOpt() BayesianOpt() Declaration strategy::BayesianOpt::BayesianOpt(const BayesianOpt&)=delete Methods operator=() Declaration BayesianOpt&strategy::BayesianOpt::operator=(const BayesianOpt&)=delete configure() Declaration void strategy::BayesianOpt::configure(const utils::Json&params, int thread_count) init() Declaration void strategy::BayesianOpt::init(size_t dimensions, uint32_t seed, size_t reserved_samples=128) init() Declaration void strategy::BayesianOpt::init(size_t dimensions, uint32_t seed, const GDParameters&model_parameters, const GDParameters&search_parameters, size_t reserved_samples=128) recommend_parameter_values() Declaration bool strategy::BayesianOpt::recommend_parameter_values(std::vector<double>&parameters_new) override add_new_sample() Declaration void strategy::BayesianOpt::add_new_sample(std::vector<double>&parameters, double objective) override set_ranges() Declaration void strategy::BayesianOpt::set_ranges(const std::vector<std::pair<double, double>>&ranges) num_of_saved_samples() Declaration size_t strategy::BayesianOpt::num_of_saved_samples() const get_sample() Declaration double strategy::BayesianOpt::get_sample(int indx, std::vector<double>&sample_point) const get_reserved_samples() Declaration uint32_t strategy::BayesianOpt::get_reserved_samples() copyout_winner() Declaration void strategy::BayesianOpt::copyout_winner(std::vector<double>&parameters) const log_hyper_parameters() Declaration void strategy::BayesianOpt::log_hyper_parameters() const"
  },
  "api/strategy/gdparameters.html": {
    "href": "api/strategy/gdparameters.html",
    "title": "Class strategy::GDParameters | qiotoolkit",
    "keywords": "Class strategy::GDParameters Inheritance utils::Component strategy::GDParameters Inherited Members render ~Component Component get_status param get_class_name Methods load() Declaration void strategy::GDParameters::load(const utils::Structure&params) configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void strategy::GDParameters::configure(const utils::Json&params) override to_string() Declaration std::string strategy::GDParameters::to_string() const"
  },
  "api/strategy/linear-search-opt.html": {
    "href": "api/strategy/linear-search-opt.html",
    "title": "Class strategy::LinearSearchOpt | qiotoolkit",
    "keywords": "Class strategy::LinearSearchOpt Linear Search Global Optimization stategy searching implementation. Implemented 1 dimensional search and refine algorithm. Solution is computed at sample points iteratively and search interval defined by sample points will be moved toward the end where the best solution is observed. Inheritance strategy::BaseOpt strategy::LinearSearchOpt Inherited Members BaseOpt operator= BaseOpt get_perf_metrics log_parameters configure render ~Component Component get_status param get_class_name Constructors LinearSearchOpt() Declaration strategy::LinearSearchOpt::LinearSearchOpt() LinearSearchOpt() Declaration strategy::LinearSearchOpt::LinearSearchOpt(const LinearSearchOpt&)=delete Methods operator=() Declaration LinearSearchOpt&strategy::LinearSearchOpt::operator=(const LinearSearchOpt&)=delete configure() Declaration void strategy::LinearSearchOpt::configure(const utils::Json&params, int thread_count) init() Declaration void strategy::LinearSearchOpt::init(size_t dimensions, uint32_t seed, size_t reserved_samples=128) recommend_parameter_values() Declaration bool strategy::LinearSearchOpt::recommend_parameter_values(std::vector<double>&parameters_new) add_new_sample() Declaration void strategy::LinearSearchOpt::add_new_sample(std::vector<double>&parameters, double objective) set_ranges() Declaration void strategy::LinearSearchOpt::set_ranges(const std::vector<int>&intial_sample_points) fit_sample_points() Search interval defined by sample points will be stretched if the best solution is produced at the last sample point. Search interval defined by sample points will be shrinked if the best solution is produced at the first sample point. Declaration void strategy::LinearSearchOpt::fit_sample_points()"
  },
  "api/stream-traits.html": {
    "href": "api/stream-traits.html",
    "title": "Struct StreamTraits | qiotoolkit",
    "keywords": "Struct StreamTraits Provides additional information for stream. By using traits pattern, this type provides a default configuration for stream. For custom stream, this type can be specialized for other configuration. See TEST(Reader, CustomStringStream) in readertest.cpp for example."
  },
  "api/stream-traits/3/01-generic-insitu-string-stream/3/01-encoding/01/4/01/4.html": {
    "href": "api/stream-traits/3/01-generic-insitu-string-stream/3/01-encoding/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/stream-traits/3/01-generic-string-stream/3/01-encoding/01/4/01/4.html": {
    "href": "api/stream-traits/3/01-generic-string-stream/3/01-encoding/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/student.html": {
    "href": "api/student.html",
    "title": "Struct Student | qiotoolkit",
    "keywords": "Struct Student Constructors Student() Declaration Student::Student() Student() Declaration Student::Student(const std::string name, unsigned age, double height, bool canSwim)"
  },
  "api/table-struct/problem/2eproto.html": {
    "href": "api/table-struct/problem/2eproto.html",
    "title": "Struct TableStruct_problem_2eproto | qiotoolkit",
    "keywords": "Struct TableStruct_problem_2eproto"
  },
  "api/testing/action-interface.html": {
    "href": "api/testing/action-interface.html",
    "title": "Class testing::ActionInterface | qiotoolkit",
    "keywords": "Class testing::ActionInterface Inheritance testing::ActionInterface Constructors ActionInterface() Declaration testing::ActionInterface<F>::ActionInterface() ActionInterface() Declaration testing::ActionInterface<F>::ActionInterface() Methods ~ActionInterface() Declaration virtual testing::ActionInterface<F>::~ActionInterface() Perform() Declaration virtual Result testing::ActionInterface<F>::Perform(const ArgumentTuple&args)=0 ~ActionInterface() Declaration virtual testing::ActionInterface<F>::~ActionInterface() Perform() Declaration virtual Result testing::ActionInterface<F>::Perform(const ArgumentTuple&args)=0 GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::ActionInterface<F>::GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionInterface) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::ActionInterface<F>::GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionInterface)"
  },
  "api/testing/action.html": {
    "href": "api/testing/action.html",
    "title": "Class testing::Action | qiotoolkit",
    "keywords": "Class testing::Action Inheritance testing::Action Constructors Action() Declaration Action() Action() Declaration testing::Action<F>::Action(G&&fun) Action() Declaration testing::Action<F>::Action(ActionInterface<F>*impl) Action() Declaration testing::Action<F>::Action(const Action<Func>&action) Action() Declaration testing::Action<F>::Action() Action() Declaration testing::Action<F>::Action(ActionInterface<F>*impl) Action() Declaration testing::Action<F>::Action(const Action<Func>&action) Action() Declaration testing::Action<F>::Action(const Action<From>&from) Methods IsDoDefault() Declaration bool testing::Action<F>::IsDoDefault() const Perform() Declaration Result testing::Action<F>::Perform(ArgumentTuple args) const IsDoDefault() Declaration bool testing::Action<F>::IsDoDefault() const Perform() Declaration Result testing::Action<F>::Perform(ArgumentTuple args) const"
  },
  "api/testing/action/action-adapter.html": {
    "href": "api/testing/action/action-adapter.html",
    "title": "Struct testing::Action::ActionAdapter | qiotoolkit",
    "keywords": "Struct testing::Action::ActionAdapter Methods operator()() Declaration internal::Function<F>::Result testing::Action<F>::ActionAdapter::operator()(Args&&... args)"
  },
  "api/testing/assertion-result.html": {
    "href": "api/testing/assertion-result.html",
    "title": "Class testing::AssertionResult | qiotoolkit",
    "keywords": "Class testing::AssertionResult Inheritance testing::AssertionResult Constructors AssertionResult() Declaration testing::AssertionResult::AssertionResult(const AssertionResult&other) AssertionResult() Declaration testing::AssertionResult::AssertionResult(const T&success, typename internal::EnableIf<!internal::ImplicitlyConvertible<T, AssertionResult>::value>::type *=NULL) Methods operator=() Declaration AssertionResult&testing::AssertionResult::operator=(AssertionResult other) operator bool() Declaration testing::AssertionResult::operator bool() const operator!() Declaration AssertionResult testing::AssertionResult::operator!() const message() Declaration const char* testing::AssertionResult::message() const failure_message() Declaration const char* testing::AssertionResult::failure_message() const <() Declaration AssertionResult&testing::AssertionResult::operator<<(const T&value) <() Declaration AssertionResult&testing::AssertionResult::operator<<(const T&value) <() Declaration AssertionResult&testing::AssertionResult::operator<<(const T&value) <() Declaration AssertionResult&testing::AssertionResult::operator<<(::std::ostream&(*basic_manipulator)(::std::ostream&stream)) <() Declaration AssertionResult&testing::AssertionResult::operator<<(::std::ostream&(*basic_manipulator)(::std::ostream&stream)) <() Declaration AssertionResult&testing::AssertionResult::operator<<(::std::ostream&(*basic_manipulator)(::std::ostream&stream)) AppendMessage() Declaration void testing::AssertionResult::AppendMessage(const Message&a_message) swap() Declaration void testing::AssertionResult::swap(AssertionResult&other)"
  },
  "api/testing/cardinality-interface.html": {
    "href": "api/testing/cardinality-interface.html",
    "title": "Class testing::CardinalityInterface | qiotoolkit",
    "keywords": "Class testing::CardinalityInterface Inheritance testing::CardinalityInterface Methods ~CardinalityInterface() Declaration virtual testing::CardinalityInterface::~CardinalityInterface() ConservativeLowerBound() Declaration virtual int testing::CardinalityInterface::ConservativeLowerBound() const ConservativeUpperBound() Declaration virtual int testing::CardinalityInterface::ConservativeUpperBound() const IsSatisfiedByCallCount() Declaration virtual bool testing::CardinalityInterface::IsSatisfiedByCallCount(int call_count) const =0 IsSaturatedByCallCount() Declaration virtual bool testing::CardinalityInterface::IsSaturatedByCallCount(int call_count) const =0 DescribeTo() Declaration virtual void testing::CardinalityInterface::DescribeTo(::std::ostream *os) const =0"
  },
  "api/testing/cardinality.html": {
    "href": "api/testing/cardinality.html",
    "title": "Class testing::Cardinality | qiotoolkit",
    "keywords": "Class testing::Cardinality Inheritance testing::Cardinality Constructors Cardinality() Declaration testing::Cardinality::Cardinality() Cardinality() Declaration testing::Cardinality::Cardinality(const CardinalityInterface *impl) Methods ConservativeLowerBound() Declaration int testing::Cardinality::ConservativeLowerBound() const ConservativeUpperBound() Declaration int testing::Cardinality::ConservativeUpperBound() const IsSatisfiedByCallCount() Declaration bool testing::Cardinality::IsSatisfiedByCallCount(int call_count) const IsSaturatedByCallCount() Declaration bool testing::Cardinality::IsSaturatedByCallCount(int call_count) const IsOverSaturatedByCallCount() Declaration bool testing::Cardinality::IsOverSaturatedByCallCount(int call_count) const DescribeTo() Declaration void testing::Cardinality::DescribeTo(::std::ostream *os) const DescribeActualCallCountTo() Declaration void testing::Cardinality::DescribeActualCallCountTo(int actual_call_count, ::std::ostream *os)"
  },
  "api/testing/default-value.html": {
    "href": "api/testing/default-value.html",
    "title": "Class testing::DefaultValue | qiotoolkit",
    "keywords": "Class testing::DefaultValue Inheritance testing::DefaultValue Methods Set() Declaration static void testing::DefaultValue<T>::Set(T x) SetFactory() Declaration static void testing::DefaultValue<T>::SetFactory(FactoryFunction factory) Clear() Declaration static void testing::DefaultValue<T>::Clear() IsSet() Declaration static bool testing::DefaultValue<T>::IsSet() Exists() Declaration static bool testing::DefaultValue<T>::Exists() Get() Declaration static T testing::DefaultValue<T>::Get() Set() Declaration static void testing::DefaultValue<T>::Set(T x) SetFactory() Declaration static void testing::DefaultValue<T>::SetFactory(FactoryFunction factory) Clear() Declaration static void testing::DefaultValue<T>::Clear() IsSet() Declaration static bool testing::DefaultValue<T>::IsSet() Exists() Declaration static bool testing::DefaultValue<T>::Exists() Get() Declaration static T testing::DefaultValue<T>::Get()"
  },
  "api/testing/default-value/3/01-t/01/6/01/4.html": {
    "href": "api/testing/default-value/3/01-t/01/6/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Set() Declaration static void testing::DefaultValue<T&>::Set(T&x) Clear() Declaration static void testing::DefaultValue<T&>::Clear() IsSet() Declaration static bool testing::DefaultValue<T&>::IsSet() Exists() Declaration static bool testing::DefaultValue<T&>::Exists() Get() Declaration static T&testing::DefaultValue<T&>::Get() Set() Declaration static void testing::DefaultValue<T&>::Set(T&x) Clear() Declaration static void testing::DefaultValue<T&>::Clear() IsSet() Declaration static bool testing::DefaultValue<T&>::IsSet() Exists() Declaration static bool testing::DefaultValue<T&>::Exists() Get() Declaration static T&testing::DefaultValue<T&>::Get()"
  },
  "api/testing/default-value/3/01void/01/4.html": {
    "href": "api/testing/default-value/3/01void/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Exists() Declaration static bool testing::DefaultValue<void>::Exists() Get() Declaration static void testing::DefaultValue<void>::Get() Exists() Declaration static bool testing::DefaultValue<void>::Exists() Get() Declaration static void testing::DefaultValue<void>::Get()"
  },
  "api/testing/default-value/factory-value-producer.html": {
    "href": "api/testing/default-value/factory-value-producer.html",
    "title": "Class testing::DefaultValue::FactoryValueProducer | qiotoolkit",
    "keywords": "Class testing::DefaultValue::FactoryValueProducer Inheritance testing::DefaultValue::FactoryValueProducer Inherited Members ~ValueProducer Constructors FactoryValueProducer() Declaration testing::DefaultValue<T>::FactoryValueProducer::FactoryValueProducer(FactoryFunction factory) FactoryValueProducer() Declaration testing::DefaultValue<T>::FactoryValueProducer::FactoryValueProducer(FactoryFunction factory) Methods Produce() Declaration T testing::DefaultValue<T>::FactoryValueProducer::Produce() override Produce() Declaration virtual T testing::DefaultValue<T>::FactoryValueProducer::Produce() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::DefaultValue<T>::FactoryValueProducer::GTEST_DISALLOW_COPY_AND_ASSIGN_(FactoryValueProducer) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::DefaultValue<T>::FactoryValueProducer::GTEST_DISALLOW_COPY_AND_ASSIGN_(FactoryValueProducer)"
  },
  "api/testing/default-value/fixed-value-producer.html": {
    "href": "api/testing/default-value/fixed-value-producer.html",
    "title": "Class testing::DefaultValue::FixedValueProducer | qiotoolkit",
    "keywords": "Class testing::DefaultValue::FixedValueProducer Inheritance testing::DefaultValue::FixedValueProducer Inherited Members ~ValueProducer Constructors FixedValueProducer() Declaration testing::DefaultValue<T>::FixedValueProducer::FixedValueProducer(T value) FixedValueProducer() Declaration testing::DefaultValue<T>::FixedValueProducer::FixedValueProducer(T value) Methods Produce() Declaration T testing::DefaultValue<T>::FixedValueProducer::Produce() override Produce() Declaration virtual T testing::DefaultValue<T>::FixedValueProducer::Produce() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::DefaultValue<T>::FixedValueProducer::GTEST_DISALLOW_COPY_AND_ASSIGN_(FixedValueProducer) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::DefaultValue<T>::FixedValueProducer::GTEST_DISALLOW_COPY_AND_ASSIGN_(FixedValueProducer)"
  },
  "api/testing/default-value/value-producer.html": {
    "href": "api/testing/default-value/value-producer.html",
    "title": "Class testing::DefaultValue::ValueProducer | qiotoolkit",
    "keywords": "Class testing::DefaultValue::ValueProducer Inheritance testing::DefaultValue::ValueProducer Methods ~ValueProducer() Declaration virtual testing::DefaultValue<T>::ValueProducer::~ValueProducer() Produce() Declaration virtual T testing::DefaultValue<T>::ValueProducer::Produce()=0 ~ValueProducer() Declaration virtual testing::DefaultValue<T>::ValueProducer::~ValueProducer() Produce() Declaration virtual T testing::DefaultValue<T>::ValueProducer::Produce()=0"
  },
  "api/testing/empty-test-event-listener.html": {
    "href": "api/testing/empty-test-event-listener.html",
    "title": "Class testing::EmptyTestEventListener | qiotoolkit",
    "keywords": "Class testing::EmptyTestEventListener Inheritance testing::TestEventListener testing::EmptyTestEventListener testing::internal::JsonUnitTestResultPrinter testing::internal::XmlUnitTestResultPrinter Inherited Members ~TestEventListener Methods OnTestProgramStart() Declaration void testing::EmptyTestEventListener::OnTestProgramStart(const UnitTest&) override OnTestIterationStart() Declaration void testing::EmptyTestEventListener::OnTestIterationStart(const UnitTest&, int) override OnEnvironmentsSetUpStart() Declaration void testing::EmptyTestEventListener::OnEnvironmentsSetUpStart(const UnitTest&) override OnEnvironmentsSetUpEnd() Declaration void testing::EmptyTestEventListener::OnEnvironmentsSetUpEnd(const UnitTest&) override OnTestSuiteStart() Declaration void testing::EmptyTestEventListener::OnTestSuiteStart(const TestSuite&) override OnTestCaseStart() Declaration void testing::EmptyTestEventListener::OnTestCaseStart(const TestCase&) override OnTestStart() Declaration void testing::EmptyTestEventListener::OnTestStart(const TestInfo&) override OnTestPartResult() Declaration void testing::EmptyTestEventListener::OnTestPartResult(const TestPartResult&) override OnTestEnd() Declaration void testing::EmptyTestEventListener::OnTestEnd(const TestInfo&) override OnTestSuiteEnd() Declaration void testing::EmptyTestEventListener::OnTestSuiteEnd(const TestSuite&) override OnTestCaseEnd() Declaration void testing::EmptyTestEventListener::OnTestCaseEnd(const TestCase&) override OnEnvironmentsTearDownStart() Declaration void testing::EmptyTestEventListener::OnEnvironmentsTearDownStart(const UnitTest&) override OnEnvironmentsTearDownEnd() Declaration void testing::EmptyTestEventListener::OnEnvironmentsTearDownEnd(const UnitTest&) override OnTestIterationEnd() Declaration void testing::EmptyTestEventListener::OnTestIterationEnd(const UnitTest&, int) override OnTestProgramEnd() Declaration void testing::EmptyTestEventListener::OnTestProgramEnd(const UnitTest&) override OnTestProgramStart() Declaration virtual void testing::EmptyTestEventListener::OnTestProgramStart(const UnitTest&) OnTestIterationStart() Declaration virtual void testing::EmptyTestEventListener::OnTestIterationStart(const UnitTest&, int) OnEnvironmentsSetUpStart() Declaration virtual void testing::EmptyTestEventListener::OnEnvironmentsSetUpStart(const UnitTest&) OnEnvironmentsSetUpEnd() Declaration virtual void testing::EmptyTestEventListener::OnEnvironmentsSetUpEnd(const UnitTest&) OnTestCaseStart() Declaration virtual void testing::EmptyTestEventListener::OnTestCaseStart(const TestCase&) OnTestStart() Declaration virtual void testing::EmptyTestEventListener::OnTestStart(const TestInfo&) OnTestPartResult() Declaration virtual void testing::EmptyTestEventListener::OnTestPartResult(const TestPartResult&) OnTestEnd() Declaration virtual void testing::EmptyTestEventListener::OnTestEnd(const TestInfo&) OnTestCaseEnd() Declaration virtual void testing::EmptyTestEventListener::OnTestCaseEnd(const TestCase&) OnEnvironmentsTearDownStart() Declaration virtual void testing::EmptyTestEventListener::OnEnvironmentsTearDownStart(const UnitTest&) OnEnvironmentsTearDownEnd() Declaration virtual void testing::EmptyTestEventListener::OnEnvironmentsTearDownEnd(const UnitTest&) OnTestIterationEnd() Declaration virtual void testing::EmptyTestEventListener::OnTestIterationEnd(const UnitTest&, int) OnTestProgramEnd() Declaration virtual void testing::EmptyTestEventListener::OnTestProgramEnd(const UnitTest&)"
  },
  "api/testing/environment.html": {
    "href": "api/testing/environment.html",
    "title": "Class testing::Environment | qiotoolkit",
    "keywords": "Class testing::Environment Inheritance testing::Environment Methods ~Environment() Declaration virtual testing::Environment::~Environment() SetUp() Declaration virtual void testing::Environment::SetUp() TearDown() Declaration virtual void testing::Environment::TearDown() ~Environment() Declaration virtual testing::Environment::~Environment() SetUp() Declaration virtual void testing::Environment::SetUp() TearDown() Declaration virtual void testing::Environment::TearDown() Setup() Declaration virtual Setup_should_be_spelled_SetUp* testing::Environment::Setup() Setup() Declaration virtual Setup_should_be_spelled_SetUp* testing::Environment::Setup()"
  },
  "api/testing/environment/setup/should/be/spelled/set-up.html": {
    "href": "api/testing/environment/setup/should/be/spelled/set-up.html",
    "title": "Struct testing::Environment::Setup_should_be_spelled_SetUp | qiotoolkit",
    "keywords": "Struct testing::Environment::Setup_should_be_spelled_SetUp"
  },
  "api/testing/expectation-set.html": {
    "href": "api/testing/expectation-set.html",
    "title": "Class testing::ExpectationSet | qiotoolkit",
    "keywords": "Class testing::ExpectationSet Inheritance testing::ExpectationSet Constructors ExpectationSet() Declaration testing::ExpectationSet::ExpectationSet() ExpectationSet() Declaration testing::ExpectationSet::ExpectationSet(internal::ExpectationBase&exp) ExpectationSet() Declaration testing::ExpectationSet::ExpectationSet(const Expectation&e) Methods operator==() Declaration bool testing::ExpectationSet::operator==(const ExpectationSet&rhs) const operator!=() Declaration bool testing::ExpectationSet::operator!=(const ExpectationSet&rhs) const operator+=() Declaration ExpectationSet&testing::ExpectationSet::operator+=(const Expectation&e) size() Declaration int testing::ExpectationSet::size() const begin() Declaration const_iterator testing::ExpectationSet::begin() const end() Declaration const_iterator testing::ExpectationSet::end() const"
  },
  "api/testing/expectation.html": {
    "href": "api/testing/expectation.html",
    "title": "Class testing::Expectation | qiotoolkit",
    "keywords": "Class testing::Expectation Inheritance testing::Expectation Constructors Expectation() Declaration testing::Expectation::Expectation() Expectation() Declaration testing::Expectation::Expectation(internal::ExpectationBase&exp) Expectation() Declaration testing::Expectation::Expectation(const internal::linked_ptr<internal::ExpectationBase>&expectation_base) Methods ~Expectation() Declaration testing::Expectation::~Expectation() operator==() Declaration bool testing::Expectation::operator==(const Expectation&rhs) const operator!=() Declaration bool testing::Expectation::operator!=(const Expectation&rhs) const expectation_base() Declaration const internal::linked_ptr<internal::ExpectationBase>&testing::Expectation::expectation_base() const"
  },
  "api/testing/expectation/less.html": {
    "href": "api/testing/expectation/less.html",
    "title": "Class testing::Expectation::Less | qiotoolkit",
    "keywords": "Class testing::Expectation::Less Inheritance testing::Expectation::Less Methods operator()() Declaration bool testing::Expectation::Less::operator()(const Expectation&lhs, const Expectation&rhs) const"
  },
  "api/testing/in-sequence.html": {
    "href": "api/testing/in-sequence.html",
    "title": "Class testing::InSequence | qiotoolkit",
    "keywords": "Class testing::InSequence Inheritance testing::InSequence Constructors InSequence() Declaration testing::InSequence::InSequence() Methods ~InSequence() Declaration testing::InSequence::~InSequence() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::InSequence::GTEST_DISALLOW_COPY_AND_ASSIGN_(InSequence)"
  },
  "api/testing/internal/action-adaptor.html": {
    "href": "api/testing/internal/action-adaptor.html",
    "title": "Class testing::internal::ActionAdaptor | qiotoolkit",
    "keywords": "Class testing::internal::ActionAdaptor Inheritance testing::internal::ActionAdaptor Constructors ActionAdaptor() Declaration testing::internal::ActionAdaptor<F1, F2>::ActionAdaptor(const Action<F2>&from) Methods Perform() Declaration virtual Result testing::internal::ActionAdaptor<F1, F2>::Perform(const ArgumentTuple&args) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ActionAdaptor<F1, F2>::GTEST_DISALLOW_ASSIGN_(ActionAdaptor)"
  },
  "api/testing/internal/action-helper.html": {
    "href": "api/testing/internal/action-helper.html",
    "title": "Class testing::internal::ActionHelper | qiotoolkit",
    "keywords": "Class testing::internal::ActionHelper Inheritance testing::internal::ActionHelper Methods Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<A0>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<A0, A1>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<A0, A1, A2>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<A0, A1, A2, A3>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<A0, A1, A2, A3, A4>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<A0, A1, A2, A3, A4, A5>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<A0, A1, A2, A3, A4, A5, A6>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<A0, A1, A2, A3, A4, A5, A6, A7>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::std::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<A0>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<A0, A1>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<A0, A1, A2>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<A0, A1, A2, A3>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<A0, A1, A2, A3, A4>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<A0, A1, A2, A3, A4, A5>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<A0, A1, A2, A3, A4, A5, A6>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<A0, A1, A2, A3, A4, A5, A6, A7>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8>&args) Perform() Declaration static Result testing::internal::ActionHelper<Result, Impl>::Perform(Impl *impl, const ::testing::tuple<A0, A1, A2, A3, A4, A5, A6, A7, A8, A9>&args)"
  },
  "api/testing/internal/action-result-holder.html": {
    "href": "api/testing/internal/action-result-holder.html",
    "title": "Class testing::internal::ActionResultHolder | qiotoolkit",
    "keywords": "Class testing::internal::ActionResultHolder Inheritance testing::internal::UntypedActionResultHolderBase testing::internal::ActionResultHolder Inherited Members ~UntypedActionResultHolderBase Constructors ActionResultHolder() Declaration testing::internal::ActionResultHolder<T>::ActionResultHolder(Wrapper result) Methods Unwrap() Declaration T testing::internal::ActionResultHolder<T>::Unwrap() PrintAsActionResult() Declaration virtual void testing::internal::ActionResultHolder<T>::PrintAsActionResult(::std::ostream *os) const PerformDefaultAction() Declaration static ActionResultHolder* testing::internal::ActionResultHolder<T>::PerformDefaultAction(const FunctionMockerBase<F>*func_mocker, typename RvalueRef<typename Function<F>::ArgumentTuple>::type args, const std::string&call_description) PerformAction() Declaration static ActionResultHolder* testing::internal::ActionResultHolder<T>::PerformAction(const Action<F>&action, typename RvalueRef<typename Function<F>::ArgumentTuple>::type args) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ActionResultHolder<T>::GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionResultHolder)"
  },
  "api/testing/internal/action-result-holder/3/01void/01/4.html": {
    "href": "api/testing/internal/action-result-holder/3/01void/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::UntypedActionResultHolderBase > Inherited Members ~UntypedActionResultHolderBase Methods Unwrap() Declaration void testing::internal::ActionResultHolder<void>::Unwrap() PrintAsActionResult() Declaration virtual void testing::internal::ActionResultHolder<void>::PrintAsActionResult(::std::ostream *) const PerformDefaultAction() Declaration static ActionResultHolder* testing::internal::ActionResultHolder<void>::PerformDefaultAction(const FunctionMockerBase<F>*func_mocker, typename RvalueRef<typename Function<F>::ArgumentTuple>::type args, const std::string&call_description) PerformAction() Declaration static ActionResultHolder* testing::internal::ActionResultHolder<void>::PerformAction(const Action<F>&action, typename RvalueRef<typename Function<F>::ArgumentTuple>::type args) ActionResultHolder() Declaration testing::internal::ActionResultHolder<void>::ActionResultHolder() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ActionResultHolder<void>::GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionResultHolder)"
  },
  "api/testing/internal/add-reference.html": {
    "href": "api/testing/internal/add-reference.html",
    "title": "Struct testing::internal::AddReference | qiotoolkit",
    "keywords": "Struct testing::internal::AddReference"
  },
  "api/testing/internal/add-reference/3/01-t/01/6/01/4.html": {
    "href": "api/testing/internal/add-reference/3/01-t/01/6/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/all-of-matcher-impl.html": {
    "href": "api/testing/internal/all-of-matcher-impl.html",
    "title": "Class testing::internal::AllOfMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::AllOfMatcherImpl Inheritance testing::MatcherInterface testing::internal::AllOfMatcherImpl Inherited Members ~MatcherDescriberInterface Constructors AllOfMatcherImpl() Declaration testing::internal::AllOfMatcherImpl<T>::AllOfMatcherImpl(std::vector<Matcher<T>>matchers) Methods DescribeTo() Declaration virtual void testing::internal::AllOfMatcherImpl<T>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::AllOfMatcherImpl<T>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::AllOfMatcherImpl<T>::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(T) x, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::AllOfMatcherImpl<T>::GTEST_DISALLOW_ASSIGN_(AllOfMatcherImpl)"
  },
  "api/testing/internal/all-of-result1.html": {
    "href": "api/testing/internal/all-of-result1.html",
    "title": "Struct testing::internal::AllOfResult1 | qiotoolkit",
    "keywords": "Struct testing::internal::AllOfResult1"
  },
  "api/testing/internal/all-of-result10.html": {
    "href": "api/testing/internal/all-of-result10.html",
    "title": "Struct testing::internal::AllOfResult10 | qiotoolkit",
    "keywords": "Struct testing::internal::AllOfResult10"
  },
  "api/testing/internal/all-of-result2.html": {
    "href": "api/testing/internal/all-of-result2.html",
    "title": "Struct testing::internal::AllOfResult2 | qiotoolkit",
    "keywords": "Struct testing::internal::AllOfResult2"
  },
  "api/testing/internal/all-of-result3.html": {
    "href": "api/testing/internal/all-of-result3.html",
    "title": "Struct testing::internal::AllOfResult3 | qiotoolkit",
    "keywords": "Struct testing::internal::AllOfResult3"
  },
  "api/testing/internal/all-of-result4.html": {
    "href": "api/testing/internal/all-of-result4.html",
    "title": "Struct testing::internal::AllOfResult4 | qiotoolkit",
    "keywords": "Struct testing::internal::AllOfResult4"
  },
  "api/testing/internal/all-of-result5.html": {
    "href": "api/testing/internal/all-of-result5.html",
    "title": "Struct testing::internal::AllOfResult5 | qiotoolkit",
    "keywords": "Struct testing::internal::AllOfResult5"
  },
  "api/testing/internal/all-of-result6.html": {
    "href": "api/testing/internal/all-of-result6.html",
    "title": "Struct testing::internal::AllOfResult6 | qiotoolkit",
    "keywords": "Struct testing::internal::AllOfResult6"
  },
  "api/testing/internal/all-of-result7.html": {
    "href": "api/testing/internal/all-of-result7.html",
    "title": "Struct testing::internal::AllOfResult7 | qiotoolkit",
    "keywords": "Struct testing::internal::AllOfResult7"
  },
  "api/testing/internal/all-of-result8.html": {
    "href": "api/testing/internal/all-of-result8.html",
    "title": "Struct testing::internal::AllOfResult8 | qiotoolkit",
    "keywords": "Struct testing::internal::AllOfResult8"
  },
  "api/testing/internal/all-of-result9.html": {
    "href": "api/testing/internal/all-of-result9.html",
    "title": "Struct testing::internal::AllOfResult9 | qiotoolkit",
    "keywords": "Struct testing::internal::AllOfResult9"
  },
  "api/testing/internal/any-eq.html": {
    "href": "api/testing/internal/any-eq.html",
    "title": "Struct testing::internal::AnyEq | qiotoolkit",
    "keywords": "Struct testing::internal::AnyEq Methods operator()() Declaration bool testing::internal::AnyEq::operator()(const A&a, const B&b) const"
  },
  "api/testing/internal/any-ge.html": {
    "href": "api/testing/internal/any-ge.html",
    "title": "Struct testing::internal::AnyGe | qiotoolkit",
    "keywords": "Struct testing::internal::AnyGe Methods operator()() Declaration bool testing::internal::AnyGe::operator()(const A&a, const B&b) const"
  },
  "api/testing/internal/any-gt.html": {
    "href": "api/testing/internal/any-gt.html",
    "title": "Struct testing::internal::AnyGt | qiotoolkit",
    "keywords": "Struct testing::internal::AnyGt Methods operator()() Declaration bool testing::internal::AnyGt::operator()(const A&a, const B&b) const"
  },
  "api/testing/internal/any-le.html": {
    "href": "api/testing/internal/any-le.html",
    "title": "Struct testing::internal::AnyLe | qiotoolkit",
    "keywords": "Struct testing::internal::AnyLe Methods operator()() Declaration bool testing::internal::AnyLe::operator()(const A&a, const B&b) const"
  },
  "api/testing/internal/any-lt.html": {
    "href": "api/testing/internal/any-lt.html",
    "title": "Struct testing::internal::AnyLt | qiotoolkit",
    "keywords": "Struct testing::internal::AnyLt Methods operator()() Declaration bool testing::internal::AnyLt::operator()(const A&a, const B&b) const"
  },
  "api/testing/internal/any-matcher-impl.html": {
    "href": "api/testing/internal/any-matcher-impl.html",
    "title": "Class testing::internal::AnyMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::AnyMatcherImpl Inheritance testing::MatcherInterface testing::internal::AnyMatcherImpl Inherited Members ~MatcherDescriberInterface Methods MatchAndExplain() Declaration virtual bool testing::internal::AnyMatcherImpl<T>::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(T), MatchResultListener *) const DescribeTo() Declaration virtual void testing::internal::AnyMatcherImpl<T>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::AnyMatcherImpl<T>::DescribeNegationTo(::std::ostream *os) const"
  },
  "api/testing/internal/any-ne.html": {
    "href": "api/testing/internal/any-ne.html",
    "title": "Struct testing::internal::AnyNe | qiotoolkit",
    "keywords": "Struct testing::internal::AnyNe Methods operator()() Declaration bool testing::internal::AnyNe::operator()(const A&a, const B&b) const"
  },
  "api/testing/internal/any-of-matcher-impl.html": {
    "href": "api/testing/internal/any-of-matcher-impl.html",
    "title": "Class testing::internal::AnyOfMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::AnyOfMatcherImpl Inheritance testing::MatcherInterface testing::internal::AnyOfMatcherImpl Inherited Members ~MatcherDescriberInterface Constructors AnyOfMatcherImpl() Declaration testing::internal::AnyOfMatcherImpl<T>::AnyOfMatcherImpl(std::vector<Matcher<T>>matchers) Methods DescribeTo() Declaration virtual void testing::internal::AnyOfMatcherImpl<T>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::AnyOfMatcherImpl<T>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::AnyOfMatcherImpl<T>::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(T) x, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::AnyOfMatcherImpl<T>::GTEST_DISALLOW_ASSIGN_(AnyOfMatcherImpl)"
  },
  "api/testing/internal/any-of-result1.html": {
    "href": "api/testing/internal/any-of-result1.html",
    "title": "Struct testing::internal::AnyOfResult1 | qiotoolkit",
    "keywords": "Struct testing::internal::AnyOfResult1"
  },
  "api/testing/internal/any-of-result10.html": {
    "href": "api/testing/internal/any-of-result10.html",
    "title": "Struct testing::internal::AnyOfResult10 | qiotoolkit",
    "keywords": "Struct testing::internal::AnyOfResult10"
  },
  "api/testing/internal/any-of-result2.html": {
    "href": "api/testing/internal/any-of-result2.html",
    "title": "Struct testing::internal::AnyOfResult2 | qiotoolkit",
    "keywords": "Struct testing::internal::AnyOfResult2"
  },
  "api/testing/internal/any-of-result3.html": {
    "href": "api/testing/internal/any-of-result3.html",
    "title": "Struct testing::internal::AnyOfResult3 | qiotoolkit",
    "keywords": "Struct testing::internal::AnyOfResult3"
  },
  "api/testing/internal/any-of-result4.html": {
    "href": "api/testing/internal/any-of-result4.html",
    "title": "Struct testing::internal::AnyOfResult4 | qiotoolkit",
    "keywords": "Struct testing::internal::AnyOfResult4"
  },
  "api/testing/internal/any-of-result5.html": {
    "href": "api/testing/internal/any-of-result5.html",
    "title": "Struct testing::internal::AnyOfResult5 | qiotoolkit",
    "keywords": "Struct testing::internal::AnyOfResult5"
  },
  "api/testing/internal/any-of-result6.html": {
    "href": "api/testing/internal/any-of-result6.html",
    "title": "Struct testing::internal::AnyOfResult6 | qiotoolkit",
    "keywords": "Struct testing::internal::AnyOfResult6"
  },
  "api/testing/internal/any-of-result7.html": {
    "href": "api/testing/internal/any-of-result7.html",
    "title": "Struct testing::internal::AnyOfResult7 | qiotoolkit",
    "keywords": "Struct testing::internal::AnyOfResult7"
  },
  "api/testing/internal/any-of-result8.html": {
    "href": "api/testing/internal/any-of-result8.html",
    "title": "Struct testing::internal::AnyOfResult8 | qiotoolkit",
    "keywords": "Struct testing::internal::AnyOfResult8"
  },
  "api/testing/internal/any-of-result9.html": {
    "href": "api/testing/internal/any-of-result9.html",
    "title": "Struct testing::internal::AnyOfResult9 | qiotoolkit",
    "keywords": "Struct testing::internal::AnyOfResult9"
  },
  "api/testing/internal/any/cast/matcher/any-cast-matcher.html": {
    "href": "api/testing/internal/any/cast/matcher/any-cast-matcher.html",
    "title": "Class testing::internal::any_cast_matcher::AnyCastMatcher | qiotoolkit",
    "keywords": "Class testing::internal::any_cast_matcher::AnyCastMatcher Inheritance testing::internal::any_cast_matcher::AnyCastMatcher Constructors AnyCastMatcher() Declaration testing::internal::any_cast_matcher::AnyCastMatcher<T>::AnyCastMatcher(const ::testing::Matcher<const T&>&matcher) Methods MatchAndExplain() Declaration bool testing::internal::any_cast_matcher::AnyCastMatcher<T>::MatchAndExplain(const AnyType&value, ::testing::MatchResultListener *listener) const DescribeTo() Declaration void testing::internal::any_cast_matcher::AnyCastMatcher<T>::DescribeTo(std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::any_cast_matcher::AnyCastMatcher<T>::DescribeNegationTo(std::ostream *os) const GetTypeName() Declaration static std::string testing::internal::any_cast_matcher::AnyCastMatcher<T>::GetTypeName()"
  },
  "api/testing/internal/anything-matcher.html": {
    "href": "api/testing/internal/anything-matcher.html",
    "title": "Class testing::internal::AnythingMatcher | qiotoolkit",
    "keywords": "Class testing::internal::AnythingMatcher Inheritance testing::internal::AnythingMatcher Methods >() Declaration testing::internal::AnythingMatcher::operator Matcher<T>() const >() Declaration testing::internal::AnythingMatcher::operator Matcher<T>() const >() Declaration testing::internal::AnythingMatcher::operator Matcher<T>() const >() Declaration testing::internal::AnythingMatcher::operator Matcher<T>() const"
  },
  "api/testing/internal/args-matcher-impl.html": {
    "href": "api/testing/internal/args-matcher-impl.html",
    "title": "Class testing::internal::ArgsMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::ArgsMatcherImpl Inheritance testing::MatcherInterface testing::internal::ArgsMatcherImpl Inherited Members ~MatcherDescriberInterface Constructors ArgsMatcherImpl() Declaration testing::internal::ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::ArgsMatcherImpl(const InnerMatcher&inner_matcher) Methods GTEST_REMOVE_REFERENCE_AND_CONST_() Declaration typedef testing::internal::ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::GTEST_REMOVE_REFERENCE_AND_CONST_(ArgsTuple) RawArgsTuple MatchAndExplain() Declaration virtual bool testing::internal::ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::MatchAndExplain(ArgsTuple args, MatchResultListener *listener) const DescribeTo() Declaration virtual void testing::internal::ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::DescribeNegationTo(::std::ostream *os) const GetSelectedArgs() Declaration static SelectedArgs testing::internal::ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::GetSelectedArgs(ArgsTuple args) PrintIndices() Declaration static void testing::internal::ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::PrintIndices(::std::ostream *os) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::GTEST_DISALLOW_ASSIGN_(ArgsMatcherImpl)"
  },
  "api/testing/internal/args-matcher.html": {
    "href": "api/testing/internal/args-matcher.html",
    "title": "Class testing::internal::ArgsMatcher | qiotoolkit",
    "keywords": "Class testing::internal::ArgsMatcher Inheritance testing::internal::ArgsMatcher Constructors ArgsMatcher() Declaration testing::internal::ArgsMatcher<InnerMatcher, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::ArgsMatcher(const InnerMatcher&inner_matcher) Methods >() Declaration testing::internal::ArgsMatcher<InnerMatcher, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::operator Matcher<ArgsTuple>() const >() Declaration testing::internal::ArgsMatcher<InnerMatcher, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::operator Matcher<ArgsTuple>() const >() Declaration testing::internal::ArgsMatcher<InnerMatcher, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::operator Matcher<ArgsTuple>() const >() Declaration testing::internal::ArgsMatcher<InnerMatcher, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::operator Matcher<ArgsTuple>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ArgsMatcher<InnerMatcher, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::GTEST_DISALLOW_ASSIGN_(ArgsMatcher)"
  },
  "api/testing/internal/assert-helper.html": {
    "href": "api/testing/internal/assert-helper.html",
    "title": "Class testing::internal::AssertHelper | qiotoolkit",
    "keywords": "Class testing::internal::AssertHelper Inheritance testing::internal::AssertHelper Constructors AssertHelper() Declaration testing::internal::AssertHelper::AssertHelper(TestPartResult::Type type, const char *file, int line, const char *message) AssertHelper() Declaration testing::internal::AssertHelper::AssertHelper(TestPartResult::Type type, const char *file, int line, const char *message) Methods ~AssertHelper() Declaration testing::internal::AssertHelper::~AssertHelper() operator=() Declaration void testing::internal::AssertHelper::operator=(const Message&message) const ~AssertHelper() Declaration testing::internal::AssertHelper::~AssertHelper() operator=() Declaration void testing::internal::AssertHelper::operator=(const Message&message) const GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::AssertHelper::GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::AssertHelper::GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper)"
  },
  "api/testing/internal/assert-helper/assert-helper-data.html": {
    "href": "api/testing/internal/assert-helper/assert-helper-data.html",
    "title": "Struct testing::internal::AssertHelper::AssertHelperData | qiotoolkit",
    "keywords": "Struct testing::internal::AssertHelper::AssertHelperData Constructors AssertHelperData() Declaration testing::internal::AssertHelper::AssertHelperData::AssertHelperData(TestPartResult::Type t, const char *srcfile, int line_num, const char *msg) AssertHelperData() Declaration testing::internal::AssertHelper::AssertHelperData::AssertHelperData(TestPartResult::Type t, const char *srcfile, int line_num, const char *msg) Methods GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::AssertHelper::AssertHelperData::GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelperData) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::AssertHelper::AssertHelperData::GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelperData)"
  },
  "api/testing/internal/assign-action.html": {
    "href": "api/testing/internal/assign-action.html",
    "title": "Class testing::internal::AssignAction | qiotoolkit",
    "keywords": "Class testing::internal::AssignAction Inheritance testing::internal::AssignAction Constructors AssignAction() Declaration testing::internal::AssignAction<T1, T2>::AssignAction(T1 *ptr, T2 value) AssignAction() Declaration testing::internal::AssignAction<T1, T2>::AssignAction(T1 *ptr, T2 value) Methods Perform() Declaration void testing::internal::AssignAction<T1, T2>::Perform(const ArgumentTuple&) const Perform() Declaration void testing::internal::AssignAction<T1, T2>::Perform(const ArgumentTuple&) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::AssignAction<T1, T2>::GTEST_DISALLOW_ASSIGN_(AssignAction) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::AssignAction<T1, T2>::GTEST_DISALLOW_ASSIGN_(AssignAction)"
  },
  "api/testing/internal/begin-end-distance-is-matcher.html": {
    "href": "api/testing/internal/begin-end-distance-is-matcher.html",
    "title": "Class testing::internal::BeginEndDistanceIsMatcher | qiotoolkit",
    "keywords": "Class testing::internal::BeginEndDistanceIsMatcher Inheritance testing::internal::BeginEndDistanceIsMatcher Constructors BeginEndDistanceIsMatcher() Declaration testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::BeginEndDistanceIsMatcher(const DistanceMatcher&distance_matcher) Methods >() Declaration testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::operator Matcher<Container>() const >() Declaration testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::operator Matcher<Container>() const >() Declaration testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::operator Matcher<Container>() const >() Declaration testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::operator Matcher<Container>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::GTEST_DISALLOW_ASSIGN_(BeginEndDistanceIsMatcher)"
  },
  "api/testing/internal/begin-end-distance-is-matcher/impl.html": {
    "href": "api/testing/internal/begin-end-distance-is-matcher/impl.html",
    "title": "Class testing::internal::BeginEndDistanceIsMatcher::Impl | qiotoolkit",
    "keywords": "Class testing::internal::BeginEndDistanceIsMatcher::Impl Inheritance testing::MatcherInterface testing::internal::BeginEndDistanceIsMatcher::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::Impl<Container>::Impl(const DistanceMatcher&distance_matcher) Methods DescribeTo() Declaration virtual void testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::Impl<Container>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::Impl<Container>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::Impl<Container>::MatchAndExplain(Container container, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::BeginEndDistanceIsMatcher<DistanceMatcher>::Impl<Container>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/bool/constant.html": {
    "href": "api/testing/internal/bool/constant.html",
    "title": "Struct testing::internal::bool_constant | qiotoolkit",
    "keywords": "Struct testing::internal::bool_constant"
  },
  "api/testing/internal/boolean-constant.html": {
    "href": "api/testing/internal/boolean-constant.html",
    "title": "Struct testing::internal::BooleanConstant | qiotoolkit",
    "keywords": "Struct testing::internal::BooleanConstant"
  },
  "api/testing/internal/both-of-matcher.html": {
    "href": "api/testing/internal/both-of-matcher.html",
    "title": "Class testing::internal::BothOfMatcher | qiotoolkit",
    "keywords": "Class testing::internal::BothOfMatcher Inheritance testing::internal::BothOfMatcher Constructors BothOfMatcher() Declaration testing::internal::BothOfMatcher<Matcher1, Matcher2>::BothOfMatcher(Matcher1 matcher1, Matcher2 matcher2) Methods >() Declaration testing::internal::BothOfMatcher<Matcher1, Matcher2>::operator Matcher<T>() const >() Declaration testing::internal::BothOfMatcher<Matcher1, Matcher2>::operator Matcher<T>() const >() Declaration testing::internal::BothOfMatcher<Matcher1, Matcher2>::operator Matcher<T>() const >() Declaration testing::internal::BothOfMatcher<Matcher1, Matcher2>::operator Matcher<T>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::BothOfMatcher<Matcher1, Matcher2>::GTEST_DISALLOW_ASSIGN_(BothOfMatcher)"
  },
  "api/testing/internal/bound-second-matcher.html": {
    "href": "api/testing/internal/bound-second-matcher.html",
    "title": "Class testing::internal::BoundSecondMatcher | qiotoolkit",
    "keywords": "Class testing::internal::BoundSecondMatcher Inheritance testing::internal::BoundSecondMatcher Constructors BoundSecondMatcher() Declaration testing::internal::BoundSecondMatcher<Tuple2Matcher, Second>::BoundSecondMatcher(const Tuple2Matcher&tm, const Second&second) Methods >() Declaration testing::internal::BoundSecondMatcher<Tuple2Matcher, Second>::operator Matcher<T>() const >() Declaration testing::internal::BoundSecondMatcher<Tuple2Matcher, Second>::operator Matcher<T>() const >() Declaration testing::internal::BoundSecondMatcher<Tuple2Matcher, Second>::operator Matcher<T>() const >() Declaration testing::internal::BoundSecondMatcher<Tuple2Matcher, Second>::operator Matcher<T>() const operator=() Declaration void testing::internal::BoundSecondMatcher<Tuple2Matcher, Second>::operator=(const BoundSecondMatcher&)"
  },
  "api/testing/internal/bound-second-matcher/impl.html": {
    "href": "api/testing/internal/bound-second-matcher/impl.html",
    "title": "Class testing::internal::BoundSecondMatcher::Impl | qiotoolkit",
    "keywords": "Class testing::internal::BoundSecondMatcher::Impl Inheritance testing::MatcherInterface testing::internal::BoundSecondMatcher::Impl Inherited Members DescribeNegationTo ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::BoundSecondMatcher<Tuple2Matcher, Second>::Impl<T>::Impl(const Tuple2Matcher&tm, const Second&second) Methods DescribeTo() Declaration virtual void testing::internal::BoundSecondMatcher<Tuple2Matcher, Second>::Impl<T>::DescribeTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::BoundSecondMatcher<Tuple2Matcher, Second>::Impl<T>::MatchAndExplain(T x, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::BoundSecondMatcher<Tuple2Matcher, Second>::Impl<T>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/built-in-default-value-getter.html": {
    "href": "api/testing/internal/built-in-default-value-getter.html",
    "title": "Struct testing::internal::BuiltInDefaultValueGetter | qiotoolkit",
    "keywords": "Struct testing::internal::BuiltInDefaultValueGetter Methods Get() Declaration static T testing::internal::BuiltInDefaultValueGetter<T, kDefaultConstructible>::Get() Get() Declaration static T testing::internal::BuiltInDefaultValueGetter<T, kDefaultConstructible>::Get()"
  },
  "api/testing/internal/built-in-default-value-getter/3/01-t/00/01false/01/4.html": {
    "href": "api/testing/internal/built-in-default-value-getter/3/01-t/00/01false/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods Get() Declaration static T testing::internal::BuiltInDefaultValueGetter<T, false>::Get() Get() Declaration static T testing::internal::BuiltInDefaultValueGetter<T, false>::Get()"
  },
  "api/testing/internal/built-in-default-value.html": {
    "href": "api/testing/internal/built-in-default-value.html",
    "title": "Class testing::internal::BuiltInDefaultValue | qiotoolkit",
    "keywords": "Class testing::internal::BuiltInDefaultValue Inheritance testing::internal::BuiltInDefaultValue Methods Exists() Declaration static bool testing::internal::BuiltInDefaultValue<T>::Exists() Get() Declaration static T testing::internal::BuiltInDefaultValue<T>::Get() Exists() Declaration static bool testing::internal::BuiltInDefaultValue<T>::Exists() Get() Declaration static T testing::internal::BuiltInDefaultValue<T>::Get()"
  },
  "api/testing/internal/built-in-default-value/3/01-t/01/5/01/4.html": {
    "href": "api/testing/internal/built-in-default-value/3/01-t/01/5/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Exists() Declaration static bool testing::internal::BuiltInDefaultValue<T *>::Exists() Get() Declaration static T* testing::internal::BuiltInDefaultValue<T *>::Get() Exists() Declaration static bool testing::internal::BuiltInDefaultValue<T *>::Exists() Get() Declaration static T* testing::internal::BuiltInDefaultValue<T *>::Get()"
  },
  "api/testing/internal/built-in-default-value/3/01const/01-t/01/4.html": {
    "href": "api/testing/internal/built-in-default-value/3/01const/01-t/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Exists() Declaration static bool testing::internal::BuiltInDefaultValue<const T>::Exists() Get() Declaration static T testing::internal::BuiltInDefaultValue<const T>::Get() Exists() Declaration static bool testing::internal::BuiltInDefaultValue<const T>::Exists() Get() Declaration static T testing::internal::BuiltInDefaultValue<const T>::Get()"
  },
  "api/testing/internal/by-move-wrapper.html": {
    "href": "api/testing/internal/by-move-wrapper.html",
    "title": "Struct testing::internal::ByMoveWrapper | qiotoolkit",
    "keywords": "Struct testing::internal::ByMoveWrapper Constructors ByMoveWrapper() Declaration testing::internal::ByMoveWrapper<T>::ByMoveWrapper(T value) ByMoveWrapper() Declaration testing::internal::ByMoveWrapper<T>::ByMoveWrapper(T value)"
  },
  "api/testing/internal/callable-traits.html": {
    "href": "api/testing/internal/callable-traits.html",
    "title": "Struct testing::internal::CallableTraits | qiotoolkit",
    "keywords": "Struct testing::internal::CallableTraits Methods CheckIsValid() Declaration static void testing::internal::CallableTraits<Functor>::CheckIsValid(Functor) Invoke() Declaration static ResultType testing::internal::CallableTraits<Functor>::Invoke(Functor f, T arg)"
  },
  "api/testing/internal/callable-traits/3/01-res-type/07/5/08/07-arg-type/08/4.html": {
    "href": "api/testing/internal/callable-traits/3/01-res-type/07/5/08/07-arg-type/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods CheckIsValid() Declaration static void testing::internal::CallableTraits<ResType(*)(ArgType)>::CheckIsValid(ResType(*f)(ArgType)) Invoke() Declaration static ResType testing::internal::CallableTraits<ResType(*)(ArgType)>::Invoke(ResType(*f)(ArgType), T arg)"
  },
  "api/testing/internal/cartesian-product-generator.html": {
    "href": "api/testing/internal/cartesian-product-generator.html",
    "title": "Class testing::internal::CartesianProductGenerator | qiotoolkit",
    "keywords": "Class testing::internal::CartesianProductGenerator Inheritance testing::internal::ParamGeneratorInterface testing::internal::CartesianProductGenerator Inherited Members ~ParamGeneratorInterface Begin End Constructors CartesianProductGenerator() Declaration testing::internal::CartesianProductGenerator<T>::CartesianProductGenerator(const std::tuple<ParamGenerator<T>...>&g) Methods ~CartesianProductGenerator() Declaration testing::internal::CartesianProductGenerator<T>::~CartesianProductGenerator() override Begin() Declaration ParamIteratorInterface<ParamType>* testing::internal::CartesianProductGenerator<T>::Begin() const override End() Declaration ParamIteratorInterface<ParamType>* testing::internal::CartesianProductGenerator<T>::End() const override"
  },
  "api/testing/internal/cartesian-product-generator/iterator-impl.html": {
    "href": "api/testing/internal/cartesian-product-generator/iterator-impl.html",
    "title": "Class testing::internal::CartesianProductGenerator::IteratorImpl | qiotoolkit",
    "keywords": "Class testing::internal::CartesianProductGenerator::IteratorImpl Inheritance testing::internal::CartesianProductGenerator::IteratorImpl"
  },
  "api/testing/internal/cartesian-product-generator/iterator-impl/3/01-index-sequence/3/01-i/8/8/8/01/4/01/4.html": {
    "href": "api/testing/internal/cartesian-product-generator/iterator-impl/3/01-index-sequence/3/01-i/8/8/8/01/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::ParamIteratorInterface > Inherited Members BaseGenerator Clone Equals ~ParamIteratorInterface Current Methods IteratorImpl() Declaration testing::internal::CartesianProductGenerator<T>::IteratorImpl<IndexSequence<I...>>::IteratorImpl(const ParamGeneratorInterface<ParamType>*base, const std::tuple<ParamGenerator<T>...>&generators, bool is_end) ~IteratorImpl() Declaration testing::internal::CartesianProductGenerator<T>::IteratorImpl<IndexSequence<I...>>::~IteratorImpl() override BaseGenerator() Declaration const ParamGeneratorInterface<ParamType>* testing::internal::CartesianProductGenerator<T>::IteratorImpl<IndexSequence<I...>>::BaseGenerator() const override Advance() Declaration void testing::internal::CartesianProductGenerator<T>::IteratorImpl<IndexSequence<I...>>::Advance() override Clone() Declaration ParamIteratorInterface<ParamType>* testing::internal::CartesianProductGenerator<T>::IteratorImpl<IndexSequence<I...>>::Clone() const override Current() Declaration const ParamType* testing::internal::CartesianProductGenerator<T>::IteratorImpl<IndexSequence<I...>>::Current() const override Equals() Declaration bool testing::internal::CartesianProductGenerator<T>::IteratorImpl<IndexSequence<I...>>::Equals(const ParamIteratorInterface<ParamType>&other) const override AdvanceIfEnd() Declaration void testing::internal::CartesianProductGenerator<T>::IteratorImpl<IndexSequence<I...>>::AdvanceIfEnd() ComputeCurrentValue() Declaration void testing::internal::CartesianProductGenerator<T>::IteratorImpl<IndexSequence<I...>>::ComputeCurrentValue() AtEnd() Declaration bool testing::internal::CartesianProductGenerator<T>::IteratorImpl<IndexSequence<I...>>::AtEnd() const"
  },
  "api/testing/internal/cartesian-product-holder.html": {
    "href": "api/testing/internal/cartesian-product-holder.html",
    "title": "Class testing::internal::CartesianProductHolder | qiotoolkit",
    "keywords": "Class testing::internal::CartesianProductHolder Inheritance testing::internal::CartesianProductHolder Constructors CartesianProductHolder() Declaration testing::internal::CartesianProductHolder<Gen>::CartesianProductHolder(const Gen&... g) Methods >() Declaration testing::internal::CartesianProductHolder<Gen>::operator ParamGenerator<::std::tuple<T...>>() const >() Declaration testing::internal::CartesianProductHolder<Gen>::operator ParamGenerator<::std::tuple<T...>>() const >() Declaration testing::internal::CartesianProductHolder<Gen>::operator ParamGenerator<::std::tuple<T...>>() const >() Declaration testing::internal::CartesianProductHolder<Gen>::operator ParamGenerator<::std::tuple<T...>>() const >() Declaration testing::internal::CartesianProductHolder<Gen>::operator ParamGenerator<::std::tuple<T...>>() const >() Declaration testing::internal::CartesianProductHolder<Gen>::operator ParamGenerator<::std::tuple<T...>>() const >() Declaration testing::internal::CartesianProductHolder<Gen>::operator ParamGenerator<::std::tuple<T...>>() const"
  },
  "api/testing/internal/cast-and-append-transform.html": {
    "href": "api/testing/internal/cast-and-append-transform.html",
    "title": "Struct testing::internal::CastAndAppendTransform | qiotoolkit",
    "keywords": "Struct testing::internal::CastAndAppendTransform Methods operator()() Declaration Matcher<Target>testing::internal::CastAndAppendTransform<Target>::operator()(const Arg&a) const"
  },
  "api/testing/internal/code-location.html": {
    "href": "api/testing/internal/code-location.html",
    "title": "Struct testing::internal::CodeLocation | qiotoolkit",
    "keywords": "Struct testing::internal::CodeLocation Constructors CodeLocation() Declaration testing::internal::CodeLocation::CodeLocation(const std::string&a_file, int a_line) CodeLocation() Declaration testing::internal::CodeLocation::CodeLocation(const std::string&a_file, int a_line)"
  },
  "api/testing/internal/comparison-base.html": {
    "href": "api/testing/internal/comparison-base.html",
    "title": "Class testing::internal::ComparisonBase | qiotoolkit",
    "keywords": "Class testing::internal::ComparisonBase Inheritance testing::internal::ComparisonBase Constructors ComparisonBase() Declaration testing::internal::ComparisonBase<D, Rhs, Op>::ComparisonBase(const Rhs&rhs) Methods >() Declaration testing::internal::ComparisonBase<D, Rhs, Op>::operator Matcher<Lhs>() const >() Declaration testing::internal::ComparisonBase<D, Rhs, Op>::operator Matcher<Lhs>() const >() Declaration testing::internal::ComparisonBase<D, Rhs, Op>::operator Matcher<Lhs>() const >() Declaration testing::internal::ComparisonBase<D, Rhs, Op>::operator Matcher<Lhs>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ComparisonBase<D, Rhs, Op>::GTEST_DISALLOW_ASSIGN_(ComparisonBase)"
  },
  "api/testing/internal/comparison-base/impl.html": {
    "href": "api/testing/internal/comparison-base/impl.html",
    "title": "Class testing::internal::ComparisonBase::Impl | qiotoolkit",
    "keywords": "Class testing::internal::ComparisonBase::Impl Inheritance testing::MatcherInterface testing::internal::ComparisonBase::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::ComparisonBase<D, Rhs, Op>::Impl<Lhs>::Impl(const Rhs&rhs) Methods MatchAndExplain() Declaration virtual bool testing::internal::ComparisonBase<D, Rhs, Op>::Impl<Lhs>::MatchAndExplain(Lhs lhs, MatchResultListener *) const DescribeTo() Declaration virtual void testing::internal::ComparisonBase<D, Rhs, Op>::Impl<Lhs>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::ComparisonBase<D, Rhs, Op>::Impl<Lhs>::DescribeNegationTo(::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ComparisonBase<D, Rhs, Op>::Impl<Lhs>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/compile-assert-types-equal.html": {
    "href": "api/testing/internal/compile-assert-types-equal.html",
    "title": "Struct testing::internal::CompileAssertTypesEqual | qiotoolkit",
    "keywords": "Struct testing::internal::CompileAssertTypesEqual"
  },
  "api/testing/internal/compile-assert-types-equal/3/01-t/00/01-t/01/4.html": {
    "href": "api/testing/internal/compile-assert-types-equal/3/01-t/00/01-t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/compile-assert.html": {
    "href": "api/testing/internal/compile-assert.html",
    "title": "Struct testing::internal::CompileAssert | qiotoolkit",
    "keywords": "Struct testing::internal::CompileAssert"
  },
  "api/testing/internal/const-char-ptr.html": {
    "href": "api/testing/internal/const-char-ptr.html",
    "title": "Struct testing::internal::ConstCharPtr | qiotoolkit",
    "keywords": "Struct testing::internal::ConstCharPtr Constructors ConstCharPtr() Declaration testing::internal::ConstCharPtr::ConstCharPtr(const char *str) ConstCharPtr() Declaration testing::internal::ConstCharPtr::ConstCharPtr(const char *str) Methods operator bool() Declaration testing::internal::ConstCharPtr::operator bool() const operator bool() Declaration testing::internal::ConstCharPtr::operator bool() const"
  },
  "api/testing/internal/const-ref.html": {
    "href": "api/testing/internal/const-ref.html",
    "title": "Struct testing::internal::ConstRef | qiotoolkit",
    "keywords": "Struct testing::internal::ConstRef"
  },
  "api/testing/internal/const-ref/3/01-t/01/6/01/4.html": {
    "href": "api/testing/internal/const-ref/3/01-t/01/6/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/container-eq-matcher.html": {
    "href": "api/testing/internal/container-eq-matcher.html",
    "title": "Class testing::internal::ContainerEqMatcher | qiotoolkit",
    "keywords": "Class testing::internal::ContainerEqMatcher Inheritance testing::internal::ContainerEqMatcher Constructors ContainerEqMatcher() Declaration testing::internal::ContainerEqMatcher<Container>::ContainerEqMatcher(const Container&expected) Methods DescribeTo() Declaration void testing::internal::ContainerEqMatcher<Container>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::ContainerEqMatcher<Container>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration bool testing::internal::ContainerEqMatcher<Container>::MatchAndExplain(const LhsContainer&lhs, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ContainerEqMatcher<Container>::GTEST_DISALLOW_ASSIGN_(ContainerEqMatcher)"
  },
  "api/testing/internal/contains-matcher-impl.html": {
    "href": "api/testing/internal/contains-matcher-impl.html",
    "title": "Class testing::internal::ContainsMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::ContainsMatcherImpl Inheritance testing::internal::QuantifierMatcherImpl testing::internal::ContainsMatcherImpl Inherited Members ~MatcherDescriberInterface GTEST_REMOVE_REFERENCE_AND_CONST_ MatchAndExplainImpl GTEST_DISALLOW_ASSIGN_ QuantifierMatcherImpl Constructors ContainsMatcherImpl() Declaration testing::internal::ContainsMatcherImpl<Container>::ContainsMatcherImpl(InnerMatcher inner_matcher) Methods DescribeTo() Declaration virtual void testing::internal::ContainsMatcherImpl<Container>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::ContainsMatcherImpl<Container>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::ContainsMatcherImpl<Container>::MatchAndExplain(Container container, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ContainsMatcherImpl<Container>::GTEST_DISALLOW_ASSIGN_(ContainsMatcherImpl)"
  },
  "api/testing/internal/contains-matcher.html": {
    "href": "api/testing/internal/contains-matcher.html",
    "title": "Class testing::internal::ContainsMatcher | qiotoolkit",
    "keywords": "Class testing::internal::ContainsMatcher Inheritance testing::internal::ContainsMatcher Constructors ContainsMatcher() Declaration testing::internal::ContainsMatcher<M>::ContainsMatcher(M m) Methods >() Declaration testing::internal::ContainsMatcher<M>::operator Matcher<Container>() const >() Declaration testing::internal::ContainsMatcher<M>::operator Matcher<Container>() const >() Declaration testing::internal::ContainsMatcher<M>::operator Matcher<Container>() const >() Declaration testing::internal::ContainsMatcher<M>::operator Matcher<Container>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ContainsMatcher<M>::GTEST_DISALLOW_ASSIGN_(ContainsMatcher)"
  },
  "api/testing/internal/decay-array.html": {
    "href": "api/testing/internal/decay-array.html",
    "title": "Struct testing::internal::DecayArray | qiotoolkit",
    "keywords": "Struct testing::internal::DecayArray"
  },
  "api/testing/internal/decay-array/3/01-t/0f-n/0e/4.html": {
    "href": "api/testing/internal/decay-array/3/01-t/0f-n/0e/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/decay-array/3/01-t/0f/0e/4.html": {
    "href": "api/testing/internal/decay-array/3/01-t/0f/0e/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/default-global-test-part-result-reporter.html": {
    "href": "api/testing/internal/default-global-test-part-result-reporter.html",
    "title": "Class testing::internal::DefaultGlobalTestPartResultReporter | qiotoolkit",
    "keywords": "Class testing::internal::DefaultGlobalTestPartResultReporter Inheritance testing::TestPartResultReporterInterface testing::internal::DefaultGlobalTestPartResultReporter Inherited Members ~TestPartResultReporterInterface Constructors DefaultGlobalTestPartResultReporter() Declaration testing::internal::DefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter(UnitTestImpl *unit_test) Methods ReportTestPartResult() Declaration void testing::internal::DefaultGlobalTestPartResultReporter::ReportTestPartResult(const TestPartResult&result) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::DefaultGlobalTestPartResultReporter::GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultGlobalTestPartResultReporter)"
  },
  "api/testing/internal/default-per-thread-test-part-result-reporter.html": {
    "href": "api/testing/internal/default-per-thread-test-part-result-reporter.html",
    "title": "Class testing::internal::DefaultPerThreadTestPartResultReporter | qiotoolkit",
    "keywords": "Class testing::internal::DefaultPerThreadTestPartResultReporter Inheritance testing::TestPartResultReporterInterface testing::internal::DefaultPerThreadTestPartResultReporter Inherited Members ~TestPartResultReporterInterface Constructors DefaultPerThreadTestPartResultReporter() Declaration testing::internal::DefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter(UnitTestImpl *unit_test) Methods ReportTestPartResult() Declaration void testing::internal::DefaultPerThreadTestPartResultReporter::ReportTestPartResult(const TestPartResult&result) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::DefaultPerThreadTestPartResultReporter::GTEST_DISALLOW_COPY_AND_ASSIGN_(DefaultPerThreadTestPartResultReporter)"
  },
  "api/testing/internal/do-all-action.html": {
    "href": "api/testing/internal/do-all-action.html",
    "title": "Struct testing::internal::DoAllAction | qiotoolkit",
    "keywords": "Struct testing::internal::DoAllAction Methods Convert() Declaration std::vector<Action<void(Args...)>>testing::internal::DoAllAction<Actions>::Convert(IndexSequence<I...>) const R() Declaration testing::internal::DoAllAction<Actions>::operator Action<R(Args...)>() const R() Declaration testing::internal::DoAllAction<Actions>::operator Action<R(Args...)>() const R() Declaration testing::internal::DoAllAction<Actions>::operator Action<R(Args...)>() const"
  },
  "api/testing/internal/do-both-action.html": {
    "href": "api/testing/internal/do-both-action.html",
    "title": "Class testing::internal::DoBothAction | qiotoolkit",
    "keywords": "Class testing::internal::DoBothAction Inheritance testing::internal::DoBothAction Constructors DoBothAction() Declaration testing::internal::DoBothAction<Action1, Action2>::DoBothAction(Action1 action1, Action2 action2) Methods >() Declaration testing::internal::DoBothAction<Action1, Action2>::operator Action<F>() const >() Declaration testing::internal::DoBothAction<Action1, Action2>::operator Action<F>() const >() Declaration testing::internal::DoBothAction<Action1, Action2>::operator Action<F>() const >() Declaration testing::internal::DoBothAction<Action1, Action2>::operator Action<F>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::DoBothAction<Action1, Action2>::GTEST_DISALLOW_ASSIGN_(DoBothAction)"
  },
  "api/testing/internal/do-both-action/impl.html": {
    "href": "api/testing/internal/do-both-action/impl.html",
    "title": "Class testing::internal::DoBothAction::Impl | qiotoolkit",
    "keywords": "Class testing::internal::DoBothAction::Impl Inheritance testing::ActionInterface testing::internal::DoBothAction::Impl Inherited Members ActionInterface ~ActionInterface Constructors Impl() Declaration testing::internal::DoBothAction<Action1, Action2>::Impl<F>::Impl(const Action<VoidResult>&action1, const Action<F>&action2) Methods Perform() Declaration virtual Result testing::internal::DoBothAction<Action1, Action2>::Impl<F>::Perform(const ArgumentTuple&args) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::DoBothAction<Action1, Action2>::Impl<F>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/do-default-action.html": {
    "href": "api/testing/internal/do-default-action.html",
    "title": "Class testing::internal::DoDefaultAction | qiotoolkit",
    "keywords": "Class testing::internal::DoDefaultAction Inheritance testing::internal::DoDefaultAction Methods >() Declaration testing::internal::DoDefaultAction::operator Action<F>() const >() Declaration testing::internal::DoDefaultAction::operator Action<F>() const >() Declaration testing::internal::DoDefaultAction::operator Action<F>() const >() Declaration testing::internal::DoDefaultAction::operator Action<F>() const >() Declaration testing::internal::DoDefaultAction::operator Action<F>() const >() Declaration testing::internal::DoDefaultAction::operator Action<F>() const >() Declaration testing::internal::DoDefaultAction::operator Action<F>() const >() Declaration testing::internal::DoDefaultAction::operator Action<F>() const"
  },
  "api/testing/internal/double-sequence.html": {
    "href": "api/testing/internal/double-sequence.html",
    "title": "Struct testing::internal::DoubleSequence | qiotoolkit",
    "keywords": "Struct testing::internal::DoubleSequence"
  },
  "api/testing/internal/double-sequence/3/01false/00/01-index-sequence/3/01-i/8/8/8/01/4/00/01sizeof-t/01/4.html": {
    "href": "api/testing/internal/double-sequence/3/01false/00/01-index-sequence/3/01-i/8/8/8/01/4/00/01sizeof-t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/double-sequence/3/01true/00/01-index-sequence/3/01-i/8/8/8/01/4/00/01sizeof-t/01/4.html": {
    "href": "api/testing/internal/double-sequence/3/01true/00/01-index-sequence/3/01-i/8/8/8/01/4/00/01sizeof-t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/dummy-match-result-listener.html": {
    "href": "api/testing/internal/dummy-match-result-listener.html",
    "title": "Class testing::internal::DummyMatchResultListener | qiotoolkit",
    "keywords": "Class testing::internal::DummyMatchResultListener Inheritance testing::MatchResultListener testing::internal::DummyMatchResultListener Inherited Members MatchResultListener stream < ~MatchResultListener IsInterested Constructors DummyMatchResultListener() Declaration testing::internal::DummyMatchResultListener::DummyMatchResultListener() Methods GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::DummyMatchResultListener::GTEST_DISALLOW_COPY_AND_ASSIGN_(DummyMatchResultListener)"
  },
  "api/testing/internal/each-matcher-impl.html": {
    "href": "api/testing/internal/each-matcher-impl.html",
    "title": "Class testing::internal::EachMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::EachMatcherImpl Inheritance testing::internal::QuantifierMatcherImpl testing::internal::EachMatcherImpl Inherited Members ~MatcherDescriberInterface GTEST_REMOVE_REFERENCE_AND_CONST_ MatchAndExplainImpl GTEST_DISALLOW_ASSIGN_ QuantifierMatcherImpl Constructors EachMatcherImpl() Declaration testing::internal::EachMatcherImpl<Container>::EachMatcherImpl(InnerMatcher inner_matcher) Methods DescribeTo() Declaration virtual void testing::internal::EachMatcherImpl<Container>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::EachMatcherImpl<Container>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::EachMatcherImpl<Container>::MatchAndExplain(Container container, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::EachMatcherImpl<Container>::GTEST_DISALLOW_ASSIGN_(EachMatcherImpl)"
  },
  "api/testing/internal/each-matcher.html": {
    "href": "api/testing/internal/each-matcher.html",
    "title": "Class testing::internal::EachMatcher | qiotoolkit",
    "keywords": "Class testing::internal::EachMatcher Inheritance testing::internal::EachMatcher Constructors EachMatcher() Declaration testing::internal::EachMatcher<M>::EachMatcher(M m) Methods >() Declaration testing::internal::EachMatcher<M>::operator Matcher<Container>() const >() Declaration testing::internal::EachMatcher<M>::operator Matcher<Container>() const >() Declaration testing::internal::EachMatcher<M>::operator Matcher<Container>() const >() Declaration testing::internal::EachMatcher<M>::operator Matcher<Container>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::EachMatcher<M>::GTEST_DISALLOW_ASSIGN_(EachMatcher)"
  },
  "api/testing/internal/either-of-matcher.html": {
    "href": "api/testing/internal/either-of-matcher.html",
    "title": "Class testing::internal::EitherOfMatcher | qiotoolkit",
    "keywords": "Class testing::internal::EitherOfMatcher Inheritance testing::internal::EitherOfMatcher Constructors EitherOfMatcher() Declaration testing::internal::EitherOfMatcher<Matcher1, Matcher2>::EitherOfMatcher(Matcher1 matcher1, Matcher2 matcher2) Methods >() Declaration testing::internal::EitherOfMatcher<Matcher1, Matcher2>::operator Matcher<T>() const >() Declaration testing::internal::EitherOfMatcher<Matcher1, Matcher2>::operator Matcher<T>() const >() Declaration testing::internal::EitherOfMatcher<Matcher1, Matcher2>::operator Matcher<T>() const >() Declaration testing::internal::EitherOfMatcher<Matcher1, Matcher2>::operator Matcher<T>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::EitherOfMatcher<Matcher1, Matcher2>::GTEST_DISALLOW_ASSIGN_(EitherOfMatcher)"
  },
  "api/testing/internal/elem-from-list-impl.html": {
    "href": "api/testing/internal/elem-from-list-impl.html",
    "title": "Struct testing::internal::ElemFromListImpl | qiotoolkit",
    "keywords": "Struct testing::internal::ElemFromListImpl"
  },
  "api/testing/internal/elem-from-list-impl/3/01-t/00/01-i/00/01-i/01/4.html": {
    "href": "api/testing/internal/elem-from-list-impl/3/01-t/00/01-i/00/01-i/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/elem-from-list.html": {
    "href": "api/testing/internal/elem-from-list.html",
    "title": "Struct testing::internal::ElemFromList | qiotoolkit",
    "keywords": "Struct testing::internal::ElemFromList"
  },
  "api/testing/internal/elem-from-list/3/01-n/00/01-index-sequence/3/01-i/8/8/8/01/4/00/01-t/8/8/8/01/4.html": {
    "href": "api/testing/internal/elem-from-list/3/01-n/00/01-index-sequence/3/01-i/8/8/8/01/4/00/01-t/8/8/8/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/elements-are-array-matcher.html": {
    "href": "api/testing/internal/elements-are-array-matcher.html",
    "title": "Class testing::internal::ElementsAreArrayMatcher | qiotoolkit",
    "keywords": "Class testing::internal::ElementsAreArrayMatcher Inheritance testing::internal::ElementsAreArrayMatcher Constructors ElementsAreArrayMatcher() Declaration testing::internal::ElementsAreArrayMatcher<T>::ElementsAreArrayMatcher(Iter first, Iter last) Methods >() Declaration testing::internal::ElementsAreArrayMatcher<T>::operator Matcher<Container>() const >() Declaration testing::internal::ElementsAreArrayMatcher<T>::operator Matcher<Container>() const >() Declaration testing::internal::ElementsAreArrayMatcher<T>::operator Matcher<Container>() const >() Declaration testing::internal::ElementsAreArrayMatcher<T>::operator Matcher<Container>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ElementsAreArrayMatcher<T>::GTEST_DISALLOW_ASSIGN_(ElementsAreArrayMatcher)"
  },
  "api/testing/internal/elements-are-matcher-impl.html": {
    "href": "api/testing/internal/elements-are-matcher-impl.html",
    "title": "Class testing::internal::ElementsAreMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::ElementsAreMatcherImpl Inheritance testing::MatcherInterface testing::internal::ElementsAreMatcherImpl Inherited Members ~MatcherDescriberInterface Constructors ElementsAreMatcherImpl() Declaration testing::internal::ElementsAreMatcherImpl<Container>::ElementsAreMatcherImpl(InputIter first, InputIter last) Methods GTEST_REMOVE_REFERENCE_AND_CONST_() Declaration typedef testing::internal::ElementsAreMatcherImpl<Container>::GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer DescribeTo() Declaration virtual void testing::internal::ElementsAreMatcherImpl<Container>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::ElementsAreMatcherImpl<Container>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::ElementsAreMatcherImpl<Container>::MatchAndExplain(Container container, MatchResultListener *listener) const Elements() Declaration static Message testing::internal::ElementsAreMatcherImpl<Container>::Elements(size_t count) count() Declaration size_t testing::internal::ElementsAreMatcherImpl<Container>::count() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ElementsAreMatcherImpl<Container>::GTEST_DISALLOW_ASSIGN_(ElementsAreMatcherImpl)"
  },
  "api/testing/internal/elements-are-matcher.html": {
    "href": "api/testing/internal/elements-are-matcher.html",
    "title": "Class testing::internal::ElementsAreMatcher | qiotoolkit",
    "keywords": "Class testing::internal::ElementsAreMatcher Inheritance testing::internal::ElementsAreMatcher Constructors ElementsAreMatcher() Declaration testing::internal::ElementsAreMatcher<MatcherTuple>::ElementsAreMatcher(const MatcherTuple&args) Methods >() Declaration testing::internal::ElementsAreMatcher<MatcherTuple>::operator Matcher<Container>() const >() Declaration testing::internal::ElementsAreMatcher<MatcherTuple>::operator Matcher<Container>() const >() Declaration testing::internal::ElementsAreMatcher<MatcherTuple>::operator Matcher<Container>() const >() Declaration testing::internal::ElementsAreMatcher<MatcherTuple>::operator Matcher<Container>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ElementsAreMatcher<MatcherTuple>::GTEST_DISALLOW_ASSIGN_(ElementsAreMatcher)"
  },
  "api/testing/internal/enable-if.html": {
    "href": "api/testing/internal/enable-if.html",
    "title": "Struct testing::internal::EnableIf | qiotoolkit",
    "keywords": "Struct testing::internal::EnableIf"
  },
  "api/testing/internal/enable-if/3/01true/01/4.html": {
    "href": "api/testing/internal/enable-if/3/01true/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/ends-with-matcher.html": {
    "href": "api/testing/internal/ends-with-matcher.html",
    "title": "Class testing::internal::EndsWithMatcher | qiotoolkit",
    "keywords": "Class testing::internal::EndsWithMatcher Inheritance testing::internal::EndsWithMatcher Constructors EndsWithMatcher() Declaration testing::internal::EndsWithMatcher<StringType>::EndsWithMatcher(const StringType&suffix) Methods MatchAndExplain() Declaration bool testing::internal::EndsWithMatcher<StringType>::MatchAndExplain(CharType *s, MatchResultListener *listener) const MatchAndExplain() Declaration bool testing::internal::EndsWithMatcher<StringType>::MatchAndExplain(const MatcheeStringType&s, MatchResultListener *) const DescribeTo() Declaration void testing::internal::EndsWithMatcher<StringType>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::EndsWithMatcher<StringType>::DescribeNegationTo(::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::EndsWithMatcher<StringType>::GTEST_DISALLOW_ASSIGN_(EndsWithMatcher)"
  },
  "api/testing/internal/eq-helper.html": {
    "href": "api/testing/internal/eq-helper.html",
    "title": "Class testing::internal::EqHelper | qiotoolkit",
    "keywords": "Class testing::internal::EqHelper Inheritance testing::internal::EqHelper Methods Compare() Declaration static AssertionResult testing::internal::EqHelper<lhs_is_null_literal>::Compare(const char *lhs_expression, const char *rhs_expression, const T1&lhs, const T2&rhs) Compare() Declaration static AssertionResult testing::internal::EqHelper<lhs_is_null_literal>::Compare(const char *lhs_expression, const char *rhs_expression, BiggestInt lhs, BiggestInt rhs) Compare() Declaration static AssertionResult testing::internal::EqHelper<lhs_is_null_literal>::Compare(const char *lhs_expression, const char *rhs_expression, std::nullptr_t, T *rhs) Compare() Declaration static AssertionResult testing::internal::EqHelper<lhs_is_null_literal>::Compare(const char *lhs_expression, const char *rhs_expression, const T1&lhs, const T2&rhs) Compare() Declaration static AssertionResult testing::internal::EqHelper<lhs_is_null_literal>::Compare(const char *lhs_expression, const char *rhs_expression, BiggestInt lhs, BiggestInt rhs)"
  },
  "api/testing/internal/eq-helper/3/01true/01/4.html": {
    "href": "api/testing/internal/eq-helper/3/01true/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Compare() Declaration static AssertionResult testing::internal::EqHelper<true>::Compare(const char *lhs_expression, const char *rhs_expression, const T1&lhs, const T2&rhs, typename EnableIf<!is_pointer<T2>::value>::type *=0) Compare() Declaration static AssertionResult testing::internal::EqHelper<true>::Compare(const char *lhs_expression, const char *rhs_expression, Secret *, T *rhs)"
  },
  "api/testing/internal/eq-matcher.html": {
    "href": "api/testing/internal/eq-matcher.html",
    "title": "Class testing::internal::EqMatcher | qiotoolkit",
    "keywords": "Class testing::internal::EqMatcher Inheritance testing::internal::ComparisonBase testing::internal::EqMatcher Inherited Members > ComparisonBase Constructors EqMatcher() Declaration testing::internal::EqMatcher<Rhs>::EqMatcher(const Rhs&rhs) Methods Desc() Declaration static const char* testing::internal::EqMatcher<Rhs>::Desc() NegatedDesc() Declaration static const char* testing::internal::EqMatcher<Rhs>::NegatedDesc()"
  },
  "api/testing/internal/eq2-matcher.html": {
    "href": "api/testing/internal/eq2-matcher.html",
    "title": "Class testing::internal::Eq2Matcher | qiotoolkit",
    "keywords": "Class testing::internal::Eq2Matcher Inheritance testing::internal::PairMatchBase testing::internal::Eq2Matcher Inherited Members > > Methods Desc() Declaration static const char* testing::internal::Eq2Matcher::Desc()"
  },
  "api/testing/internal/excessive-arg.html": {
    "href": "api/testing/internal/excessive-arg.html",
    "title": "Struct testing::internal::ExcessiveArg | qiotoolkit",
    "keywords": "Struct testing::internal::ExcessiveArg"
  },
  "api/testing/internal/expectation-base.html": {
    "href": "api/testing/internal/expectation-base.html",
    "title": "Class testing::internal::ExpectationBase | qiotoolkit",
    "keywords": "Class testing::internal::ExpectationBase Inheritance testing::internal::ExpectationBase Constructors ExpectationBase() Declaration testing::internal::ExpectationBase::ExpectationBase(const char *file, int line, const std::string&source_text) Methods ~ExpectationBase() Declaration testing::internal::ExpectationBase::~ExpectationBase() file() Declaration const char* testing::internal::ExpectationBase::file() const line() Declaration int testing::internal::ExpectationBase::line() const source_text() Declaration const char* testing::internal::ExpectationBase::source_text() const cardinality() Declaration const Cardinality&testing::internal::ExpectationBase::cardinality() const DescribeLocationTo() Declaration void testing::internal::ExpectationBase::DescribeLocationTo(::std::ostream *os) const DescribeCallCountTo() Declaration void testing::internal::ExpectationBase::DescribeCallCountTo(::std::ostream *os) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) MaybeDescribeExtraMatcherTo() Declaration virtual void testing::internal::ExpectationBase::MaybeDescribeExtraMatcherTo(::std::ostream *os)=0 GetHandle() Declaration virtual Expectation testing::internal::ExpectationBase::GetHandle()=0 AssertSpecProperty() Declaration void testing::internal::ExpectationBase::AssertSpecProperty(bool property, const std::string&failure_message) const ExpectSpecProperty() Declaration void testing::internal::ExpectationBase::ExpectSpecProperty(bool property, const std::string&failure_message) const SpecifyCardinality() Declaration void testing::internal::ExpectationBase::SpecifyCardinality(const Cardinality&cardinality) cardinality_specified() Declaration bool testing::internal::ExpectationBase::cardinality_specified() const set_cardinality() Declaration void testing::internal::ExpectationBase::set_cardinality(const Cardinality&a_cardinality) RetireAllPreRequisites() Declaration void testing::internal::ExpectationBase::RetireAllPreRequisites() GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) is_retired() Declaration bool testing::internal::ExpectationBase::is_retired() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) Retire() Declaration void testing::internal::ExpectationBase::Retire() GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) IsSatisfied() Declaration bool testing::internal::ExpectationBase::IsSatisfied() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) IsSaturated() Declaration bool testing::internal::ExpectationBase::IsSaturated() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) IsOverSaturated() Declaration bool testing::internal::ExpectationBase::IsOverSaturated() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) AllPrerequisitesAreSatisfied() Declaration bool testing::internal::ExpectationBase::AllPrerequisitesAreSatisfied() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) FindUnsatisfiedPrerequisites() Declaration void testing::internal::ExpectationBase::FindUnsatisfiedPrerequisites(ExpectationSet *result) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) call_count() Declaration int testing::internal::ExpectationBase::call_count() const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) IncrementCallCount() Declaration void testing::internal::ExpectationBase::IncrementCallCount() GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) CheckActionCountIfNotDone() Declaration void testing::internal::ExpectationBase::CheckActionCountIfNotDone() const GTEST_LOCK_EXCLUDED_(mutex_) UntypedTimes() Declaration void testing::internal::ExpectationBase::UntypedTimes(const Cardinality&a_cardinality) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ExpectationBase::GTEST_DISALLOW_ASSIGN_(ExpectationBase)"
  },
  "api/testing/internal/faketype.html": {
    "href": "api/testing/internal/faketype.html",
    "title": "Struct testing::internal::faketype | qiotoolkit",
    "keywords": "Struct testing::internal::faketype"
  },
  "api/testing/internal/field-matcher.html": {
    "href": "api/testing/internal/field-matcher.html",
    "title": "Class testing::internal::FieldMatcher | qiotoolkit",
    "keywords": "Class testing::internal::FieldMatcher Inheritance testing::internal::FieldMatcher Constructors FieldMatcher() Declaration testing::internal::FieldMatcher<Class, FieldType>::FieldMatcher(FieldType Class::*field, const Matcher<const FieldType&>&matcher) FieldMatcher() Declaration testing::internal::FieldMatcher<Class, FieldType>::FieldMatcher(const std::string&field_name, FieldType Class::*field, const Matcher<const FieldType&>&matcher) Methods DescribeTo() Declaration void testing::internal::FieldMatcher<Class, FieldType>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::FieldMatcher<Class, FieldType>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration bool testing::internal::FieldMatcher<Class, FieldType>::MatchAndExplain(const T&value, MatchResultListener *listener) const MatchAndExplainImpl() Declaration bool testing::internal::FieldMatcher<Class, FieldType>::MatchAndExplainImpl(false_type, const Class&obj, MatchResultListener *listener) const MatchAndExplainImpl() Declaration bool testing::internal::FieldMatcher<Class, FieldType>::MatchAndExplainImpl(true_type, const Class *p, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::FieldMatcher<Class, FieldType>::GTEST_DISALLOW_ASSIGN_(FieldMatcher)"
  },
  "api/testing/internal/file-path.html": {
    "href": "api/testing/internal/file-path.html",
    "title": "Class testing::internal::FilePath | qiotoolkit",
    "keywords": "Class testing::internal::FilePath Inheritance testing::internal::FilePath Constructors FilePath() Declaration testing::internal::FilePath::FilePath() FilePath() Declaration testing::internal::FilePath::FilePath(const FilePath&rhs) FilePath() Declaration testing::internal::FilePath::FilePath(const std::string&pathname) Methods operator=() Declaration FilePath&testing::internal::FilePath::operator=(const FilePath&rhs) Set() Declaration void testing::internal::FilePath::Set(const FilePath&rhs) string() Declaration const std::string&testing::internal::FilePath::string() const c_str() Declaration const char* testing::internal::FilePath::c_str() const IsEmpty() Declaration bool testing::internal::FilePath::IsEmpty() const RemoveTrailingPathSeparator() Declaration FilePath testing::internal::FilePath::RemoveTrailingPathSeparator() const RemoveDirectoryName() Declaration FilePath testing::internal::FilePath::RemoveDirectoryName() const RemoveFileName() Declaration FilePath testing::internal::FilePath::RemoveFileName() const RemoveExtension() Declaration FilePath testing::internal::FilePath::RemoveExtension(const char *extension) const CreateDirectoriesRecursively() Declaration bool testing::internal::FilePath::CreateDirectoriesRecursively() const CreateFolder() Declaration bool testing::internal::FilePath::CreateFolder() const FileOrDirectoryExists() Declaration bool testing::internal::FilePath::FileOrDirectoryExists() const DirectoryExists() Declaration bool testing::internal::FilePath::DirectoryExists() const IsDirectory() Declaration bool testing::internal::FilePath::IsDirectory() const IsRootDirectory() Declaration bool testing::internal::FilePath::IsRootDirectory() const IsAbsolutePath() Declaration bool testing::internal::FilePath::IsAbsolutePath() const GetCurrentDir() Declaration FilePath testing::internal::FilePath::GetCurrentDir() MakeFileName() Declaration FilePath testing::internal::FilePath::MakeFileName(const FilePath&directory, const FilePath&base_name, int number, const char *extension) ConcatPaths() Declaration FilePath testing::internal::FilePath::ConcatPaths(const FilePath&directory, const FilePath&relative_path) GenerateUniqueFileName() Declaration FilePath testing::internal::FilePath::GenerateUniqueFileName(const FilePath&directory, const FilePath&base_name, const char *extension) Normalize() Declaration void testing::internal::FilePath::Normalize() FindLastPathSeparator() Declaration const char * testing::internal::FilePath::FindLastPathSeparator() const"
  },
  "api/testing/internal/flat-tuple-base.html": {
    "href": "api/testing/internal/flat-tuple-base.html",
    "title": "Struct testing::internal::FlatTupleBase | qiotoolkit",
    "keywords": "Struct testing::internal::FlatTupleBase"
  },
  "api/testing/internal/flat-tuple-base/3/01-flat-tuple/3/01-t/8/8/8/01/4/00/01-index-sequence/3/01-idx/8/8/8/01/4/01/4.html": {
    "href": "api/testing/internal/flat-tuple-base/3/01-flat-tuple/3/01-t/8/8/8/01/4/00/01-index-sequence/3/01-idx/8/8/8/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods FlatTupleBase() Declaration testing::internal::FlatTupleBase<FlatTuple<T...>, IndexSequence<Idx...>>::FlatTupleBase()=default FlatTupleBase() Declaration testing::internal::FlatTupleBase<FlatTuple<T...>, IndexSequence<Idx...>>::FlatTupleBase(T... t)"
  },
  "api/testing/internal/flat-tuple-elem-base.html": {
    "href": "api/testing/internal/flat-tuple-elem-base.html",
    "title": "Struct testing::internal::FlatTupleElemBase | qiotoolkit",
    "keywords": "Struct testing::internal::FlatTupleElemBase"
  },
  "api/testing/internal/flat-tuple-elem-base/3/01-flat-tuple/3/01-t/8/8/8/01/4/00/01-i/01/4.html": {
    "href": "api/testing/internal/flat-tuple-elem-base/3/01-flat-tuple/3/01-t/8/8/8/01/4/00/01-i/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods FlatTupleElemBase() Declaration testing::internal::FlatTupleElemBase<FlatTuple<T...>, I>::FlatTupleElemBase()=default FlatTupleElemBase() Declaration testing::internal::FlatTupleElemBase<FlatTuple<T...>, I>::FlatTupleElemBase(value_type t)"
  },
  "api/testing/internal/flat-tuple.html": {
    "href": "api/testing/internal/flat-tuple.html",
    "title": "Class testing::internal::FlatTuple | qiotoolkit",
    "keywords": "Class testing::internal::FlatTuple Inheritance testing::internal::FlatTuple Constructors FlatTuple() Declaration testing::internal::FlatTuple<T>::FlatTuple()=default FlatTuple() Declaration testing::internal::FlatTuple<T>::FlatTuple(T... t) Methods Get() Declaration const ElemFromList<I, Indices, T...>::type&testing::internal::FlatTuple<T>::Get() const Get() Declaration ElemFromList<I, Indices, T...>::type&testing::internal::FlatTuple<T>::Get()"
  },
  "api/testing/internal/floating-eq-matcher.html": {
    "href": "api/testing/internal/floating-eq-matcher.html",
    "title": "Class testing::internal::FloatingEqMatcher | qiotoolkit",
    "keywords": "Class testing::internal::FloatingEqMatcher Inheritance testing::internal::FloatingEqMatcher Constructors FloatingEqMatcher() Declaration testing::internal::FloatingEqMatcher<FloatType>::FloatingEqMatcher(FloatType expected, bool nan_eq_nan) FloatingEqMatcher() Declaration testing::internal::FloatingEqMatcher<FloatType>::FloatingEqMatcher(FloatType expected, bool nan_eq_nan, FloatType max_abs_error) Methods >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<FloatType>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<FloatType>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<FloatType>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<FloatType>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<const FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<const FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<const FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<const FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<const FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<const FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<FloatType&>() const >() Declaration testing::internal::FloatingEqMatcher<FloatType>::operator Matcher<FloatType&>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::FloatingEqMatcher<FloatType>::GTEST_DISALLOW_ASSIGN_(FloatingEqMatcher)"
  },
  "api/testing/internal/floating-eq-matcher/impl.html": {
    "href": "api/testing/internal/floating-eq-matcher/impl.html",
    "title": "Class testing::internal::FloatingEqMatcher::Impl | qiotoolkit",
    "keywords": "Class testing::internal::FloatingEqMatcher::Impl Inheritance testing::MatcherInterface testing::internal::FloatingEqMatcher::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::FloatingEqMatcher<FloatType>::Impl<T>::Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error) Methods MatchAndExplain() Declaration virtual bool testing::internal::FloatingEqMatcher<FloatType>::Impl<T>::MatchAndExplain(T value, MatchResultListener *listener) const DescribeTo() Declaration virtual void testing::internal::FloatingEqMatcher<FloatType>::Impl<T>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::FloatingEqMatcher<FloatType>::Impl<T>::DescribeNegationTo(::std::ostream *os) const HasMaxAbsError() Declaration bool testing::internal::FloatingEqMatcher<FloatType>::Impl<T>::HasMaxAbsError() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::FloatingEqMatcher<FloatType>::Impl<T>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/floating-eq2-matcher.html": {
    "href": "api/testing/internal/floating-eq2-matcher.html",
    "title": "Class testing::internal::FloatingEq2Matcher | qiotoolkit",
    "keywords": "Class testing::internal::FloatingEq2Matcher Inheritance testing::internal::FloatingEq2Matcher Constructors FloatingEq2Matcher() Declaration testing::internal::FloatingEq2Matcher<FloatType>::FloatingEq2Matcher() FloatingEq2Matcher() Declaration testing::internal::FloatingEq2Matcher<FloatType>::FloatingEq2Matcher(bool nan_eq_nan) FloatingEq2Matcher() Declaration testing::internal::FloatingEq2Matcher<FloatType>::FloatingEq2Matcher(FloatType max_abs_error) FloatingEq2Matcher() Declaration testing::internal::FloatingEq2Matcher<FloatType>::FloatingEq2Matcher(FloatType max_abs_error, bool nan_eq_nan) Methods >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::FloatingEq2Matcher<FloatType>::operator Matcher<const ::testing::tuple<T1, T2>&>() const GetDesc() Declaration ::std::ostream&testing::internal::FloatingEq2Matcher<FloatType>::GetDesc(::std::ostream&os) Init() Declaration void testing::internal::FloatingEq2Matcher<FloatType>::Init(FloatType max_abs_error_val, bool nan_eq_nan_val)"
  },
  "api/testing/internal/floating-eq2-matcher/impl.html": {
    "href": "api/testing/internal/floating-eq2-matcher/impl.html",
    "title": "Class testing::internal::FloatingEq2Matcher::Impl | qiotoolkit",
    "keywords": "Class testing::internal::FloatingEq2Matcher::Impl Inheritance testing::MatcherInterface testing::internal::FloatingEq2Matcher::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::FloatingEq2Matcher<FloatType>::Impl<Tuple>::Impl(FloatType max_abs_error, bool nan_eq_nan) Methods MatchAndExplain() Declaration virtual bool testing::internal::FloatingEq2Matcher<FloatType>::Impl<Tuple>::MatchAndExplain(Tuple args, MatchResultListener *listener) const DescribeTo() Declaration virtual void testing::internal::FloatingEq2Matcher<FloatType>::Impl<Tuple>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::FloatingEq2Matcher<FloatType>::Impl<Tuple>::DescribeNegationTo(::std::ostream *os) const"
  },
  "api/testing/internal/floating-point.html": {
    "href": "api/testing/internal/floating-point.html",
    "title": "Class testing::internal::FloatingPoint | qiotoolkit",
    "keywords": "Class testing::internal::FloatingPoint Inheritance testing::internal::FloatingPoint Constructors FloatingPoint() Declaration testing::internal::FloatingPoint<RawType>::FloatingPoint(const RawType&x) FloatingPoint() Declaration testing::internal::FloatingPoint<RawType>::FloatingPoint(const RawType&x) Methods bits() Declaration const Bits&testing::internal::FloatingPoint<RawType>::bits() const exponent_bits() Declaration Bits testing::internal::FloatingPoint<RawType>::exponent_bits() const fraction_bits() Declaration Bits testing::internal::FloatingPoint<RawType>::fraction_bits() const sign_bit() Declaration Bits testing::internal::FloatingPoint<RawType>::sign_bit() const is_nan() Declaration bool testing::internal::FloatingPoint<RawType>::is_nan() const AlmostEquals() Declaration bool testing::internal::FloatingPoint<RawType>::AlmostEquals(const FloatingPoint&rhs) const bits() Declaration const Bits&testing::internal::FloatingPoint<RawType>::bits() const exponent_bits() Declaration Bits testing::internal::FloatingPoint<RawType>::exponent_bits() const fraction_bits() Declaration Bits testing::internal::FloatingPoint<RawType>::fraction_bits() const sign_bit() Declaration Bits testing::internal::FloatingPoint<RawType>::sign_bit() const is_nan() Declaration bool testing::internal::FloatingPoint<RawType>::is_nan() const AlmostEquals() Declaration bool testing::internal::FloatingPoint<RawType>::AlmostEquals(const FloatingPoint&rhs) const Max() Declaration float testing::internal::FloatingPoint<float>::Max() Max() Declaration double testing::internal::FloatingPoint<double>::Max() Max() Declaration float testing::internal::FloatingPoint<float>::Max() Max() Declaration double testing::internal::FloatingPoint<double>::Max() ReinterpretBits() Declaration static RawType testing::internal::FloatingPoint<RawType>::ReinterpretBits(const Bits bits) Infinity() Declaration static RawType testing::internal::FloatingPoint<RawType>::Infinity() Max() Declaration static RawType testing::internal::FloatingPoint<RawType>::Max() ReinterpretBits() Declaration static RawType testing::internal::FloatingPoint<RawType>::ReinterpretBits(const Bits bits) Infinity() Declaration static RawType testing::internal::FloatingPoint<RawType>::Infinity() Max() Declaration static RawType testing::internal::FloatingPoint<RawType>::Max() SignAndMagnitudeToBiased() Declaration static Bits testing::internal::FloatingPoint<RawType>::SignAndMagnitudeToBiased(const Bits&sam) DistanceBetweenSignAndMagnitudeNumbers() Declaration static Bits testing::internal::FloatingPoint<RawType>::DistanceBetweenSignAndMagnitudeNumbers(const Bits&sam1, const Bits&sam2) SignAndMagnitudeToBiased() Declaration static Bits testing::internal::FloatingPoint<RawType>::SignAndMagnitudeToBiased(const Bits&sam) DistanceBetweenSignAndMagnitudeNumbers() Declaration static Bits testing::internal::FloatingPoint<RawType>::DistanceBetweenSignAndMagnitudeNumbers(const Bits&sam1, const Bits&sam2)"
  },
  "api/testing/internal/format-for-comparison.html": {
    "href": "api/testing/internal/format-for-comparison.html",
    "title": "Class testing::internal::FormatForComparison | qiotoolkit",
    "keywords": "Class testing::internal::FormatForComparison Inheritance testing::internal::FormatForComparison Methods Format() Declaration ::std::string testing::internal::FormatForComparison<ToPrint, OtherOperand>::Format(const ToPrint&value) Format() Declaration ::std::string testing::internal::FormatForComparison<ToPrint, OtherOperand>::Format(const ToPrint&value)"
  },
  "api/testing/internal/format-for-comparison/3/01-to-print/0f-n/0e/00/01-other-operand/01/4.html": {
    "href": "api/testing/internal/format-for-comparison/3/01-to-print/0f-n/0e/00/01-other-operand/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Format() Declaration ::std::string testing::internal::FormatForComparison<ToPrint[N], OtherOperand>::Format(const ToPrint *value) Format() Declaration ::std::string testing::internal::FormatForComparison<ToPrint[N], OtherOperand>::Format(const ToPrint *value)"
  },
  "api/testing/internal/function-mocker-base.html": {
    "href": "api/testing/internal/function-mocker-base.html",
    "title": "Class testing::internal::FunctionMockerBase | qiotoolkit",
    "keywords": "Class testing::internal::FunctionMockerBase Inheritance testing::internal::FunctionMockerBase Constructors FunctionMockerBase() Declaration testing::internal::FunctionMockerBase<F>::FunctionMockerBase() Methods ~FunctionMockerBase() Declaration virtual testing::internal::FunctionMockerBase<F>::~FunctionMockerBase() GTEST_LOCK_EXCLUDED_(g_gmock_mutex) FindOnCallSpec() Declaration const OnCallSpec<F>* testing::internal::FunctionMockerBase<F>::FindOnCallSpec(const ArgumentTuple&args) const PerformDefaultAction() Declaration Result testing::internal::FunctionMockerBase<F>::PerformDefaultAction(typename RvalueRef<typename Function<F>::ArgumentTuple>::type args, const std::string&call_description) const UntypedPerformDefaultAction() Declaration virtual UntypedActionResultHolderBase* testing::internal::FunctionMockerBase<F>::UntypedPerformDefaultAction(void *untyped_args, const std::string&call_description) const UntypedPerformAction() Declaration virtual UntypedActionResultHolderBase* testing::internal::FunctionMockerBase<F>::UntypedPerformAction(const void *untyped_action, void *untyped_args) const ClearDefaultActionsLocked() Declaration virtual void testing::internal::FunctionMockerBase<F>::ClearDefaultActionsLocked() GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) InvokeWith() Declaration Result testing::internal::FunctionMockerBase<F>::InvokeWith(typename RvalueRef<typename Function<F>::ArgumentTuple>::type args) GTEST_LOCK_EXCLUDED_(g_gmock_mutex) AddNewOnCallSpec() Declaration OnCallSpec<F>&testing::internal::FunctionMockerBase<F>::AddNewOnCallSpec(const char *file, int line, const ArgumentMatcherTuple&m) GTEST_LOCK_EXCLUDED_(g_gmock_mutex) AddNewExpectation() Declaration TypedExpectation<F>&testing::internal::FunctionMockerBase<F>::AddNewExpectation(const char *file, int line, const std::string&source_text, const ArgumentMatcherTuple&m) GTEST_LOCK_EXCLUDED_(g_gmock_mutex) DescribeDefaultActionTo() Declaration void testing::internal::FunctionMockerBase<F>::DescribeDefaultActionTo(const ArgumentTuple&args, ::std::ostream *os) const UntypedDescribeUninterestingCall() Declaration virtual void testing::internal::FunctionMockerBase<F>::UntypedDescribeUninterestingCall(const void *untyped_args, ::std::ostream *os) const GTEST_LOCK_EXCLUDED_(g_gmock_mutex) UntypedFindMatchingExpectation() Declaration virtual const ExpectationBase* testing::internal::FunctionMockerBase<F>::UntypedFindMatchingExpectation(const void *untyped_args, const void **untyped_action, bool *is_excessive, ::std::ostream *what, ::std::ostream *why) GTEST_LOCK_EXCLUDED_(g_gmock_mutex) UntypedPrintArgs() Declaration virtual void testing::internal::FunctionMockerBase<F>::UntypedPrintArgs(const void *untyped_args, ::std::ostream *os) const FindMatchingExpectationLocked() Declaration TypedExpectation<F>* testing::internal::FunctionMockerBase<F>::FindMatchingExpectationLocked(const ArgumentTuple&args) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) FormatUnexpectedCallMessageLocked() Declaration void testing::internal::FunctionMockerBase<F>::FormatUnexpectedCallMessageLocked(const ArgumentTuple&args, ::std::ostream *os, ::std::ostream *why) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) PrintTriedExpectationsLocked() Declaration void testing::internal::FunctionMockerBase<F>::PrintTriedExpectationsLocked(const ArgumentTuple&args, ::std::ostream *why) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::FunctionMockerBase<F>::GTEST_DISALLOW_COPY_AND_ASSIGN_(FunctionMockerBase)"
  },
  "api/testing/internal/function-mocker.html": {
    "href": "api/testing/internal/function-mocker.html",
    "title": "Class testing::internal::FunctionMocker | qiotoolkit",
    "keywords": "Class testing::internal::FunctionMocker Inheritance testing::internal::FunctionMocker"
  },
  "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/00/01-a9/08/4.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/00/01-a9/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8, A9)>::With(const Matcher<A1>&m1, const Matcher<A2>&m2, const Matcher<A3>&m3, const Matcher<A4>&m4, const Matcher<A5>&m5, const Matcher<A6>&m6, const Matcher<A7>&m7, const Matcher<A8>&m8, const Matcher<A9>&m9) Invoke() Declaration R testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8, A9)>::Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9)"
  },
  "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/08/4.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8)>::With(const Matcher<A1>&m1, const Matcher<A2>&m2, const Matcher<A3>&m3, const Matcher<A4>&m4, const Matcher<A5>&m5, const Matcher<A6>&m6, const Matcher<A7>&m7, const Matcher<A8>&m8) Invoke() Declaration R testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8)>::Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8)"
  },
  "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/08/4.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7)>::With(const Matcher<A1>&m1, const Matcher<A2>&m2, const Matcher<A3>&m3, const Matcher<A4>&m4, const Matcher<A5>&m5, const Matcher<A6>&m6, const Matcher<A7>&m7) Invoke() Declaration R testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7)>::Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)"
  },
  "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/0079295c90ba14a714e84d5a856a5b50dd.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/0079295c90ba14a714e84d5a856a5b50dd.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::With(const Matcher<A1>&m1, const Matcher<A2>&m2, const Matcher<A3>&m3, const Matcher<A4>&m4, const Matcher<A5>&m5, const Matcher<A6>&m6, const Matcher<A7>&m7, const Matcher<A8>&m8, const Matcher<A9>&m9, const Matcher<A10>&m10) Invoke() Declaration R testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10)"
  },
  "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/08/4.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5, A6)>::With(const Matcher<A1>&m1, const Matcher<A2>&m2, const Matcher<A3>&m3, const Matcher<A4>&m4, const Matcher<A5>&m5, const Matcher<A6>&m6) Invoke() Declaration R testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5, A6)>::Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)"
  },
  "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/08/4.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5)>::With(const Matcher<A1>&m1, const Matcher<A2>&m2, const Matcher<A3>&m3, const Matcher<A4>&m4, const Matcher<A5>&m5) Invoke() Declaration R testing::internal::FunctionMocker<R(A1, A2, A3, A4, A5)>::Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)"
  },
  "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/08/4.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R(A1, A2, A3, A4)>::With(const Matcher<A1>&m1, const Matcher<A2>&m2, const Matcher<A3>&m3, const Matcher<A4>&m4) Invoke() Declaration R testing::internal::FunctionMocker<R(A1, A2, A3, A4)>::Invoke(A1 a1, A2 a2, A3 a3, A4 a4)"
  },
  "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/08/4.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/00/01-a3/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R(A1, A2, A3)>::With(const Matcher<A1>&m1, const Matcher<A2>&m2, const Matcher<A3>&m3) Invoke() Declaration R testing::internal::FunctionMocker<R(A1, A2, A3)>::Invoke(A1 a1, A2 a2, A3 a3)"
  },
  "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/08/4.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07-a1/00/01-a2/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R(A1, A2)>::With(const Matcher<A1>&m1, const Matcher<A2>&m2) Invoke() Declaration R testing::internal::FunctionMocker<R(A1, A2)>::Invoke(A1 a1, A2 a2)"
  },
  "api/testing/internal/function-mocker/3/01-r/07-a1/08/4.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07-a1/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R(A1)>::With(const Matcher<A1>&m1) Invoke() Declaration R testing::internal::FunctionMocker<R(A1)>::Invoke(A1 a1)"
  },
  "api/testing/internal/function-mocker/3/01-r/07/08/4.html": {
    "href": "api/testing/internal/function-mocker/3/01-r/07/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::FunctionMockerBase > Inherited Members FunctionMockerBase AddNewOnCallSpec PerformDefaultAction UntypedPerformDefaultAction FindOnCallSpec ~FunctionMockerBase UntypedPerformAction AddNewExpectation InvokeWith ClearDefaultActionsLocked Methods With() Declaration MockSpec<F>testing::internal::FunctionMocker<R()>::With() Invoke() Declaration R testing::internal::FunctionMocker<R()>::Invoke()"
  },
  "api/testing/internal/function.html": {
    "href": "api/testing/internal/function.html",
    "title": "Struct testing::internal::Function | qiotoolkit",
    "keywords": "Struct testing::internal::Function"
  },
  "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/00/01-a9/00/01-a10/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/00/01-a9/00/01-a10/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/00/01-a9/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/00/01-a9/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/00/01-a4/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-a1/00/01-a2/00/01-a3/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07-a1/00/01-a2/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-a1/00/01-a2/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07-a1/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-a1/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07-args/8/8/8/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07-args/8/8/8/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/function/3/01-r/07/08/4.html": {
    "href": "api/testing/internal/function/3/01-r/07/08/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/ge-matcher.html": {
    "href": "api/testing/internal/ge-matcher.html",
    "title": "Class testing::internal::GeMatcher | qiotoolkit",
    "keywords": "Class testing::internal::GeMatcher Inheritance testing::internal::ComparisonBase testing::internal::GeMatcher Inherited Members > ComparisonBase Constructors GeMatcher() Declaration testing::internal::GeMatcher<Rhs>::GeMatcher(const Rhs&rhs) Methods Desc() Declaration static const char* testing::internal::GeMatcher<Rhs>::Desc() NegatedDesc() Declaration static const char* testing::internal::GeMatcher<Rhs>::NegatedDesc()"
  },
  "api/testing/internal/ge2-matcher.html": {
    "href": "api/testing/internal/ge2-matcher.html",
    "title": "Class testing::internal::Ge2Matcher | qiotoolkit",
    "keywords": "Class testing::internal::Ge2Matcher Inheritance testing::internal::PairMatchBase testing::internal::Ge2Matcher Inherited Members > > Methods Desc() Declaration static const char* testing::internal::Ge2Matcher::Desc()"
  },
  "api/testing/internal/google-test-failure-reporter.html": {
    "href": "api/testing/internal/google-test-failure-reporter.html",
    "title": "Class testing::internal::GoogleTestFailureReporter | qiotoolkit",
    "keywords": "Class testing::internal::GoogleTestFailureReporter Inheritance testing::internal::GoogleTestFailureReporter Methods ReportFailure() Declaration void testing::internal::GoogleTestFailureReporter::ReportFailure(FailureType type, const char *file, int line, const std::string&message) override ReportFailure() Declaration virtual void testing::internal::GoogleTestFailureReporter::ReportFailure(FailureType type, const char *file, int line, const std::string&message)"
  },
  "api/testing/internal/gt-matcher.html": {
    "href": "api/testing/internal/gt-matcher.html",
    "title": "Class testing::internal::GtMatcher | qiotoolkit",
    "keywords": "Class testing::internal::GtMatcher Inheritance testing::internal::ComparisonBase testing::internal::GtMatcher Inherited Members > ComparisonBase Constructors GtMatcher() Declaration testing::internal::GtMatcher<Rhs>::GtMatcher(const Rhs&rhs) Methods Desc() Declaration static const char* testing::internal::GtMatcher<Rhs>::Desc() NegatedDesc() Declaration static const char* testing::internal::GtMatcher<Rhs>::NegatedDesc()"
  },
  "api/testing/internal/gt2-matcher.html": {
    "href": "api/testing/internal/gt2-matcher.html",
    "title": "Class testing::internal::Gt2Matcher | qiotoolkit",
    "keywords": "Class testing::internal::Gt2Matcher Inheritance testing::internal::PairMatchBase testing::internal::Gt2Matcher Inherited Members > > Methods Desc() Declaration static const char* testing::internal::Gt2Matcher::Desc()"
  },
  "api/testing/internal/gtest-flag-saver.html": {
    "href": "api/testing/internal/gtest-flag-saver.html",
    "title": "Class testing::internal::GTestFlagSaver | qiotoolkit",
    "keywords": "Class testing::internal::GTestFlagSaver Inheritance testing::internal::GTestFlagSaver Constructors GTestFlagSaver() Declaration testing::internal::GTestFlagSaver::GTestFlagSaver() Methods ~GTestFlagSaver() Declaration testing::internal::GTestFlagSaver::~GTestFlagSaver()"
  },
  "api/testing/internal/gtest-log.html": {
    "href": "api/testing/internal/gtest-log.html",
    "title": "Class testing::internal::GTestLog | qiotoolkit",
    "keywords": "Class testing::internal::GTestLog Inheritance testing::internal::GTestLog Constructors GTestLog() Declaration testing::internal::GTestLog::GTestLog(GTestLogSeverity severity, const char *file, int line) GTestLog() Declaration testing::internal::GTestLog::GTestLog(GTestLogSeverity severity, const char *file, int line) Methods ~GTestLog() Declaration testing::internal::GTestLog::~GTestLog() GetStream() Declaration ::std::ostream&testing::internal::GTestLog::GetStream() ~GTestLog() Declaration testing::internal::GTestLog::~GTestLog() GetStream() Declaration ::std::ostream&testing::internal::GTestLog::GetStream() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::GTestLog::GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestLog) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::GTestLog::GTEST_DISALLOW_COPY_AND_ASSIGN_(GTestLog)"
  },
  "api/testing/internal/gtest-mutex-lock.html": {
    "href": "api/testing/internal/gtest-mutex-lock.html",
    "title": "Class testing::internal::GTestMutexLock | qiotoolkit",
    "keywords": "Class testing::internal::GTestMutexLock Inheritance testing::internal::GTestMutexLock Constructors GTestMutexLock() Declaration testing::internal::GTestMutexLock::GTestMutexLock(Mutex *) GTestMutexLock() Declaration testing::internal::GTestMutexLock::GTestMutexLock(Mutex *)"
  },
  "api/testing/internal/has-new-fatal-failure-helper.html": {
    "href": "api/testing/internal/has-new-fatal-failure-helper.html",
    "title": "Class testing::internal::HasNewFatalFailureHelper | qiotoolkit",
    "keywords": "Class testing::internal::HasNewFatalFailureHelper Inheritance testing::TestPartResultReporterInterface testing::internal::HasNewFatalFailureHelper Inherited Members ~TestPartResultReporterInterface Constructors HasNewFatalFailureHelper() Declaration testing::internal::HasNewFatalFailureHelper::HasNewFatalFailureHelper() Methods ~HasNewFatalFailureHelper() Declaration testing::internal::HasNewFatalFailureHelper::~HasNewFatalFailureHelper() ReportTestPartResult() Declaration void testing::internal::HasNewFatalFailureHelper::ReportTestPartResult(const TestPartResult&result) has_new_fatal_failure() Declaration bool testing::internal::HasNewFatalFailureHelper::has_new_fatal_failure() const GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::HasNewFatalFailureHelper::GTEST_DISALLOW_COPY_AND_ASSIGN_(HasNewFatalFailureHelper)"
  },
  "api/testing/internal/has-substr-matcher.html": {
    "href": "api/testing/internal/has-substr-matcher.html",
    "title": "Class testing::internal::HasSubstrMatcher | qiotoolkit",
    "keywords": "Class testing::internal::HasSubstrMatcher Inheritance testing::internal::HasSubstrMatcher Constructors HasSubstrMatcher() Declaration testing::internal::HasSubstrMatcher<StringType>::HasSubstrMatcher(const StringType&substring) Methods MatchAndExplain() Declaration bool testing::internal::HasSubstrMatcher<StringType>::MatchAndExplain(CharType *s, MatchResultListener *listener) const MatchAndExplain() Declaration bool testing::internal::HasSubstrMatcher<StringType>::MatchAndExplain(const MatcheeStringType&s, MatchResultListener *) const DescribeTo() Declaration void testing::internal::HasSubstrMatcher<StringType>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::HasSubstrMatcher<StringType>::DescribeNegationTo(::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::HasSubstrMatcher<StringType>::GTEST_DISALLOW_ASSIGN_(HasSubstrMatcher)"
  },
  "api/testing/internal/has-value-type.html": {
    "href": "api/testing/internal/has-value-type.html",
    "title": "Struct testing::internal::HasValueType | qiotoolkit",
    "keywords": "Struct testing::internal::HasValueType"
  },
  "api/testing/internal/has-value-type/3/01-t/00/01-void-t/3/01typename/01-t/value/type/01/4/01/4.html": {
    "href": "api/testing/internal/has-value-type/3/01-t/00/01-void-t/3/01typename/01-t/value/type/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/ignore-result-action.html": {
    "href": "api/testing/internal/ignore-result-action.html",
    "title": "Class testing::internal::IgnoreResultAction | qiotoolkit",
    "keywords": "Class testing::internal::IgnoreResultAction Inheritance testing::internal::IgnoreResultAction Constructors IgnoreResultAction() Declaration testing::internal::IgnoreResultAction<A>::IgnoreResultAction(const A&action) IgnoreResultAction() Declaration testing::internal::IgnoreResultAction<A>::IgnoreResultAction(const A&action) Methods >() Declaration testing::internal::IgnoreResultAction<A>::operator Action<F>() const >() Declaration testing::internal::IgnoreResultAction<A>::operator Action<F>() const >() Declaration testing::internal::IgnoreResultAction<A>::operator Action<F>() const >() Declaration testing::internal::IgnoreResultAction<A>::operator Action<F>() const >() Declaration testing::internal::IgnoreResultAction<A>::operator Action<F>() const >() Declaration testing::internal::IgnoreResultAction<A>::operator Action<F>() const >() Declaration testing::internal::IgnoreResultAction<A>::operator Action<F>() const >() Declaration testing::internal::IgnoreResultAction<A>::operator Action<F>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::IgnoreResultAction<A>::GTEST_DISALLOW_ASSIGN_(IgnoreResultAction) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::IgnoreResultAction<A>::GTEST_DISALLOW_ASSIGN_(IgnoreResultAction)"
  },
  "api/testing/internal/ignore-result-action/impl.html": {
    "href": "api/testing/internal/ignore-result-action/impl.html",
    "title": "Class testing::internal::IgnoreResultAction::Impl | qiotoolkit",
    "keywords": "Class testing::internal::IgnoreResultAction::Impl Inheritance testing::ActionInterface testing::internal::IgnoreResultAction::Impl Inherited Members ActionInterface ~ActionInterface Constructors Impl() Declaration testing::internal::IgnoreResultAction<A>::Impl<F>::Impl(const A&action) Impl() Declaration testing::internal::IgnoreResultAction<A>::Impl<F>::Impl(const A&action) Methods Perform() Declaration void testing::internal::IgnoreResultAction<A>::Impl<F>::Perform(const ArgumentTuple&args) override Perform() Declaration virtual void testing::internal::IgnoreResultAction<A>::Impl<F>::Perform(const ArgumentTuple&args) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::IgnoreResultAction<A>::Impl<F>::GTEST_DISALLOW_ASSIGN_(Impl) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::IgnoreResultAction<A>::Impl<F>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/ignored-value.html": {
    "href": "api/testing/internal/ignored-value.html",
    "title": "Class testing::internal::IgnoredValue | qiotoolkit",
    "keywords": "Class testing::internal::IgnoredValue Inheritance testing::internal::IgnoredValue Constructors IgnoredValue() Declaration testing::internal::IgnoredValue::IgnoredValue(const T&) IgnoredValue() Declaration testing::internal::IgnoredValue::IgnoredValue(const T&)"
  },
  "api/testing/internal/ignored-value/sink.html": {
    "href": "api/testing/internal/ignored-value/sink.html",
    "title": "Struct testing::internal::IgnoredValue::Sink | qiotoolkit",
    "keywords": "Struct testing::internal::IgnoredValue::Sink"
  },
  "api/testing/internal/implicitly-convertible.html": {
    "href": "api/testing/internal/implicitly-convertible.html",
    "title": "Class testing::internal::ImplicitlyConvertible | qiotoolkit",
    "keywords": "Class testing::internal::ImplicitlyConvertible Inheritance testing::internal::ImplicitlyConvertible Methods MakeFrom() Declaration static AddReference<From>::type testing::internal::ImplicitlyConvertible<From, To>::MakeFrom() Helper() Declaration static char testing::internal::ImplicitlyConvertible<From, To>::Helper(To) Helper() Declaration static char(&testing::internal::ImplicitlyConvertible<From, To>::Helper(...))[2]"
  },
  "api/testing/internal/index-sequence.html": {
    "href": "api/testing/internal/index-sequence.html",
    "title": "Struct testing::internal::IndexSequence | qiotoolkit",
    "keywords": "Struct testing::internal::IndexSequence"
  },
  "api/testing/internal/invoke-action.html": {
    "href": "api/testing/internal/invoke-action.html",
    "title": "Class testing::internal::InvokeAction | qiotoolkit",
    "keywords": "Class testing::internal::InvokeAction Inheritance testing::internal::InvokeAction Constructors InvokeAction() Declaration testing::internal::InvokeAction<FunctionImpl>::InvokeAction(FunctionImpl function_impl) Methods Perform() Declaration Result testing::internal::InvokeAction<FunctionImpl>::Perform(const ArgumentTuple&args) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::InvokeAction<FunctionImpl>::GTEST_DISALLOW_ASSIGN_(InvokeAction)"
  },
  "api/testing/internal/invoke-callback-action.html": {
    "href": "api/testing/internal/invoke-callback-action.html",
    "title": "Class testing::internal::InvokeCallbackAction | qiotoolkit",
    "keywords": "Class testing::internal::InvokeCallbackAction Inheritance testing::internal::InvokeCallbackAction Constructors InvokeCallbackAction() Declaration testing::internal::InvokeCallbackAction<CallbackType>::InvokeCallbackAction(CallbackType *callback) Methods Perform() Declaration Result testing::internal::InvokeCallbackAction<CallbackType>::Perform(const ArgumentTuple&args) const"
  },
  "api/testing/internal/invoke-callback-without-args-action.html": {
    "href": "api/testing/internal/invoke-callback-without-args-action.html",
    "title": "Class testing::internal::InvokeCallbackWithoutArgsAction | qiotoolkit",
    "keywords": "Class testing::internal::InvokeCallbackWithoutArgsAction Inheritance testing::internal::InvokeCallbackWithoutArgsAction Constructors InvokeCallbackWithoutArgsAction() Declaration testing::internal::InvokeCallbackWithoutArgsAction<CallbackType>::InvokeCallbackWithoutArgsAction(CallbackType *callback) Methods Perform() Declaration Result testing::internal::InvokeCallbackWithoutArgsAction<CallbackType>::Perform(const ArgumentTuple&) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::InvokeCallbackWithoutArgsAction<CallbackType>::GTEST_DISALLOW_ASSIGN_(InvokeCallbackWithoutArgsAction)"
  },
  "api/testing/internal/invoke-helper.html": {
    "href": "api/testing/internal/invoke-helper.html",
    "title": "Class testing::internal::InvokeHelper | qiotoolkit",
    "keywords": "Class testing::internal::InvokeHelper Inheritance testing::internal::InvokeHelper"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/01/4/01/4.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/01/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5>>::Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5>&args) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<A1, A2, A3, A4, A5>&args) InvokeCallback() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5>>::InvokeCallback(CallbackType *callback, const ::testing::tuple<A1, A2, A3, A4, A5>&args)"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a4/01/4/01/4.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a4/01/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4>>::Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4>&args) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<A1, A2, A3, A4>&args) InvokeCallback() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4>>::InvokeCallback(CallbackType *callback, const ::testing::tuple<A1, A2, A3, A4>&args)"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/01/4/01/4.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/01/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3>>::Invoke(Function function, const ::testing::tuple<A1, A2, A3>&args) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<A1, A2, A3>&args) InvokeCallback() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3>>::InvokeCallback(CallbackType *callback, const ::testing::tuple<A1, A2, A3>&args)"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/129338555c00c55487bfe9fa59e479ab.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/129338555c00c55487bfe9fa59e479ab.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6>>::Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5, A6>&args) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<A1, A2, A3, A4, A5, A6>&args)"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/1c5f66c8b5e7674a520f1ea38507628c.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/1c5f66c8b5e7674a520f1ea38507628c.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9>>::Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9>&args) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9>&args)"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/3417e5c524ad74e18b0b4b31a005e438.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/3417e5c524ad74e18b0b4b31a005e438.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8>>::Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8>&args) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8>&args)"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/39d55f6ea73f4d04a19cf9b6bab3a605.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/39d55f6ea73f4d04a19cf9b6bab3a605.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7>>::Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7>&args) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7>&args)"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/9a04af5e172e051ec3c8faaa2f50b42f.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/9a04af5e172e051ec3c8faaa2f50b42f.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>>::Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>&args) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>&args)"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/01/4/01/4.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/00/01-a2/01/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2>>::Invoke(Function function, const ::testing::tuple<A1, A2>&args) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<A1, A2>&args) InvokeCallback() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1, A2>>::InvokeCallback(CallbackType *callback, const ::testing::tuple<A1, A2>&args)"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/01/4/01/4.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/01-a1/01/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1>>::Invoke(Function function, const ::testing::tuple<A1>&args) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<A1>&args) InvokeCallback() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<A1>>::InvokeCallback(CallbackType *callback, const ::testing::tuple<A1>&args)"
  },
  "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/4/01/4.html": {
    "href": "api/testing/internal/invoke-helper/3/01-r/00/0/1testing/tuple/3/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Invoke() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<>>::Invoke(Function function, const ::testing::tuple<>&) InvokeMethod() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<>>::InvokeMethod(Class *obj_ptr, MethodPtr method_ptr, const ::testing::tuple<>&) InvokeCallback() Declaration static R testing::internal::InvokeHelper<R, ::testing::tuple<>>::InvokeCallback(CallbackType *callback, const ::testing::tuple<>&)"
  },
  "api/testing/internal/invoke-method-action.html": {
    "href": "api/testing/internal/invoke-method-action.html",
    "title": "Class testing::internal::InvokeMethodAction | qiotoolkit",
    "keywords": "Class testing::internal::InvokeMethodAction Inheritance testing::internal::InvokeMethodAction Constructors InvokeMethodAction() Declaration testing::internal::InvokeMethodAction<Class, MethodPtr>::InvokeMethodAction(Class *obj_ptr, MethodPtr method_ptr) Methods operator()() Declaration auto testing::internal::InvokeMethodAction<Class, MethodPtr>::operator()(Args&&... args) const ->decltype((obj_ptr->*method_ptr)(std::forward<Args>(args)...)) Perform() Declaration Result testing::internal::InvokeMethodAction<Class, MethodPtr>::Perform(const ArgumentTuple&args) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::InvokeMethodAction<Class, MethodPtr>::GTEST_DISALLOW_ASSIGN_(InvokeMethodAction)"
  },
  "api/testing/internal/invoke-method-without-args-action.html": {
    "href": "api/testing/internal/invoke-method-without-args-action.html",
    "title": "Class testing::internal::InvokeMethodWithoutArgsAction | qiotoolkit",
    "keywords": "Class testing::internal::InvokeMethodWithoutArgsAction Inheritance testing::internal::InvokeMethodWithoutArgsAction Constructors InvokeMethodWithoutArgsAction() Declaration testing::internal::InvokeMethodWithoutArgsAction<Class, MethodPtr>::InvokeMethodWithoutArgsAction(Class *obj_ptr, MethodPtr method_ptr) Methods operator()() Declaration ReturnType testing::internal::InvokeMethodWithoutArgsAction<Class, MethodPtr>::operator()(const Args&...) const Perform() Declaration Result testing::internal::InvokeMethodWithoutArgsAction<Class, MethodPtr>::Perform(const ArgumentTuple&) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::InvokeMethodWithoutArgsAction<Class, MethodPtr>::GTEST_DISALLOW_ASSIGN_(InvokeMethodWithoutArgsAction)"
  },
  "api/testing/internal/invoke-without-args-action.html": {
    "href": "api/testing/internal/invoke-without-args-action.html",
    "title": "Class testing::internal::InvokeWithoutArgsAction | qiotoolkit",
    "keywords": "Class testing::internal::InvokeWithoutArgsAction Inheritance testing::internal::InvokeWithoutArgsAction Constructors InvokeWithoutArgsAction() Declaration testing::internal::InvokeWithoutArgsAction<FunctionImpl>::InvokeWithoutArgsAction(FunctionImpl function_impl) Methods operator()() Declaration auto testing::internal::InvokeWithoutArgsAction<FunctionImpl>::operator()(const Args&...) ->decltype(function_impl()) Perform() Declaration Result testing::internal::InvokeWithoutArgsAction<FunctionImpl>::Perform(const ArgumentTuple&) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::InvokeWithoutArgsAction<FunctionImpl>::GTEST_DISALLOW_ASSIGN_(InvokeWithoutArgsAction)"
  },
  "api/testing/internal/invoke/argument/adl-tag.html": {
    "href": "api/testing/internal/invoke/argument/adl-tag.html",
    "title": "Struct testing::internal::invoke_argument::AdlTag | qiotoolkit",
    "keywords": "Struct testing::internal::invoke_argument::AdlTag"
  },
  "api/testing/internal/is-aprotocol-message.html": {
    "href": "api/testing/internal/is-aprotocol-message.html",
    "title": "Struct testing::internal::IsAProtocolMessage | qiotoolkit",
    "keywords": "Struct testing::internal::IsAProtocolMessage"
  },
  "api/testing/internal/is-hash-table.html": {
    "href": "api/testing/internal/is-hash-table.html",
    "title": "Struct testing::internal::IsHashTable | qiotoolkit",
    "keywords": "Struct testing::internal::IsHashTable Methods test() Declaration static char testing::internal::IsHashTable<T>::test(typename U::hasher *, typename U::reverse_iterator *) test() Declaration static int testing::internal::IsHashTable<T>::test(typename U::hasher *,...) test() Declaration static char testing::internal::IsHashTable<T>::test(...) test() Declaration static char testing::internal::IsHashTable<T>::test(typename U::hasher *, typename U::reverse_iterator *) test() Declaration static int testing::internal::IsHashTable<T>::test(typename U::hasher *,...) test() Declaration static char testing::internal::IsHashTable<T>::test(...)"
  },
  "api/testing/internal/is-null-matcher.html": {
    "href": "api/testing/internal/is-null-matcher.html",
    "title": "Class testing::internal::IsNullMatcher | qiotoolkit",
    "keywords": "Class testing::internal::IsNullMatcher Inheritance testing::internal::IsNullMatcher Methods MatchAndExplain() Declaration bool testing::internal::IsNullMatcher::MatchAndExplain(const Pointer&p, MatchResultListener *) const DescribeTo() Declaration void testing::internal::IsNullMatcher::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::IsNullMatcher::DescribeNegationTo(::std::ostream *os) const"
  },
  "api/testing/internal/is-recursive-container-impl.html": {
    "href": "api/testing/internal/is-recursive-container-impl.html",
    "title": "Struct testing::internal::IsRecursiveContainerImpl | qiotoolkit",
    "keywords": "Struct testing::internal::IsRecursiveContainerImpl"
  },
  "api/testing/internal/is-recursive-container-impl/3/01-c/00/01false/00/01-hv/01/4.html": {
    "href": "api/testing/internal/is-recursive-container-impl/3/01-c/00/01false/00/01-hv/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/is-recursive-container-impl/3/01-c/00/01false/01/4.html": {
    "href": "api/testing/internal/is-recursive-container-impl/3/01-c/00/01false/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/is-recursive-container-impl/3/01-c/00/01true/00/01false/01/4.html": {
    "href": "api/testing/internal/is-recursive-container-impl/3/01-c/00/01true/00/01false/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/is-recursive-container-impl/3/01-c/00/01true/00/01true/01/4.html": {
    "href": "api/testing/internal/is-recursive-container-impl/3/01-c/00/01true/00/01true/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/is-recursive-container-impl/3/01-c/00/01true/01/4.html": {
    "href": "api/testing/internal/is-recursive-container-impl/3/01-c/00/01true/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/is-recursive-container.html": {
    "href": "api/testing/internal/is-recursive-container.html",
    "title": "Struct testing::internal::IsRecursiveContainer | qiotoolkit",
    "keywords": "Struct testing::internal::IsRecursiveContainer"
  },
  "api/testing/internal/is-same.html": {
    "href": "api/testing/internal/is-same.html",
    "title": "Struct testing::internal::IsSame | qiotoolkit",
    "keywords": "Struct testing::internal::IsSame"
  },
  "api/testing/internal/is-same/3/01-t/00/01-t/01/4.html": {
    "href": "api/testing/internal/is-same/3/01-t/00/01-t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/is/pointer.html": {
    "href": "api/testing/internal/is/pointer.html",
    "title": "Struct testing::internal::is_pointer | qiotoolkit",
    "keywords": "Struct testing::internal::is_pointer"
  },
  "api/testing/internal/is/pointer/3/01-t/01/5/01/4.html": {
    "href": "api/testing/internal/is/pointer/3/01-t/01/5/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/is/reference.html": {
    "href": "api/testing/internal/is/reference.html",
    "title": "Struct testing::internal::is_reference | qiotoolkit",
    "keywords": "Struct testing::internal::is_reference"
  },
  "api/testing/internal/is/reference/3/01-t/01/6/01/4.html": {
    "href": "api/testing/internal/is/reference/3/01-t/01/6/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/is/same.html": {
    "href": "api/testing/internal/is/same.html",
    "title": "Struct testing::internal::is_same | qiotoolkit",
    "keywords": "Struct testing::internal::is_same"
  },
  "api/testing/internal/is/same/3/01-t/00/01-t/01/4.html": {
    "href": "api/testing/internal/is/same/3/01-t/00/01-t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/iterator-traits.html": {
    "href": "api/testing/internal/iterator-traits.html",
    "title": "Struct testing::internal::IteratorTraits | qiotoolkit",
    "keywords": "Struct testing::internal::IteratorTraits"
  },
  "api/testing/internal/iterator-traits/3/01-t/01/5/01/4.html": {
    "href": "api/testing/internal/iterator-traits/3/01-t/01/5/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/iterator-traits/3/01const/01-t/01/5/01/4.html": {
    "href": "api/testing/internal/iterator-traits/3/01const/01-t/01/5/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/json-unit-test-result-printer.html": {
    "href": "api/testing/internal/json-unit-test-result-printer.html",
    "title": "Class testing::internal::JsonUnitTestResultPrinter | qiotoolkit",
    "keywords": "Class testing::internal::JsonUnitTestResultPrinter Inheritance testing::EmptyTestEventListener testing::internal::JsonUnitTestResultPrinter Inherited Members OnEnvironmentsTearDownStart OnTestProgramEnd OnEnvironmentsSetUpStart OnTestStart OnTestSuiteStart OnTestIterationStart OnEnvironmentsTearDownStart OnTestPartResult OnTestCaseEnd OnEnvironmentsSetUpStart OnTestEnd OnTestCaseStart OnTestIterationStart OnTestStart OnEnvironmentsSetUpEnd OnTestProgramStart OnTestProgramEnd OnTestPartResult OnEnvironmentsSetUpEnd OnTestCaseEnd OnTestProgramStart OnEnvironmentsTearDownEnd OnTestCaseStart OnEnvironmentsTearDownEnd OnTestSuiteEnd OnTestEnd ~TestEventListener Constructors JsonUnitTestResultPrinter() Declaration testing::internal::JsonUnitTestResultPrinter::JsonUnitTestResultPrinter(const char *output_file) JsonUnitTestResultPrinter() Declaration testing::internal::JsonUnitTestResultPrinter::JsonUnitTestResultPrinter(const char *output_file) Methods OnTestIterationEnd() Declaration void testing::internal::JsonUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&unit_test, int iteration) override OnTestIterationEnd() Declaration virtual void testing::internal::JsonUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&unit_test, int iteration) PrintJsonTestList() Declaration void testing::internal::JsonUnitTestResultPrinter::PrintJsonTestList(::std::ostream *stream, const std::vector<TestSuite *>&test_suites) EscapeJson() Declaration std::string testing::internal::JsonUnitTestResultPrinter::EscapeJson(const std::string&str) OutputJsonKey() Declaration void testing::internal::JsonUnitTestResultPrinter::OutputJsonKey(std::ostream *stream, const std::string&element_name, const std::string&name, const std::string&value, const std::string&indent, bool comma=true) OutputJsonKey() Declaration void testing::internal::JsonUnitTestResultPrinter::OutputJsonKey(std::ostream *stream, const std::string&element_name, const std::string&name, int value, const std::string&indent, bool comma=true) OutputJsonTestInfo() Declaration void testing::internal::JsonUnitTestResultPrinter::OutputJsonTestInfo(::std::ostream *stream, const char *test_suite_name, const TestInfo&test_info) PrintJsonTestSuite() Declaration void testing::internal::JsonUnitTestResultPrinter::PrintJsonTestSuite(::std::ostream *stream, const TestSuite&test_suite) PrintJsonUnitTest() Declaration static void testing::internal::JsonUnitTestResultPrinter::PrintJsonUnitTest(::std::ostream *stream, const UnitTest&unit_test) TestPropertiesAsJson() Declaration std::string testing::internal::JsonUnitTestResultPrinter::TestPropertiesAsJson(const TestResult&result, const std::string&indent) EscapeJson() Declaration static std::string testing::internal::JsonUnitTestResultPrinter::EscapeJson(const std::string&str) OutputJsonKey() Declaration static void testing::internal::JsonUnitTestResultPrinter::OutputJsonKey(std::ostream *stream, const std::string&element_name, const std::string&name, const std::string&value, const std::string&indent, bool comma=true) OutputJsonKey() Declaration static void testing::internal::JsonUnitTestResultPrinter::OutputJsonKey(std::ostream *stream, const std::string&element_name, const std::string&name, int value, const std::string&indent, bool comma=true) OutputJsonTestInfo() Declaration static void testing::internal::JsonUnitTestResultPrinter::OutputJsonTestInfo(::std::ostream *stream, const char *test_case_name, const TestInfo&test_info) PrintJsonTestCase() Declaration void testing::internal::JsonUnitTestResultPrinter::PrintJsonTestCase(::std::ostream *stream, const TestCase&test_case) PrintJsonUnitTest() Declaration static void testing::internal::JsonUnitTestResultPrinter::PrintJsonUnitTest(::std::ostream *stream, const UnitTest&unit_test) TestPropertiesAsJson() Declaration static std::string testing::internal::JsonUnitTestResultPrinter::TestPropertiesAsJson(const TestResult&result, const std::string&indent) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::JsonUnitTestResultPrinter::GTEST_DISALLOW_COPY_AND_ASSIGN_(JsonUnitTestResultPrinter) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::JsonUnitTestResultPrinter::GTEST_DISALLOW_COPY_AND_ASSIGN_(JsonUnitTestResultPrinter)"
  },
  "api/testing/internal/key-matcher-impl.html": {
    "href": "api/testing/internal/key-matcher-impl.html",
    "title": "Class testing::internal::KeyMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::KeyMatcherImpl Inheritance testing::MatcherInterface testing::internal::KeyMatcherImpl Inherited Members ~MatcherDescriberInterface Constructors KeyMatcherImpl() Declaration testing::internal::KeyMatcherImpl<PairType>::KeyMatcherImpl(InnerMatcher inner_matcher) Methods GTEST_REMOVE_REFERENCE_AND_CONST_() Declaration typedef testing::internal::KeyMatcherImpl<PairType>::GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType MatchAndExplain() Declaration virtual bool testing::internal::KeyMatcherImpl<PairType>::MatchAndExplain(PairType key_value, MatchResultListener *listener) const DescribeTo() Declaration virtual void testing::internal::KeyMatcherImpl<PairType>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::KeyMatcherImpl<PairType>::DescribeNegationTo(::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::KeyMatcherImpl<PairType>::GTEST_DISALLOW_ASSIGN_(KeyMatcherImpl)"
  },
  "api/testing/internal/key-matcher.html": {
    "href": "api/testing/internal/key-matcher.html",
    "title": "Class testing::internal::KeyMatcher | qiotoolkit",
    "keywords": "Class testing::internal::KeyMatcher Inheritance testing::internal::KeyMatcher Constructors KeyMatcher() Declaration testing::internal::KeyMatcher<M>::KeyMatcher(M m) Methods >() Declaration testing::internal::KeyMatcher<M>::operator Matcher<PairType>() const >() Declaration testing::internal::KeyMatcher<M>::operator Matcher<PairType>() const >() Declaration testing::internal::KeyMatcher<M>::operator Matcher<PairType>() const >() Declaration testing::internal::KeyMatcher<M>::operator Matcher<PairType>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::KeyMatcher<M>::GTEST_DISALLOW_ASSIGN_(KeyMatcher)"
  },
  "api/testing/internal/kind-of.html": {
    "href": "api/testing/internal/kind-of.html",
    "title": "Struct testing::internal::KindOf | qiotoolkit",
    "keywords": "Struct testing::internal::KindOf"
  },
  "api/testing/internal/le-matcher.html": {
    "href": "api/testing/internal/le-matcher.html",
    "title": "Class testing::internal::LeMatcher | qiotoolkit",
    "keywords": "Class testing::internal::LeMatcher Inheritance testing::internal::ComparisonBase testing::internal::LeMatcher Inherited Members > ComparisonBase Constructors LeMatcher() Declaration testing::internal::LeMatcher<Rhs>::LeMatcher(const Rhs&rhs) Methods Desc() Declaration static const char* testing::internal::LeMatcher<Rhs>::Desc() NegatedDesc() Declaration static const char* testing::internal::LeMatcher<Rhs>::NegatedDesc()"
  },
  "api/testing/internal/le2-matcher.html": {
    "href": "api/testing/internal/le2-matcher.html",
    "title": "Class testing::internal::Le2Matcher | qiotoolkit",
    "keywords": "Class testing::internal::Le2Matcher Inheritance testing::internal::PairMatchBase testing::internal::Le2Matcher Inherited Members > > Methods Desc() Declaration static const char* testing::internal::Le2Matcher::Desc()"
  },
  "api/testing/internal/less-comparator.html": {
    "href": "api/testing/internal/less-comparator.html",
    "title": "Struct testing::internal::LessComparator | qiotoolkit",
    "keywords": "Struct testing::internal::LessComparator Methods operator()() Declaration bool testing::internal::LessComparator::operator()(const T&lhs, const U&rhs) const"
  },
  "api/testing/internal/linked-ptr-less-than.html": {
    "href": "api/testing/internal/linked-ptr-less-than.html",
    "title": "Struct testing::internal::LinkedPtrLessThan | qiotoolkit",
    "keywords": "Struct testing::internal::LinkedPtrLessThan Methods operator()() Declaration bool testing::internal::LinkedPtrLessThan<T>::operator()(const ::testing::internal::linked_ptr<T>&lhs, const ::testing::internal::linked_ptr<T>&rhs) const"
  },
  "api/testing/internal/linked/ptr.html": {
    "href": "api/testing/internal/linked/ptr.html",
    "title": "Class testing::internal::linked_ptr | qiotoolkit",
    "keywords": "Class testing::internal::linked_ptr Inheritance testing::internal::linked_ptr Constructors linked_ptr() Declaration testing::internal::linked_ptr<T>::linked_ptr(T *ptr=NULL) linked_ptr() Declaration testing::internal::linked_ptr<T>::linked_ptr(linked_ptr<U>const&ptr) linked_ptr() Declaration testing::internal::linked_ptr<T>::linked_ptr(linked_ptr const&ptr) Methods ~linked_ptr() Declaration testing::internal::linked_ptr<T>::~linked_ptr() operator=() Declaration linked_ptr&testing::internal::linked_ptr<T>::operator=(linked_ptr<U>const&ptr) operator=() Declaration linked_ptr&testing::internal::linked_ptr<T>::operator=(linked_ptr const&ptr) reset() Declaration void testing::internal::linked_ptr<T>::reset(T *ptr=NULL) get() Declaration T* testing::internal::linked_ptr<T>::get() const >() Declaration T* testing::internal::linked_ptr<T>::operator->() const >() Declaration T* testing::internal::linked_ptr<T>::operator->() const operator*() Declaration T&testing::internal::linked_ptr<T>::operator*() const operator==() Declaration bool testing::internal::linked_ptr<T>::operator==(T *p) const operator!=() Declaration bool testing::internal::linked_ptr<T>::operator!=(T *p) const operator==() Declaration bool testing::internal::linked_ptr<T>::operator==(linked_ptr<U>const&ptr) const operator!=() Declaration bool testing::internal::linked_ptr<T>::operator!=(linked_ptr<U>const&ptr) const depart() Declaration void testing::internal::linked_ptr<T>::depart() capture() Declaration void testing::internal::linked_ptr<T>::capture(T *ptr) copy() Declaration void testing::internal::linked_ptr<T>::copy(linked_ptr<U>const *ptr)"
  },
  "api/testing/internal/linked/ptr/internal.html": {
    "href": "api/testing/internal/linked/ptr/internal.html",
    "title": "Class testing::internal::linked_ptr_internal | qiotoolkit",
    "keywords": "Class testing::internal::linked_ptr_internal Inheritance testing::internal::linked_ptr_internal Methods join_new() Declaration void testing::internal::linked_ptr_internal::join_new() join() Declaration void testing::internal::linked_ptr_internal::join(linked_ptr_internal const *ptr) GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) depart() Declaration bool testing::internal::linked_ptr_internal::depart() GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex)"
  },
  "api/testing/internal/lossless-arithmetic-convertible-impl.html": {
    "href": "api/testing/internal/lossless-arithmetic-convertible-impl.html",
    "title": "Struct testing::internal::LosslessArithmeticConvertibleImpl | qiotoolkit",
    "keywords": "Struct testing::internal::LosslessArithmeticConvertibleImpl"
  },
  "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-bool/00/01bool/00/01k-bool/00/01bool/01/4.html": {
    "href": "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-bool/00/01bool/00/01k-bool/00/01bool/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-bool/00/01bool/00/01k-floating-point/00/01-to/01/4.html": {
    "href": "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-bool/00/01bool/00/01k-floating-point/00/01-to/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-bool/00/01bool/00/01k-integer/00/01-to/01/4.html": {
    "href": "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-bool/00/01bool/00/01k-integer/00/01-to/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-floating-point/00/01-from/00/01k-bool/00/01bool/01/4.html": {
    "href": "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-floating-point/00/01-from/00/01k-bool/00/01bool/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-floating-point/00/01-from/00/01k-integer/00/01-to/01/4.html": {
    "href": "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-floating-point/00/01-from/00/01k-integer/00/01-to/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-integer/00/01-from/00/01k-bool/00/01bool/01/4.html": {
    "href": "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-integer/00/01-from/00/01k-bool/00/01bool/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-integer/00/01-from/00/01k-floating-point/00/01-to/01/4.html": {
    "href": "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-integer/00/01-from/00/01k-floating-point/00/01-to/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-integer/00/01-from/00/01k-integer/00/01-to/01/4.html": {
    "href": "api/testing/internal/lossless-arithmetic-convertible-impl/3/01k-integer/00/01-from/00/01k-integer/00/01-to/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/lt-matcher.html": {
    "href": "api/testing/internal/lt-matcher.html",
    "title": "Class testing::internal::LtMatcher | qiotoolkit",
    "keywords": "Class testing::internal::LtMatcher Inheritance testing::internal::ComparisonBase testing::internal::LtMatcher Inherited Members > ComparisonBase Constructors LtMatcher() Declaration testing::internal::LtMatcher<Rhs>::LtMatcher(const Rhs&rhs) Methods Desc() Declaration static const char* testing::internal::LtMatcher<Rhs>::Desc() NegatedDesc() Declaration static const char* testing::internal::LtMatcher<Rhs>::NegatedDesc()"
  },
  "api/testing/internal/lt2-matcher.html": {
    "href": "api/testing/internal/lt2-matcher.html",
    "title": "Class testing::internal::Lt2Matcher | qiotoolkit",
    "keywords": "Class testing::internal::Lt2Matcher Inheritance testing::internal::PairMatchBase testing::internal::Lt2Matcher Inherited Members > > Methods Desc() Declaration static const char* testing::internal::Lt2Matcher::Desc()"
  },
  "api/testing/internal/make-index-sequence.html": {
    "href": "api/testing/internal/make-index-sequence.html",
    "title": "Struct testing::internal::MakeIndexSequence | qiotoolkit",
    "keywords": "Struct testing::internal::MakeIndexSequence"
  },
  "api/testing/internal/make-index-sequence/3/010/01/4.html": {
    "href": "api/testing/internal/make-index-sequence/3/010/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/match-matrix.html": {
    "href": "api/testing/internal/match-matrix.html",
    "title": "Class testing::internal::MatchMatrix | qiotoolkit",
    "keywords": "Class testing::internal::MatchMatrix Inheritance testing::internal::MatchMatrix Constructors MatchMatrix() Declaration testing::internal::MatchMatrix::MatchMatrix(size_t num_elements, size_t num_matchers) Methods LhsSize() Declaration size_t testing::internal::MatchMatrix::LhsSize() const RhsSize() Declaration size_t testing::internal::MatchMatrix::RhsSize() const HasEdge() Declaration bool testing::internal::MatchMatrix::HasEdge(size_t ilhs, size_t irhs) const SetEdge() Declaration void testing::internal::MatchMatrix::SetEdge(size_t ilhs, size_t irhs, bool b) NextGraph() Declaration bool testing::internal::MatchMatrix::NextGraph() Randomize() Declaration void testing::internal::MatchMatrix::Randomize() DebugString() Declaration std::string testing::internal::MatchMatrix::DebugString() const SpaceIndex() Declaration size_t testing::internal::MatchMatrix::SpaceIndex(size_t ilhs, size_t irhs) const"
  },
  "api/testing/internal/matcher-as-predicate.html": {
    "href": "api/testing/internal/matcher-as-predicate.html",
    "title": "Class testing::internal::MatcherAsPredicate | qiotoolkit",
    "keywords": "Class testing::internal::MatcherAsPredicate Inheritance testing::internal::MatcherAsPredicate Constructors MatcherAsPredicate() Declaration testing::internal::MatcherAsPredicate<M>::MatcherAsPredicate(M matcher) Methods operator()() Declaration bool testing::internal::MatcherAsPredicate<M>::operator()(const T&x) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::MatcherAsPredicate<M>::GTEST_DISALLOW_ASSIGN_(MatcherAsPredicate)"
  },
  "api/testing/internal/matcher-base.html": {
    "href": "api/testing/internal/matcher-base.html",
    "title": "Class testing::internal::MatcherBase | qiotoolkit",
    "keywords": "Class testing::internal::MatcherBase Inheritance testing::internal::MatcherBase Constructors MatcherBase() Declaration testing::internal::MatcherBase<T>::MatcherBase() MatcherBase() Declaration testing::internal::MatcherBase<T>::MatcherBase(const MatcherInterface<GTEST_REFERENCE_TO_CONST_(T)>*impl) MatcherBase() Declaration testing::internal::MatcherBase<T>::MatcherBase(const MatcherInterface<U>*impl, typename internal::EnableIf<!internal::IsSame<U, GTEST_REFERENCE_TO_CONST_(U)>::value>::type *=NULL) Methods MatchAndExplain() Declaration bool testing::internal::MatcherBase<T>::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(T) x, MatchResultListener *listener) const Matches() Declaration bool testing::internal::MatcherBase<T>::Matches(GTEST_REFERENCE_TO_CONST_(T) x) const DescribeTo() Declaration void testing::internal::MatcherBase<T>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::MatcherBase<T>::DescribeNegationTo(::std::ostream *os) const ExplainMatchResultTo() Declaration void testing::internal::MatcherBase<T>::ExplainMatchResultTo(GTEST_REFERENCE_TO_CONST_(T) x, ::std::ostream *os) const GetDescriber() Declaration const MatcherDescriberInterface* testing::internal::MatcherBase<T>::GetDescriber() const ~MatcherBase() Declaration virtual testing::internal::MatcherBase<T>::~MatcherBase()"
  },
  "api/testing/internal/matcher-cast-impl.html": {
    "href": "api/testing/internal/matcher-cast-impl.html",
    "title": "Class testing::internal::MatcherCastImpl | qiotoolkit",
    "keywords": "Class testing::internal::MatcherCastImpl Inheritance testing::internal::MatcherCastImpl Methods Cast() Declaration static Matcher<T>testing::internal::MatcherCastImpl<T, M>::Cast(const M&polymorphic_matcher_or_value) CastImpl() Declaration static Matcher<T>testing::internal::MatcherCastImpl<T, M>::CastImpl(const M&polymorphic_matcher_or_value, BooleanConstant<true>, BooleanConstant<Ignore>) CastImpl() Declaration static Matcher<T>testing::internal::MatcherCastImpl<T, M>::CastImpl(const M&value, BooleanConstant<false>, BooleanConstant<true>) CastImpl() Declaration Matcher<T>testing::internal::MatcherCastImpl<T, M>::CastImpl(const M&value, BooleanConstant<false>, BooleanConstant<false>)"
  },
  "api/testing/internal/matcher-cast-impl/3/01-t/00/01-matcher/3/01-t/01/4/01/4.html": {
    "href": "api/testing/internal/matcher-cast-impl/3/01-t/00/01-matcher/3/01-t/01/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Cast() Declaration static Matcher<T>testing::internal::MatcherCastImpl<T, Matcher<T>>::Cast(const Matcher<T>&matcher)"
  },
  "api/testing/internal/matcher-cast-impl/3/01-t/00/01-matcher/3/01-u/01/4/01/4.html": {
    "href": "api/testing/internal/matcher-cast-impl/3/01-t/00/01-matcher/3/01-u/01/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Cast() Declaration static Matcher<T>testing::internal::MatcherCastImpl<T, Matcher<U>>::Cast(const Matcher<U>&source_matcher)"
  },
  "api/testing/internal/matcher-cast-impl/3/01-t/00/01-matcher/3/01-u/01/4/01/4/impl.html": {
    "href": "api/testing/internal/matcher-cast-impl/3/01-t/00/01-matcher/3/01-u/01/4/01/4/impl.html",
    "title": "Class ::Impl | qiotoolkit",
    "keywords": "Class ::Impl Inheritance testing::MatcherInterface ::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::MatcherCastImpl<T, Matcher<U>>::Impl::Impl(const Matcher<U>&source_matcher) Methods MatchAndExplain() Declaration virtual bool testing::internal::MatcherCastImpl<T, Matcher<U>>::Impl::MatchAndExplain(T x, MatchResultListener *listener) const DescribeTo() Declaration virtual void testing::internal::MatcherCastImpl<T, Matcher<U>>::Impl::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::MatcherCastImpl<T, Matcher<U>>::Impl::DescribeNegationTo(::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::MatcherCastImpl<T, Matcher<U>>::Impl::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/matcher-interface-adapter.html": {
    "href": "api/testing/internal/matcher-interface-adapter.html",
    "title": "Class testing::internal::MatcherInterfaceAdapter | qiotoolkit",
    "keywords": "Class testing::internal::MatcherInterfaceAdapter Inheritance testing::MatcherInterface testing::internal::MatcherInterfaceAdapter Inherited Members ~MatcherDescriberInterface Constructors MatcherInterfaceAdapter() Declaration testing::internal::MatcherInterfaceAdapter<T>::MatcherInterfaceAdapter(const MatcherInterface<T>*impl) Methods ~MatcherInterfaceAdapter() Declaration virtual testing::internal::MatcherInterfaceAdapter<T>::~MatcherInterfaceAdapter() DescribeTo() Declaration virtual void testing::internal::MatcherInterfaceAdapter<T>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::MatcherInterfaceAdapter<T>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::MatcherInterfaceAdapter<T>::MatchAndExplain(const T&x, MatchResultListener *listener) const GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::MatcherInterfaceAdapter<T>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MatcherInterfaceAdapter)"
  },
  "api/testing/internal/matcher-tuple.html": {
    "href": "api/testing/internal/matcher-tuple.html",
    "title": "Struct testing::internal::MatcherTuple | qiotoolkit",
    "keywords": "Struct testing::internal::MatcherTuple"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/01/4/01/4.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/01/4/01/4.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a4/01/4/01/4.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a4/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a63c742e825c64dbe2671b0a407b3db47.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-a63c742e825c64dbe2671b0a407b3db47.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-aa256ea461b02eca0db9561b7bbf2c82d.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-aa256ea461b02eca0db9561b7bbf2c82d.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-aa73012c63a4e11ec83732b0fb70972c7.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-aa73012c63a4e11ec83732b0fb70972c7.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-aed2bba98e2ef5f11a8df3506707ec6d8.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/00/01-aed2bba98e2ef5f11a8df3506707ec6d8.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/01/4/01/4.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/00/01-a3/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/01/4/01/4.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/00/01-a2/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/01/4/01/4.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/01-a1/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/4/01/4.html": {
    "href": "api/testing/internal/matcher-tuple/3/0/1testing/tuple/3/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/matches-regex-matcher.html": {
    "href": "api/testing/internal/matches-regex-matcher.html",
    "title": "Class testing::internal::MatchesRegexMatcher | qiotoolkit",
    "keywords": "Class testing::internal::MatchesRegexMatcher Inheritance testing::internal::MatchesRegexMatcher Constructors MatchesRegexMatcher() Declaration testing::internal::MatchesRegexMatcher::MatchesRegexMatcher(const RE *regex, bool full_match) Methods MatchAndExplain() Declaration bool testing::internal::MatchesRegexMatcher::MatchAndExplain(CharType *s, MatchResultListener *listener) const MatchAndExplain() Declaration bool testing::internal::MatchesRegexMatcher::MatchAndExplain(const MatcheeStringType&s, MatchResultListener *) const DescribeTo() Declaration void testing::internal::MatchesRegexMatcher::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::MatchesRegexMatcher::DescribeNegationTo(::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::MatchesRegexMatcher::GTEST_DISALLOW_ASSIGN_(MatchesRegexMatcher)"
  },
  "api/testing/internal/max-bipartite-match-state.html": {
    "href": "api/testing/internal/max-bipartite-match-state.html",
    "title": "Class testing::internal::MaxBipartiteMatchState | qiotoolkit",
    "keywords": "Class testing::internal::MaxBipartiteMatchState Inheritance testing::internal::MaxBipartiteMatchState Constructors MaxBipartiteMatchState() Declaration testing::internal::MaxBipartiteMatchState::MaxBipartiteMatchState(const MatchMatrix&graph) MaxBipartiteMatchState() Declaration testing::internal::MaxBipartiteMatchState::MaxBipartiteMatchState(const MatchMatrix&graph) Methods Compute() Declaration ElementMatcherPairs testing::internal::MaxBipartiteMatchState::Compute() Compute() Declaration ElementMatcherPairs testing::internal::MaxBipartiteMatchState::Compute() TryAugment() Declaration bool testing::internal::MaxBipartiteMatchState::TryAugment(size_t ilhs, ::std::vector<char>*seen) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::MaxBipartiteMatchState::GTEST_DISALLOW_ASSIGN_(MaxBipartiteMatchState) TryAugment() Declaration bool testing::internal::MaxBipartiteMatchState::TryAugment(size_t ilhs, ::std::vector<char>*seen) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::MaxBipartiteMatchState::GTEST_DISALLOW_ASSIGN_(MaxBipartiteMatchState)"
  },
  "api/testing/internal/mock-spec.html": {
    "href": "api/testing/internal/mock-spec.html",
    "title": "Class testing::internal::MockSpec | qiotoolkit",
    "keywords": "Class testing::internal::MockSpec Inheritance testing::internal::MockSpec Constructors MockSpec() Declaration testing::internal::MockSpec<F>::MockSpec(internal::FunctionMockerBase<F>*function_mocker, const ArgumentMatcherTuple&matchers) Methods InternalDefaultActionSetAt() Declaration internal::OnCallSpec<F>&testing::internal::MockSpec<F>::InternalDefaultActionSetAt(const char *file, int line, const char *obj, const char *call) InternalExpectedAt() Declaration internal::TypedExpectation<F>&testing::internal::MockSpec<F>::InternalExpectedAt(const char *file, int line, const char *obj, const char *call) operator()() Declaration MockSpec<F>&testing::internal::MockSpec<F>::operator()(const internal::WithoutMatchers&, void *const) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::MockSpec<F>::GTEST_DISALLOW_ASSIGN_(MockSpec)"
  },
  "api/testing/internal/mutex.html": {
    "href": "api/testing/internal/mutex.html",
    "title": "Class testing::internal::Mutex | qiotoolkit",
    "keywords": "Class testing::internal::Mutex Inheritance testing::internal::Mutex Constructors Mutex() Declaration testing::internal::Mutex::Mutex() Mutex() Declaration testing::internal::Mutex::Mutex() Methods Lock() Declaration void testing::internal::Mutex::Lock() Unlock() Declaration void testing::internal::Mutex::Unlock() AssertHeld() Declaration void testing::internal::Mutex::AssertHeld() const Lock() Declaration void testing::internal::Mutex::Lock() Unlock() Declaration void testing::internal::Mutex::Unlock() AssertHeld() Declaration void testing::internal::Mutex::AssertHeld() const"
  },
  "api/testing/internal/native-array.html": {
    "href": "api/testing/internal/native-array.html",
    "title": "Class testing::internal::NativeArray | qiotoolkit",
    "keywords": "Class testing::internal::NativeArray Inheritance testing::internal::NativeArray Constructors NativeArray() Declaration testing::internal::NativeArray<Element>::NativeArray(const Element *array, size_t count, RelationToSourceReference) NativeArray() Declaration testing::internal::NativeArray<Element>::NativeArray(const Element *array, size_t count, RelationToSourceCopy) NativeArray() Declaration testing::internal::NativeArray<Element>::NativeArray(const NativeArray&rhs) NativeArray() Declaration testing::internal::NativeArray<Element>::NativeArray(const Element *array, size_t count, RelationToSourceReference) NativeArray() Declaration testing::internal::NativeArray<Element>::NativeArray(const Element *array, size_t count, RelationToSourceCopy) NativeArray() Declaration testing::internal::NativeArray<Element>::NativeArray(const NativeArray&rhs) Methods ~NativeArray() Declaration testing::internal::NativeArray<Element>::~NativeArray() size() Declaration size_t testing::internal::NativeArray<Element>::size() const begin() Declaration const_iterator testing::internal::NativeArray<Element>::begin() const end() Declaration const_iterator testing::internal::NativeArray<Element>::end() const operator==() Declaration bool testing::internal::NativeArray<Element>::operator==(const NativeArray&rhs) const ~NativeArray() Declaration testing::internal::NativeArray<Element>::~NativeArray() size() Declaration size_t testing::internal::NativeArray<Element>::size() const begin() Declaration const_iterator testing::internal::NativeArray<Element>::begin() const end() Declaration const_iterator testing::internal::NativeArray<Element>::end() const operator==() Declaration bool testing::internal::NativeArray<Element>::operator==(const NativeArray&rhs) const InitCopy() Declaration void testing::internal::NativeArray<Element>::InitCopy(const Element *array, size_t a_size) InitRef() Declaration void testing::internal::NativeArray<Element>::InitRef(const Element *array, size_t a_size) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::NativeArray<Element>::GTEST_DISALLOW_ASSIGN_(NativeArray) InitCopy() Declaration void testing::internal::NativeArray<Element>::InitCopy(const Element *array, size_t a_size) InitRef() Declaration void testing::internal::NativeArray<Element>::InitRef(const Element *array, size_t a_size) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::NativeArray<Element>::GTEST_DISALLOW_ASSIGN_(NativeArray)"
  },
  "api/testing/internal/ne-matcher.html": {
    "href": "api/testing/internal/ne-matcher.html",
    "title": "Class testing::internal::NeMatcher | qiotoolkit",
    "keywords": "Class testing::internal::NeMatcher Inheritance testing::internal::ComparisonBase testing::internal::NeMatcher Inherited Members > ComparisonBase Constructors NeMatcher() Declaration testing::internal::NeMatcher<Rhs>::NeMatcher(const Rhs&rhs) Methods Desc() Declaration static const char* testing::internal::NeMatcher<Rhs>::Desc() NegatedDesc() Declaration static const char* testing::internal::NeMatcher<Rhs>::NegatedDesc()"
  },
  "api/testing/internal/ne2-matcher.html": {
    "href": "api/testing/internal/ne2-matcher.html",
    "title": "Class testing::internal::Ne2Matcher | qiotoolkit",
    "keywords": "Class testing::internal::Ne2Matcher Inheritance testing::internal::PairMatchBase testing::internal::Ne2Matcher Inherited Members > > Methods Desc() Declaration static const char* testing::internal::Ne2Matcher::Desc()"
  },
  "api/testing/internal/not-matcher-impl.html": {
    "href": "api/testing/internal/not-matcher-impl.html",
    "title": "Class testing::internal::NotMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::NotMatcherImpl Inheritance testing::MatcherInterface testing::internal::NotMatcherImpl Inherited Members ~MatcherDescriberInterface Constructors NotMatcherImpl() Declaration testing::internal::NotMatcherImpl<T>::NotMatcherImpl(const Matcher<T>&matcher) Methods MatchAndExplain() Declaration virtual bool testing::internal::NotMatcherImpl<T>::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(T) x, MatchResultListener *listener) const DescribeTo() Declaration virtual void testing::internal::NotMatcherImpl<T>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::NotMatcherImpl<T>::DescribeNegationTo(::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::NotMatcherImpl<T>::GTEST_DISALLOW_ASSIGN_(NotMatcherImpl)"
  },
  "api/testing/internal/not-matcher.html": {
    "href": "api/testing/internal/not-matcher.html",
    "title": "Class testing::internal::NotMatcher | qiotoolkit",
    "keywords": "Class testing::internal::NotMatcher Inheritance testing::internal::NotMatcher Constructors NotMatcher() Declaration testing::internal::NotMatcher<InnerMatcher>::NotMatcher(InnerMatcher matcher) Methods >() Declaration testing::internal::NotMatcher<InnerMatcher>::operator Matcher<T>() const >() Declaration testing::internal::NotMatcher<InnerMatcher>::operator Matcher<T>() const >() Declaration testing::internal::NotMatcher<InnerMatcher>::operator Matcher<T>() const >() Declaration testing::internal::NotMatcher<InnerMatcher>::operator Matcher<T>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::NotMatcher<InnerMatcher>::GTEST_DISALLOW_ASSIGN_(NotMatcher)"
  },
  "api/testing/internal/not-null-matcher.html": {
    "href": "api/testing/internal/not-null-matcher.html",
    "title": "Class testing::internal::NotNullMatcher | qiotoolkit",
    "keywords": "Class testing::internal::NotNullMatcher Inheritance testing::internal::NotNullMatcher Methods MatchAndExplain() Declaration bool testing::internal::NotNullMatcher::MatchAndExplain(const Pointer&p, MatchResultListener *) const DescribeTo() Declaration void testing::internal::NotNullMatcher::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::NotNullMatcher::DescribeNegationTo(::std::ostream *os) const"
  },
  "api/testing/internal/on-call-spec.html": {
    "href": "api/testing/internal/on-call-spec.html",
    "title": "Class testing::internal::OnCallSpec | qiotoolkit",
    "keywords": "Class testing::internal::OnCallSpec Inheritance testing::internal::UntypedOnCallSpecBase testing::internal::OnCallSpec Inherited Members line ExpectSpecProperty file AssertSpecProperty Clause UntypedOnCallSpecBase Constructors OnCallSpec() Declaration testing::internal::OnCallSpec<F>::OnCallSpec(const char *a_file, int a_line, const ArgumentMatcherTuple&matchers) Methods With() Declaration OnCallSpec&testing::internal::OnCallSpec<F>::With(const Matcher<const ArgumentTuple&>&m) WillByDefault() Declaration OnCallSpec&testing::internal::OnCallSpec<F>::WillByDefault(const Action<F>&action) Matches() Declaration bool testing::internal::OnCallSpec<F>::Matches(const ArgumentTuple&args) const GetAction() Declaration const Action<F>&testing::internal::OnCallSpec<F>::GetAction() const"
  },
  "api/testing/internal/optional-matcher.html": {
    "href": "api/testing/internal/optional-matcher.html",
    "title": "Class testing::internal::OptionalMatcher | qiotoolkit",
    "keywords": "Class testing::internal::OptionalMatcher Inheritance testing::internal::OptionalMatcher Constructors OptionalMatcher() Declaration testing::internal::OptionalMatcher<ValueMatcher>::OptionalMatcher(const ValueMatcher&value_matcher) Methods >() Declaration testing::internal::OptionalMatcher<ValueMatcher>::operator Matcher<Optional>() const >() Declaration testing::internal::OptionalMatcher<ValueMatcher>::operator Matcher<Optional>() const >() Declaration testing::internal::OptionalMatcher<ValueMatcher>::operator Matcher<Optional>() const >() Declaration testing::internal::OptionalMatcher<ValueMatcher>::operator Matcher<Optional>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::OptionalMatcher<ValueMatcher>::GTEST_DISALLOW_ASSIGN_(OptionalMatcher)"
  },
  "api/testing/internal/optional-matcher/impl.html": {
    "href": "api/testing/internal/optional-matcher/impl.html",
    "title": "Class testing::internal::OptionalMatcher::Impl | qiotoolkit",
    "keywords": "Class testing::internal::OptionalMatcher::Impl Inheritance testing::MatcherInterface testing::internal::OptionalMatcher::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::OptionalMatcher<ValueMatcher>::Impl<Optional>::Impl(const ValueMatcher&value_matcher) Methods GTEST_REMOVE_REFERENCE_AND_CONST_() Declaration typedef testing::internal::OptionalMatcher<ValueMatcher>::Impl<Optional>::GTEST_REMOVE_REFERENCE_AND_CONST_(Optional) OptionalView DescribeTo() Declaration virtual void testing::internal::OptionalMatcher<ValueMatcher>::Impl<Optional>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::OptionalMatcher<ValueMatcher>::Impl<Optional>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::OptionalMatcher<ValueMatcher>::Impl<Optional>::MatchAndExplain(Optional optional, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::OptionalMatcher<ValueMatcher>::Impl<Optional>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/os-stack-trace-getter-interface.html": {
    "href": "api/testing/internal/os-stack-trace-getter-interface.html",
    "title": "Class testing::internal::OsStackTraceGetterInterface | qiotoolkit",
    "keywords": "Class testing::internal::OsStackTraceGetterInterface Inheritance testing::internal::OsStackTraceGetterInterface testing::internal::OsStackTraceGetter Constructors OsStackTraceGetterInterface() Declaration testing::internal::OsStackTraceGetterInterface::OsStackTraceGetterInterface() Methods ~OsStackTraceGetterInterface() Declaration virtual testing::internal::OsStackTraceGetterInterface::~OsStackTraceGetterInterface() CurrentStackTrace() Declaration virtual std::string testing::internal::OsStackTraceGetterInterface::CurrentStackTrace(int max_depth, int skip_count)=0 UponLeavingGTest() Declaration virtual void testing::internal::OsStackTraceGetterInterface::UponLeavingGTest()=0 GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::OsStackTraceGetterInterface::GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetterInterface)"
  },
  "api/testing/internal/os-stack-trace-getter.html": {
    "href": "api/testing/internal/os-stack-trace-getter.html",
    "title": "Class testing::internal::OsStackTraceGetter | qiotoolkit",
    "keywords": "Class testing::internal::OsStackTraceGetter Inheritance testing::internal::OsStackTraceGetterInterface testing::internal::OsStackTraceGetter Inherited Members ~OsStackTraceGetterInterface OsStackTraceGetterInterface Constructors OsStackTraceGetter() Declaration testing::internal::OsStackTraceGetter::OsStackTraceGetter() Methods CurrentStackTrace() Declaration std::string testing::internal::OsStackTraceGetter::CurrentStackTrace(int max_depth, int skip_count) UponLeavingGTest() Declaration void testing::internal::OsStackTraceGetter::UponLeavingGTest() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::OsStackTraceGetter::GTEST_DISALLOW_COPY_AND_ASSIGN_(OsStackTraceGetter)"
  },
  "api/testing/internal/pair-match-base.html": {
    "href": "api/testing/internal/pair-match-base.html",
    "title": "Class testing::internal::PairMatchBase | qiotoolkit",
    "keywords": "Class testing::internal::PairMatchBase Inheritance testing::internal::PairMatchBase Methods >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<::testing::tuple<T1, T2>>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<const ::testing::tuple<T1, T2>&>() const >() Declaration testing::internal::PairMatchBase<D, Op>::operator Matcher<const ::testing::tuple<T1, T2>&>() const GetDesc() Declaration ::std::ostream&testing::internal::PairMatchBase<D, Op>::GetDesc(::std::ostream&os)"
  },
  "api/testing/internal/pair-match-base/impl.html": {
    "href": "api/testing/internal/pair-match-base/impl.html",
    "title": "Class testing::internal::PairMatchBase::Impl | qiotoolkit",
    "keywords": "Class testing::internal::PairMatchBase::Impl Inheritance testing::MatcherInterface testing::internal::PairMatchBase::Impl Inherited Members ~MatcherDescriberInterface Methods MatchAndExplain() Declaration virtual bool testing::internal::PairMatchBase<D, Op>::Impl<Tuple>::MatchAndExplain(Tuple args, MatchResultListener *) const DescribeTo() Declaration virtual void testing::internal::PairMatchBase<D, Op>::Impl<Tuple>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::PairMatchBase<D, Op>::Impl<Tuple>::DescribeNegationTo(::std::ostream *os) const"
  },
  "api/testing/internal/pair-matcher-impl.html": {
    "href": "api/testing/internal/pair-matcher-impl.html",
    "title": "Class testing::internal::PairMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::PairMatcherImpl Inheritance testing::MatcherInterface testing::internal::PairMatcherImpl Inherited Members ~MatcherDescriberInterface Constructors PairMatcherImpl() Declaration testing::internal::PairMatcherImpl<PairType>::PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher) Methods GTEST_REMOVE_REFERENCE_AND_CONST_() Declaration typedef testing::internal::PairMatcherImpl<PairType>::GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType DescribeTo() Declaration virtual void testing::internal::PairMatcherImpl<PairType>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::PairMatcherImpl<PairType>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::PairMatcherImpl<PairType>::MatchAndExplain(PairType a_pair, MatchResultListener *listener) const ExplainSuccess() Declaration void testing::internal::PairMatcherImpl<PairType>::ExplainSuccess(const std::string&first_explanation, const std::string&second_explanation, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::PairMatcherImpl<PairType>::GTEST_DISALLOW_ASSIGN_(PairMatcherImpl)"
  },
  "api/testing/internal/pair-matcher.html": {
    "href": "api/testing/internal/pair-matcher.html",
    "title": "Class testing::internal::PairMatcher | qiotoolkit",
    "keywords": "Class testing::internal::PairMatcher Inheritance testing::internal::PairMatcher Constructors PairMatcher() Declaration testing::internal::PairMatcher<FirstMatcher, SecondMatcher>::PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher) Methods >() Declaration testing::internal::PairMatcher<FirstMatcher, SecondMatcher>::operator Matcher<PairType>() const >() Declaration testing::internal::PairMatcher<FirstMatcher, SecondMatcher>::operator Matcher<PairType>() const >() Declaration testing::internal::PairMatcher<FirstMatcher, SecondMatcher>::operator Matcher<PairType>() const >() Declaration testing::internal::PairMatcher<FirstMatcher, SecondMatcher>::operator Matcher<PairType>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::PairMatcher<FirstMatcher, SecondMatcher>::GTEST_DISALLOW_ASSIGN_(PairMatcher)"
  },
  "api/testing/internal/param-generator-interface.html": {
    "href": "api/testing/internal/param-generator-interface.html",
    "title": "Class testing::internal::ParamGeneratorInterface | qiotoolkit",
    "keywords": "Class testing::internal::ParamGeneratorInterface Inheritance testing::internal::ParamGeneratorInterface testing::internal::RangeGenerator testing::internal::ValuesInIteratorRangeGenerator Methods ~ParamGeneratorInterface() Declaration virtual testing::internal::ParamGeneratorInterface<T>::~ParamGeneratorInterface() Begin() Declaration virtual ParamIteratorInterface<T>* testing::internal::ParamGeneratorInterface<T>::Begin() const =0 End() Declaration virtual ParamIteratorInterface<T>* testing::internal::ParamGeneratorInterface<T>::End() const =0 ~ParamGeneratorInterface() Declaration virtual testing::internal::ParamGeneratorInterface<T>::~ParamGeneratorInterface() Begin() Declaration virtual ParamIteratorInterface<T>* testing::internal::ParamGeneratorInterface<T>::Begin() const =0 End() Declaration virtual ParamIteratorInterface<T>* testing::internal::ParamGeneratorInterface<T>::End() const =0"
  },
  "api/testing/internal/param-generator.html": {
    "href": "api/testing/internal/param-generator.html",
    "title": "Class testing::internal::ParamGenerator | qiotoolkit",
    "keywords": "Class testing::internal::ParamGenerator Inheritance testing::internal::ParamGenerator Constructors ParamGenerator() Declaration testing::internal::ParamGenerator<T>::ParamGenerator(ParamGeneratorInterface<T>*impl) ParamGenerator() Declaration testing::internal::ParamGenerator<T>::ParamGenerator(const ParamGenerator&other) ParamGenerator() Declaration testing::internal::ParamGenerator<T>::ParamGenerator(ParamGeneratorInterface<T>*impl) ParamGenerator() Declaration testing::internal::ParamGenerator<T>::ParamGenerator(const ParamGenerator&other) Methods operator=() Declaration ParamGenerator&testing::internal::ParamGenerator<T>::operator=(const ParamGenerator&other) begin() Declaration iterator testing::internal::ParamGenerator<T>::begin() const end() Declaration iterator testing::internal::ParamGenerator<T>::end() const operator=() Declaration ParamGenerator&testing::internal::ParamGenerator<T>::operator=(const ParamGenerator&other) begin() Declaration iterator testing::internal::ParamGenerator<T>::begin() const end() Declaration iterator testing::internal::ParamGenerator<T>::end() const"
  },
  "api/testing/internal/param-iterator-interface.html": {
    "href": "api/testing/internal/param-iterator-interface.html",
    "title": "Class testing::internal::ParamIteratorInterface | qiotoolkit",
    "keywords": "Class testing::internal::ParamIteratorInterface Inheritance testing::internal::ParamIteratorInterface Methods ~ParamIteratorInterface() Declaration virtual testing::internal::ParamIteratorInterface<T>::~ParamIteratorInterface() BaseGenerator() Declaration virtual const ParamGeneratorInterface<T>* testing::internal::ParamIteratorInterface<T>::BaseGenerator() const =0 Advance() Declaration virtual void testing::internal::ParamIteratorInterface<T>::Advance()=0 Clone() Declaration virtual ParamIteratorInterface* testing::internal::ParamIteratorInterface<T>::Clone() const =0 Current() Declaration virtual const T* testing::internal::ParamIteratorInterface<T>::Current() const =0 Equals() Declaration virtual bool testing::internal::ParamIteratorInterface<T>::Equals(const ParamIteratorInterface&other) const =0 ~ParamIteratorInterface() Declaration virtual testing::internal::ParamIteratorInterface<T>::~ParamIteratorInterface() BaseGenerator() Declaration virtual const ParamGeneratorInterface<T>* testing::internal::ParamIteratorInterface<T>::BaseGenerator() const =0 Advance() Declaration virtual void testing::internal::ParamIteratorInterface<T>::Advance()=0 Clone() Declaration virtual ParamIteratorInterface* testing::internal::ParamIteratorInterface<T>::Clone() const =0 Current() Declaration virtual const T* testing::internal::ParamIteratorInterface<T>::Current() const =0 Equals() Declaration virtual bool testing::internal::ParamIteratorInterface<T>::Equals(const ParamIteratorInterface&other) const =0"
  },
  "api/testing/internal/param-iterator.html": {
    "href": "api/testing/internal/param-iterator.html",
    "title": "Class testing::internal::ParamIterator | qiotoolkit",
    "keywords": "Class testing::internal::ParamIterator Inheritance testing::internal::ParamIterator Constructors ParamIterator() Declaration testing::internal::ParamIterator<T>::ParamIterator(const ParamIterator&other) ParamIterator() Declaration testing::internal::ParamIterator<T>::ParamIterator(const ParamIterator&other) ParamIterator() Declaration testing::internal::ParamIterator<T>::ParamIterator(ParamIteratorInterface<T>*impl) ParamIterator() Declaration testing::internal::ParamIterator<T>::ParamIterator(ParamIteratorInterface<T>*impl) Methods operator=() Declaration ParamIterator&testing::internal::ParamIterator<T>::operator=(const ParamIterator&other) operator*() Declaration const T&testing::internal::ParamIterator<T>::operator*() const >() Declaration const T* testing::internal::ParamIterator<T>::operator->() const >() Declaration const T* testing::internal::ParamIterator<T>::operator->() const operator++() Declaration ParamIterator&testing::internal::ParamIterator<T>::operator++() operator++() Declaration ParamIterator testing::internal::ParamIterator<T>::operator++(int) operator==() Declaration bool testing::internal::ParamIterator<T>::operator==(const ParamIterator&other) const operator!=() Declaration bool testing::internal::ParamIterator<T>::operator!=(const ParamIterator&other) const operator=() Declaration ParamIterator&testing::internal::ParamIterator<T>::operator=(const ParamIterator&other) operator*() Declaration const T&testing::internal::ParamIterator<T>::operator*() const >() Declaration const T* testing::internal::ParamIterator<T>::operator->() const >() Declaration const T* testing::internal::ParamIterator<T>::operator->() const operator++() Declaration ParamIterator&testing::internal::ParamIterator<T>::operator++() operator++() Declaration ParamIterator testing::internal::ParamIterator<T>::operator++(int) operator==() Declaration bool testing::internal::ParamIterator<T>::operator==(const ParamIterator&other) const operator!=() Declaration bool testing::internal::ParamIterator<T>::operator!=(const ParamIterator&other) const"
  },
  "api/testing/internal/param-name-gen-func.html": {
    "href": "api/testing/internal/param-name-gen-func.html",
    "title": "Struct testing::internal::ParamNameGenFunc | qiotoolkit",
    "keywords": "Struct testing::internal::ParamNameGenFunc"
  },
  "api/testing/internal/parameterized-test-case-info-base.html": {
    "href": "api/testing/internal/parameterized-test-case-info-base.html",
    "title": "Class testing::internal::ParameterizedTestCaseInfoBase | qiotoolkit",
    "keywords": "Class testing::internal::ParameterizedTestCaseInfoBase Inheritance testing::internal::ParameterizedTestCaseInfoBase testing::internal::ParameterizedTestCaseInfo Constructors ParameterizedTestCaseInfoBase() Declaration testing::internal::ParameterizedTestCaseInfoBase::ParameterizedTestCaseInfoBase() Methods ~ParameterizedTestCaseInfoBase() Declaration virtual testing::internal::ParameterizedTestCaseInfoBase::~ParameterizedTestCaseInfoBase() GetTestCaseName() Declaration virtual const std::string&testing::internal::ParameterizedTestCaseInfoBase::GetTestCaseName() const =0 GetTestCaseTypeId() Declaration virtual TypeId testing::internal::ParameterizedTestCaseInfoBase::GetTestCaseTypeId() const =0 RegisterTests() Declaration virtual void testing::internal::ParameterizedTestCaseInfoBase::RegisterTests()=0 GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ParameterizedTestCaseInfoBase::GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseInfoBase)"
  },
  "api/testing/internal/parameterized-test-case-info.html": {
    "href": "api/testing/internal/parameterized-test-case-info.html",
    "title": "Class testing::internal::ParameterizedTestCaseInfo | qiotoolkit",
    "keywords": "Class testing::internal::ParameterizedTestCaseInfo Inheritance testing::internal::ParameterizedTestCaseInfoBase testing::internal::ParameterizedTestCaseInfo Inherited Members ParameterizedTestCaseInfoBase ~ParameterizedTestCaseInfoBase Constructors ParameterizedTestCaseInfo() Declaration testing::internal::ParameterizedTestCaseInfo<TestCase>::ParameterizedTestCaseInfo(const char *name, CodeLocation code_location) Methods ParamGenerator() Declaration typedef testing::internal::ParameterizedTestCaseInfo<TestCase>::ParamGenerator(GeneratorCreationFunc)() GetTestCaseName() Declaration virtual const std::string&testing::internal::ParameterizedTestCaseInfo<TestCase>::GetTestCaseName() const GetTestCaseTypeId() Declaration virtual TypeId testing::internal::ParameterizedTestCaseInfo<TestCase>::GetTestCaseTypeId() const AddTestPattern() Declaration void testing::internal::ParameterizedTestCaseInfo<TestCase>::AddTestPattern(const char *test_case_name, const char *test_base_name, TestMetaFactoryBase<ParamType>*meta_factory) AddTestCaseInstantiation() Declaration int testing::internal::ParameterizedTestCaseInfo<TestCase>::AddTestCaseInstantiation(const std::string&instantiation_name, GeneratorCreationFunc *func, ParamNameGeneratorFunc *name_func, const char *file, int line) RegisterTests() Declaration virtual void testing::internal::ParameterizedTestCaseInfo<TestCase>::RegisterTests() IsValidParamName() Declaration static bool testing::internal::ParameterizedTestCaseInfo<TestCase>::IsValidParamName(const std::string&name) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ParameterizedTestCaseInfo<TestCase>::GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseInfo)"
  },
  "api/testing/internal/parameterized-test-case-info/instantiation-info.html": {
    "href": "api/testing/internal/parameterized-test-case-info/instantiation-info.html",
    "title": "Struct testing::internal::ParameterizedTestCaseInfo::InstantiationInfo | qiotoolkit",
    "keywords": "Struct testing::internal::ParameterizedTestCaseInfo::InstantiationInfo Constructors InstantiationInfo() Declaration testing::internal::ParameterizedTestCaseInfo<TestCase>::InstantiationInfo::InstantiationInfo(const std::string&name_in, GeneratorCreationFunc *generator_in, ParamNameGeneratorFunc *name_func_in, const char *file_in, int line_in)"
  },
  "api/testing/internal/parameterized-test-case-info/test-info.html": {
    "href": "api/testing/internal/parameterized-test-case-info/test-info.html",
    "title": "Struct testing::internal::ParameterizedTestCaseInfo::TestInfo | qiotoolkit",
    "keywords": "Struct testing::internal::ParameterizedTestCaseInfo::TestInfo Constructors TestInfo() Declaration testing::internal::ParameterizedTestCaseInfo<TestCase>::TestInfo::TestInfo(const char *a_test_case_base_name, const char *a_test_base_name, TestMetaFactoryBase<ParamType>*a_test_meta_factory)"
  },
  "api/testing/internal/parameterized-test-case-registry.html": {
    "href": "api/testing/internal/parameterized-test-case-registry.html",
    "title": "Class testing::internal::ParameterizedTestCaseRegistry | qiotoolkit",
    "keywords": "Class testing::internal::ParameterizedTestCaseRegistry Inheritance testing::internal::ParameterizedTestCaseRegistry Constructors ParameterizedTestCaseRegistry() Declaration testing::internal::ParameterizedTestCaseRegistry::ParameterizedTestCaseRegistry() Methods ~ParameterizedTestCaseRegistry() Declaration testing::internal::ParameterizedTestCaseRegistry::~ParameterizedTestCaseRegistry() GetTestCasePatternHolder() Declaration ParameterizedTestCaseInfo<TestCase>* testing::internal::ParameterizedTestCaseRegistry::GetTestCasePatternHolder(const char *test_case_name, CodeLocation code_location) RegisterTests() Declaration void testing::internal::ParameterizedTestCaseRegistry::RegisterTests() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ParameterizedTestCaseRegistry::GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestCaseRegistry)"
  },
  "api/testing/internal/parameterized-test-factory.html": {
    "href": "api/testing/internal/parameterized-test-factory.html",
    "title": "Class testing::internal::ParameterizedTestFactory | qiotoolkit",
    "keywords": "Class testing::internal::ParameterizedTestFactory Inheritance testing::internal::TestFactoryBase testing::internal::ParameterizedTestFactory Inherited Members ~TestFactoryBase TestFactoryBase Constructors ParameterizedTestFactory() Declaration testing::internal::ParameterizedTestFactory<TestClass>::ParameterizedTestFactory(ParamType parameter) ParameterizedTestFactory() Declaration testing::internal::ParameterizedTestFactory<TestClass>::ParameterizedTestFactory(ParamType parameter) Methods CreateTest() Declaration Test* testing::internal::ParameterizedTestFactory<TestClass>::CreateTest() override CreateTest() Declaration virtual Test* testing::internal::ParameterizedTestFactory<TestClass>::CreateTest() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ParameterizedTestFactory<TestClass>::GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestFactory) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ParameterizedTestFactory<TestClass>::GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestFactory)"
  },
  "api/testing/internal/parameterized-test-suite-info-base.html": {
    "href": "api/testing/internal/parameterized-test-suite-info-base.html",
    "title": "Class testing::internal::ParameterizedTestSuiteInfoBase | qiotoolkit",
    "keywords": "Class testing::internal::ParameterizedTestSuiteInfoBase Inheritance testing::internal::ParameterizedTestSuiteInfoBase testing::internal::ParameterizedTestSuiteInfo Constructors ParameterizedTestSuiteInfoBase() Declaration testing::internal::ParameterizedTestSuiteInfoBase::ParameterizedTestSuiteInfoBase() Methods ~ParameterizedTestSuiteInfoBase() Declaration virtual testing::internal::ParameterizedTestSuiteInfoBase::~ParameterizedTestSuiteInfoBase() GetTestSuiteName() Declaration virtual const std::string&testing::internal::ParameterizedTestSuiteInfoBase::GetTestSuiteName() const =0 GetTestSuiteTypeId() Declaration virtual TypeId testing::internal::ParameterizedTestSuiteInfoBase::GetTestSuiteTypeId() const =0 RegisterTests() Declaration virtual void testing::internal::ParameterizedTestSuiteInfoBase::RegisterTests()=0 GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ParameterizedTestSuiteInfoBase::GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestSuiteInfoBase)"
  },
  "api/testing/internal/parameterized-test-suite-info.html": {
    "href": "api/testing/internal/parameterized-test-suite-info.html",
    "title": "Class testing::internal::ParameterizedTestSuiteInfo | qiotoolkit",
    "keywords": "Class testing::internal::ParameterizedTestSuiteInfo Inheritance testing::internal::ParameterizedTestSuiteInfoBase testing::internal::ParameterizedTestSuiteInfo Inherited Members ParameterizedTestSuiteInfoBase ~ParameterizedTestSuiteInfoBase Constructors ParameterizedTestSuiteInfo() Declaration testing::internal::ParameterizedTestSuiteInfo<TestSuite>::ParameterizedTestSuiteInfo(const char *name, CodeLocation code_location) Methods ParamGenerator() Declaration typedef testing::internal::ParameterizedTestSuiteInfo<TestSuite>::ParamGenerator(GeneratorCreationFunc)() GetTestSuiteName() Declaration const std::string&testing::internal::ParameterizedTestSuiteInfo<TestSuite>::GetTestSuiteName() const override GetTestSuiteTypeId() Declaration TypeId testing::internal::ParameterizedTestSuiteInfo<TestSuite>::GetTestSuiteTypeId() const override AddTestPattern() Declaration void testing::internal::ParameterizedTestSuiteInfo<TestSuite>::AddTestPattern(const char *test_suite_name, const char *test_base_name, TestMetaFactoryBase<ParamType>*meta_factory) AddTestSuiteInstantiation() Declaration int testing::internal::ParameterizedTestSuiteInfo<TestSuite>::AddTestSuiteInstantiation(const std::string&instantiation_name, GeneratorCreationFunc *func, ParamNameGeneratorFunc *name_func, const char *file, int line) RegisterTests() Declaration void testing::internal::ParameterizedTestSuiteInfo<TestSuite>::RegisterTests() override IsValidParamName() Declaration static bool testing::internal::ParameterizedTestSuiteInfo<TestSuite>::IsValidParamName(const std::string&name) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ParameterizedTestSuiteInfo<TestSuite>::GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestSuiteInfo)"
  },
  "api/testing/internal/parameterized-test-suite-info/instantiation-info.html": {
    "href": "api/testing/internal/parameterized-test-suite-info/instantiation-info.html",
    "title": "Struct testing::internal::ParameterizedTestSuiteInfo::InstantiationInfo | qiotoolkit",
    "keywords": "Struct testing::internal::ParameterizedTestSuiteInfo::InstantiationInfo Constructors InstantiationInfo() Declaration testing::internal::ParameterizedTestSuiteInfo<TestSuite>::InstantiationInfo::InstantiationInfo(const std::string&name_in, GeneratorCreationFunc *generator_in, ParamNameGeneratorFunc *name_func_in, const char *file_in, int line_in)"
  },
  "api/testing/internal/parameterized-test-suite-info/test-info.html": {
    "href": "api/testing/internal/parameterized-test-suite-info/test-info.html",
    "title": "Struct testing::internal::ParameterizedTestSuiteInfo::TestInfo | qiotoolkit",
    "keywords": "Struct testing::internal::ParameterizedTestSuiteInfo::TestInfo Constructors TestInfo() Declaration testing::internal::ParameterizedTestSuiteInfo<TestSuite>::TestInfo::TestInfo(const char *a_test_suite_base_name, const char *a_test_base_name, TestMetaFactoryBase<ParamType>*a_test_meta_factory)"
  },
  "api/testing/internal/parameterized-test-suite-registry.html": {
    "href": "api/testing/internal/parameterized-test-suite-registry.html",
    "title": "Class testing::internal::ParameterizedTestSuiteRegistry | qiotoolkit",
    "keywords": "Class testing::internal::ParameterizedTestSuiteRegistry Inheritance testing::internal::ParameterizedTestSuiteRegistry Constructors ParameterizedTestSuiteRegistry() Declaration testing::internal::ParameterizedTestSuiteRegistry::ParameterizedTestSuiteRegistry() Methods ~ParameterizedTestSuiteRegistry() Declaration testing::internal::ParameterizedTestSuiteRegistry::~ParameterizedTestSuiteRegistry() GetTestSuitePatternHolder() Declaration ParameterizedTestSuiteInfo<TestSuite>* testing::internal::ParameterizedTestSuiteRegistry::GetTestSuitePatternHolder(const char *test_suite_name, CodeLocation code_location) RegisterTests() Declaration void testing::internal::ParameterizedTestSuiteRegistry::RegisterTests() GetTestCasePatternHolder() Declaration ParameterizedTestCaseInfo<TestCase>* testing::internal::ParameterizedTestSuiteRegistry::GetTestCasePatternHolder(const char *test_case_name, CodeLocation code_location) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ParameterizedTestSuiteRegistry::GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestSuiteRegistry)"
  },
  "api/testing/internal/pointee-matcher.html": {
    "href": "api/testing/internal/pointee-matcher.html",
    "title": "Class testing::internal::PointeeMatcher | qiotoolkit",
    "keywords": "Class testing::internal::PointeeMatcher Inheritance testing::internal::PointeeMatcher Constructors PointeeMatcher() Declaration testing::internal::PointeeMatcher<InnerMatcher>::PointeeMatcher(const InnerMatcher&matcher) Methods >() Declaration testing::internal::PointeeMatcher<InnerMatcher>::operator Matcher<Pointer>() const >() Declaration testing::internal::PointeeMatcher<InnerMatcher>::operator Matcher<Pointer>() const >() Declaration testing::internal::PointeeMatcher<InnerMatcher>::operator Matcher<Pointer>() const >() Declaration testing::internal::PointeeMatcher<InnerMatcher>::operator Matcher<Pointer>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::PointeeMatcher<InnerMatcher>::GTEST_DISALLOW_ASSIGN_(PointeeMatcher)"
  },
  "api/testing/internal/pointee-matcher/impl.html": {
    "href": "api/testing/internal/pointee-matcher/impl.html",
    "title": "Class testing::internal::PointeeMatcher::Impl | qiotoolkit",
    "keywords": "Class testing::internal::PointeeMatcher::Impl Inheritance testing::MatcherInterface testing::internal::PointeeMatcher::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::PointeeMatcher<InnerMatcher>::Impl<Pointer>::Impl(const InnerMatcher&matcher) Methods DescribeTo() Declaration virtual void testing::internal::PointeeMatcher<InnerMatcher>::Impl<Pointer>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::PointeeMatcher<InnerMatcher>::Impl<Pointer>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::PointeeMatcher<InnerMatcher>::Impl<Pointer>::MatchAndExplain(Pointer pointer, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::PointeeMatcher<InnerMatcher>::Impl<Pointer>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/pointee-of.html": {
    "href": "api/testing/internal/pointee-of.html",
    "title": "Struct testing::internal::PointeeOf | qiotoolkit",
    "keywords": "Struct testing::internal::PointeeOf"
  },
  "api/testing/internal/pointee-of/3/01-t/01/5/01/4.html": {
    "href": "api/testing/internal/pointee-of/3/01-t/01/5/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/pointwise-matcher.html": {
    "href": "api/testing/internal/pointwise-matcher.html",
    "title": "Class testing::internal::PointwiseMatcher | qiotoolkit",
    "keywords": "Class testing::internal::PointwiseMatcher Inheritance testing::internal::PointwiseMatcher Constructors PointwiseMatcher() Declaration testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::PointwiseMatcher(const TupleMatcher&tuple_matcher, const RhsContainer&rhs) Methods GTEST_COMPILE_ASSERT_() Declaration testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::GTEST_COMPILE_ASSERT_(!IsHashTable<GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)>::value, use_UnorderedPointwise_with_hash_tables) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::GTEST_DISALLOW_ASSIGN_(PointwiseMatcher) >() Declaration testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::operator Matcher<LhsContainer>() const >() Declaration testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::operator Matcher<LhsContainer>() const >() Declaration testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::operator Matcher<LhsContainer>() const >() Declaration testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::operator Matcher<LhsContainer>() const"
  },
  "api/testing/internal/pointwise-matcher/impl.html": {
    "href": "api/testing/internal/pointwise-matcher/impl.html",
    "title": "Class testing::internal::PointwiseMatcher::Impl | qiotoolkit",
    "keywords": "Class testing::internal::PointwiseMatcher::Impl Inheritance testing::MatcherInterface testing::internal::PointwiseMatcher::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::Impl<LhsContainer>::Impl(const TupleMatcher&tuple_matcher, const RhsStlContainer&rhs) Methods DescribeTo() Declaration virtual void testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::Impl<LhsContainer>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::Impl<LhsContainer>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::Impl<LhsContainer>::MatchAndExplain(LhsContainer lhs, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::PointwiseMatcher<TupleMatcher, RhsContainer>::Impl<LhsContainer>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/predicate-formatter-from-matcher.html": {
    "href": "api/testing/internal/predicate-formatter-from-matcher.html",
    "title": "Class testing::internal::PredicateFormatterFromMatcher | qiotoolkit",
    "keywords": "Class testing::internal::PredicateFormatterFromMatcher Inheritance testing::internal::PredicateFormatterFromMatcher Constructors PredicateFormatterFromMatcher() Declaration testing::internal::PredicateFormatterFromMatcher<M>::PredicateFormatterFromMatcher(M m) Methods operator()() Declaration AssertionResult testing::internal::PredicateFormatterFromMatcher<M>::operator()(const char *value_text, const T&x) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::PredicateFormatterFromMatcher<M>::GTEST_DISALLOW_ASSIGN_(PredicateFormatterFromMatcher)"
  },
  "api/testing/internal/pretty-unit-test-result-printer.html": {
    "href": "api/testing/internal/pretty-unit-test-result-printer.html",
    "title": "Class testing::internal::PrettyUnitTestResultPrinter | qiotoolkit",
    "keywords": "Class testing::internal::PrettyUnitTestResultPrinter Inheritance testing::TestEventListener testing::internal::PrettyUnitTestResultPrinter Inherited Members OnTestSuiteStart ~TestEventListener OnTestSuiteEnd Constructors PrettyUnitTestResultPrinter() Declaration testing::internal::PrettyUnitTestResultPrinter::PrettyUnitTestResultPrinter() PrettyUnitTestResultPrinter() Declaration testing::internal::PrettyUnitTestResultPrinter::PrettyUnitTestResultPrinter() Methods OnTestProgramStart() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnTestProgramStart(const UnitTest&) override OnTestIterationStart() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart(const UnitTest&unit_test, int iteration) override OnEnvironmentsSetUpStart() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(const UnitTest&unit_test) override OnEnvironmentsSetUpEnd() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsSetUpEnd(const UnitTest&) override OnTestCaseStart() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnTestCaseStart(const TestCase&test_case) override OnTestStart() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnTestStart(const TestInfo&test_info) override OnTestPartResult() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnTestPartResult(const TestPartResult&result) override OnTestEnd() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnTestEnd(const TestInfo&test_info) override OnTestCaseEnd() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd(const TestCase&test_case) override OnEnvironmentsTearDownStart() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(const UnitTest&unit_test) override OnEnvironmentsTearDownEnd() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsTearDownEnd(const UnitTest&) override OnTestIterationEnd() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&unit_test, int iteration) override OnTestProgramEnd() Declaration void testing::internal::PrettyUnitTestResultPrinter::OnTestProgramEnd(const UnitTest&) override OnTestProgramStart() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestProgramStart(const UnitTest&) OnTestIterationStart() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestIterationStart(const UnitTest&unit_test, int iteration) OnEnvironmentsSetUpStart() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(const UnitTest&unit_test) OnEnvironmentsSetUpEnd() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsSetUpEnd(const UnitTest&) OnTestCaseStart() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestCaseStart(const TestCase&test_case) OnTestStart() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestStart(const TestInfo&test_info) OnTestPartResult() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestPartResult(const TestPartResult&result) OnTestEnd() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestEnd(const TestInfo&test_info) OnTestCaseEnd() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestCaseEnd(const TestCase&test_case) OnEnvironmentsTearDownStart() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(const UnitTest&unit_test) OnEnvironmentsTearDownEnd() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnEnvironmentsTearDownEnd(const UnitTest&) OnTestIterationEnd() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&unit_test, int iteration) OnTestProgramEnd() Declaration virtual void testing::internal::PrettyUnitTestResultPrinter::OnTestProgramEnd(const UnitTest&) PrintTestName() Declaration static void testing::internal::PrettyUnitTestResultPrinter::PrintTestName(const char *test_suite, const char *test) PrintTestName() Declaration static void testing::internal::PrettyUnitTestResultPrinter::PrintTestName(const char *test_case, const char *test) PrintFailedTests() Declaration void testing::internal::PrettyUnitTestResultPrinter::PrintFailedTests(const UnitTest&unit_test) PrintSkippedTests() Declaration void testing::internal::PrettyUnitTestResultPrinter::PrintSkippedTests(const UnitTest&unit_test) PrintFailedTests() Declaration static void testing::internal::PrettyUnitTestResultPrinter::PrintFailedTests(const UnitTest&unit_test)"
  },
  "api/testing/internal/property-matcher.html": {
    "href": "api/testing/internal/property-matcher.html",
    "title": "Class testing::internal::PropertyMatcher | qiotoolkit",
    "keywords": "Class testing::internal::PropertyMatcher Inheritance testing::internal::PropertyMatcher Constructors PropertyMatcher() Declaration testing::internal::PropertyMatcher<Class, PropertyType, Property>::PropertyMatcher(Property property, const Matcher<RefToConstProperty>&matcher) PropertyMatcher() Declaration testing::internal::PropertyMatcher<Class, PropertyType, Property>::PropertyMatcher(const std::string&property_name, Property property, const Matcher<RefToConstProperty>&matcher) Methods GTEST_REFERENCE_TO_CONST_() Declaration typedef testing::internal::PropertyMatcher<Class, PropertyType, Property>::GTEST_REFERENCE_TO_CONST_(PropertyType) RefToConstProperty DescribeTo() Declaration void testing::internal::PropertyMatcher<Class, PropertyType, Property>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::PropertyMatcher<Class, PropertyType, Property>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration bool testing::internal::PropertyMatcher<Class, PropertyType, Property>::MatchAndExplain(const T&value, MatchResultListener *listener) const MatchAndExplainImpl() Declaration bool testing::internal::PropertyMatcher<Class, PropertyType, Property>::MatchAndExplainImpl(false_type, const Class&obj, MatchResultListener *listener) const MatchAndExplainImpl() Declaration bool testing::internal::PropertyMatcher<Class, PropertyType, Property>::MatchAndExplainImpl(true_type, const Class *p, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::PropertyMatcher<Class, PropertyType, Property>::GTEST_DISALLOW_ASSIGN_(PropertyMatcher)"
  },
  "api/testing/internal/quantifier-matcher-impl.html": {
    "href": "api/testing/internal/quantifier-matcher-impl.html",
    "title": "Class testing::internal::QuantifierMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::QuantifierMatcherImpl Inheritance testing::MatcherInterface testing::internal::QuantifierMatcherImpl testing::internal::ContainsMatcherImpl testing::internal::EachMatcherImpl Inherited Members DescribeNegationTo DescribeTo ~MatcherDescriberInterface MatchAndExplain Constructors QuantifierMatcherImpl() Declaration testing::internal::QuantifierMatcherImpl<Container>::QuantifierMatcherImpl(InnerMatcher inner_matcher) Methods GTEST_REMOVE_REFERENCE_AND_CONST_() Declaration typedef testing::internal::QuantifierMatcherImpl<Container>::GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer MatchAndExplainImpl() Declaration bool testing::internal::QuantifierMatcherImpl<Container>::MatchAndExplainImpl(bool all_elements_should_match, Container container, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::QuantifierMatcherImpl<Container>::GTEST_DISALLOW_ASSIGN_(QuantifierMatcherImpl)"
  },
  "api/testing/internal/random.html": {
    "href": "api/testing/internal/random.html",
    "title": "Class testing::internal::Random | qiotoolkit",
    "keywords": "Class testing::internal::Random Inheritance testing::internal::Random Constructors Random() Declaration testing::internal::Random::Random(UInt32 seed) Random() Declaration testing::internal::Random::Random(UInt32 seed) Methods Reseed() Declaration void testing::internal::Random::Reseed(UInt32 seed) Generate() Declaration UInt32 testing::internal::Random::Generate(UInt32 range) Reseed() Declaration void testing::internal::Random::Reseed(UInt32 seed) Generate() Declaration UInt32 testing::internal::Random::Generate(UInt32 range) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::Random::GTEST_DISALLOW_COPY_AND_ASSIGN_(Random) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::Random::GTEST_DISALLOW_COPY_AND_ASSIGN_(Random)"
  },
  "api/testing/internal/range-generator.html": {
    "href": "api/testing/internal/range-generator.html",
    "title": "Class testing::internal::RangeGenerator | qiotoolkit",
    "keywords": "Class testing::internal::RangeGenerator Inheritance testing::internal::ParamGeneratorInterface testing::internal::RangeGenerator Inherited Members ~ParamGeneratorInterface Constructors RangeGenerator() Declaration testing::internal::RangeGenerator<T, IncrementT>::RangeGenerator(T begin, T end, IncrementT step) RangeGenerator() Declaration testing::internal::RangeGenerator<T, IncrementT>::RangeGenerator(T begin, T end, IncrementT step) Methods ~RangeGenerator() Declaration testing::internal::RangeGenerator<T, IncrementT>::~RangeGenerator() override Begin() Declaration ParamIteratorInterface<T>* testing::internal::RangeGenerator<T, IncrementT>::Begin() const override End() Declaration ParamIteratorInterface<T>* testing::internal::RangeGenerator<T, IncrementT>::End() const override ~RangeGenerator() Declaration virtual testing::internal::RangeGenerator<T, IncrementT>::~RangeGenerator() Begin() Declaration virtual ParamIteratorInterface<T>* testing::internal::RangeGenerator<T, IncrementT>::Begin() const End() Declaration virtual ParamIteratorInterface<T>* testing::internal::RangeGenerator<T, IncrementT>::End() const CalculateEndIndex() Declaration static int testing::internal::RangeGenerator<T, IncrementT>::CalculateEndIndex(const T&begin, const T&end, const IncrementT&step) CalculateEndIndex() Declaration static int testing::internal::RangeGenerator<T, IncrementT>::CalculateEndIndex(const T&begin, const T&end, const IncrementT&step) operator=() Declaration void testing::internal::RangeGenerator<T, IncrementT>::operator=(const RangeGenerator&other) operator=() Declaration void testing::internal::RangeGenerator<T, IncrementT>::operator=(const RangeGenerator&other)"
  },
  "api/testing/internal/range-generator/iterator.html": {
    "href": "api/testing/internal/range-generator/iterator.html",
    "title": "Class testing::internal::RangeGenerator::Iterator | qiotoolkit",
    "keywords": "Class testing::internal::RangeGenerator::Iterator Inheritance testing::internal::ParamIteratorInterface testing::internal::RangeGenerator::Iterator Inherited Members ~ParamIteratorInterface Constructors Iterator() Declaration testing::internal::RangeGenerator<T, IncrementT>::Iterator::Iterator(const ParamGeneratorInterface<T>*base, T value, int index, IncrementT step) Iterator() Declaration testing::internal::RangeGenerator<T, IncrementT>::Iterator::Iterator(const ParamGeneratorInterface<T>*base, T value, int index, IncrementT step) Iterator() Declaration testing::internal::RangeGenerator<T, IncrementT>::Iterator::Iterator(const Iterator&other) Iterator() Declaration testing::internal::RangeGenerator<T, IncrementT>::Iterator::Iterator(const Iterator&other) Methods ~Iterator() Declaration testing::internal::RangeGenerator<T, IncrementT>::Iterator::~Iterator() override BaseGenerator() Declaration const ParamGeneratorInterface<T>* testing::internal::RangeGenerator<T, IncrementT>::Iterator::BaseGenerator() const override Advance() Declaration void testing::internal::RangeGenerator<T, IncrementT>::Iterator::Advance() override Clone() Declaration ParamIteratorInterface<T>* testing::internal::RangeGenerator<T, IncrementT>::Iterator::Clone() const override Current() Declaration const T* testing::internal::RangeGenerator<T, IncrementT>::Iterator::Current() const override Equals() Declaration bool testing::internal::RangeGenerator<T, IncrementT>::Iterator::Equals(const ParamIteratorInterface<T>&other) const override ~Iterator() Declaration virtual testing::internal::RangeGenerator<T, IncrementT>::Iterator::~Iterator() BaseGenerator() Declaration virtual const ParamGeneratorInterface<T>* testing::internal::RangeGenerator<T, IncrementT>::Iterator::BaseGenerator() const Advance() Declaration virtual void testing::internal::RangeGenerator<T, IncrementT>::Iterator::Advance() Clone() Declaration virtual ParamIteratorInterface<T>* testing::internal::RangeGenerator<T, IncrementT>::Iterator::Clone() const Current() Declaration virtual const T* testing::internal::RangeGenerator<T, IncrementT>::Iterator::Current() const Equals() Declaration virtual bool testing::internal::RangeGenerator<T, IncrementT>::Iterator::Equals(const ParamIteratorInterface<T>&other) const operator=() Declaration void testing::internal::RangeGenerator<T, IncrementT>::Iterator::operator=(const Iterator&other) operator=() Declaration void testing::internal::RangeGenerator<T, IncrementT>::Iterator::operator=(const Iterator&other)"
  },
  "api/testing/internal/rank0.html": {
    "href": "api/testing/internal/rank0.html",
    "title": "Struct testing::internal::Rank0 | qiotoolkit",
    "keywords": "Struct testing::internal::Rank0"
  },
  "api/testing/internal/rank1.html": {
    "href": "api/testing/internal/rank1.html",
    "title": "Struct testing::internal::Rank1 | qiotoolkit",
    "keywords": "Struct testing::internal::Rank1"
  },
  "api/testing/internal/re.html": {
    "href": "api/testing/internal/re.html",
    "title": "Class testing::internal::RE | qiotoolkit",
    "keywords": "Class testing::internal::RE Inheritance testing::internal::RE Constructors RE() Declaration testing::internal::RE::RE(const RE&other) RE() Declaration testing::internal::RE::RE(const ::std::string&regex) RE() Declaration testing::internal::RE::RE(const char *regex) RE() Declaration testing::internal::RE::RE(const RE&other) RE() Declaration testing::internal::RE::RE(const ::std::string&regex) RE() Declaration testing::internal::RE::RE(const char *regex) Methods ~RE() Declaration testing::internal::RE::~RE() pattern() Declaration const char* testing::internal::RE::pattern() const ~RE() Declaration testing::internal::RE::~RE() pattern() Declaration const char* testing::internal::RE::pattern() const FullMatch() Declaration static bool testing::internal::RE::FullMatch(const ::std::string&str, const RE&re) PartialMatch() Declaration static bool testing::internal::RE::PartialMatch(const ::std::string&str, const RE&re) FullMatch() Declaration static bool testing::internal::RE::FullMatch(const char *str, const RE&re) PartialMatch() Declaration static bool testing::internal::RE::PartialMatch(const char *str, const RE&re) FullMatch() Declaration static bool testing::internal::RE::FullMatch(const ::std::string&str, const RE&re) PartialMatch() Declaration static bool testing::internal::RE::PartialMatch(const ::std::string&str, const RE&re) FullMatch() Declaration static bool testing::internal::RE::FullMatch(const char *str, const RE&re) PartialMatch() Declaration static bool testing::internal::RE::PartialMatch(const char *str, const RE&re) Init() Declaration void testing::internal::RE::Init(const char *regex) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::RE::GTEST_DISALLOW_ASSIGN_(RE) Init() Declaration void testing::internal::RE::Init(const char *regex) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::RE::GTEST_DISALLOW_ASSIGN_(RE)"
  },
  "api/testing/internal/ref-matcher.html": {
    "href": "api/testing/internal/ref-matcher.html",
    "title": "Class testing::internal::RefMatcher | qiotoolkit",
    "keywords": "Class testing::internal::RefMatcher Inheritance testing::internal::RefMatcher"
  },
  "api/testing/internal/ref-matcher/3/01-t/01/6/01/4.html": {
    "href": "api/testing/internal/ref-matcher/3/01-t/01/6/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods RefMatcher() Declaration testing::internal::RefMatcher<T&>::RefMatcher(T&x) >() Declaration testing::internal::RefMatcher<T&>::operator Matcher<Super&>() const >() Declaration testing::internal::RefMatcher<T&>::operator Matcher<Super&>() const >() Declaration testing::internal::RefMatcher<T&>::operator Matcher<Super&>() const >() Declaration testing::internal::RefMatcher<T&>::operator Matcher<Super&>() const >() Declaration testing::internal::RefMatcher<T&>::operator Matcher<Super&>() const >() Declaration testing::internal::RefMatcher<T&>::operator Matcher<Super&>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::RefMatcher<T&>::GTEST_DISALLOW_ASSIGN_(RefMatcher)"
  },
  "api/testing/internal/ref-matcher/3/01-t/01/6/01/4/impl.html": {
    "href": "api/testing/internal/ref-matcher/3/01-t/01/6/01/4/impl.html",
    "title": "Class ::Impl | qiotoolkit",
    "keywords": "Class ::Impl Inheritance testing::MatcherInterface ::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::RefMatcher<T&>::Impl<Super>::Impl(Super&x) Methods MatchAndExplain() Declaration virtual bool testing::internal::RefMatcher<T&>::Impl<Super>::MatchAndExplain(Super&x, MatchResultListener *listener) const DescribeTo() Declaration virtual void testing::internal::RefMatcher<T&>::Impl<Super>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::RefMatcher<T&>::Impl<Super>::DescribeNegationTo(::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::RefMatcher<T&>::Impl<Super>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/reference-or-value-wrapper.html": {
    "href": "api/testing/internal/reference-or-value-wrapper.html",
    "title": "Class testing::internal::ReferenceOrValueWrapper | qiotoolkit",
    "keywords": "Class testing::internal::ReferenceOrValueWrapper Inheritance testing::internal::ReferenceOrValueWrapper Constructors ReferenceOrValueWrapper() Declaration testing::internal::ReferenceOrValueWrapper<T>::ReferenceOrValueWrapper(T value) Methods Unwrap() Declaration T testing::internal::ReferenceOrValueWrapper<T>::Unwrap() Peek() Declaration const T&testing::internal::ReferenceOrValueWrapper<T>::Peek() const"
  },
  "api/testing/internal/reference-or-value-wrapper/3/01-t/01/6/01/4.html": {
    "href": "api/testing/internal/reference-or-value-wrapper/3/01-t/01/6/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods ReferenceOrValueWrapper() Declaration testing::internal::ReferenceOrValueWrapper<T&>::ReferenceOrValueWrapper(reference ref) Unwrap() Declaration T&testing::internal::ReferenceOrValueWrapper<T&>::Unwrap() Peek() Declaration const T&testing::internal::ReferenceOrValueWrapper<T&>::Peek() const"
  },
  "api/testing/internal/reference-wrapper.html": {
    "href": "api/testing/internal/reference-wrapper.html",
    "title": "Class testing::internal::ReferenceWrapper | qiotoolkit",
    "keywords": "Class testing::internal::ReferenceWrapper Inheritance testing::internal::ReferenceWrapper Constructors ReferenceWrapper() Declaration testing::internal::ReferenceWrapper<T>::ReferenceWrapper(T&l_value) Methods &() Declaration testing::internal::ReferenceWrapper<T>::operator T&() const &() Declaration testing::internal::ReferenceWrapper<T>::operator T&() const"
  },
  "api/testing/internal/relation-to-source-copy.html": {
    "href": "api/testing/internal/relation-to-source-copy.html",
    "title": "Struct testing::internal::RelationToSourceCopy | qiotoolkit",
    "keywords": "Struct testing::internal::RelationToSourceCopy"
  },
  "api/testing/internal/relation-to-source-reference.html": {
    "href": "api/testing/internal/relation-to-source-reference.html",
    "title": "Struct testing::internal::RelationToSourceReference | qiotoolkit",
    "keywords": "Struct testing::internal::RelationToSourceReference"
  },
  "api/testing/internal/remove-const-from-key.html": {
    "href": "api/testing/internal/remove-const-from-key.html",
    "title": "Struct testing::internal::RemoveConstFromKey | qiotoolkit",
    "keywords": "Struct testing::internal::RemoveConstFromKey"
  },
  "api/testing/internal/remove-const-from-key/3/01std/pair/3/01const/01-k/00/01-v/01/4/01/4.html": {
    "href": "api/testing/internal/remove-const-from-key/3/01std/pair/3/01const/01-k/00/01-v/01/4/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/remove-const.html": {
    "href": "api/testing/internal/remove-const.html",
    "title": "Struct testing::internal::RemoveConst | qiotoolkit",
    "keywords": "Struct testing::internal::RemoveConst"
  },
  "api/testing/internal/remove-const/3/01const/01-t/01/4.html": {
    "href": "api/testing/internal/remove-const/3/01const/01-t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/remove-const/3/01const/01-t/0f-n/0e/4.html": {
    "href": "api/testing/internal/remove-const/3/01const/01-t/0f-n/0e/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/remove-reference.html": {
    "href": "api/testing/internal/remove-reference.html",
    "title": "Struct testing::internal::RemoveReference | qiotoolkit",
    "keywords": "Struct testing::internal::RemoveReference"
  },
  "api/testing/internal/remove-reference/3/01-t/01/6/01/4.html": {
    "href": "api/testing/internal/remove-reference/3/01-t/01/6/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/remove/reference.html": {
    "href": "api/testing/internal/remove/reference.html",
    "title": "Struct testing::internal::remove_reference | qiotoolkit",
    "keywords": "Struct testing::internal::remove_reference"
  },
  "api/testing/internal/remove/reference/3/01-t/01/6/01/4.html": {
    "href": "api/testing/internal/remove/reference/3/01-t/01/6/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/result-of-matcher.html": {
    "href": "api/testing/internal/result-of-matcher.html",
    "title": "Class testing::internal::ResultOfMatcher | qiotoolkit",
    "keywords": "Class testing::internal::ResultOfMatcher Inheritance testing::internal::ResultOfMatcher Constructors ResultOfMatcher() Declaration testing::internal::ResultOfMatcher<Callable>::ResultOfMatcher(Callable callable, const Matcher<ResultType>&matcher) Methods >() Declaration testing::internal::ResultOfMatcher<Callable>::operator Matcher<T>() const >() Declaration testing::internal::ResultOfMatcher<Callable>::operator Matcher<T>() const >() Declaration testing::internal::ResultOfMatcher<Callable>::operator Matcher<T>() const >() Declaration testing::internal::ResultOfMatcher<Callable>::operator Matcher<T>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ResultOfMatcher<Callable>::GTEST_DISALLOW_ASSIGN_(ResultOfMatcher)"
  },
  "api/testing/internal/result-of-matcher/impl.html": {
    "href": "api/testing/internal/result-of-matcher/impl.html",
    "title": "Class testing::internal::ResultOfMatcher::Impl | qiotoolkit",
    "keywords": "Class testing::internal::ResultOfMatcher::Impl Inheritance testing::MatcherInterface testing::internal::ResultOfMatcher::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::ResultOfMatcher<Callable>::Impl<T>::Impl(CallableStorageType callable, const Matcher<ResultType>&matcher) Methods DescribeTo() Declaration virtual void testing::internal::ResultOfMatcher<Callable>::Impl<T>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::ResultOfMatcher<Callable>::Impl<T>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::ResultOfMatcher<Callable>::Impl<T>::MatchAndExplain(T obj, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ResultOfMatcher<Callable>::Impl<T>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/return-action.html": {
    "href": "api/testing/internal/return-action.html",
    "title": "Class testing::internal::ReturnAction | qiotoolkit",
    "keywords": "Class testing::internal::ReturnAction Inheritance testing::internal::ReturnAction Constructors ReturnAction() Declaration testing::internal::ReturnAction<R>::ReturnAction(R value) ReturnAction() Declaration testing::internal::ReturnAction<R>::ReturnAction(R value) Methods >() Declaration testing::internal::ReturnAction<R>::operator Action<F>() const >() Declaration testing::internal::ReturnAction<R>::operator Action<F>() const >() Declaration testing::internal::ReturnAction<R>::operator Action<F>() const >() Declaration testing::internal::ReturnAction<R>::operator Action<F>() const >() Declaration testing::internal::ReturnAction<R>::operator Action<F>() const >() Declaration testing::internal::ReturnAction<R>::operator Action<F>() const >() Declaration testing::internal::ReturnAction<R>::operator Action<F>() const >() Declaration testing::internal::ReturnAction<R>::operator Action<F>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnAction<R>::GTEST_DISALLOW_ASSIGN_(ReturnAction) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnAction<R>::GTEST_DISALLOW_ASSIGN_(ReturnAction)"
  },
  "api/testing/internal/return-action/impl.html": {
    "href": "api/testing/internal/return-action/impl.html",
    "title": "Class testing::internal::ReturnAction::Impl | qiotoolkit",
    "keywords": "Class testing::internal::ReturnAction::Impl Inheritance testing::ActionInterface testing::internal::ReturnAction::Impl Inherited Members ActionInterface ~ActionInterface Constructors Impl() Declaration testing::internal::ReturnAction<R>::Impl<R_, F>::Impl(const std::shared_ptr<R>&value) Impl() Declaration testing::internal::ReturnAction<R>::Impl<R_, F>::Impl(const linked_ptr<R>&value) Methods Perform() Declaration Result testing::internal::ReturnAction<R>::Impl<R_, F>::Perform(const ArgumentTuple&) override Perform() Declaration virtual Result testing::internal::ReturnAction<R>::Impl<R_, F>::Perform(const ArgumentTuple&) GTEST_COMPILE_ASSERT_() Declaration testing::internal::ReturnAction<R>::Impl<R_, F>::GTEST_COMPILE_ASSERT_(!std::is_reference<Result>::value, Result_cannot_be_a_reference_type) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ReturnAction<R>::Impl<R_, F>::GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl) GTEST_COMPILE_ASSERT_() Declaration testing::internal::ReturnAction<R>::Impl<R_, F>::GTEST_COMPILE_ASSERT_(!is_reference<Result>::value, Result_cannot_be_a_reference_type) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ReturnAction<R>::Impl<R_, F>::GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl)"
  },
  "api/testing/internal/return-action/impl/3/01-by-move-wrapper/3/01-r/01/4/00/01-f/01/4.html": {
    "href": "api/testing/internal/return-action/impl/3/01-by-move-wrapper/3/01-r/01/4/00/01-f/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::ActionInterface > Inherited Members ActionInterface ~ActionInterface Methods Impl() Declaration testing::internal::ReturnAction<R>::Impl<ByMoveWrapper<R_>, F>::Impl(const std::shared_ptr<R>&wrapper) Perform() Declaration Result testing::internal::ReturnAction<R>::Impl<ByMoveWrapper<R_>, F>::Perform(const ArgumentTuple&) override Impl() Declaration testing::internal::ReturnAction<R>::Impl<ByMoveWrapper<R_>, F>::Impl(const linked_ptr<R>&wrapper) Perform() Declaration virtual Result testing::internal::ReturnAction<R>::Impl<ByMoveWrapper<R_>, F>::Perform(const ArgumentTuple&) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnAction<R>::Impl<ByMoveWrapper<R_>, F>::GTEST_DISALLOW_ASSIGN_(Impl) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnAction<R>::Impl<ByMoveWrapper<R_>, F>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/return-null-action.html": {
    "href": "api/testing/internal/return-null-action.html",
    "title": "Class testing::internal::ReturnNullAction | qiotoolkit",
    "keywords": "Class testing::internal::ReturnNullAction Inheritance testing::internal::ReturnNullAction Methods Perform() Declaration static Result testing::internal::ReturnNullAction::Perform(const ArgumentTuple&) Perform() Declaration static Result testing::internal::ReturnNullAction::Perform(const ArgumentTuple&)"
  },
  "api/testing/internal/return-ref-action.html": {
    "href": "api/testing/internal/return-ref-action.html",
    "title": "Class testing::internal::ReturnRefAction | qiotoolkit",
    "keywords": "Class testing::internal::ReturnRefAction Inheritance testing::internal::ReturnRefAction Constructors ReturnRefAction() Declaration testing::internal::ReturnRefAction<T>::ReturnRefAction(T&ref) ReturnRefAction() Declaration testing::internal::ReturnRefAction<T>::ReturnRefAction(T&ref) Methods >() Declaration testing::internal::ReturnRefAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefAction<T>::operator Action<F>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnRefAction<T>::GTEST_DISALLOW_ASSIGN_(ReturnRefAction) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnRefAction<T>::GTEST_DISALLOW_ASSIGN_(ReturnRefAction)"
  },
  "api/testing/internal/return-ref-action/impl.html": {
    "href": "api/testing/internal/return-ref-action/impl.html",
    "title": "Class testing::internal::ReturnRefAction::Impl | qiotoolkit",
    "keywords": "Class testing::internal::ReturnRefAction::Impl Inheritance testing::ActionInterface testing::internal::ReturnRefAction::Impl Inherited Members ActionInterface ~ActionInterface Constructors Impl() Declaration testing::internal::ReturnRefAction<T>::Impl<F>::Impl(T&ref) Impl() Declaration testing::internal::ReturnRefAction<T>::Impl<F>::Impl(T&ref) Methods Perform() Declaration Result testing::internal::ReturnRefAction<T>::Impl<F>::Perform(const ArgumentTuple&) override Perform() Declaration virtual Result testing::internal::ReturnRefAction<T>::Impl<F>::Perform(const ArgumentTuple&) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnRefAction<T>::Impl<F>::GTEST_DISALLOW_ASSIGN_(Impl) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnRefAction<T>::Impl<F>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/return-ref-of-copy-action.html": {
    "href": "api/testing/internal/return-ref-of-copy-action.html",
    "title": "Class testing::internal::ReturnRefOfCopyAction | qiotoolkit",
    "keywords": "Class testing::internal::ReturnRefOfCopyAction Inheritance testing::internal::ReturnRefOfCopyAction Constructors ReturnRefOfCopyAction() Declaration testing::internal::ReturnRefOfCopyAction<T>::ReturnRefOfCopyAction(const T&value) ReturnRefOfCopyAction() Declaration testing::internal::ReturnRefOfCopyAction<T>::ReturnRefOfCopyAction(const T&value) Methods >() Declaration testing::internal::ReturnRefOfCopyAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefOfCopyAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefOfCopyAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefOfCopyAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefOfCopyAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefOfCopyAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefOfCopyAction<T>::operator Action<F>() const >() Declaration testing::internal::ReturnRefOfCopyAction<T>::operator Action<F>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnRefOfCopyAction<T>::GTEST_DISALLOW_ASSIGN_(ReturnRefOfCopyAction) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnRefOfCopyAction<T>::GTEST_DISALLOW_ASSIGN_(ReturnRefOfCopyAction)"
  },
  "api/testing/internal/return-ref-of-copy-action/impl.html": {
    "href": "api/testing/internal/return-ref-of-copy-action/impl.html",
    "title": "Class testing::internal::ReturnRefOfCopyAction::Impl | qiotoolkit",
    "keywords": "Class testing::internal::ReturnRefOfCopyAction::Impl Inheritance testing::ActionInterface testing::internal::ReturnRefOfCopyAction::Impl Inherited Members ActionInterface ~ActionInterface Constructors Impl() Declaration testing::internal::ReturnRefOfCopyAction<T>::Impl<F>::Impl(const T&value) Impl() Declaration testing::internal::ReturnRefOfCopyAction<T>::Impl<F>::Impl(const T&value) Methods Perform() Declaration Result testing::internal::ReturnRefOfCopyAction<T>::Impl<F>::Perform(const ArgumentTuple&) override Perform() Declaration virtual Result testing::internal::ReturnRefOfCopyAction<T>::Impl<F>::Perform(const ArgumentTuple&) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnRefOfCopyAction<T>::Impl<F>::GTEST_DISALLOW_ASSIGN_(Impl) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::ReturnRefOfCopyAction<T>::Impl<F>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/return-void-action.html": {
    "href": "api/testing/internal/return-void-action.html",
    "title": "Class testing::internal::ReturnVoidAction | qiotoolkit",
    "keywords": "Class testing::internal::ReturnVoidAction Inheritance testing::internal::ReturnVoidAction Methods Perform() Declaration static void testing::internal::ReturnVoidAction::Perform(const ArgumentTuple&) Perform() Declaration static void testing::internal::ReturnVoidAction::Perform(const ArgumentTuple&)"
  },
  "api/testing/internal/rvalue-ref.html": {
    "href": "api/testing/internal/rvalue-ref.html",
    "title": "Struct testing::internal::RvalueRef | qiotoolkit",
    "keywords": "Struct testing::internal::RvalueRef"
  },
  "api/testing/internal/scoped-premature-exit-file.html": {
    "href": "api/testing/internal/scoped-premature-exit-file.html",
    "title": "Class testing::internal::ScopedPrematureExitFile | qiotoolkit",
    "keywords": "Class testing::internal::ScopedPrematureExitFile Inheritance testing::internal::ScopedPrematureExitFile Constructors ScopedPrematureExitFile() Declaration testing::internal::ScopedPrematureExitFile::ScopedPrematureExitFile(const char *premature_exit_filepath) ScopedPrematureExitFile() Declaration testing::internal::ScopedPrematureExitFile::ScopedPrematureExitFile(const char *premature_exit_filepath) Methods ~ScopedPrematureExitFile() Declaration testing::internal::ScopedPrematureExitFile::~ScopedPrematureExitFile() ~ScopedPrematureExitFile() Declaration testing::internal::ScopedPrematureExitFile::~ScopedPrematureExitFile() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ScopedPrematureExitFile::GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedPrematureExitFile) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::ScopedPrematureExitFile::GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedPrematureExitFile)"
  },
  "api/testing/internal/scoped/ptr.html": {
    "href": "api/testing/internal/scoped/ptr.html",
    "title": "Class testing::internal::scoped_ptr | qiotoolkit",
    "keywords": "Class testing::internal::scoped_ptr Inheritance testing::internal::scoped_ptr Constructors scoped_ptr() Declaration testing::internal::scoped_ptr<T>::scoped_ptr(T *p=NULL) Methods ~scoped_ptr() Declaration testing::internal::scoped_ptr<T>::~scoped_ptr() operator*() Declaration T&testing::internal::scoped_ptr<T>::operator*() const >() Declaration T* testing::internal::scoped_ptr<T>::operator->() const >() Declaration T* testing::internal::scoped_ptr<T>::operator->() const get() Declaration T* testing::internal::scoped_ptr<T>::get() const release() Declaration T* testing::internal::scoped_ptr<T>::release() reset() Declaration void testing::internal::scoped_ptr<T>::reset(T *p=NULL) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::scoped_ptr<T>::GTEST_DISALLOW_COPY_AND_ASSIGN_(scoped_ptr)"
  },
  "api/testing/internal/select-args.html": {
    "href": "api/testing/internal/select-args.html",
    "title": "Class testing::internal::SelectArgs | qiotoolkit",
    "keywords": "Class testing::internal::SelectArgs Inheritance testing::internal::SelectArgs Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10>::Select(const ArgumentTuple&args)"
  },
  "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01-1/00/01-1/00/01-1/00/d26521468f85209f6b4c61eca65baf5d.html": {
    "href": "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01-1/00/01-1/00/01-1/00/d26521468f85209f6b4c61eca65baf5d.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1>::Select(const ArgumentTuple&)"
  },
  "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01-1/00/01-1/00/6a5fc7802a60cf36c89bd10623cc9552.html": {
    "href": "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01-1/00/01-1/00/6a5fc7802a60cf36c89bd10623cc9552.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, k1, -1, -1, -1, -1, -1, -1, -1, -1, -1>::Select(const ArgumentTuple&args)"
  },
  "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01-1/00/9a332764141890440172b7f06e77bbee.html": {
    "href": "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01-1/00/9a332764141890440172b7f06e77bbee.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, k1, k2, -1, -1, -1, -1, -1, -1, -1, -1>::Select(const ArgumentTuple&args)"
  },
  "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/030eb2335b9fd029fe61511c21b4d364.html": {
    "href": "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/030eb2335b9fd029fe61511c21b4d364.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4, -1, -1, -1, -1, -1, -1>::Select(const ArgumentTuple&args)"
  },
  "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/39929402cb68b57f60e280a41eb60fed.html": {
    "href": "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/39929402cb68b57f60e280a41eb60fed.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4, k5, k6, k7, -1, -1, -1>::Select(const ArgumentTuple&args)"
  },
  "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/4b8877f94cb457a4d2bd6b2630090309.html": {
    "href": "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/4b8877f94cb457a4d2bd6b2630090309.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, k1, k2, k3, -1, -1, -1, -1, -1, -1, -1>::Select(const ArgumentTuple&args)"
  },
  "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/5bf9522b4f7bab9048d7587f1d9fbf27.html": {
    "href": "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/5bf9522b4f7bab9048d7587f1d9fbf27.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4, k5, k6, k7, k8, -1, -1>::Select(const ArgumentTuple&args)"
  },
  "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/a44b2a3fb6bab261818c61ba2b7f389a.html": {
    "href": "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/a44b2a3fb6bab261818c61ba2b7f389a.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4, k5, k6, k7, k8, k9, -1>::Select(const ArgumentTuple&args)"
  },
  "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/bb7097ad0bebc299c171ea7e2f7fc9a0.html": {
    "href": "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/bb7097ad0bebc299c171ea7e2f7fc9a0.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4, k5, k6, -1, -1, -1, -1>::Select(const ArgumentTuple&args)"
  },
  "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/dabb861d0dfd59e876e4adc8d7e61c25.html": {
    "href": "api/testing/internal/select-args/3/01-result/00/01-argument-tuple/00/01k1/00/01k2/00/01k3/00/dabb861d0dfd59e876e4adc8d7e61c25.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Select() Declaration static SelectedArgs testing::internal::SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4, k5, -1, -1, -1, -1, -1>::Select(const ArgumentTuple&args)"
  },
  "api/testing/internal/set-argument-pointee-action.html": {
    "href": "api/testing/internal/set-argument-pointee-action.html",
    "title": "Class testing::internal::SetArgumentPointeeAction | qiotoolkit",
    "keywords": "Class testing::internal::SetArgumentPointeeAction Inheritance testing::internal::SetArgumentPointeeAction Constructors SetArgumentPointeeAction() Declaration testing::internal::SetArgumentPointeeAction<N, A, typename>::SetArgumentPointeeAction(const A&value) Methods operator()() Declaration void testing::internal::SetArgumentPointeeAction<N, A, typename>::operator()(const Args&... args) const Perform() Declaration void testing::internal::SetArgumentPointeeAction<N, A, typename>::Perform(const ArgumentTuple&args) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::SetArgumentPointeeAction<N, A, typename>::GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction)"
  },
  "api/testing/internal/set-argument-pointee-action/3/01-n/00/01-proto/00/01true/01/4.html": {
    "href": "api/testing/internal/set-argument-pointee-action/3/01-n/00/01-proto/00/01true/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods SetArgumentPointeeAction() Declaration testing::internal::SetArgumentPointeeAction<N, Proto, true>::SetArgumentPointeeAction(const Proto&proto) Perform() Declaration void testing::internal::SetArgumentPointeeAction<N, Proto, true>::Perform(const ArgumentTuple&args) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::SetArgumentPointeeAction<N, Proto, true>::GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction)"
  },
  "api/testing/internal/set-errno-and-return-action.html": {
    "href": "api/testing/internal/set-errno-and-return-action.html",
    "title": "Class testing::internal::SetErrnoAndReturnAction | qiotoolkit",
    "keywords": "Class testing::internal::SetErrnoAndReturnAction Inheritance testing::internal::SetErrnoAndReturnAction Constructors SetErrnoAndReturnAction() Declaration testing::internal::SetErrnoAndReturnAction<T>::SetErrnoAndReturnAction(int errno_value, T result) SetErrnoAndReturnAction() Declaration testing::internal::SetErrnoAndReturnAction<T>::SetErrnoAndReturnAction(int errno_value, T result) Methods Perform() Declaration Result testing::internal::SetErrnoAndReturnAction<T>::Perform(const ArgumentTuple&) const Perform() Declaration Result testing::internal::SetErrnoAndReturnAction<T>::Perform(const ArgumentTuple&) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::SetErrnoAndReturnAction<T>::GTEST_DISALLOW_ASSIGN_(SetErrnoAndReturnAction) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::SetErrnoAndReturnAction<T>::GTEST_DISALLOW_ASSIGN_(SetErrnoAndReturnAction)"
  },
  "api/testing/internal/single-failure-checker.html": {
    "href": "api/testing/internal/single-failure-checker.html",
    "title": "Class testing::internal::SingleFailureChecker | qiotoolkit",
    "keywords": "Class testing::internal::SingleFailureChecker Inheritance testing::internal::SingleFailureChecker Constructors SingleFailureChecker() Declaration testing::internal::SingleFailureChecker::SingleFailureChecker(const TestPartResultArray *results, TestPartResult::Type type, const std::string&substr) Methods ~SingleFailureChecker() Declaration testing::internal::SingleFailureChecker::~SingleFailureChecker() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::SingleFailureChecker::GTEST_DISALLOW_COPY_AND_ASSIGN_(SingleFailureChecker)"
  },
  "api/testing/internal/size-is-matcher.html": {
    "href": "api/testing/internal/size-is-matcher.html",
    "title": "Class testing::internal::SizeIsMatcher | qiotoolkit",
    "keywords": "Class testing::internal::SizeIsMatcher Inheritance testing::internal::SizeIsMatcher Constructors SizeIsMatcher() Declaration testing::internal::SizeIsMatcher<SizeMatcher>::SizeIsMatcher(const SizeMatcher&size_matcher) Methods >() Declaration testing::internal::SizeIsMatcher<SizeMatcher>::operator Matcher<Container>() const >() Declaration testing::internal::SizeIsMatcher<SizeMatcher>::operator Matcher<Container>() const >() Declaration testing::internal::SizeIsMatcher<SizeMatcher>::operator Matcher<Container>() const >() Declaration testing::internal::SizeIsMatcher<SizeMatcher>::operator Matcher<Container>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::SizeIsMatcher<SizeMatcher>::GTEST_DISALLOW_ASSIGN_(SizeIsMatcher)"
  },
  "api/testing/internal/size-is-matcher/impl.html": {
    "href": "api/testing/internal/size-is-matcher/impl.html",
    "title": "Class testing::internal::SizeIsMatcher::Impl | qiotoolkit",
    "keywords": "Class testing::internal::SizeIsMatcher::Impl Inheritance testing::MatcherInterface testing::internal::SizeIsMatcher::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::SizeIsMatcher<SizeMatcher>::Impl<Container>::Impl(const SizeMatcher&size_matcher) Methods DescribeTo() Declaration virtual void testing::internal::SizeIsMatcher<SizeMatcher>::Impl<Container>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::SizeIsMatcher<SizeMatcher>::Impl<Container>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::SizeIsMatcher<SizeMatcher>::Impl<Container>::MatchAndExplain(Container container, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::SizeIsMatcher<SizeMatcher>::Impl<Container>::GTEST_DISALLOW_ASSIGN_(Impl)"
  },
  "api/testing/internal/starts-with-matcher.html": {
    "href": "api/testing/internal/starts-with-matcher.html",
    "title": "Class testing::internal::StartsWithMatcher | qiotoolkit",
    "keywords": "Class testing::internal::StartsWithMatcher Inheritance testing::internal::StartsWithMatcher Constructors StartsWithMatcher() Declaration testing::internal::StartsWithMatcher<StringType>::StartsWithMatcher(const StringType&prefix) Methods MatchAndExplain() Declaration bool testing::internal::StartsWithMatcher<StringType>::MatchAndExplain(CharType *s, MatchResultListener *listener) const MatchAndExplain() Declaration bool testing::internal::StartsWithMatcher<StringType>::MatchAndExplain(const MatcheeStringType&s, MatchResultListener *) const DescribeTo() Declaration void testing::internal::StartsWithMatcher<StringType>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::StartsWithMatcher<StringType>::DescribeNegationTo(::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::StartsWithMatcher<StringType>::GTEST_DISALLOW_ASSIGN_(StartsWithMatcher)"
  },
  "api/testing/internal/static-assert-type-eq-helper.html": {
    "href": "api/testing/internal/static-assert-type-eq-helper.html",
    "title": "Struct testing::internal::StaticAssertTypeEqHelper | qiotoolkit",
    "keywords": "Struct testing::internal::StaticAssertTypeEqHelper"
  },
  "api/testing/internal/static-assert-type-eq-helper/3/01-t/00/01-t/01/4.html": {
    "href": "api/testing/internal/static-assert-type-eq-helper/3/01-t/00/01-t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/stl-container-view.html": {
    "href": "api/testing/internal/stl-container-view.html",
    "title": "Class testing::internal::StlContainerView | qiotoolkit",
    "keywords": "Class testing::internal::StlContainerView Inheritance testing::internal::StlContainerView Methods ConstReference() Declaration static const_reference testing::internal::StlContainerView<RawContainer>::ConstReference(const RawContainer&container) Copy() Declaration static type testing::internal::StlContainerView<RawContainer>::Copy(const RawContainer&container) ConstReference() Declaration static const_reference testing::internal::StlContainerView<RawContainer>::ConstReference(const RawContainer&container) Copy() Declaration static type testing::internal::StlContainerView<RawContainer>::Copy(const RawContainer&container)"
  },
  "api/testing/internal/stl-container-view/3/0/1std/tuple/3/01-element-pointer/00/01-size/01/4/01/4.html": {
    "href": "api/testing/internal/stl-container-view/3/0/1std/tuple/3/01-element-pointer/00/01-size/01/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods ConstReference() Declaration static const_reference testing::internal::StlContainerView<::std::tuple<ElementPointer, Size>>::ConstReference(const ::std::tuple<ElementPointer, Size>&array) Copy() Declaration static type testing::internal::StlContainerView<::std::tuple<ElementPointer, Size>>::Copy(const ::std::tuple<ElementPointer, Size>&array)"
  },
  "api/testing/internal/stl-container-view/3/0/1testing/tuple/3/01-element-pointer/00/01-size/01/4/01/4.html": {
    "href": "api/testing/internal/stl-container-view/3/0/1testing/tuple/3/01-element-pointer/00/01-size/01/4/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GTEST_REMOVE_CONST_() Declaration typedef testing::internal::StlContainerView<::testing::tuple<ElementPointer, Size>>::GTEST_REMOVE_CONST_(typename internal::PointeeOf<ElementPointer>::type) RawElement ConstReference() Declaration static const_reference testing::internal::StlContainerView<::testing::tuple<ElementPointer, Size>>::ConstReference(const ::testing::tuple<ElementPointer, Size>&array) Copy() Declaration static type testing::internal::StlContainerView<::testing::tuple<ElementPointer, Size>>::Copy(const ::testing::tuple<ElementPointer, Size>&array)"
  },
  "api/testing/internal/stl-container-view/3/01-element/0f-n/0e/4.html": {
    "href": "api/testing/internal/stl-container-view/3/01-element/0f-n/0e/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods ConstReference() Declaration static const_reference testing::internal::StlContainerView<Element[N]>::ConstReference(const Element(&array)[N]) Copy() Declaration static type testing::internal::StlContainerView<Element[N]>::Copy(const Element(&array)[N]) ConstReference() Declaration static const_reference testing::internal::StlContainerView<Element[N]>::ConstReference(const Element(&array)[N]) Copy() Declaration static type testing::internal::StlContainerView<Element[N]>::Copy(const Element(&array)[N]) GTEST_REMOVE_CONST_() Declaration typedef testing::internal::StlContainerView<Element[N]>::GTEST_REMOVE_CONST_(Element) RawElement"
  },
  "api/testing/internal/str-equality-matcher.html": {
    "href": "api/testing/internal/str-equality-matcher.html",
    "title": "Class testing::internal::StrEqualityMatcher | qiotoolkit",
    "keywords": "Class testing::internal::StrEqualityMatcher Inheritance testing::internal::StrEqualityMatcher Constructors StrEqualityMatcher() Declaration testing::internal::StrEqualityMatcher<StringType>::StrEqualityMatcher(const StringType&str, bool expect_eq, bool case_sensitive) Methods MatchAndExplain() Declaration bool testing::internal::StrEqualityMatcher<StringType>::MatchAndExplain(CharType *s, MatchResultListener *listener) const MatchAndExplain() Declaration bool testing::internal::StrEqualityMatcher<StringType>::MatchAndExplain(const MatcheeStringType&s, MatchResultListener *) const DescribeTo() Declaration void testing::internal::StrEqualityMatcher<StringType>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::StrEqualityMatcher<StringType>::DescribeNegationTo(::std::ostream *os) const DescribeToHelper() Declaration void testing::internal::StrEqualityMatcher<StringType>::DescribeToHelper(bool expect_eq, ::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::StrEqualityMatcher<StringType>::GTEST_DISALLOW_ASSIGN_(StrEqualityMatcher)"
  },
  "api/testing/internal/stream-match-result-listener.html": {
    "href": "api/testing/internal/stream-match-result-listener.html",
    "title": "Class testing::internal::StreamMatchResultListener | qiotoolkit",
    "keywords": "Class testing::internal::StreamMatchResultListener Inheritance testing::MatchResultListener testing::internal::StreamMatchResultListener Inherited Members MatchResultListener stream < ~MatchResultListener IsInterested Constructors StreamMatchResultListener() Declaration testing::internal::StreamMatchResultListener::StreamMatchResultListener(::std::ostream *os) Methods GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::StreamMatchResultListener::GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamMatchResultListener)"
  },
  "api/testing/internal/string.html": {
    "href": "api/testing/internal/string.html",
    "title": "Class testing::internal::String | qiotoolkit",
    "keywords": "Class testing::internal::String Inheritance testing::internal::String Constructors String() Declaration testing::internal::String::String() String() Declaration testing::internal::String::String() Methods CloneCString() Declaration static const char* testing::internal::String::CloneCString(const char *c_str) CStringEquals() Declaration bool testing::internal::String::CStringEquals(const char *lhs, const char *rhs) ShowWideCString() Declaration std::string testing::internal::String::ShowWideCString(const wchar_t *wide_c_str) WideCStringEquals() Declaration bool testing::internal::String::WideCStringEquals(const wchar_t *lhs, const wchar_t *rhs) CaseInsensitiveCStringEquals() Declaration bool testing::internal::String::CaseInsensitiveCStringEquals(const char *lhs, const char *rhs) CaseInsensitiveWideCStringEquals() Declaration bool testing::internal::String::CaseInsensitiveWideCStringEquals(const wchar_t *lhs, const wchar_t *rhs) EndsWithCaseInsensitive() Declaration bool testing::internal::String::EndsWithCaseInsensitive(const std::string&str, const std::string&suffix) FormatIntWidth2() Declaration std::string testing::internal::String::FormatIntWidth2(int value) FormatHexInt() Declaration std::string testing::internal::String::FormatHexInt(int value) FormatHexUInt32() Declaration std::string testing::internal::String::FormatHexUInt32(UInt32 value) FormatByte() Declaration std::string testing::internal::String::FormatByte(unsigned char value) CloneCString() Declaration static const char* testing::internal::String::CloneCString(const char *c_str) CStringEquals() Declaration static bool testing::internal::String::CStringEquals(const char *lhs, const char *rhs) ShowWideCString() Declaration static std::string testing::internal::String::ShowWideCString(const wchar_t *wide_c_str) WideCStringEquals() Declaration static bool testing::internal::String::WideCStringEquals(const wchar_t *lhs, const wchar_t *rhs) CaseInsensitiveCStringEquals() Declaration static bool testing::internal::String::CaseInsensitiveCStringEquals(const char *lhs, const char *rhs) CaseInsensitiveWideCStringEquals() Declaration static bool testing::internal::String::CaseInsensitiveWideCStringEquals(const wchar_t *lhs, const wchar_t *rhs) EndsWithCaseInsensitive() Declaration static bool testing::internal::String::EndsWithCaseInsensitive(const std::string&str, const std::string&suffix) FormatIntWidth2() Declaration static std::string testing::internal::String::FormatIntWidth2(int value) FormatHexInt() Declaration static std::string testing::internal::String::FormatHexInt(int value) FormatByte() Declaration static std::string testing::internal::String::FormatByte(unsigned char value)"
  },
  "api/testing/internal/suite-api-resolver.html": {
    "href": "api/testing/internal/suite-api-resolver.html",
    "title": "Struct testing::internal::SuiteApiResolver | qiotoolkit",
    "keywords": "Struct testing::internal::SuiteApiResolver Methods GetSetUpCaseOrSuite() Declaration static SetUpTearDownSuiteFuncType testing::internal::SuiteApiResolver<T>::GetSetUpCaseOrSuite(const char *filename, int line_num) GetTearDownCaseOrSuite() Declaration static SetUpTearDownSuiteFuncType testing::internal::SuiteApiResolver<T>::GetTearDownCaseOrSuite(const char *filename, int line_num)"
  },
  "api/testing/internal/test-case-name-is.html": {
    "href": "api/testing/internal/test-case-name-is.html",
    "title": "Class testing::internal::TestCaseNameIs | qiotoolkit",
    "keywords": "Class testing::internal::TestCaseNameIs Inheritance testing::internal::TestCaseNameIs Constructors TestCaseNameIs() Declaration testing::internal::TestCaseNameIs::TestCaseNameIs(const std::string&name) Methods operator()() Declaration bool testing::internal::TestCaseNameIs::operator()(const TestCase *test_case) const"
  },
  "api/testing/internal/test-event-repeater.html": {
    "href": "api/testing/internal/test-event-repeater.html",
    "title": "Class testing::internal::TestEventRepeater | qiotoolkit",
    "keywords": "Class testing::internal::TestEventRepeater Inheritance testing::TestEventListener testing::internal::TestEventRepeater Inherited Members ~TestEventListener Constructors TestEventRepeater() Declaration testing::internal::TestEventRepeater::TestEventRepeater() TestEventRepeater() Declaration testing::internal::TestEventRepeater::TestEventRepeater() Methods ~TestEventRepeater() Declaration testing::internal::TestEventRepeater::~TestEventRepeater() override Append() Declaration void testing::internal::TestEventRepeater::Append(TestEventListener *listener) Release() Declaration TestEventListener * testing::internal::TestEventRepeater::Release(TestEventListener *listener) forwarding_enabled() Declaration bool testing::internal::TestEventRepeater::forwarding_enabled() const set_forwarding_enabled() Declaration void testing::internal::TestEventRepeater::set_forwarding_enabled(bool enable) OnTestProgramStart() Declaration void testing::internal::TestEventRepeater::OnTestProgramStart(const UnitTest&unit_test) override OnTestIterationStart() Declaration void testing::internal::TestEventRepeater::OnTestIterationStart(const UnitTest&unit_test, int iteration) override OnEnvironmentsSetUpStart() Declaration void testing::internal::TestEventRepeater::OnEnvironmentsSetUpStart(const UnitTest&unit_test) override OnEnvironmentsSetUpEnd() Declaration void testing::internal::TestEventRepeater::OnEnvironmentsSetUpEnd(const UnitTest&unit_test) override OnTestCaseStart() Declaration void testing::internal::TestEventRepeater::OnTestCaseStart(const TestSuite&parameter) override OnTestSuiteStart() Declaration void testing::internal::TestEventRepeater::OnTestSuiteStart(const TestSuite&parameter) override OnTestStart() Declaration void testing::internal::TestEventRepeater::OnTestStart(const TestInfo&test_info) override OnTestPartResult() Declaration void testing::internal::TestEventRepeater::OnTestPartResult(const TestPartResult&result) override OnTestEnd() Declaration void testing::internal::TestEventRepeater::OnTestEnd(const TestInfo&test_info) override OnTestCaseEnd() Declaration void testing::internal::TestEventRepeater::OnTestCaseEnd(const TestCase&parameter) override OnTestSuiteEnd() Declaration void testing::internal::TestEventRepeater::OnTestSuiteEnd(const TestSuite&parameter) override OnEnvironmentsTearDownStart() Declaration void testing::internal::TestEventRepeater::OnEnvironmentsTearDownStart(const UnitTest&unit_test) override OnEnvironmentsTearDownEnd() Declaration void testing::internal::TestEventRepeater::OnEnvironmentsTearDownEnd(const UnitTest&unit_test) override OnTestIterationEnd() Declaration void testing::internal::TestEventRepeater::OnTestIterationEnd(const UnitTest&unit_test, int iteration) override OnTestProgramEnd() Declaration void testing::internal::TestEventRepeater::OnTestProgramEnd(const UnitTest&unit_test) override ~TestEventRepeater() Declaration virtual testing::internal::TestEventRepeater::~TestEventRepeater() Append() Declaration void testing::internal::TestEventRepeater::Append(TestEventListener *listener) Release() Declaration TestEventListener* testing::internal::TestEventRepeater::Release(TestEventListener *listener) forwarding_enabled() Declaration bool testing::internal::TestEventRepeater::forwarding_enabled() const set_forwarding_enabled() Declaration void testing::internal::TestEventRepeater::set_forwarding_enabled(bool enable) OnTestProgramStart() Declaration virtual void testing::internal::TestEventRepeater::OnTestProgramStart(const UnitTest&unit_test) OnTestIterationStart() Declaration virtual void testing::internal::TestEventRepeater::OnTestIterationStart(const UnitTest&unit_test, int iteration) OnEnvironmentsSetUpStart() Declaration virtual void testing::internal::TestEventRepeater::OnEnvironmentsSetUpStart(const UnitTest&unit_test) OnEnvironmentsSetUpEnd() Declaration virtual void testing::internal::TestEventRepeater::OnEnvironmentsSetUpEnd(const UnitTest&unit_test) OnTestCaseStart() Declaration virtual void testing::internal::TestEventRepeater::OnTestCaseStart(const TestCase&test_case) OnTestStart() Declaration virtual void testing::internal::TestEventRepeater::OnTestStart(const TestInfo&test_info) OnTestPartResult() Declaration virtual void testing::internal::TestEventRepeater::OnTestPartResult(const TestPartResult&result) OnTestEnd() Declaration virtual void testing::internal::TestEventRepeater::OnTestEnd(const TestInfo&test_info) OnTestCaseEnd() Declaration virtual void testing::internal::TestEventRepeater::OnTestCaseEnd(const TestCase&test_case) OnEnvironmentsTearDownStart() Declaration virtual void testing::internal::TestEventRepeater::OnEnvironmentsTearDownStart(const UnitTest&unit_test) OnEnvironmentsTearDownEnd() Declaration virtual void testing::internal::TestEventRepeater::OnEnvironmentsTearDownEnd(const UnitTest&unit_test) OnTestIterationEnd() Declaration virtual void testing::internal::TestEventRepeater::OnTestIterationEnd(const UnitTest&unit_test, int iteration) OnTestProgramEnd() Declaration virtual void testing::internal::TestEventRepeater::OnTestProgramEnd(const UnitTest&unit_test) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::TestEventRepeater::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventRepeater) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::TestEventRepeater::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventRepeater)"
  },
  "api/testing/internal/test-factory-base.html": {
    "href": "api/testing/internal/test-factory-base.html",
    "title": "Class testing::internal::TestFactoryBase | qiotoolkit",
    "keywords": "Class testing::internal::TestFactoryBase Inheritance testing::internal::TestFactoryBase testing::internal::ParameterizedTestFactory testing::internal::TestFactoryImpl Constructors TestFactoryBase() Declaration testing::internal::TestFactoryBase::TestFactoryBase() TestFactoryBase() Declaration testing::internal::TestFactoryBase::TestFactoryBase() Methods ~TestFactoryBase() Declaration virtual testing::internal::TestFactoryBase::~TestFactoryBase() CreateTest() Declaration virtual Test* testing::internal::TestFactoryBase::CreateTest()=0 ~TestFactoryBase() Declaration virtual testing::internal::TestFactoryBase::~TestFactoryBase() CreateTest() Declaration virtual Test* testing::internal::TestFactoryBase::CreateTest()=0 GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::TestFactoryBase::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::TestFactoryBase::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestFactoryBase)"
  },
  "api/testing/internal/test-factory-impl.html": {
    "href": "api/testing/internal/test-factory-impl.html",
    "title": "Class testing::internal::TestFactoryImpl | qiotoolkit",
    "keywords": "Class testing::internal::TestFactoryImpl Inheritance testing::internal::TestFactoryBase testing::internal::TestFactoryImpl Inherited Members ~TestFactoryBase TestFactoryBase Methods CreateTest() Declaration Test* testing::internal::TestFactoryImpl<TestClass>::CreateTest() override CreateTest() Declaration virtual Test* testing::internal::TestFactoryImpl<TestClass>::CreateTest()"
  },
  "api/testing/internal/test-meta-factory-base.html": {
    "href": "api/testing/internal/test-meta-factory-base.html",
    "title": "Class testing::internal::TestMetaFactoryBase | qiotoolkit",
    "keywords": "Class testing::internal::TestMetaFactoryBase Inheritance testing::internal::TestMetaFactoryBase Methods ~TestMetaFactoryBase() Declaration virtual testing::internal::TestMetaFactoryBase<ParamType>::~TestMetaFactoryBase() CreateTestFactory() Declaration virtual TestFactoryBase* testing::internal::TestMetaFactoryBase<ParamType>::CreateTestFactory(ParamType parameter)=0 ~TestMetaFactoryBase() Declaration virtual testing::internal::TestMetaFactoryBase<ParamType>::~TestMetaFactoryBase() CreateTestFactory() Declaration virtual TestFactoryBase* testing::internal::TestMetaFactoryBase<ParamType>::CreateTestFactory(ParamType parameter)=0"
  },
  "api/testing/internal/test-meta-factory.html": {
    "href": "api/testing/internal/test-meta-factory.html",
    "title": "Class testing::internal::TestMetaFactory | qiotoolkit",
    "keywords": "Class testing::internal::TestMetaFactory Inheritance testing::internal::TestMetaFactoryBase testing::internal::TestMetaFactory Inherited Members CreateTestFactory ~TestMetaFactoryBase Constructors TestMetaFactory() Declaration testing::internal::TestMetaFactory<TestSuite>::TestMetaFactory() TestMetaFactory() Declaration testing::internal::TestMetaFactory<TestSuite>::TestMetaFactory() Methods CreateTestFactory() Declaration TestFactoryBase* testing::internal::TestMetaFactory<TestSuite>::CreateTestFactory(ParamType parameter) override CreateTestFactory() Declaration virtual TestFactoryBase* testing::internal::TestMetaFactory<TestSuite>::CreateTestFactory(ParamType parameter) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::TestMetaFactory<TestSuite>::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestMetaFactory) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::TestMetaFactory<TestSuite>::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestMetaFactory)"
  },
  "api/testing/internal/test-property-key-is.html": {
    "href": "api/testing/internal/test-property-key-is.html",
    "title": "Class testing::internal::TestPropertyKeyIs | qiotoolkit",
    "keywords": "Class testing::internal::TestPropertyKeyIs Inheritance testing::internal::TestPropertyKeyIs Constructors TestPropertyKeyIs() Declaration testing::internal::TestPropertyKeyIs::TestPropertyKeyIs(const std::string&key) Methods operator()() Declaration bool testing::internal::TestPropertyKeyIs::operator()(const TestProperty&test_property) const"
  },
  "api/testing/internal/test-result-accessor.html": {
    "href": "api/testing/internal/test-result-accessor.html",
    "title": "Class testing::internal::TestResultAccessor | qiotoolkit",
    "keywords": "Class testing::internal::TestResultAccessor Inheritance testing::internal::TestResultAccessor Methods RecordProperty() Declaration static void testing::internal::TestResultAccessor::RecordProperty(TestResult *test_result, const std::string&xml_element, const TestProperty&property) ClearTestPartResults() Declaration static void testing::internal::TestResultAccessor::ClearTestPartResults(TestResult *test_result) test_part_results() Declaration static const std::vector<testing::TestPartResult>&testing::internal::TestResultAccessor::test_part_results(const TestResult&test_result)"
  },
  "api/testing/internal/test-suite-name-is.html": {
    "href": "api/testing/internal/test-suite-name-is.html",
    "title": "Class testing::internal::TestSuiteNameIs | qiotoolkit",
    "keywords": "Class testing::internal::TestSuiteNameIs Inheritance testing::internal::TestSuiteNameIs Constructors TestSuiteNameIs() Declaration testing::internal::TestSuiteNameIs::TestSuiteNameIs(const std::string&name) Methods operator()() Declaration bool testing::internal::TestSuiteNameIs::operator()(const TestSuite *test_suite) const"
  },
  "api/testing/internal/thread-local.html": {
    "href": "api/testing/internal/thread-local.html",
    "title": "Class testing::internal::ThreadLocal | qiotoolkit",
    "keywords": "Class testing::internal::ThreadLocal Inheritance testing::internal::ThreadLocal Constructors ThreadLocal() Declaration testing::internal::ThreadLocal<T>::ThreadLocal() ThreadLocal() Declaration testing::internal::ThreadLocal<T>::ThreadLocal(const T&value) ThreadLocal() Declaration testing::internal::ThreadLocal<T>::ThreadLocal() ThreadLocal() Declaration testing::internal::ThreadLocal<T>::ThreadLocal(const T&value) Methods pointer() Declaration T* testing::internal::ThreadLocal<T>::pointer() pointer() Declaration const T* testing::internal::ThreadLocal<T>::pointer() const get() Declaration const T&testing::internal::ThreadLocal<T>::get() const set() Declaration void testing::internal::ThreadLocal<T>::set(const T&value) pointer() Declaration T* testing::internal::ThreadLocal<T>::pointer() pointer() Declaration const T* testing::internal::ThreadLocal<T>::pointer() const get() Declaration const T&testing::internal::ThreadLocal<T>::get() const set() Declaration void testing::internal::ThreadLocal<T>::set(const T&value)"
  },
  "api/testing/internal/trace-info.html": {
    "href": "api/testing/internal/trace-info.html",
    "title": "Struct testing::internal::TraceInfo | qiotoolkit",
    "keywords": "Struct testing::internal::TraceInfo"
  },
  "api/testing/internal/transform-tuple-values-helper.html": {
    "href": "api/testing/internal/transform-tuple-values-helper.html",
    "title": "Class testing::internal::TransformTupleValuesHelper | qiotoolkit",
    "keywords": "Class testing::internal::TransformTupleValuesHelper Inheritance testing::internal::TransformTupleValuesHelper Methods Run() Declaration static OutIter testing::internal::TransformTupleValuesHelper<Tuple, Func, OutIter>::Run(Func f, const Tuple&t, OutIter out)"
  },
  "api/testing/internal/transform-tuple-values-helper/iterate-over-tuple.html": {
    "href": "api/testing/internal/transform-tuple-values-helper/iterate-over-tuple.html",
    "title": "Struct testing::internal::TransformTupleValuesHelper::IterateOverTuple | qiotoolkit",
    "keywords": "Struct testing::internal::TransformTupleValuesHelper::IterateOverTuple Methods operator()() Declaration OutIter testing::internal::TransformTupleValuesHelper<Tuple, Func, OutIter>::IterateOverTuple<Tup, kRemainingSize>::operator()(Func f, const Tup&t, OutIter out) const"
  },
  "api/testing/internal/transform-tuple-values-helper/iterate-over-tuple/3/01-tup/00/010/01/4.html": {
    "href": "api/testing/internal/transform-tuple-values-helper/iterate-over-tuple/3/01-tup/00/010/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Methods operator()() Declaration OutIter testing::internal::TransformTupleValuesHelper<Tuple, Func, OutIter>::IterateOverTuple<Tup, 0>::operator()(Func, const Tup&, OutIter out) const"
  },
  "api/testing/internal/truly-matcher.html": {
    "href": "api/testing/internal/truly-matcher.html",
    "title": "Class testing::internal::TrulyMatcher | qiotoolkit",
    "keywords": "Class testing::internal::TrulyMatcher Inheritance testing::internal::TrulyMatcher Constructors TrulyMatcher() Declaration testing::internal::TrulyMatcher<Predicate>::TrulyMatcher(Predicate pred) Methods MatchAndExplain() Declaration bool testing::internal::TrulyMatcher<Predicate>::MatchAndExplain(T&x, MatchResultListener *) const DescribeTo() Declaration void testing::internal::TrulyMatcher<Predicate>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::TrulyMatcher<Predicate>::DescribeNegationTo(::std::ostream *os) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::TrulyMatcher<Predicate>::GTEST_DISALLOW_ASSIGN_(TrulyMatcher)"
  },
  "api/testing/internal/tuple-fields.html": {
    "href": "api/testing/internal/tuple-fields.html",
    "title": "Class testing::internal::TupleFields | qiotoolkit",
    "keywords": "Class testing::internal::TupleFields Inheritance testing::internal::TupleFields Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, k9>::GetSelectedFields(const Tuple&t)"
  },
  "api/testing/internal/tuple-fields/3/01-tuple/00/01-1/00/01-1/00/01-1/00/01-1/00/01-1/00/01-e023d39d312048e71832a898e9e07f70.html": {
    "href": "api/testing/internal/tuple-fields/3/01-tuple/00/01-1/00/01-1/00/01-1/00/01-1/00/01-1/00/01-e023d39d312048e71832a898e9e07f70.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1>::GetSelectedFields(const Tuple&)"
  },
  "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01-1/00/01-1/00/01-1/00/01-1/00/01-d80da5b2d6dff94ddefe7f2fc2de778d.html": {
    "href": "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01-1/00/01-1/00/01-1/00/01-1/00/01-d80da5b2d6dff94ddefe7f2fc2de778d.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, k0, -1, -1, -1, -1, -1, -1, -1, -1, -1>::GetSelectedFields(const Tuple&t)"
  },
  "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01-1/00/01-1/00/01-1/00/01-fb5812c507091ce72ac353453b83394d.html": {
    "href": "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01-1/00/01-1/00/01-1/00/01-fb5812c507091ce72ac353453b83394d.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, k0, k1, -1, -1, -1, -1, -1, -1, -1, -1>::GetSelectedFields(const Tuple&t)"
  },
  "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01-1/00/01-1/00/01-d40fb0064dd627afc9c2b7f6513ffcb3.html": {
    "href": "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01-1/00/01-1/00/01-d40fb0064dd627afc9c2b7f6513ffcb3.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, k0, k1, k2, -1, -1, -1, -1, -1, -1, -1>::GetSelectedFields(const Tuple&t)"
  },
  "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01-1/00/01-5ce285d726b58f03354f318c4712939e.html": {
    "href": "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01-1/00/01-5ce285d726b58f03354f318c4712939e.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, k0, k1, k2, k3, -1, -1, -1, -1, -1, -1>::GetSelectedFields(const Tuple&t)"
  },
  "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01k4/00/01-111caa1fee55a41736499c292bb1a612.html": {
    "href": "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01k4/00/01-111caa1fee55a41736499c292bb1a612.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, k0, k1, k2, k3, k4, -1, -1, -1, -1, -1>::GetSelectedFields(const Tuple&t)"
  },
  "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01k4/00/01k15c11b8436218f7eb1523adb30f3f284.html": {
    "href": "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01k4/00/01k15c11b8436218f7eb1523adb30f3f284.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, k0, k1, k2, k3, k4, k5, -1, -1, -1, -1>::GetSelectedFields(const Tuple&t)"
  },
  "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01k4/00/01k478398ee7a3c50306b8ce1483964573e.html": {
    "href": "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01k4/00/01k478398ee7a3c50306b8ce1483964573e.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, -1>::GetSelectedFields(const Tuple&t)"
  },
  "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01k4/00/01kb66bdb5aa3faae197a495470a1b8e9d1.html": {
    "href": "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01k4/00/01kb66bdb5aa3faae197a495470a1b8e9d1.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, -1, -1>::GetSelectedFields(const Tuple&t)"
  },
  "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01k4/00/01keabdf503bd0192bc35ddb795df95316f.html": {
    "href": "api/testing/internal/tuple-fields/3/01-tuple/00/01k0/00/01k1/00/01k2/00/01k3/00/01k4/00/01keabdf503bd0192bc35ddb795df95316f.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods GetSelectedFields() Declaration static type testing::internal::TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, -1, -1, -1>::GetSelectedFields(const Tuple&t)"
  },
  "api/testing/internal/tuple-policy.html": {
    "href": "api/testing/internal/tuple-policy.html",
    "title": "Struct testing::internal::TuplePolicy | qiotoolkit",
    "keywords": "Struct testing::internal::TuplePolicy"
  },
  "api/testing/internal/tuple-prefix.html": {
    "href": "api/testing/internal/tuple-prefix.html",
    "title": "Class testing::internal::TuplePrefix | qiotoolkit",
    "keywords": "Class testing::internal::TuplePrefix Inheritance testing::internal::TuplePrefix Methods Matches() Declaration static bool testing::internal::TuplePrefix<N>::Matches(const MatcherTuple&matcher_tuple, const ValueTuple&value_tuple) ExplainMatchFailuresTo() Declaration static void testing::internal::TuplePrefix<N>::ExplainMatchFailuresTo(const MatcherTuple&matchers, const ValueTuple&values, ::std::ostream *os)"
  },
  "api/testing/internal/tuple-prefix/3/010/01/4.html": {
    "href": "api/testing/internal/tuple-prefix/3/010/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Matches() Declaration static bool testing::internal::TuplePrefix<0>::Matches(const MatcherTuple&, const ValueTuple&) ExplainMatchFailuresTo() Declaration static void testing::internal::TuplePrefix<0>::ExplainMatchFailuresTo(const MatcherTuple&, const ValueTuple&, ::std::ostream *)"
  },
  "api/testing/internal/type-id-helper.html": {
    "href": "api/testing/internal/type-id-helper.html",
    "title": "Class testing::internal::TypeIdHelper | qiotoolkit",
    "keywords": "Class testing::internal::TypeIdHelper Inheritance testing::internal::TypeIdHelper"
  },
  "api/testing/internal/type-with-size.html": {
    "href": "api/testing/internal/type-with-size.html",
    "title": "Class testing::internal::TypeWithSize | qiotoolkit",
    "keywords": "Class testing::internal::TypeWithSize Inheritance testing::internal::TypeWithSize"
  },
  "api/testing/internal/type-with-size/3/014/01/4.html": {
    "href": "api/testing/internal/type-with-size/3/014/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance >"
  },
  "api/testing/internal/type-with-size/3/018/01/4.html": {
    "href": "api/testing/internal/type-with-size/3/018/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance >"
  },
  "api/testing/internal/type/equals.html": {
    "href": "api/testing/internal/type/equals.html",
    "title": "Struct testing::internal::type_equals | qiotoolkit",
    "keywords": "Struct testing::internal::type_equals"
  },
  "api/testing/internal/type/equals/3/01-t/00/01-t/01/4.html": {
    "href": "api/testing/internal/type/equals/3/01-t/00/01-t/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct >"
  },
  "api/testing/internal/typed-expectation.html": {
    "href": "api/testing/internal/typed-expectation.html",
    "title": "Class testing::internal::TypedExpectation | qiotoolkit",
    "keywords": "Class testing::internal::TypedExpectation Inheritance testing::internal::TypedExpectation Constructors TypedExpectation() Declaration testing::internal::TypedExpectation<F>::TypedExpectation(FunctionMockerBase<F>*owner, const char *a_file, int a_line, const std::string&a_source_text, const ArgumentMatcherTuple&m) Methods ~TypedExpectation() Declaration virtual testing::internal::TypedExpectation<F>::~TypedExpectation() With() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::With(const Matcher<const ArgumentTuple&>&m) Times() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::Times(const Cardinality&a_cardinality) Times() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::Times(int n) InSequence() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::InSequence(const Sequence&s) InSequence() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::InSequence(const Sequence&s1, const Sequence&s2) InSequence() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::InSequence(const Sequence&s1, const Sequence&s2, const Sequence&s3) InSequence() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::InSequence(const Sequence&s1, const Sequence&s2, const Sequence&s3, const Sequence&s4) InSequence() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::InSequence(const Sequence&s1, const Sequence&s2, const Sequence&s3, const Sequence&s4, const Sequence&s5) After() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::After(const ExpectationSet&s) After() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::After(const ExpectationSet&s1, const ExpectationSet&s2) After() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::After(const ExpectationSet&s1, const ExpectationSet&s2, const ExpectationSet&s3) After() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::After(const ExpectationSet&s1, const ExpectationSet&s2, const ExpectationSet&s3, const ExpectationSet&s4) After() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::After(const ExpectationSet&s1, const ExpectationSet&s2, const ExpectationSet&s3, const ExpectationSet&s4, const ExpectationSet&s5) WillOnce() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::WillOnce(const Action<F>&action) WillRepeatedly() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::WillRepeatedly(const Action<F>&action) RetiresOnSaturation() Declaration TypedExpectation&testing::internal::TypedExpectation<F>::RetiresOnSaturation() matchers() Declaration const ArgumentMatcherTuple&testing::internal::TypedExpectation<F>::matchers() const extra_matcher() Declaration const Matcher<const ArgumentTuple&>&testing::internal::TypedExpectation<F>::extra_matcher() const repeated_action() Declaration const Action<F>&testing::internal::TypedExpectation<F>::repeated_action() const MaybeDescribeExtraMatcherTo() Declaration virtual void testing::internal::TypedExpectation<F>::MaybeDescribeExtraMatcherTo(::std::ostream *os) GetHandle() Declaration virtual Expectation testing::internal::TypedExpectation<F>::GetHandle() Matches() Declaration bool testing::internal::TypedExpectation<F>::Matches(const ArgumentTuple&args) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) ShouldHandleArguments() Declaration bool testing::internal::TypedExpectation<F>::ShouldHandleArguments(const ArgumentTuple&args) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) ExplainMatchResultTo() Declaration void testing::internal::TypedExpectation<F>::ExplainMatchResultTo(const ArgumentTuple&args, ::std::ostream *os) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) GetCurrentAction() Declaration const Action<F>&testing::internal::TypedExpectation<F>::GetCurrentAction(const FunctionMockerBase<F>*mocker, const ArgumentTuple&args) const GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) GetActionForArguments() Declaration const Action<F>* testing::internal::TypedExpectation<F>::GetActionForArguments(const FunctionMockerBase<F>*mocker, const ArgumentTuple&args, ::std::ostream *what, ::std::ostream *why) GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::TypedExpectation<F>::GTEST_DISALLOW_COPY_AND_ASSIGN_(TypedExpectation)"
  },
  "api/testing/internal/unit-test-impl.html": {
    "href": "api/testing/internal/unit-test-impl.html",
    "title": "Class testing::internal::UnitTestImpl | qiotoolkit",
    "keywords": "Class testing::internal::UnitTestImpl Inheritance testing::internal::UnitTestImpl Constructors UnitTestImpl() Declaration testing::internal::UnitTestImpl::UnitTestImpl(UnitTest *parent) Methods ~UnitTestImpl() Declaration testing::internal::UnitTestImpl::~UnitTestImpl() GetGlobalTestPartResultReporter() Declaration TestPartResultReporterInterface * testing::internal::UnitTestImpl::GetGlobalTestPartResultReporter() SetGlobalTestPartResultReporter() Declaration void testing::internal::UnitTestImpl::SetGlobalTestPartResultReporter(TestPartResultReporterInterface *reporter) GetTestPartResultReporterForCurrentThread() Declaration TestPartResultReporterInterface * testing::internal::UnitTestImpl::GetTestPartResultReporterForCurrentThread() SetTestPartResultReporterForCurrentThread() Declaration void testing::internal::UnitTestImpl::SetTestPartResultReporterForCurrentThread(TestPartResultReporterInterface *reporter) successful_test_case_count() Declaration int testing::internal::UnitTestImpl::successful_test_case_count() const failed_test_case_count() Declaration int testing::internal::UnitTestImpl::failed_test_case_count() const total_test_case_count() Declaration int testing::internal::UnitTestImpl::total_test_case_count() const test_case_to_run_count() Declaration int testing::internal::UnitTestImpl::test_case_to_run_count() const successful_test_count() Declaration int testing::internal::UnitTestImpl::successful_test_count() const failed_test_count() Declaration int testing::internal::UnitTestImpl::failed_test_count() const reportable_disabled_test_count() Declaration int testing::internal::UnitTestImpl::reportable_disabled_test_count() const disabled_test_count() Declaration int testing::internal::UnitTestImpl::disabled_test_count() const reportable_test_count() Declaration int testing::internal::UnitTestImpl::reportable_test_count() const total_test_count() Declaration int testing::internal::UnitTestImpl::total_test_count() const test_to_run_count() Declaration int testing::internal::UnitTestImpl::test_to_run_count() const start_timestamp() Declaration TimeInMillis testing::internal::UnitTestImpl::start_timestamp() const elapsed_time() Declaration TimeInMillis testing::internal::UnitTestImpl::elapsed_time() const Passed() Declaration bool testing::internal::UnitTestImpl::Passed() const Failed() Declaration bool testing::internal::UnitTestImpl::Failed() const GetTestCase() Declaration const TestCase* testing::internal::UnitTestImpl::GetTestCase(int i) const GetMutableTestCase() Declaration TestCase* testing::internal::UnitTestImpl::GetMutableTestCase(int i) listeners() Declaration TestEventListeners* testing::internal::UnitTestImpl::listeners() current_test_result() Declaration TestResult * testing::internal::UnitTestImpl::current_test_result() ad_hoc_test_result() Declaration const TestResult* testing::internal::UnitTestImpl::ad_hoc_test_result() const set_os_stack_trace_getter() Declaration void testing::internal::UnitTestImpl::set_os_stack_trace_getter(OsStackTraceGetterInterface *getter) os_stack_trace_getter() Declaration OsStackTraceGetterInterface * testing::internal::UnitTestImpl::os_stack_trace_getter() CurrentOsStackTraceExceptTop() Declaration std::string testing::internal::UnitTestImpl::CurrentOsStackTraceExceptTop(int skip_count) GTEST_NO_INLINE_ GetTestCase() Declaration TestCase * testing::internal::UnitTestImpl::GetTestCase(const char *test_case_name, const char *type_param, Test::SetUpTestCaseFunc set_up_tc, Test::TearDownTestCaseFunc tear_down_tc) AddTestInfo() Declaration void testing::internal::UnitTestImpl::AddTestInfo(Test::SetUpTestCaseFunc set_up_tc, Test::TearDownTestCaseFunc tear_down_tc, TestInfo *test_info) parameterized_test_registry() Declaration internal::ParameterizedTestCaseRegistry&testing::internal::UnitTestImpl::parameterized_test_registry() set_current_test_case() Declaration void testing::internal::UnitTestImpl::set_current_test_case(TestCase *a_current_test_case) set_current_test_info() Declaration void testing::internal::UnitTestImpl::set_current_test_info(TestInfo *a_current_test_info) RegisterParameterizedTests() Declaration void testing::internal::UnitTestImpl::RegisterParameterizedTests() RunAllTests() Declaration bool testing::internal::UnitTestImpl::RunAllTests() ClearNonAdHocTestResult() Declaration void testing::internal::UnitTestImpl::ClearNonAdHocTestResult() ClearAdHocTestResult() Declaration void testing::internal::UnitTestImpl::ClearAdHocTestResult() RecordProperty() Declaration void testing::internal::UnitTestImpl::RecordProperty(const TestProperty&test_property) FilterTests() Declaration int testing::internal::UnitTestImpl::FilterTests(ReactionToSharding shard_tests) ListTestsMatchingFilter() Declaration void testing::internal::UnitTestImpl::ListTestsMatchingFilter() current_test_case() Declaration const TestCase* testing::internal::UnitTestImpl::current_test_case() const current_test_info() Declaration TestInfo* testing::internal::UnitTestImpl::current_test_info() current_test_info() Declaration const TestInfo* testing::internal::UnitTestImpl::current_test_info() const environments() Declaration std::vector<Environment*>&testing::internal::UnitTestImpl::environments() gtest_trace_stack() Declaration std::vector<TraceInfo>&testing::internal::UnitTestImpl::gtest_trace_stack() gtest_trace_stack() Declaration const std::vector<TraceInfo>&testing::internal::UnitTestImpl::gtest_trace_stack() const ConfigureXmlOutput() Declaration void testing::internal::UnitTestImpl::ConfigureXmlOutput() PostFlagParsingInit() Declaration void testing::internal::UnitTestImpl::PostFlagParsingInit() random_seed() Declaration int testing::internal::UnitTestImpl::random_seed() const random() Declaration internal::Random* testing::internal::UnitTestImpl::random() ShuffleTests() Declaration void testing::internal::UnitTestImpl::ShuffleTests() UnshuffleTests() Declaration void testing::internal::UnitTestImpl::UnshuffleTests() catch_exceptions() Declaration bool testing::internal::UnitTestImpl::catch_exceptions() const set_catch_exceptions() Declaration void testing::internal::UnitTestImpl::set_catch_exceptions(bool value) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::UnitTestImpl::GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTestImpl)"
  },
  "api/testing/internal/unit-test-options.html": {
    "href": "api/testing/internal/unit-test-options.html",
    "title": "Class testing::internal::UnitTestOptions | qiotoolkit",
    "keywords": "Class testing::internal::UnitTestOptions Inheritance testing::internal::UnitTestOptions Methods GetOutputFormat() Declaration std::string testing::internal::UnitTestOptions::GetOutputFormat() GetAbsolutePathToOutputFile() Declaration std::string testing::internal::UnitTestOptions::GetAbsolutePathToOutputFile() PatternMatchesString() Declaration bool testing::internal::UnitTestOptions::PatternMatchesString(const char *pattern, const char *str) FilterMatchesTest() Declaration bool testing::internal::UnitTestOptions::FilterMatchesTest(const std::string&test_case_name, const std::string&test_name) MatchesFilter() Declaration bool testing::internal::UnitTestOptions::MatchesFilter(const std::string&name, const char *filter)"
  },
  "api/testing/internal/universal-printer.html": {
    "href": "api/testing/internal/universal-printer.html",
    "title": "Class testing::internal::UniversalPrinter | qiotoolkit",
    "keywords": "Class testing::internal::UniversalPrinter Inheritance testing::internal::UniversalPrinter Methods Print() Declaration static void testing::internal::UniversalPrinter<T>::Print(const T&value, ::std::ostream *os) Print() Declaration static void testing::internal::UniversalPrinter<T>::Print(const T&value, ::std::ostream *os)"
  },
  "api/testing/internal/universal-printer/3/01-t/01/6/01/4.html": {
    "href": "api/testing/internal/universal-printer/3/01-t/01/6/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Print() Declaration static void testing::internal::UniversalPrinter<T&>::Print(const T&value, ::std::ostream *os) Print() Declaration static void testing::internal::UniversalPrinter<T&>::Print(const T&value, ::std::ostream *os)"
  },
  "api/testing/internal/universal-printer/3/01-t/0f-n/0e/4.html": {
    "href": "api/testing/internal/universal-printer/3/01-t/0f-n/0e/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Print() Declaration static void testing::internal::UniversalPrinter<T[N]>::Print(const T(&a)[N], ::std::ostream *os) Print() Declaration static void testing::internal::UniversalPrinter<T[N]>::Print(const T(&a)[N], ::std::ostream *os)"
  },
  "api/testing/internal/universal-terse-printer.html": {
    "href": "api/testing/internal/universal-terse-printer.html",
    "title": "Class testing::internal::UniversalTersePrinter | qiotoolkit",
    "keywords": "Class testing::internal::UniversalTersePrinter Inheritance testing::internal::UniversalTersePrinter Methods Print() Declaration static void testing::internal::UniversalTersePrinter<T>::Print(const T&value, ::std::ostream *os) Print() Declaration static void testing::internal::UniversalTersePrinter<T>::Print(const T&value, ::std::ostream *os)"
  },
  "api/testing/internal/universal-terse-printer/3/01-t/01/6/01/4.html": {
    "href": "api/testing/internal/universal-terse-printer/3/01-t/01/6/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Print() Declaration static void testing::internal::UniversalTersePrinter<T&>::Print(const T&value, ::std::ostream *os) Print() Declaration static void testing::internal::UniversalTersePrinter<T&>::Print(const T&value, ::std::ostream *os)"
  },
  "api/testing/internal/universal-terse-printer/3/01-t/0f-n/0e/4.html": {
    "href": "api/testing/internal/universal-terse-printer/3/01-t/0f-n/0e/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Print() Declaration static void testing::internal::UniversalTersePrinter<T[N]>::Print(const T(&value)[N], ::std::ostream *os) Print() Declaration static void testing::internal::UniversalTersePrinter<T[N]>::Print(const T(&value)[N], ::std::ostream *os)"
  },
  "api/testing/internal/universal-terse-printer/3/01char/01/5/01/4.html": {
    "href": "api/testing/internal/universal-terse-printer/3/01char/01/5/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Print() Declaration static void testing::internal::UniversalTersePrinter<char *>::Print(char *str, ::std::ostream *os) Print() Declaration static void testing::internal::UniversalTersePrinter<char *>::Print(char *str, ::std::ostream *os)"
  },
  "api/testing/internal/universal-terse-printer/3/01const/01char/01/5/01/4.html": {
    "href": "api/testing/internal/universal-terse-printer/3/01const/01char/01/5/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Print() Declaration static void testing::internal::UniversalTersePrinter<const char *>::Print(const char *str, ::std::ostream *os) Print() Declaration static void testing::internal::UniversalTersePrinter<const char *>::Print(const char *str, ::std::ostream *os)"
  },
  "api/testing/internal/universal-terse-printer/3/01wchar/t/01/5/01/4.html": {
    "href": "api/testing/internal/universal-terse-printer/3/01wchar/t/01/5/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods Print() Declaration static void testing::internal::UniversalTersePrinter<wchar_t *>::Print(wchar_t *str, ::std::ostream *os) Print() Declaration static void testing::internal::UniversalTersePrinter<wchar_t *>::Print(wchar_t *str, ::std::ostream *os)"
  },
  "api/testing/internal/unordered-elements-are-array-matcher.html": {
    "href": "api/testing/internal/unordered-elements-are-array-matcher.html",
    "title": "Class testing::internal::UnorderedElementsAreArrayMatcher | qiotoolkit",
    "keywords": "Class testing::internal::UnorderedElementsAreArrayMatcher Inheritance testing::internal::UnorderedElementsAreArrayMatcher Constructors UnorderedElementsAreArrayMatcher() Declaration testing::internal::UnorderedElementsAreArrayMatcher<T>::UnorderedElementsAreArrayMatcher(UnorderedMatcherRequire::Flags match_flags, Iter first, Iter last) Methods >() Declaration testing::internal::UnorderedElementsAreArrayMatcher<T>::operator Matcher<Container>() const >() Declaration testing::internal::UnorderedElementsAreArrayMatcher<T>::operator Matcher<Container>() const >() Declaration testing::internal::UnorderedElementsAreArrayMatcher<T>::operator Matcher<Container>() const >() Declaration testing::internal::UnorderedElementsAreArrayMatcher<T>::operator Matcher<Container>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::UnorderedElementsAreArrayMatcher<T>::GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreArrayMatcher)"
  },
  "api/testing/internal/unordered-elements-are-matcher-impl-base.html": {
    "href": "api/testing/internal/unordered-elements-are-matcher-impl-base.html",
    "title": "Class testing::internal::UnorderedElementsAreMatcherImplBase | qiotoolkit",
    "keywords": "Class testing::internal::UnorderedElementsAreMatcherImplBase Inheritance testing::internal::UnorderedElementsAreMatcherImplBase testing::internal::UnorderedElementsAreMatcherImpl Constructors UnorderedElementsAreMatcherImplBase() Declaration testing::internal::UnorderedElementsAreMatcherImplBase::UnorderedElementsAreMatcherImplBase(UnorderedMatcherRequire::Flags matcher_flags) Methods DescribeToImpl() Declaration void testing::internal::UnorderedElementsAreMatcherImplBase::DescribeToImpl(::std::ostream *os) const DescribeNegationToImpl() Declaration void testing::internal::UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(::std::ostream *os) const VerifyMatchMatrix() Declaration bool testing::internal::UnorderedElementsAreMatcherImplBase::VerifyMatchMatrix(const ::std::vector<std::string>&element_printouts, const MatchMatrix&matrix, MatchResultListener *listener) const FindPairing() Declaration bool testing::internal::UnorderedElementsAreMatcherImplBase::FindPairing(const MatchMatrix&matrix, MatchResultListener *listener) const matcher_describers() Declaration MatcherDescriberVec&testing::internal::UnorderedElementsAreMatcherImplBase::matcher_describers() match_flags() Declaration UnorderedMatcherRequire::Flags testing::internal::UnorderedElementsAreMatcherImplBase::match_flags() const Elements() Declaration static Message testing::internal::UnorderedElementsAreMatcherImplBase::Elements(size_t n) GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::UnorderedElementsAreMatcherImplBase::GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImplBase)"
  },
  "api/testing/internal/unordered-elements-are-matcher-impl.html": {
    "href": "api/testing/internal/unordered-elements-are-matcher-impl.html",
    "title": "Class testing::internal::UnorderedElementsAreMatcherImpl | qiotoolkit",
    "keywords": "Class testing::internal::UnorderedElementsAreMatcherImpl Inheritance testing::MatcherInterface testing::internal::UnorderedElementsAreMatcherImplBase testing::internal::UnorderedElementsAreMatcherImpl Inherited Members ~MatcherDescriberInterface matcher_describers DescribeToImpl FindPairing VerifyMatchMatrix DescribeNegationToImpl Elements UnorderedElementsAreMatcherImplBase match_flags Constructors UnorderedElementsAreMatcherImpl() Declaration testing::internal::UnorderedElementsAreMatcherImpl<Container>::UnorderedElementsAreMatcherImpl(UnorderedMatcherRequire::Flags matcher_flags, InputIter first, InputIter last) Methods GTEST_REMOVE_REFERENCE_AND_CONST_() Declaration typedef testing::internal::UnorderedElementsAreMatcherImpl<Container>::GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer DescribeTo() Declaration virtual void testing::internal::UnorderedElementsAreMatcherImpl<Container>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::UnorderedElementsAreMatcherImpl<Container>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::UnorderedElementsAreMatcherImpl<Container>::MatchAndExplain(Container container, MatchResultListener *listener) const AnalyzeElements() Declaration MatchMatrix testing::internal::UnorderedElementsAreMatcherImpl<Container>::AnalyzeElements(ElementIter elem_first, ElementIter elem_last, ::std::vector<std::string>*element_printouts, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::UnorderedElementsAreMatcherImpl<Container>::GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImpl)"
  },
  "api/testing/internal/unordered-elements-are-matcher.html": {
    "href": "api/testing/internal/unordered-elements-are-matcher.html",
    "title": "Class testing::internal::UnorderedElementsAreMatcher | qiotoolkit",
    "keywords": "Class testing::internal::UnorderedElementsAreMatcher Inheritance testing::internal::UnorderedElementsAreMatcher Constructors UnorderedElementsAreMatcher() Declaration testing::internal::UnorderedElementsAreMatcher<MatcherTuple>::UnorderedElementsAreMatcher(const MatcherTuple&args) Methods >() Declaration testing::internal::UnorderedElementsAreMatcher<MatcherTuple>::operator Matcher<Container>() const >() Declaration testing::internal::UnorderedElementsAreMatcher<MatcherTuple>::operator Matcher<Container>() const >() Declaration testing::internal::UnorderedElementsAreMatcher<MatcherTuple>::operator Matcher<Container>() const >() Declaration testing::internal::UnorderedElementsAreMatcher<MatcherTuple>::operator Matcher<Container>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::UnorderedElementsAreMatcher<MatcherTuple>::GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcher)"
  },
  "api/testing/internal/unordered-matcher-require.html": {
    "href": "api/testing/internal/unordered-matcher-require.html",
    "title": "Struct testing::internal::UnorderedMatcherRequire | qiotoolkit",
    "keywords": "Struct testing::internal::UnorderedMatcherRequire"
  },
  "api/testing/internal/untyped-action-result-holder-base.html": {
    "href": "api/testing/internal/untyped-action-result-holder-base.html",
    "title": "Class testing::internal::UntypedActionResultHolderBase | qiotoolkit",
    "keywords": "Class testing::internal::UntypedActionResultHolderBase Inheritance testing::internal::UntypedActionResultHolderBase testing::internal::ActionResultHolder > Methods ~UntypedActionResultHolderBase() Declaration virtual testing::internal::UntypedActionResultHolderBase::~UntypedActionResultHolderBase() PrintAsActionResult() Declaration virtual void testing::internal::UntypedActionResultHolderBase::PrintAsActionResult(::std::ostream *os) const =0"
  },
  "api/testing/internal/untyped-function-mocker-base.html": {
    "href": "api/testing/internal/untyped-function-mocker-base.html",
    "title": "Class testing::internal::UntypedFunctionMockerBase | qiotoolkit",
    "keywords": "Class testing::internal::UntypedFunctionMockerBase Inheritance testing::internal::UntypedFunctionMockerBase Constructors UntypedFunctionMockerBase() Declaration testing::internal::UntypedFunctionMockerBase::UntypedFunctionMockerBase() Methods ~UntypedFunctionMockerBase() Declaration testing::internal::UntypedFunctionMockerBase::~UntypedFunctionMockerBase() VerifyAndClearExpectationsLocked() Declaration bool testing::internal::UntypedFunctionMockerBase::VerifyAndClearExpectationsLocked() GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) ClearDefaultActionsLocked() Declaration virtual void testing::internal::UntypedFunctionMockerBase::ClearDefaultActionsLocked() GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex)=0 UntypedPerformDefaultAction() Declaration virtual UntypedActionResultHolderBase* testing::internal::UntypedFunctionMockerBase::UntypedPerformDefaultAction(void *untyped_args, const std::string&call_description) const =0 UntypedPerformAction() Declaration virtual UntypedActionResultHolderBase* testing::internal::UntypedFunctionMockerBase::UntypedPerformAction(const void *untyped_action, void *untyped_args) const =0 UntypedDescribeUninterestingCall() Declaration virtual void testing::internal::UntypedFunctionMockerBase::UntypedDescribeUninterestingCall(const void *untyped_args, ::std::ostream *os) const GTEST_LOCK_EXCLUDED_(g_gmock_mutex)=0 UntypedFindMatchingExpectation() Declaration virtual const ExpectationBase* testing::internal::UntypedFunctionMockerBase::UntypedFindMatchingExpectation(const void *untyped_args, const void **untyped_action, bool *is_excessive, ::std::ostream *what, ::std::ostream *why) GTEST_LOCK_EXCLUDED_(g_gmock_mutex)=0 UntypedPrintArgs() Declaration virtual void testing::internal::UntypedFunctionMockerBase::UntypedPrintArgs(const void *untyped_args, ::std::ostream *os) const =0 RegisterOwner() Declaration void testing::internal::UntypedFunctionMockerBase::RegisterOwner(const void *mock_obj) GTEST_LOCK_EXCLUDED_(g_gmock_mutex) SetOwnerAndName() Declaration void testing::internal::UntypedFunctionMockerBase::SetOwnerAndName(const void *mock_obj, const char *name) GTEST_LOCK_EXCLUDED_(g_gmock_mutex) MockObject() Declaration const void * testing::internal::UntypedFunctionMockerBase::MockObject() const GTEST_LOCK_EXCLUDED_(g_gmock_mutex) Name() Declaration const char * testing::internal::UntypedFunctionMockerBase::Name() const GTEST_LOCK_EXCLUDED_(g_gmock_mutex) UntypedInvokeWith() Declaration UntypedActionResultHolderBase * testing::internal::UntypedFunctionMockerBase::UntypedInvokeWith(void *untyped_args) GTEST_LOCK_EXCLUDED_(g_gmock_mutex) GetHandleOf() Declaration Expectation testing::internal::UntypedFunctionMockerBase::GetHandleOf(ExpectationBase *exp)"
  },
  "api/testing/internal/untyped-on-call-spec-base.html": {
    "href": "api/testing/internal/untyped-on-call-spec-base.html",
    "title": "Class testing::internal::UntypedOnCallSpecBase | qiotoolkit",
    "keywords": "Class testing::internal::UntypedOnCallSpecBase Inheritance testing::internal::UntypedOnCallSpecBase testing::internal::OnCallSpec Constructors UntypedOnCallSpecBase() Declaration testing::internal::UntypedOnCallSpecBase::UntypedOnCallSpecBase(const char *a_file, int a_line) Methods file() Declaration const char* testing::internal::UntypedOnCallSpecBase::file() const line() Declaration int testing::internal::UntypedOnCallSpecBase::line() const AssertSpecProperty() Declaration void testing::internal::UntypedOnCallSpecBase::AssertSpecProperty(bool property, const std::string&failure_message) const ExpectSpecProperty() Declaration void testing::internal::UntypedOnCallSpecBase::ExpectSpecProperty(bool property, const std::string&failure_message) const"
  },
  "api/testing/internal/value-array.html": {
    "href": "api/testing/internal/value-array.html",
    "title": "Class testing::internal::ValueArray | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray Inheritance testing::internal::ValueArray Constructors ValueArray() Declaration testing::internal::ValueArray<Ts>::ValueArray(Ts... v) Methods >() Declaration testing::internal::ValueArray<Ts>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray<Ts>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray<Ts>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray<Ts>::operator ParamGenerator<T>() const MakeVector() Declaration std::vector<T>testing::internal::ValueArray<Ts>::MakeVector(IndexSequence<I...>) const"
  },
  "api/testing/internal/value-array1.html": {
    "href": "api/testing/internal/value-array1.html",
    "title": "Class testing::internal::ValueArray1 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray1 Inheritance testing::internal::ValueArray1 Constructors ValueArray1() Declaration testing::internal::ValueArray1<T1>::ValueArray1(T1 v1) Methods >() Declaration testing::internal::ValueArray1<T1>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray1<T1>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray1<T1>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray1<T1>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray1<T1>::operator=(const ValueArray1&other)"
  },
  "api/testing/internal/value-array10.html": {
    "href": "api/testing/internal/value-array10.html",
    "title": "Class testing::internal::ValueArray10 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray10 Inheritance testing::internal::ValueArray10 Constructors ValueArray10() Declaration testing::internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>::ValueArray10(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10) Methods >() Declaration testing::internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>::operator=(const ValueArray10&other)"
  },
  "api/testing/internal/value-array11.html": {
    "href": "api/testing/internal/value-array11.html",
    "title": "Class testing::internal::ValueArray11 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray11 Inheritance testing::internal::ValueArray11 Constructors ValueArray11() Declaration testing::internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>::ValueArray11(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11) Methods >() Declaration testing::internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>::operator=(const ValueArray11&other)"
  },
  "api/testing/internal/value-array12.html": {
    "href": "api/testing/internal/value-array12.html",
    "title": "Class testing::internal::ValueArray12 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray12 Inheritance testing::internal::ValueArray12 Constructors ValueArray12() Declaration testing::internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>::ValueArray12(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12) Methods >() Declaration testing::internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>::operator=(const ValueArray12&other)"
  },
  "api/testing/internal/value-array13.html": {
    "href": "api/testing/internal/value-array13.html",
    "title": "Class testing::internal::ValueArray13 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray13 Inheritance testing::internal::ValueArray13 Constructors ValueArray13() Declaration testing::internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>::ValueArray13(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13) Methods >() Declaration testing::internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>::operator=(const ValueArray13&other)"
  },
  "api/testing/internal/value-array14.html": {
    "href": "api/testing/internal/value-array14.html",
    "title": "Class testing::internal::ValueArray14 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray14 Inheritance testing::internal::ValueArray14 Constructors ValueArray14() Declaration testing::internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>::ValueArray14(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) Methods >() Declaration testing::internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>::operator=(const ValueArray14&other)"
  },
  "api/testing/internal/value-array15.html": {
    "href": "api/testing/internal/value-array15.html",
    "title": "Class testing::internal::ValueArray15 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray15 Inheritance testing::internal::ValueArray15 Constructors ValueArray15() Declaration testing::internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>::ValueArray15(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) Methods >() Declaration testing::internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>::operator=(const ValueArray15&other)"
  },
  "api/testing/internal/value-array16.html": {
    "href": "api/testing/internal/value-array16.html",
    "title": "Class testing::internal::ValueArray16 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray16 Inheritance testing::internal::ValueArray16 Constructors ValueArray16() Declaration testing::internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>::ValueArray16(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16) Methods >() Declaration testing::internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>::operator=(const ValueArray16&other)"
  },
  "api/testing/internal/value-array17.html": {
    "href": "api/testing/internal/value-array17.html",
    "title": "Class testing::internal::ValueArray17 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray17 Inheritance testing::internal::ValueArray17 Constructors ValueArray17() Declaration testing::internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>::ValueArray17(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17) Methods >() Declaration testing::internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>::operator=(const ValueArray17&other)"
  },
  "api/testing/internal/value-array18.html": {
    "href": "api/testing/internal/value-array18.html",
    "title": "Class testing::internal::ValueArray18 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray18 Inheritance testing::internal::ValueArray18 Constructors ValueArray18() Declaration testing::internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>::ValueArray18(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18) Methods >() Declaration testing::internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>::operator=(const ValueArray18&other)"
  },
  "api/testing/internal/value-array19.html": {
    "href": "api/testing/internal/value-array19.html",
    "title": "Class testing::internal::ValueArray19 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray19 Inheritance testing::internal::ValueArray19 Constructors ValueArray19() Declaration testing::internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>::ValueArray19(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19) Methods >() Declaration testing::internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>::operator=(const ValueArray19&other)"
  },
  "api/testing/internal/value-array2.html": {
    "href": "api/testing/internal/value-array2.html",
    "title": "Class testing::internal::ValueArray2 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray2 Inheritance testing::internal::ValueArray2 Constructors ValueArray2() Declaration testing::internal::ValueArray2<T1, T2>::ValueArray2(T1 v1, T2 v2) Methods >() Declaration testing::internal::ValueArray2<T1, T2>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray2<T1, T2>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray2<T1, T2>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray2<T1, T2>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray2<T1, T2>::operator=(const ValueArray2&other)"
  },
  "api/testing/internal/value-array20.html": {
    "href": "api/testing/internal/value-array20.html",
    "title": "Class testing::internal::ValueArray20 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray20 Inheritance testing::internal::ValueArray20 Constructors ValueArray20() Declaration testing::internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>::ValueArray20(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20) Methods >() Declaration testing::internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>::operator=(const ValueArray20&other)"
  },
  "api/testing/internal/value-array21.html": {
    "href": "api/testing/internal/value-array21.html",
    "title": "Class testing::internal::ValueArray21 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray21 Inheritance testing::internal::ValueArray21 Constructors ValueArray21() Declaration testing::internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>::ValueArray21(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21) Methods >() Declaration testing::internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>::operator=(const ValueArray21&other)"
  },
  "api/testing/internal/value-array22.html": {
    "href": "api/testing/internal/value-array22.html",
    "title": "Class testing::internal::ValueArray22 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray22 Inheritance testing::internal::ValueArray22 Constructors ValueArray22() Declaration testing::internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>::ValueArray22(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22) Methods >() Declaration testing::internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>::operator=(const ValueArray22&other)"
  },
  "api/testing/internal/value-array23.html": {
    "href": "api/testing/internal/value-array23.html",
    "title": "Class testing::internal::ValueArray23 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray23 Inheritance testing::internal::ValueArray23 Constructors ValueArray23() Declaration testing::internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>::ValueArray23(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23) Methods >() Declaration testing::internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>::operator=(const ValueArray23&other)"
  },
  "api/testing/internal/value-array24.html": {
    "href": "api/testing/internal/value-array24.html",
    "title": "Class testing::internal::ValueArray24 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray24 Inheritance testing::internal::ValueArray24 Constructors ValueArray24() Declaration testing::internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>::ValueArray24(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24) Methods >() Declaration testing::internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>::operator=(const ValueArray24&other)"
  },
  "api/testing/internal/value-array25.html": {
    "href": "api/testing/internal/value-array25.html",
    "title": "Class testing::internal::ValueArray25 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray25 Inheritance testing::internal::ValueArray25 Constructors ValueArray25() Declaration testing::internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>::ValueArray25(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25) Methods >() Declaration testing::internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>::operator=(const ValueArray25&other)"
  },
  "api/testing/internal/value-array26.html": {
    "href": "api/testing/internal/value-array26.html",
    "title": "Class testing::internal::ValueArray26 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray26 Inheritance testing::internal::ValueArray26 Constructors ValueArray26() Declaration testing::internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26>::ValueArray26(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26) Methods >() Declaration testing::internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26>::operator=(const ValueArray26&other)"
  },
  "api/testing/internal/value-array27.html": {
    "href": "api/testing/internal/value-array27.html",
    "title": "Class testing::internal::ValueArray27 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray27 Inheritance testing::internal::ValueArray27 Constructors ValueArray27() Declaration testing::internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27>::ValueArray27(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27) Methods >() Declaration testing::internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27>::operator=(const ValueArray27&other)"
  },
  "api/testing/internal/value-array28.html": {
    "href": "api/testing/internal/value-array28.html",
    "title": "Class testing::internal::ValueArray28 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray28 Inheritance testing::internal::ValueArray28 Constructors ValueArray28() Declaration testing::internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28>::ValueArray28(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28) Methods >() Declaration testing::internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28>::operator=(const ValueArray28&other)"
  },
  "api/testing/internal/value-array29.html": {
    "href": "api/testing/internal/value-array29.html",
    "title": "Class testing::internal::ValueArray29 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray29 Inheritance testing::internal::ValueArray29 Constructors ValueArray29() Declaration testing::internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29>::ValueArray29(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29) Methods >() Declaration testing::internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29>::operator=(const ValueArray29&other)"
  },
  "api/testing/internal/value-array3.html": {
    "href": "api/testing/internal/value-array3.html",
    "title": "Class testing::internal::ValueArray3 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray3 Inheritance testing::internal::ValueArray3 Constructors ValueArray3() Declaration testing::internal::ValueArray3<T1, T2, T3>::ValueArray3(T1 v1, T2 v2, T3 v3) Methods >() Declaration testing::internal::ValueArray3<T1, T2, T3>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray3<T1, T2, T3>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray3<T1, T2, T3>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray3<T1, T2, T3>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray3<T1, T2, T3>::operator=(const ValueArray3&other)"
  },
  "api/testing/internal/value-array30.html": {
    "href": "api/testing/internal/value-array30.html",
    "title": "Class testing::internal::ValueArray30 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray30 Inheritance testing::internal::ValueArray30 Constructors ValueArray30() Declaration testing::internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30>::ValueArray30(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) Methods >() Declaration testing::internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30>::operator=(const ValueArray30&other)"
  },
  "api/testing/internal/value-array31.html": {
    "href": "api/testing/internal/value-array31.html",
    "title": "Class testing::internal::ValueArray31 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray31 Inheritance testing::internal::ValueArray31 Constructors ValueArray31() Declaration testing::internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31>::ValueArray31(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) Methods >() Declaration testing::internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31>::operator=(const ValueArray31&other)"
  },
  "api/testing/internal/value-array32.html": {
    "href": "api/testing/internal/value-array32.html",
    "title": "Class testing::internal::ValueArray32 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray32 Inheritance testing::internal::ValueArray32 Constructors ValueArray32() Declaration testing::internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32>::ValueArray32(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32) Methods >() Declaration testing::internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32>::operator=(const ValueArray32&other)"
  },
  "api/testing/internal/value-array33.html": {
    "href": "api/testing/internal/value-array33.html",
    "title": "Class testing::internal::ValueArray33 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray33 Inheritance testing::internal::ValueArray33 Constructors ValueArray33() Declaration testing::internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33>::ValueArray33(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33) Methods >() Declaration testing::internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33>::operator=(const ValueArray33&other)"
  },
  "api/testing/internal/value-array34.html": {
    "href": "api/testing/internal/value-array34.html",
    "title": "Class testing::internal::ValueArray34 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray34 Inheritance testing::internal::ValueArray34 Constructors ValueArray34() Declaration testing::internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34>::ValueArray34(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34) Methods >() Declaration testing::internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34>::operator=(const ValueArray34&other)"
  },
  "api/testing/internal/value-array35.html": {
    "href": "api/testing/internal/value-array35.html",
    "title": "Class testing::internal::ValueArray35 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray35 Inheritance testing::internal::ValueArray35 Constructors ValueArray35() Declaration testing::internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>::ValueArray35(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35) Methods >() Declaration testing::internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>::operator=(const ValueArray35&other)"
  },
  "api/testing/internal/value-array36.html": {
    "href": "api/testing/internal/value-array36.html",
    "title": "Class testing::internal::ValueArray36 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray36 Inheritance testing::internal::ValueArray36 Constructors ValueArray36() Declaration testing::internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>::ValueArray36(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36) Methods >() Declaration testing::internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>::operator=(const ValueArray36&other)"
  },
  "api/testing/internal/value-array37.html": {
    "href": "api/testing/internal/value-array37.html",
    "title": "Class testing::internal::ValueArray37 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray37 Inheritance testing::internal::ValueArray37 Constructors ValueArray37() Declaration testing::internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>::ValueArray37(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37) Methods >() Declaration testing::internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>::operator=(const ValueArray37&other)"
  },
  "api/testing/internal/value-array38.html": {
    "href": "api/testing/internal/value-array38.html",
    "title": "Class testing::internal::ValueArray38 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray38 Inheritance testing::internal::ValueArray38 Constructors ValueArray38() Declaration testing::internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>::ValueArray38(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38) Methods >() Declaration testing::internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>::operator=(const ValueArray38&other)"
  },
  "api/testing/internal/value-array39.html": {
    "href": "api/testing/internal/value-array39.html",
    "title": "Class testing::internal::ValueArray39 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray39 Inheritance testing::internal::ValueArray39 Constructors ValueArray39() Declaration testing::internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>::ValueArray39(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39) Methods >() Declaration testing::internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>::operator=(const ValueArray39&other)"
  },
  "api/testing/internal/value-array4.html": {
    "href": "api/testing/internal/value-array4.html",
    "title": "Class testing::internal::ValueArray4 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray4 Inheritance testing::internal::ValueArray4 Constructors ValueArray4() Declaration testing::internal::ValueArray4<T1, T2, T3, T4>::ValueArray4(T1 v1, T2 v2, T3 v3, T4 v4) Methods >() Declaration testing::internal::ValueArray4<T1, T2, T3, T4>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray4<T1, T2, T3, T4>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray4<T1, T2, T3, T4>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray4<T1, T2, T3, T4>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray4<T1, T2, T3, T4>::operator=(const ValueArray4&other)"
  },
  "api/testing/internal/value-array40.html": {
    "href": "api/testing/internal/value-array40.html",
    "title": "Class testing::internal::ValueArray40 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray40 Inheritance testing::internal::ValueArray40 Constructors ValueArray40() Declaration testing::internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40>::ValueArray40(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) Methods >() Declaration testing::internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40>::operator=(const ValueArray40&other)"
  },
  "api/testing/internal/value-array41.html": {
    "href": "api/testing/internal/value-array41.html",
    "title": "Class testing::internal::ValueArray41 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray41 Inheritance testing::internal::ValueArray41 Constructors ValueArray41() Declaration testing::internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41>::ValueArray41(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41) Methods >() Declaration testing::internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41>::operator=(const ValueArray41&other)"
  },
  "api/testing/internal/value-array42.html": {
    "href": "api/testing/internal/value-array42.html",
    "title": "Class testing::internal::ValueArray42 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray42 Inheritance testing::internal::ValueArray42 Constructors ValueArray42() Declaration testing::internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42>::ValueArray42(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41, T42 v42) Methods >() Declaration testing::internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42>::operator=(const ValueArray42&other)"
  },
  "api/testing/internal/value-array43.html": {
    "href": "api/testing/internal/value-array43.html",
    "title": "Class testing::internal::ValueArray43 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray43 Inheritance testing::internal::ValueArray43 Constructors ValueArray43() Declaration testing::internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43>::ValueArray43(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43) Methods >() Declaration testing::internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43>::operator=(const ValueArray43&other)"
  },
  "api/testing/internal/value-array44.html": {
    "href": "api/testing/internal/value-array44.html",
    "title": "Class testing::internal::ValueArray44 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray44 Inheritance testing::internal::ValueArray44 Constructors ValueArray44() Declaration testing::internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44>::ValueArray44(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44) Methods >() Declaration testing::internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44>::operator=(const ValueArray44&other)"
  },
  "api/testing/internal/value-array45.html": {
    "href": "api/testing/internal/value-array45.html",
    "title": "Class testing::internal::ValueArray45 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray45 Inheritance testing::internal::ValueArray45 Constructors ValueArray45() Declaration testing::internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45>::ValueArray45(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45) Methods >() Declaration testing::internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45>::operator=(const ValueArray45&other)"
  },
  "api/testing/internal/value-array46.html": {
    "href": "api/testing/internal/value-array46.html",
    "title": "Class testing::internal::ValueArray46 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray46 Inheritance testing::internal::ValueArray46 Constructors ValueArray46() Declaration testing::internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46>::ValueArray46(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) Methods >() Declaration testing::internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46>::operator=(const ValueArray46&other)"
  },
  "api/testing/internal/value-array47.html": {
    "href": "api/testing/internal/value-array47.html",
    "title": "Class testing::internal::ValueArray47 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray47 Inheritance testing::internal::ValueArray47 Constructors ValueArray47() Declaration testing::internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47>::ValueArray47(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) Methods >() Declaration testing::internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47>::operator=(const ValueArray47&other)"
  },
  "api/testing/internal/value-array48.html": {
    "href": "api/testing/internal/value-array48.html",
    "title": "Class testing::internal::ValueArray48 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray48 Inheritance testing::internal::ValueArray48 Constructors ValueArray48() Declaration testing::internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48>::ValueArray48(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48) Methods >() Declaration testing::internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48>::operator=(const ValueArray48&other)"
  },
  "api/testing/internal/value-array49.html": {
    "href": "api/testing/internal/value-array49.html",
    "title": "Class testing::internal::ValueArray49 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray49 Inheritance testing::internal::ValueArray49 Constructors ValueArray49() Declaration testing::internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>::ValueArray49(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48, T49 v49) Methods >() Declaration testing::internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>::operator=(const ValueArray49&other)"
  },
  "api/testing/internal/value-array5.html": {
    "href": "api/testing/internal/value-array5.html",
    "title": "Class testing::internal::ValueArray5 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray5 Inheritance testing::internal::ValueArray5 Constructors ValueArray5() Declaration testing::internal::ValueArray5<T1, T2, T3, T4, T5>::ValueArray5(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5) Methods >() Declaration testing::internal::ValueArray5<T1, T2, T3, T4, T5>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray5<T1, T2, T3, T4, T5>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray5<T1, T2, T3, T4, T5>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray5<T1, T2, T3, T4, T5>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray5<T1, T2, T3, T4, T5>::operator=(const ValueArray5&other)"
  },
  "api/testing/internal/value-array50.html": {
    "href": "api/testing/internal/value-array50.html",
    "title": "Class testing::internal::ValueArray50 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray50 Inheritance testing::internal::ValueArray50 Constructors ValueArray50() Declaration testing::internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::ValueArray50(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48, T49 v49, T50 v50) Methods >() Declaration testing::internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::operator=(const ValueArray50&other)"
  },
  "api/testing/internal/value-array6.html": {
    "href": "api/testing/internal/value-array6.html",
    "title": "Class testing::internal::ValueArray6 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray6 Inheritance testing::internal::ValueArray6 Constructors ValueArray6() Declaration testing::internal::ValueArray6<T1, T2, T3, T4, T5, T6>::ValueArray6(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6) Methods >() Declaration testing::internal::ValueArray6<T1, T2, T3, T4, T5, T6>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray6<T1, T2, T3, T4, T5, T6>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray6<T1, T2, T3, T4, T5, T6>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray6<T1, T2, T3, T4, T5, T6>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray6<T1, T2, T3, T4, T5, T6>::operator=(const ValueArray6&other)"
  },
  "api/testing/internal/value-array7.html": {
    "href": "api/testing/internal/value-array7.html",
    "title": "Class testing::internal::ValueArray7 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray7 Inheritance testing::internal::ValueArray7 Constructors ValueArray7() Declaration testing::internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>::ValueArray7(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7) Methods >() Declaration testing::internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>::operator=(const ValueArray7&other)"
  },
  "api/testing/internal/value-array8.html": {
    "href": "api/testing/internal/value-array8.html",
    "title": "Class testing::internal::ValueArray8 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray8 Inheritance testing::internal::ValueArray8 Constructors ValueArray8() Declaration testing::internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>::ValueArray8(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8) Methods >() Declaration testing::internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>::operator=(const ValueArray8&other)"
  },
  "api/testing/internal/value-array9.html": {
    "href": "api/testing/internal/value-array9.html",
    "title": "Class testing::internal::ValueArray9 | qiotoolkit",
    "keywords": "Class testing::internal::ValueArray9 Inheritance testing::internal::ValueArray9 Constructors ValueArray9() Declaration testing::internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>::ValueArray9(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9) Methods >() Declaration testing::internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>::operator ParamGenerator<T>() const >() Declaration testing::internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>::operator ParamGenerator<T>() const operator=() Declaration void testing::internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>::operator=(const ValueArray9&other)"
  },
  "api/testing/internal/values-in-iterator-range-generator.html": {
    "href": "api/testing/internal/values-in-iterator-range-generator.html",
    "title": "Class testing::internal::ValuesInIteratorRangeGenerator | qiotoolkit",
    "keywords": "Class testing::internal::ValuesInIteratorRangeGenerator Inheritance testing::internal::ParamGeneratorInterface testing::internal::ValuesInIteratorRangeGenerator Inherited Members ~ParamGeneratorInterface Constructors ValuesInIteratorRangeGenerator() Declaration testing::internal::ValuesInIteratorRangeGenerator<T>::ValuesInIteratorRangeGenerator(ForwardIterator begin, ForwardIterator end) ValuesInIteratorRangeGenerator() Declaration testing::internal::ValuesInIteratorRangeGenerator<T>::ValuesInIteratorRangeGenerator(ForwardIterator begin, ForwardIterator end) Methods ~ValuesInIteratorRangeGenerator() Declaration testing::internal::ValuesInIteratorRangeGenerator<T>::~ValuesInIteratorRangeGenerator() override Begin() Declaration ParamIteratorInterface<T>* testing::internal::ValuesInIteratorRangeGenerator<T>::Begin() const override End() Declaration ParamIteratorInterface<T>* testing::internal::ValuesInIteratorRangeGenerator<T>::End() const override ~ValuesInIteratorRangeGenerator() Declaration virtual testing::internal::ValuesInIteratorRangeGenerator<T>::~ValuesInIteratorRangeGenerator() Begin() Declaration virtual ParamIteratorInterface<T>* testing::internal::ValuesInIteratorRangeGenerator<T>::Begin() const End() Declaration virtual ParamIteratorInterface<T>* testing::internal::ValuesInIteratorRangeGenerator<T>::End() const operator=() Declaration void testing::internal::ValuesInIteratorRangeGenerator<T>::operator=(const ValuesInIteratorRangeGenerator&other) operator=() Declaration void testing::internal::ValuesInIteratorRangeGenerator<T>::operator=(const ValuesInIteratorRangeGenerator&other)"
  },
  "api/testing/internal/values-in-iterator-range-generator/iterator.html": {
    "href": "api/testing/internal/values-in-iterator-range-generator/iterator.html",
    "title": "Class testing::internal::ValuesInIteratorRangeGenerator::Iterator | qiotoolkit",
    "keywords": "Class testing::internal::ValuesInIteratorRangeGenerator::Iterator Inheritance testing::internal::ParamIteratorInterface testing::internal::ValuesInIteratorRangeGenerator::Iterator Inherited Members ~ParamIteratorInterface Constructors Iterator() Declaration testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Iterator(const ParamGeneratorInterface<T>*base, typename ContainerType::const_iterator iterator) Iterator() Declaration testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Iterator(const ParamGeneratorInterface<T>*base, typename ContainerType::const_iterator iterator) Iterator() Declaration testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Iterator(const Iterator&other) Iterator() Declaration testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Iterator(const Iterator&other) Methods ~Iterator() Declaration testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::~Iterator() override BaseGenerator() Declaration const ParamGeneratorInterface<T>* testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::BaseGenerator() const override Advance() Declaration void testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Advance() override Clone() Declaration ParamIteratorInterface<T>* testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Clone() const override Current() Declaration const T* testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Current() const override Equals() Declaration bool testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Equals(const ParamIteratorInterface<T>&other) const override ~Iterator() Declaration virtual testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::~Iterator() BaseGenerator() Declaration virtual const ParamGeneratorInterface<T>* testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::BaseGenerator() const Advance() Declaration virtual void testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Advance() Clone() Declaration virtual ParamIteratorInterface<T>* testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Clone() const Current() Declaration virtual const T* testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Current() const Equals() Declaration virtual bool testing::internal::ValuesInIteratorRangeGenerator<T>::Iterator::Equals(const ParamIteratorInterface<T>&other) const"
  },
  "api/testing/internal/variant/matcher/variant-matcher.html": {
    "href": "api/testing/internal/variant/matcher/variant-matcher.html",
    "title": "Class testing::internal::variant_matcher::VariantMatcher | qiotoolkit",
    "keywords": "Class testing::internal::variant_matcher::VariantMatcher Inheritance testing::internal::variant_matcher::VariantMatcher Constructors VariantMatcher() Declaration testing::internal::variant_matcher::VariantMatcher<T>::VariantMatcher(::testing::Matcher<const T&>matcher) Methods MatchAndExplain() Declaration bool testing::internal::variant_matcher::VariantMatcher<T>::MatchAndExplain(const Variant&value, ::testing::MatchResultListener *listener) const DescribeTo() Declaration void testing::internal::variant_matcher::VariantMatcher<T>::DescribeTo(std::ostream *os) const DescribeNegationTo() Declaration void testing::internal::variant_matcher::VariantMatcher<T>::DescribeNegationTo(std::ostream *os) const GetTypeName() Declaration static std::string testing::internal::variant_matcher::VariantMatcher<T>::GetTypeName()"
  },
  "api/testing/internal/void-t.html": {
    "href": "api/testing/internal/void-t.html",
    "title": "Struct testing::internal::VoidT | qiotoolkit",
    "keywords": "Struct testing::internal::VoidT"
  },
  "api/testing/internal/when-sorted-by-matcher.html": {
    "href": "api/testing/internal/when-sorted-by-matcher.html",
    "title": "Class testing::internal::WhenSortedByMatcher | qiotoolkit",
    "keywords": "Class testing::internal::WhenSortedByMatcher Inheritance testing::internal::WhenSortedByMatcher Constructors WhenSortedByMatcher() Declaration testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::WhenSortedByMatcher(const Comparator&comparator, const ContainerMatcher&matcher) Methods >() Declaration testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::operator Matcher<LhsContainer>() const >() Declaration testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::operator Matcher<LhsContainer>() const >() Declaration testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::operator Matcher<LhsContainer>() const >() Declaration testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::operator Matcher<LhsContainer>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::GTEST_DISALLOW_ASSIGN_(WhenSortedByMatcher)"
  },
  "api/testing/internal/when-sorted-by-matcher/impl.html": {
    "href": "api/testing/internal/when-sorted-by-matcher/impl.html",
    "title": "Class testing::internal::WhenSortedByMatcher::Impl | qiotoolkit",
    "keywords": "Class testing::internal::WhenSortedByMatcher::Impl Inheritance testing::MatcherInterface testing::internal::WhenSortedByMatcher::Impl Inherited Members ~MatcherDescriberInterface Constructors Impl() Declaration testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::Impl<LhsContainer>::Impl(const Comparator&comparator, const ContainerMatcher&matcher) Methods DescribeTo() Declaration virtual void testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::Impl<LhsContainer>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::Impl<LhsContainer>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::Impl<LhsContainer>::MatchAndExplain(LhsContainer lhs, MatchResultListener *listener) const GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::WhenSortedByMatcher<Comparator, ContainerMatcher>::Impl<LhsContainer>::GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl)"
  },
  "api/testing/internal/with-args-action.html": {
    "href": "api/testing/internal/with-args-action.html",
    "title": "Class testing::internal::WithArgsAction | qiotoolkit",
    "keywords": "Class testing::internal::WithArgsAction Inheritance testing::internal::WithArgsAction Constructors WithArgsAction() Declaration testing::internal::WithArgsAction<InnerAction, I>::WithArgsAction(const InnerAction&action) Methods R() Declaration testing::internal::WithArgsAction<InnerAction, I>::operator Action<R(Args...)>() const R() Declaration testing::internal::WithArgsAction<InnerAction, I>::operator Action<R(Args...)>() const R() Declaration testing::internal::WithArgsAction<InnerAction, I>::operator Action<R(Args...)>() const >() Declaration testing::internal::WithArgsAction<InnerAction, I>::operator Action<F>() const >() Declaration testing::internal::WithArgsAction<InnerAction, I>::operator Action<F>() const >() Declaration testing::internal::WithArgsAction<InnerAction, I>::operator Action<F>() const >() Declaration testing::internal::WithArgsAction<InnerAction, I>::operator Action<F>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::internal::WithArgsAction<InnerAction, I>::GTEST_DISALLOW_ASSIGN_(WithArgsAction)"
  },
  "api/testing/internal/with-args-action/impl.html": {
    "href": "api/testing/internal/with-args-action/impl.html",
    "title": "Class testing::internal::WithArgsAction::Impl | qiotoolkit",
    "keywords": "Class testing::internal::WithArgsAction::Impl Inheritance testing::ActionInterface testing::internal::WithArgsAction::Impl Inherited Members ActionInterface ~ActionInterface Constructors Impl() Declaration testing::internal::WithArgsAction<InnerAction, I>::Impl<F>::Impl(const InnerAction&action) Methods Perform() Declaration virtual Result testing::internal::WithArgsAction<InnerAction, I>::Impl<F>::Perform(const ArgumentTuple&args)"
  },
  "api/testing/internal/without-matchers.html": {
    "href": "api/testing/internal/without-matchers.html",
    "title": "Class testing::internal::WithoutMatchers | qiotoolkit",
    "keywords": "Class testing::internal::WithoutMatchers Inheritance testing::internal::WithoutMatchers Constructors WithoutMatchers() Declaration testing::internal::WithoutMatchers::WithoutMatchers() WithoutMatchers() Declaration testing::internal::WithoutMatchers::WithoutMatchers()"
  },
  "api/testing/internal/wrap-printer-type.html": {
    "href": "api/testing/internal/wrap-printer-type.html",
    "title": "Struct testing::internal::WrapPrinterType | qiotoolkit",
    "keywords": "Struct testing::internal::WrapPrinterType"
  },
  "api/testing/internal/xml-unit-test-result-printer.html": {
    "href": "api/testing/internal/xml-unit-test-result-printer.html",
    "title": "Class testing::internal::XmlUnitTestResultPrinter | qiotoolkit",
    "keywords": "Class testing::internal::XmlUnitTestResultPrinter Inheritance testing::EmptyTestEventListener testing::internal::XmlUnitTestResultPrinter Inherited Members OnEnvironmentsTearDownStart OnTestProgramEnd OnEnvironmentsSetUpStart OnTestStart OnTestSuiteStart OnTestIterationStart OnEnvironmentsTearDownStart OnTestPartResult OnTestCaseEnd OnEnvironmentsSetUpStart OnTestEnd OnTestCaseStart OnTestIterationStart OnTestStart OnEnvironmentsSetUpEnd OnTestProgramStart OnTestProgramEnd OnTestPartResult OnEnvironmentsSetUpEnd OnTestCaseEnd OnTestProgramStart OnEnvironmentsTearDownEnd OnTestCaseStart OnEnvironmentsTearDownEnd OnTestSuiteEnd OnTestEnd ~TestEventListener Constructors XmlUnitTestResultPrinter() Declaration testing::internal::XmlUnitTestResultPrinter::XmlUnitTestResultPrinter(const char *output_file) XmlUnitTestResultPrinter() Declaration testing::internal::XmlUnitTestResultPrinter::XmlUnitTestResultPrinter(const char *output_file) Methods OnTestIterationEnd() Declaration void testing::internal::XmlUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&unit_test, int iteration) override ListTestsMatchingFilter() Declaration void testing::internal::XmlUnitTestResultPrinter::ListTestsMatchingFilter(const std::vector<TestSuite *>&test_suites) OnTestIterationEnd() Declaration virtual void testing::internal::XmlUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&unit_test, int iteration) PrintXmlTestsList() Declaration void testing::internal::XmlUnitTestResultPrinter::PrintXmlTestsList(std::ostream *stream, const std::vector<TestSuite *>&test_suites) IsNormalizableWhitespace() Declaration static bool testing::internal::XmlUnitTestResultPrinter::IsNormalizableWhitespace(char c) IsValidXmlCharacter() Declaration static bool testing::internal::XmlUnitTestResultPrinter::IsValidXmlCharacter(char c) EscapeXml() Declaration std::string testing::internal::XmlUnitTestResultPrinter::EscapeXml(const std::string&str, bool is_attribute) RemoveInvalidXmlCharacters() Declaration std::string testing::internal::XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(const std::string&str) EscapeXmlAttribute() Declaration static std::string testing::internal::XmlUnitTestResultPrinter::EscapeXmlAttribute(const std::string&str) EscapeXmlText() Declaration static std::string testing::internal::XmlUnitTestResultPrinter::EscapeXmlText(const char *str) OutputXmlAttribute() Declaration void testing::internal::XmlUnitTestResultPrinter::OutputXmlAttribute(std::ostream *stream, const std::string&element_name, const std::string&name, const std::string&value) OutputXmlCDataSection() Declaration void testing::internal::XmlUnitTestResultPrinter::OutputXmlCDataSection(::std::ostream *stream, const char *data) OutputXmlTestInfo() Declaration void testing::internal::XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream *stream, const char *test_suite_name, const TestInfo&test_info) PrintXmlTestSuite() Declaration void testing::internal::XmlUnitTestResultPrinter::PrintXmlTestSuite(::std::ostream *stream, const TestSuite&test_suite) PrintXmlUnitTest() Declaration static void testing::internal::XmlUnitTestResultPrinter::PrintXmlUnitTest(::std::ostream *stream, const UnitTest&unit_test) TestPropertiesAsXmlAttributes() Declaration std::string testing::internal::XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes(const TestResult&result) OutputXmlTestProperties() Declaration void testing::internal::XmlUnitTestResultPrinter::OutputXmlTestProperties(std::ostream *stream, const TestResult&result) IsNormalizableWhitespace() Declaration static bool testing::internal::XmlUnitTestResultPrinter::IsNormalizableWhitespace(char c) IsValidXmlCharacter() Declaration static bool testing::internal::XmlUnitTestResultPrinter::IsValidXmlCharacter(char c) EscapeXml() Declaration static std::string testing::internal::XmlUnitTestResultPrinter::EscapeXml(const std::string&str, bool is_attribute) RemoveInvalidXmlCharacters() Declaration static std::string testing::internal::XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(const std::string&str) EscapeXmlAttribute() Declaration static std::string testing::internal::XmlUnitTestResultPrinter::EscapeXmlAttribute(const std::string&str) EscapeXmlText() Declaration static std::string testing::internal::XmlUnitTestResultPrinter::EscapeXmlText(const char *str) OutputXmlAttribute() Declaration static void testing::internal::XmlUnitTestResultPrinter::OutputXmlAttribute(std::ostream *stream, const std::string&element_name, const std::string&name, const std::string&value) OutputXmlCDataSection() Declaration static void testing::internal::XmlUnitTestResultPrinter::OutputXmlCDataSection(::std::ostream *stream, const char *data) OutputXmlTestInfo() Declaration static void testing::internal::XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream *stream, const char *test_case_name, const TestInfo&test_info) PrintXmlTestCase() Declaration void testing::internal::XmlUnitTestResultPrinter::PrintXmlTestCase(::std::ostream *stream, const TestCase&test_case) PrintXmlUnitTest() Declaration static void testing::internal::XmlUnitTestResultPrinter::PrintXmlUnitTest(::std::ostream *stream, const UnitTest&unit_test) TestPropertiesAsXmlAttributes() Declaration static std::string testing::internal::XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes(const TestResult&result) OutputXmlTestProperties() Declaration static void testing::internal::XmlUnitTestResultPrinter::OutputXmlTestProperties(std::ostream *stream, const TestResult&result) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::XmlUnitTestResultPrinter::GTEST_DISALLOW_COPY_AND_ASSIGN_(XmlUnitTestResultPrinter) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::internal::XmlUnitTestResultPrinter::GTEST_DISALLOW_COPY_AND_ASSIGN_(XmlUnitTestResultPrinter)"
  },
  "api/testing/internal2/type-without-formatter.html": {
    "href": "api/testing/internal2/type-without-formatter.html",
    "title": "Class testing::internal2::TypeWithoutFormatter | qiotoolkit",
    "keywords": "Class testing::internal2::TypeWithoutFormatter Inheritance testing::internal2::TypeWithoutFormatter Methods PrintValue() Declaration static void testing::internal2::TypeWithoutFormatter<T, kTypeKind>::PrintValue(const T&value, ::std::ostream *os) PrintValue() Declaration static void testing::internal2::TypeWithoutFormatter<T, kTypeKind>::PrintValue(const T&value, ::std::ostream *os)"
  },
  "api/testing/internal2/type-without-formatter/3/01-t/00/01k-convertible-to-integer/01/4.html": {
    "href": "api/testing/internal2/type-without-formatter/3/01-t/00/01k-convertible-to-integer/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods PrintValue() Declaration static void testing::internal2::TypeWithoutFormatter<T, kConvertibleToInteger>::PrintValue(const T&value, ::std::ostream *os) PrintValue() Declaration static void testing::internal2::TypeWithoutFormatter<T, kConvertibleToInteger>::PrintValue(const T&value, ::std::ostream *os)"
  },
  "api/testing/internal2/type-without-formatter/3/01-t/00/01k-protobuf/01/4.html": {
    "href": "api/testing/internal2/type-without-formatter/3/01-t/00/01k-protobuf/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods PrintValue() Declaration static void testing::internal2::TypeWithoutFormatter<T, kProtobuf>::PrintValue(const T&value, ::std::ostream *os) PrintValue() Declaration static void testing::internal2::TypeWithoutFormatter<T, kProtobuf>::PrintValue(const T&value, ::std::ostream *os)"
  },
  "api/testing/match-result-listener.html": {
    "href": "api/testing/match-result-listener.html",
    "title": "Class testing::MatchResultListener | qiotoolkit",
    "keywords": "Class testing::MatchResultListener Inheritance testing::MatchResultListener testing::StringMatchResultListener testing::internal::DummyMatchResultListener testing::internal::StreamMatchResultListener Constructors MatchResultListener() Declaration testing::MatchResultListener::MatchResultListener(::std::ostream *os) Methods ~MatchResultListener() Declaration testing::MatchResultListener::~MatchResultListener()=0 <() Declaration MatchResultListener&testing::MatchResultListener::operator<<(const T&x) <() Declaration MatchResultListener&testing::MatchResultListener::operator<<(const T&x) <() Declaration MatchResultListener&testing::MatchResultListener::operator<<(const T&x) stream() Declaration ::std::ostream* testing::MatchResultListener::stream() IsInterested() Declaration bool testing::MatchResultListener::IsInterested() const GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MatchResultListener::GTEST_DISALLOW_COPY_AND_ASSIGN_(MatchResultListener)"
  },
  "api/testing/matcher-describer-interface.html": {
    "href": "api/testing/matcher-describer-interface.html",
    "title": "Class testing::MatcherDescriberInterface | qiotoolkit",
    "keywords": "Class testing::MatcherDescriberInterface Inheritance testing::MatcherDescriberInterface testing::MatcherInterface Methods ~MatcherDescriberInterface() Declaration virtual testing::MatcherDescriberInterface::~MatcherDescriberInterface() DescribeTo() Declaration virtual void testing::MatcherDescriberInterface::DescribeTo(::std::ostream *os) const =0 DescribeNegationTo() Declaration virtual void testing::MatcherDescriberInterface::DescribeNegationTo(::std::ostream *os) const"
  },
  "api/testing/matcher-interface.html": {
    "href": "api/testing/matcher-interface.html",
    "title": "Class testing::MatcherInterface | qiotoolkit",
    "keywords": "Class testing::MatcherInterface Inheritance testing::MatcherDescriberInterface testing::MatcherInterface testing::internal::FloatingEqMatcher::Impl Inherited Members DescribeNegationTo DescribeTo ~MatcherDescriberInterface Methods MatchAndExplain() Declaration virtual bool testing::MatcherInterface<T>::MatchAndExplain(T x, MatchResultListener *listener) const =0"
  },
  "api/testing/matcher.html": {
    "href": "api/testing/matcher.html",
    "title": "Class testing::Matcher | qiotoolkit",
    "keywords": "Class testing::Matcher Inheritance testing::Matcher Constructors Matcher() Declaration testing::Matcher<T>::Matcher() Matcher() Declaration testing::Matcher<T>::Matcher(const MatcherInterface<GTEST_REFERENCE_TO_CONST_(T)>*impl) Matcher() Declaration testing::Matcher<T>::Matcher(const MatcherInterface<U>*impl, typename internal::EnableIf<!internal::IsSame<U, GTEST_REFERENCE_TO_CONST_(U)>::value>::type *=NULL) Matcher() Declaration testing::Matcher<T>::Matcher(T value)"
  },
  "api/testing/matcher/3/01const/01std/string/01/6/01/4.html": {
    "href": "api/testing/matcher/3/01const/01std/string/01/6/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::MatcherBase > Inherited Members MatcherBase ExplainMatchResultTo ~MatcherBase MatcherBase DescribeTo GetDescriber MatchAndExplain MatcherBase Matches DescribeNegationTo Methods Matcher() Declaration testing::Matcher<const std::string&>::Matcher() Matcher() Declaration testing::Matcher<const std::string&>::Matcher(const MatcherInterface<const std::string&>*impl) Matcher() Declaration testing::Matcher<const std::string&>::Matcher(const std::string&s) Matcher() Declaration testing::Matcher<const std::string&>::Matcher(const char *s)"
  },
  "api/testing/matcher/3/01std/string/01/4.html": {
    "href": "api/testing/matcher/3/01std/string/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance testing::internal::MatcherBase > Inherited Members MatcherBase ExplainMatchResultTo ~MatcherBase MatcherBase DescribeTo GetDescriber MatchAndExplain MatcherBase Matches DescribeNegationTo Methods Matcher() Declaration testing::Matcher<std::string>::Matcher() Matcher() Declaration testing::Matcher<std::string>::Matcher(const MatcherInterface<const std::string&>*impl) Matcher() Declaration testing::Matcher<std::string>::Matcher(const MatcherInterface<std::string>*impl) Matcher() Declaration testing::Matcher<std::string>::Matcher(const std::string&s) Matcher() Declaration testing::Matcher<std::string>::Matcher(const char *s)"
  },
  "api/testing/message.html": {
    "href": "api/testing/message.html",
    "title": "Class testing::Message | qiotoolkit",
    "keywords": "Class testing::Message Inheritance testing::Message Constructors Message() Declaration testing::Message::Message() Message() Declaration testing::Message::Message(const Message&msg) Message() Declaration testing::Message::Message(const char *str) Message() Declaration testing::Message::Message() Message() Declaration testing::Message::Message(const Message&msg) Message() Declaration testing::Message::Message(const char *str) Methods <() Declaration Message&testing::Message::operator<<(const T&val) <() Declaration Message&testing::Message::operator<<(const T&val) <() Declaration Message&testing::Message::operator<<(const T&val) <() Declaration Message&testing::Message::operator<<(T *const&pointer) <() Declaration Message&testing::Message::operator<<(T *const&pointer) <() Declaration Message&testing::Message::operator<<(T *const&pointer) <() Declaration Message&testing::Message::operator<<(BasicNarrowIoManip val) <() Declaration Message&testing::Message::operator<<(BasicNarrowIoManip val) <() Declaration Message&testing::Message::operator<<(BasicNarrowIoManip val) <() Declaration Message&testing::Message::operator<<(bool b) <() Declaration Message&testing::Message::operator<<(bool b) <() Declaration Message&testing::Message::operator<<(bool b) <() Declaration Message&testing::Message::operator<<(const wchar_t *wide_c_str) <() Declaration Message&testing::Message::operator<<(const wchar_t *wide_c_str) <() Declaration Message&testing::Message::operator<<(const wchar_t *wide_c_str) <() Declaration Message&testing::Message::operator<<(wchar_t *wide_c_str) <() Declaration Message&testing::Message::operator<<(wchar_t *wide_c_str) <() Declaration Message&testing::Message::operator<<(wchar_t *wide_c_str) GetString() Declaration std::string testing::Message::GetString() const <() Declaration Message&testing::Message::operator<<(const T&val) <() Declaration Message&testing::Message::operator<<(const T&val) <() Declaration Message&testing::Message::operator<<(const T&val) <() Declaration Message&testing::Message::operator<<(T *const&pointer) <() Declaration Message&testing::Message::operator<<(T *const&pointer) <() Declaration Message&testing::Message::operator<<(T *const&pointer) <() Declaration Message&testing::Message::operator<<(BasicNarrowIoManip val) <() Declaration Message&testing::Message::operator<<(BasicNarrowIoManip val) <() Declaration Message&testing::Message::operator<<(BasicNarrowIoManip val) <() Declaration Message&testing::Message::operator<<(bool b) <() Declaration Message&testing::Message::operator<<(bool b) <() Declaration Message&testing::Message::operator<<(bool b) <() Declaration Message&testing::Message::operator<<(const wchar_t *wide_c_str) <() Declaration Message&testing::Message::operator<<(const wchar_t *wide_c_str) <() Declaration Message&testing::Message::operator<<(const wchar_t *wide_c_str) <() Declaration Message&testing::Message::operator<<(wchar_t *wide_c_str) <() Declaration Message&testing::Message::operator<<(wchar_t *wide_c_str) <() Declaration Message&testing::Message::operator<<(wchar_t *wide_c_str) GetString() Declaration std::string testing::Message::GetString() const operator=() Declaration void testing::Message::operator=(const Message&) operator=() Declaration void testing::Message::operator=(const Message&)"
  },
  "api/testing/mock-function.html": {
    "href": "api/testing/mock-function.html",
    "title": "Class testing::MockFunction | qiotoolkit",
    "keywords": "Class testing::MockFunction Inheritance testing::MockFunction"
  },
  "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/00/01-a9/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/00/01-a9/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::MockFunction() MOCK_METHOD10_T() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::MOCK_METHOD10_T(Call, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/00/01-a8/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>::MockFunction() MOCK_METHOD9_T() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>::MOCK_METHOD9_T(Call, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/00/01-a7/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7)>::MockFunction() MOCK_METHOD8_T() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7)>::MOCK_METHOD8_T(Call, R(A0, A1, A2, A3, A4, A5, A6, A7)) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7)>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/00/01-a6/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6)>::MockFunction() MOCK_METHOD7_T() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6)>::MOCK_METHOD7_T(Call, R(A0, A1, A2, A3, A4, A5, A6)) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5, A6)>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/00/01-a5/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5)>::MockFunction() MOCK_METHOD6_T() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5)>::MOCK_METHOD6_T(Call, R(A0, A1, A2, A3, A4, A5)) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4, A5)>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/00/01-a4/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4)>::MockFunction() MOCK_METHOD5_T() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4)>::MOCK_METHOD5_T(Call, R(A0, A1, A2, A3, A4)) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R(A0, A1, A2, A3, A4)>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/00/01-a3/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R(A0, A1, A2, A3)>::MockFunction() MOCK_METHOD4_T() Declaration testing::MockFunction<R(A0, A1, A2, A3)>::MOCK_METHOD4_T(Call, R(A0, A1, A2, A3)) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R(A0, A1, A2, A3)>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07-a0/00/01-a1/00/01-a2/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R(A0, A1, A2)>::MockFunction() MOCK_METHOD3_T() Declaration testing::MockFunction<R(A0, A1, A2)>::MOCK_METHOD3_T(Call, R(A0, A1, A2)) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R(A0, A1, A2)>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock-function/3/01-r/07-a0/00/01-a1/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07-a0/00/01-a1/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R(A0, A1)>::MockFunction() MOCK_METHOD2_T() Declaration testing::MockFunction<R(A0, A1)>::MOCK_METHOD2_T(Call, R(A0, A1)) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R(A0, A1)>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock-function/3/01-r/07-a0/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07-a0/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R(A0)>::MockFunction() MOCK_METHOD1_T() Declaration testing::MockFunction<R(A0)>::MOCK_METHOD1_T(Call, R(A0)) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R(A0)>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock-function/3/01-r/07/08/4.html": {
    "href": "api/testing/mock-function/3/01-r/07/08/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance > Methods MockFunction() Declaration testing::MockFunction<R()>::MockFunction() MOCK_METHOD0_T() Declaration testing::MockFunction<R()>::MOCK_METHOD0_T(Call, R()) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::MockFunction<R()>::GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction)"
  },
  "api/testing/mock.html": {
    "href": "api/testing/mock.html",
    "title": "Class testing::Mock | qiotoolkit",
    "keywords": "Class testing::Mock Inheritance testing::Mock"
  },
  "api/testing/naggy-mock.html": {
    "href": "api/testing/naggy-mock.html",
    "title": "Class testing::NaggyMock | qiotoolkit",
    "keywords": "Class testing::NaggyMock Inheritance testing::NaggyMock Constructors NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock() NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(A&&arg) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(A1&&arg1, A2&&arg2, An&&... args) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock() NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(const A1&a1) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(const A1&a1, const A2&a2) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(const A1&a1, const A2&a2, const A3&a3) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7, const A8&a8) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7, const A8&a8, const A9&a9) NaggyMock() Declaration testing::NaggyMock<MockClass>::NaggyMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7, const A8&a8, const A9&a9, const A10&a10) Methods ~NaggyMock() Declaration testing::NaggyMock<MockClass>::~NaggyMock() ~NaggyMock() Declaration testing::NaggyMock<MockClass>::~NaggyMock() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::NaggyMock<MockClass>::GTEST_DISALLOW_COPY_AND_ASSIGN_(NaggyMock) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::NaggyMock<MockClass>::GTEST_DISALLOW_COPY_AND_ASSIGN_(NaggyMock)"
  },
  "api/testing/nice-mock.html": {
    "href": "api/testing/nice-mock.html",
    "title": "Class testing::NiceMock | qiotoolkit",
    "keywords": "Class testing::NiceMock Inheritance testing::NiceMock Constructors NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock() NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(A&&arg) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(A1&&arg1, A2&&arg2, An&&... args) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock() NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(const A1&a1) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(const A1&a1, const A2&a2) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(const A1&a1, const A2&a2, const A3&a3) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7, const A8&a8) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7, const A8&a8, const A9&a9) NiceMock() Declaration testing::NiceMock<MockClass>::NiceMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7, const A8&a8, const A9&a9, const A10&a10) Methods ~NiceMock() Declaration testing::NiceMock<MockClass>::~NiceMock() ~NiceMock() Declaration testing::NiceMock<MockClass>::~NiceMock() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::NiceMock<MockClass>::GTEST_DISALLOW_COPY_AND_ASSIGN_(NiceMock) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::NiceMock<MockClass>::GTEST_DISALLOW_COPY_AND_ASSIGN_(NiceMock)"
  },
  "api/testing/polymorphic-action.html": {
    "href": "api/testing/polymorphic-action.html",
    "title": "Class testing::PolymorphicAction | qiotoolkit",
    "keywords": "Class testing::PolymorphicAction Inheritance testing::PolymorphicAction Constructors PolymorphicAction() Declaration testing::PolymorphicAction<Impl>::PolymorphicAction(const Impl&impl) PolymorphicAction() Declaration testing::PolymorphicAction<Impl>::PolymorphicAction(const Impl&impl) Methods >() Declaration testing::PolymorphicAction<Impl>::operator Action<F>() const >() Declaration testing::PolymorphicAction<Impl>::operator Action<F>() const >() Declaration testing::PolymorphicAction<Impl>::operator Action<F>() const >() Declaration testing::PolymorphicAction<Impl>::operator Action<F>() const >() Declaration testing::PolymorphicAction<Impl>::operator Action<F>() const >() Declaration testing::PolymorphicAction<Impl>::operator Action<F>() const >() Declaration testing::PolymorphicAction<Impl>::operator Action<F>() const >() Declaration testing::PolymorphicAction<Impl>::operator Action<F>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::PolymorphicAction<Impl>::GTEST_DISALLOW_ASSIGN_(PolymorphicAction) GTEST_DISALLOW_ASSIGN_() Declaration testing::PolymorphicAction<Impl>::GTEST_DISALLOW_ASSIGN_(PolymorphicAction)"
  },
  "api/testing/polymorphic-action/monomorphic-impl.html": {
    "href": "api/testing/polymorphic-action/monomorphic-impl.html",
    "title": "Class testing::PolymorphicAction::MonomorphicImpl | qiotoolkit",
    "keywords": "Class testing::PolymorphicAction::MonomorphicImpl Inheritance testing::ActionInterface testing::PolymorphicAction::MonomorphicImpl Inherited Members ActionInterface ~ActionInterface Constructors MonomorphicImpl() Declaration testing::PolymorphicAction<Impl>::MonomorphicImpl<F>::MonomorphicImpl(const Impl&impl) MonomorphicImpl() Declaration testing::PolymorphicAction<Impl>::MonomorphicImpl<F>::MonomorphicImpl(const Impl&impl) Methods Perform() Declaration Result testing::PolymorphicAction<Impl>::MonomorphicImpl<F>::Perform(const ArgumentTuple&args) override Perform() Declaration virtual Result testing::PolymorphicAction<Impl>::MonomorphicImpl<F>::Perform(const ArgumentTuple&args) GTEST_DISALLOW_ASSIGN_() Declaration testing::PolymorphicAction<Impl>::MonomorphicImpl<F>::GTEST_DISALLOW_ASSIGN_(MonomorphicImpl) GTEST_DISALLOW_ASSIGN_() Declaration testing::PolymorphicAction<Impl>::MonomorphicImpl<F>::GTEST_DISALLOW_ASSIGN_(MonomorphicImpl)"
  },
  "api/testing/polymorphic-matcher.html": {
    "href": "api/testing/polymorphic-matcher.html",
    "title": "Class testing::PolymorphicMatcher | qiotoolkit",
    "keywords": "Class testing::PolymorphicMatcher Inheritance testing::PolymorphicMatcher Constructors PolymorphicMatcher() Declaration testing::PolymorphicMatcher<Impl>::PolymorphicMatcher(const Impl&an_impl) Methods mutable_impl() Declaration Impl&testing::PolymorphicMatcher<Impl>::mutable_impl() impl() Declaration const Impl&testing::PolymorphicMatcher<Impl>::impl() const >() Declaration testing::PolymorphicMatcher<Impl>::operator Matcher<T>() const >() Declaration testing::PolymorphicMatcher<Impl>::operator Matcher<T>() const >() Declaration testing::PolymorphicMatcher<Impl>::operator Matcher<T>() const >() Declaration testing::PolymorphicMatcher<Impl>::operator Matcher<T>() const GTEST_DISALLOW_ASSIGN_() Declaration testing::PolymorphicMatcher<Impl>::GTEST_DISALLOW_ASSIGN_(PolymorphicMatcher)"
  },
  "api/testing/polymorphic-matcher/monomorphic-impl.html": {
    "href": "api/testing/polymorphic-matcher/monomorphic-impl.html",
    "title": "Class testing::PolymorphicMatcher::MonomorphicImpl | qiotoolkit",
    "keywords": "Class testing::PolymorphicMatcher::MonomorphicImpl Inheritance testing::MatcherInterface testing::PolymorphicMatcher::MonomorphicImpl Inherited Members ~MatcherDescriberInterface Constructors MonomorphicImpl() Declaration testing::PolymorphicMatcher<Impl>::MonomorphicImpl<T>::MonomorphicImpl(const Impl&impl) Methods DescribeTo() Declaration virtual void testing::PolymorphicMatcher<Impl>::MonomorphicImpl<T>::DescribeTo(::std::ostream *os) const DescribeNegationTo() Declaration virtual void testing::PolymorphicMatcher<Impl>::MonomorphicImpl<T>::DescribeNegationTo(::std::ostream *os) const MatchAndExplain() Declaration virtual bool testing::PolymorphicMatcher<Impl>::MonomorphicImpl<T>::MatchAndExplain(T x, MatchResultListener *listener) const GTEST_DISALLOW_ASSIGN_() Declaration testing::PolymorphicMatcher<Impl>::MonomorphicImpl<T>::GTEST_DISALLOW_ASSIGN_(MonomorphicImpl)"
  },
  "api/testing/print-to-string-param-name.html": {
    "href": "api/testing/print-to-string-param-name.html",
    "title": "Struct testing::PrintToStringParamName | qiotoolkit",
    "keywords": "Struct testing::PrintToStringParamName Methods operator()() Declaration std::string testing::PrintToStringParamName::operator()(const TestParamInfo<ParamType>&info) const operator()() Declaration std::string testing::PrintToStringParamName::operator()(const TestParamInfo<ParamType>&info) const"
  },
  "api/testing/safe-matcher-cast-impl.html": {
    "href": "api/testing/safe-matcher-cast-impl.html",
    "title": "Class testing::SafeMatcherCastImpl | qiotoolkit",
    "keywords": "Class testing::SafeMatcherCastImpl Inheritance testing::SafeMatcherCastImpl Methods Cast() Declaration static Matcher<T>testing::SafeMatcherCastImpl<T>::Cast(const M&polymorphic_matcher_or_value) Cast() Declaration static Matcher<T>testing::SafeMatcherCastImpl<T>::Cast(const Matcher<U>&matcher)"
  },
  "api/testing/scoped-fake-test-part-result-reporter.html": {
    "href": "api/testing/scoped-fake-test-part-result-reporter.html",
    "title": "Class testing::ScopedFakeTestPartResultReporter | qiotoolkit",
    "keywords": "Class testing::ScopedFakeTestPartResultReporter Inheritance testing::TestPartResultReporterInterface testing::ScopedFakeTestPartResultReporter Inherited Members ~TestPartResultReporterInterface Constructors ScopedFakeTestPartResultReporter() Declaration testing::ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(TestPartResultArray *result) ScopedFakeTestPartResultReporter() Declaration testing::ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(InterceptMode intercept_mode, TestPartResultArray *result) Methods ~ScopedFakeTestPartResultReporter() Declaration testing::ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() ReportTestPartResult() Declaration void testing::ScopedFakeTestPartResultReporter::ReportTestPartResult(const TestPartResult&result) Init() Declaration void testing::ScopedFakeTestPartResultReporter::Init() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::ScopedFakeTestPartResultReporter::GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedFakeTestPartResultReporter)"
  },
  "api/testing/scoped-trace.html": {
    "href": "api/testing/scoped-trace.html",
    "title": "Class testing::ScopedTrace | qiotoolkit",
    "keywords": "Class testing::ScopedTrace Inheritance testing::ScopedTrace Constructors ScopedTrace() Declaration testing::ScopedTrace::ScopedTrace(const char *file, int line, const T&message) ScopedTrace() Declaration testing::ScopedTrace::ScopedTrace(const char *file, int line, const char *message) ScopedTrace() Declaration testing::ScopedTrace::ScopedTrace(const char *file, int line, const std::string&message) ScopedTrace() Declaration testing::ScopedTrace::ScopedTrace(const char *file, int line, const T&message) ScopedTrace() Declaration testing::ScopedTrace::ScopedTrace(const char *file, int line, const char *message) ScopedTrace() Declaration testing::ScopedTrace::ScopedTrace(const char *file, int line, const std::string&message) Methods ~ScopedTrace() Declaration testing::ScopedTrace::~ScopedTrace() ~ScopedTrace() Declaration testing::ScopedTrace::~ScopedTrace() PushTrace() Declaration void testing::ScopedTrace::PushTrace(const char *file, int line, std::string message) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::ScopedTrace::GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace) PushTrace() Declaration void testing::ScopedTrace::PushTrace(const char *file, int line, std::string message) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::ScopedTrace::GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedTrace)"
  },
  "api/testing/sequence.html": {
    "href": "api/testing/sequence.html",
    "title": "Class testing::Sequence | qiotoolkit",
    "keywords": "Class testing::Sequence Inheritance testing::Sequence Constructors Sequence() Declaration testing::Sequence::Sequence() Methods AddExpectation() Declaration void testing::Sequence::AddExpectation(const Expectation&expectation) const"
  },
  "api/testing/strict-mock.html": {
    "href": "api/testing/strict-mock.html",
    "title": "Class testing::StrictMock | qiotoolkit",
    "keywords": "Class testing::StrictMock Inheritance testing::StrictMock Constructors StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock() StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(A&&arg) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(A1&&arg1, A2&&arg2, An&&... args) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock() StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(const A1&a1) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(const A1&a1, const A2&a2) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(const A1&a1, const A2&a2, const A3&a3) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7, const A8&a8) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7, const A8&a8, const A9&a9) StrictMock() Declaration testing::StrictMock<MockClass>::StrictMock(const A1&a1, const A2&a2, const A3&a3, const A4&a4, const A5&a5, const A6&a6, const A7&a7, const A8&a8, const A9&a9, const A10&a10) Methods ~StrictMock() Declaration testing::StrictMock<MockClass>::~StrictMock() ~StrictMock() Declaration testing::StrictMock<MockClass>::~StrictMock() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::StrictMock<MockClass>::GTEST_DISALLOW_COPY_AND_ASSIGN_(StrictMock) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::StrictMock<MockClass>::GTEST_DISALLOW_COPY_AND_ASSIGN_(StrictMock)"
  },
  "api/testing/string-match-result-listener.html": {
    "href": "api/testing/string-match-result-listener.html",
    "title": "Class testing::StringMatchResultListener | qiotoolkit",
    "keywords": "Class testing::StringMatchResultListener Inheritance testing::MatchResultListener testing::StringMatchResultListener Inherited Members MatchResultListener stream < ~MatchResultListener IsInterested Constructors StringMatchResultListener() Declaration testing::StringMatchResultListener::StringMatchResultListener() Methods str() Declaration std::string testing::StringMatchResultListener::str() const Clear() Declaration void testing::StringMatchResultListener::Clear() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::StringMatchResultListener::GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener)"
  },
  "api/testing/test-case.html": {
    "href": "api/testing/test-case.html",
    "title": "Class testing::TestCase | qiotoolkit",
    "keywords": "Class testing::TestCase Inheritance testing::TestCase Constructors TestCase() Declaration testing::TestCase::TestCase(const char *name, const char *a_type_param, Test::SetUpTestCaseFunc set_up_tc, Test::TearDownTestCaseFunc tear_down_tc) Methods ~TestCase() Declaration testing::TestCase::~TestCase() name() Declaration const char* testing::TestCase::name() const type_param() Declaration const char* testing::TestCase::type_param() const should_run() Declaration bool testing::TestCase::should_run() const successful_test_count() Declaration int testing::TestCase::successful_test_count() const failed_test_count() Declaration int testing::TestCase::failed_test_count() const reportable_disabled_test_count() Declaration int testing::TestCase::reportable_disabled_test_count() const disabled_test_count() Declaration int testing::TestCase::disabled_test_count() const reportable_test_count() Declaration int testing::TestCase::reportable_test_count() const test_to_run_count() Declaration int testing::TestCase::test_to_run_count() const total_test_count() Declaration int testing::TestCase::total_test_count() const Passed() Declaration bool testing::TestCase::Passed() const Failed() Declaration bool testing::TestCase::Failed() const elapsed_time() Declaration TimeInMillis testing::TestCase::elapsed_time() const GetTestInfo() Declaration const TestInfo * testing::TestCase::GetTestInfo(int i) const ad_hoc_test_result() Declaration const TestResult&testing::TestCase::ad_hoc_test_result() const test_info_list() Declaration std::vector<TestInfo*>&testing::TestCase::test_info_list() test_info_list() Declaration const std::vector<TestInfo*>&testing::TestCase::test_info_list() const GetMutableTestInfo() Declaration TestInfo * testing::TestCase::GetMutableTestInfo(int i) set_should_run() Declaration void testing::TestCase::set_should_run(bool should) AddTestInfo() Declaration void testing::TestCase::AddTestInfo(TestInfo *test_info) ClearResult() Declaration void testing::TestCase::ClearResult() Run() Declaration void testing::TestCase::Run() RunSetUpTestCase() Declaration void testing::TestCase::RunSetUpTestCase() RunTearDownTestCase() Declaration void testing::TestCase::RunTearDownTestCase() ShuffleTests() Declaration void testing::TestCase::ShuffleTests(internal::Random *random) UnshuffleTests() Declaration void testing::TestCase::UnshuffleTests() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::TestCase::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestCase) ClearTestCaseResult() Declaration static void testing::TestCase::ClearTestCaseResult(TestCase *test_case) TestPassed() Declaration static bool testing::TestCase::TestPassed(const TestInfo *test_info) TestFailed() Declaration static bool testing::TestCase::TestFailed(const TestInfo *test_info) TestReportableDisabled() Declaration static bool testing::TestCase::TestReportableDisabled(const TestInfo *test_info) TestDisabled() Declaration static bool testing::TestCase::TestDisabled(const TestInfo *test_info) TestReportable() Declaration static bool testing::TestCase::TestReportable(const TestInfo *test_info) ShouldRunTest() Declaration static bool testing::TestCase::ShouldRunTest(const TestInfo *test_info)"
  },
  "api/testing/test-event-listener.html": {
    "href": "api/testing/test-event-listener.html",
    "title": "Class testing::TestEventListener | qiotoolkit",
    "keywords": "Class testing::TestEventListener Inheritance testing::TestEventListener testing::EmptyTestEventListener testing::internal::PrettyUnitTestResultPrinter testing::internal::TestEventRepeater Methods ~TestEventListener() Declaration virtual testing::TestEventListener::~TestEventListener() OnTestProgramStart() Declaration virtual void testing::TestEventListener::OnTestProgramStart(const UnitTest&unit_test)=0 OnTestIterationStart() Declaration virtual void testing::TestEventListener::OnTestIterationStart(const UnitTest&unit_test, int iteration)=0 OnEnvironmentsSetUpStart() Declaration virtual void testing::TestEventListener::OnEnvironmentsSetUpStart(const UnitTest&unit_test)=0 OnEnvironmentsSetUpEnd() Declaration virtual void testing::TestEventListener::OnEnvironmentsSetUpEnd(const UnitTest&unit_test)=0 OnTestSuiteStart() Declaration virtual void testing::TestEventListener::OnTestSuiteStart(const TestSuite&) OnTestCaseStart() Declaration virtual void testing::TestEventListener::OnTestCaseStart(const TestCase&) OnTestStart() Declaration virtual void testing::TestEventListener::OnTestStart(const TestInfo&test_info)=0 OnTestPartResult() Declaration virtual void testing::TestEventListener::OnTestPartResult(const TestPartResult&test_part_result)=0 OnTestEnd() Declaration virtual void testing::TestEventListener::OnTestEnd(const TestInfo&test_info)=0 OnTestSuiteEnd() Declaration virtual void testing::TestEventListener::OnTestSuiteEnd(const TestSuite&) OnTestCaseEnd() Declaration virtual void testing::TestEventListener::OnTestCaseEnd(const TestCase&) OnEnvironmentsTearDownStart() Declaration virtual void testing::TestEventListener::OnEnvironmentsTearDownStart(const UnitTest&unit_test)=0 OnEnvironmentsTearDownEnd() Declaration virtual void testing::TestEventListener::OnEnvironmentsTearDownEnd(const UnitTest&unit_test)=0 OnTestIterationEnd() Declaration virtual void testing::TestEventListener::OnTestIterationEnd(const UnitTest&unit_test, int iteration)=0 OnTestProgramEnd() Declaration virtual void testing::TestEventListener::OnTestProgramEnd(const UnitTest&unit_test)=0 ~TestEventListener() Declaration virtual testing::TestEventListener::~TestEventListener() OnTestProgramStart() Declaration virtual void testing::TestEventListener::OnTestProgramStart(const UnitTest&unit_test)=0 OnTestIterationStart() Declaration virtual void testing::TestEventListener::OnTestIterationStart(const UnitTest&unit_test, int iteration)=0 OnEnvironmentsSetUpStart() Declaration virtual void testing::TestEventListener::OnEnvironmentsSetUpStart(const UnitTest&unit_test)=0 OnEnvironmentsSetUpEnd() Declaration virtual void testing::TestEventListener::OnEnvironmentsSetUpEnd(const UnitTest&unit_test)=0 OnTestCaseStart() Declaration virtual void testing::TestEventListener::OnTestCaseStart(const TestCase&test_case)=0 OnTestStart() Declaration virtual void testing::TestEventListener::OnTestStart(const TestInfo&test_info)=0 OnTestPartResult() Declaration virtual void testing::TestEventListener::OnTestPartResult(const TestPartResult&test_part_result)=0 OnTestEnd() Declaration virtual void testing::TestEventListener::OnTestEnd(const TestInfo&test_info)=0 OnTestCaseEnd() Declaration virtual void testing::TestEventListener::OnTestCaseEnd(const TestCase&test_case)=0 OnEnvironmentsTearDownStart() Declaration virtual void testing::TestEventListener::OnEnvironmentsTearDownStart(const UnitTest&unit_test)=0 OnEnvironmentsTearDownEnd() Declaration virtual void testing::TestEventListener::OnEnvironmentsTearDownEnd(const UnitTest&unit_test)=0 OnTestIterationEnd() Declaration virtual void testing::TestEventListener::OnTestIterationEnd(const UnitTest&unit_test, int iteration)=0 OnTestProgramEnd() Declaration virtual void testing::TestEventListener::OnTestProgramEnd(const UnitTest&unit_test)=0"
  },
  "api/testing/test-event-listeners.html": {
    "href": "api/testing/test-event-listeners.html",
    "title": "Class testing::TestEventListeners | qiotoolkit",
    "keywords": "Class testing::TestEventListeners Inheritance testing::TestEventListeners Constructors TestEventListeners() Declaration testing::TestEventListeners::TestEventListeners() TestEventListeners() Declaration testing::TestEventListeners::TestEventListeners() Methods ~TestEventListeners() Declaration testing::TestEventListeners::~TestEventListeners() Append() Declaration void testing::TestEventListeners::Append(TestEventListener *listener) Release() Declaration TestEventListener * testing::TestEventListeners::Release(TestEventListener *listener) default_result_printer() Declaration TestEventListener* testing::TestEventListeners::default_result_printer() const default_xml_generator() Declaration TestEventListener* testing::TestEventListeners::default_xml_generator() const ~TestEventListeners() Declaration testing::TestEventListeners::~TestEventListeners() Append() Declaration void testing::TestEventListeners::Append(TestEventListener *listener) Release() Declaration TestEventListener* testing::TestEventListeners::Release(TestEventListener *listener) default_result_printer() Declaration TestEventListener* testing::TestEventListeners::default_result_printer() const default_xml_generator() Declaration TestEventListener* testing::TestEventListeners::default_xml_generator() const repeater() Declaration TestEventListener * testing::TestEventListeners::repeater() SetDefaultResultPrinter() Declaration void testing::TestEventListeners::SetDefaultResultPrinter(TestEventListener *listener) SetDefaultXmlGenerator() Declaration void testing::TestEventListeners::SetDefaultXmlGenerator(TestEventListener *listener) EventForwardingEnabled() Declaration bool testing::TestEventListeners::EventForwardingEnabled() const SuppressEventForwarding() Declaration void testing::TestEventListeners::SuppressEventForwarding() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::TestEventListeners::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventListeners) repeater() Declaration TestEventListener* testing::TestEventListeners::repeater() SetDefaultResultPrinter() Declaration void testing::TestEventListeners::SetDefaultResultPrinter(TestEventListener *listener) SetDefaultXmlGenerator() Declaration void testing::TestEventListeners::SetDefaultXmlGenerator(TestEventListener *listener) EventForwardingEnabled() Declaration bool testing::TestEventListeners::EventForwardingEnabled() const SuppressEventForwarding() Declaration void testing::TestEventListeners::SuppressEventForwarding() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::TestEventListeners::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventListeners)"
  },
  "api/testing/test-info.html": {
    "href": "api/testing/test-info.html",
    "title": "Class testing::TestInfo | qiotoolkit",
    "keywords": "Class testing::TestInfo Inheritance testing::TestInfo Constructors TestInfo() Declaration testing::TestInfo::TestInfo(const std::string&test_suite_name, const std::string&name, const char *a_type_param, const char *a_value_param, internal::CodeLocation a_code_location, internal::TypeId fixture_class_id, internal::TestFactoryBase *factory) TestInfo() Declaration testing::TestInfo::TestInfo(const std::string&test_case_name, const std::string&name, const char *a_type_param, const char *a_value_param, internal::CodeLocation a_code_location, internal::TypeId fixture_class_id, internal::TestFactoryBase *factory) Methods ~TestInfo() Declaration testing::TestInfo::~TestInfo() test_suite_name() Declaration const char* testing::TestInfo::test_suite_name() const test_case_name() Declaration const char* testing::TestInfo::test_case_name() const name() Declaration const char* testing::TestInfo::name() const type_param() Declaration const char* testing::TestInfo::type_param() const value_param() Declaration const char* testing::TestInfo::value_param() const file() Declaration const char* testing::TestInfo::file() const line() Declaration int testing::TestInfo::line() const is_in_another_shard() Declaration bool testing::TestInfo::is_in_another_shard() const should_run() Declaration bool testing::TestInfo::should_run() const is_reportable() Declaration bool testing::TestInfo::is_reportable() const result() Declaration const TestResult* testing::TestInfo::result() const ~TestInfo() Declaration testing::TestInfo::~TestInfo() test_case_name() Declaration const char* testing::TestInfo::test_case_name() const name() Declaration const char* testing::TestInfo::name() const type_param() Declaration const char* testing::TestInfo::type_param() const value_param() Declaration const char* testing::TestInfo::value_param() const file() Declaration const char* testing::TestInfo::file() const line() Declaration int testing::TestInfo::line() const is_in_another_shard() Declaration bool testing::TestInfo::is_in_another_shard() const should_run() Declaration bool testing::TestInfo::should_run() const is_reportable() Declaration bool testing::TestInfo::is_reportable() const result() Declaration const TestResult* testing::TestInfo::result() const increment_death_test_count() Declaration int testing::TestInfo::increment_death_test_count() Run() Declaration void testing::TestInfo::Run() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::TestInfo::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestInfo) increment_death_test_count() Declaration int testing::TestInfo::increment_death_test_count() Run() Declaration void testing::TestInfo::Run() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::TestInfo::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestInfo) ClearTestResult() Declaration static void testing::TestInfo::ClearTestResult(TestInfo *test_info) ClearTestResult() Declaration static void testing::TestInfo::ClearTestResult(TestInfo *test_info)"
  },
  "api/testing/test-param-info.html": {
    "href": "api/testing/test-param-info.html",
    "title": "Struct testing::TestParamInfo | qiotoolkit",
    "keywords": "Struct testing::TestParamInfo Constructors TestParamInfo() Declaration testing::TestParamInfo<ParamType>::TestParamInfo(const ParamType&a_param, size_t an_index) TestParamInfo() Declaration testing::TestParamInfo<ParamType>::TestParamInfo(const ParamType&a_param, size_t an_index)"
  },
  "api/testing/test-part-result-array.html": {
    "href": "api/testing/test-part-result-array.html",
    "title": "Class testing::TestPartResultArray | qiotoolkit",
    "keywords": "Class testing::TestPartResultArray Inheritance testing::TestPartResultArray Constructors TestPartResultArray() Declaration testing::TestPartResultArray::TestPartResultArray() Methods Append() Declaration void testing::TestPartResultArray::Append(const TestPartResult&result) GetTestPartResult() Declaration const TestPartResult&testing::TestPartResultArray::GetTestPartResult(int index) const size() Declaration int testing::TestPartResultArray::size() const GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::TestPartResultArray::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestPartResultArray)"
  },
  "api/testing/test-part-result-reporter-interface.html": {
    "href": "api/testing/test-part-result-reporter-interface.html",
    "title": "Class testing::TestPartResultReporterInterface | qiotoolkit",
    "keywords": "Class testing::TestPartResultReporterInterface Inheritance testing::TestPartResultReporterInterface testing::ScopedFakeTestPartResultReporter testing::internal::DefaultGlobalTestPartResultReporter testing::internal::DefaultPerThreadTestPartResultReporter testing::internal::HasNewFatalFailureHelper Methods ~TestPartResultReporterInterface() Declaration virtual testing::TestPartResultReporterInterface::~TestPartResultReporterInterface() ReportTestPartResult() Declaration virtual void testing::TestPartResultReporterInterface::ReportTestPartResult(const TestPartResult&result)=0"
  },
  "api/testing/test-part-result.html": {
    "href": "api/testing/test-part-result.html",
    "title": "Class testing::TestPartResult | qiotoolkit",
    "keywords": "Class testing::TestPartResult Inheritance testing::TestPartResult Constructors TestPartResult() Declaration testing::TestPartResult::TestPartResult(Type a_type, const char *a_file_name, int a_line_number, const char *a_message) Methods type() Declaration Type testing::TestPartResult::type() const file_name() Declaration const char* testing::TestPartResult::file_name() const line_number() Declaration int testing::TestPartResult::line_number() const summary() Declaration const char* testing::TestPartResult::summary() const message() Declaration const char* testing::TestPartResult::message() const passed() Declaration bool testing::TestPartResult::passed() const failed() Declaration bool testing::TestPartResult::failed() const nonfatally_failed() Declaration bool testing::TestPartResult::nonfatally_failed() const fatally_failed() Declaration bool testing::TestPartResult::fatally_failed() const ExtractSummary() Declaration std::string testing::TestPartResult::ExtractSummary(const char *message)"
  },
  "api/testing/test-property.html": {
    "href": "api/testing/test-property.html",
    "title": "Class testing::TestProperty | qiotoolkit",
    "keywords": "Class testing::TestProperty Inheritance testing::TestProperty Constructors TestProperty() Declaration testing::TestProperty::TestProperty(const std::string&a_key, const std::string&a_value) TestProperty() Declaration testing::TestProperty::TestProperty(const std::string&a_key, const std::string&a_value) Methods key() Declaration const char* testing::TestProperty::key() const value() Declaration const char* testing::TestProperty::value() const SetValue() Declaration void testing::TestProperty::SetValue(const std::string&new_value) key() Declaration const char* testing::TestProperty::key() const value() Declaration const char* testing::TestProperty::value() const SetValue() Declaration void testing::TestProperty::SetValue(const std::string&new_value)"
  },
  "api/testing/test-result.html": {
    "href": "api/testing/test-result.html",
    "title": "Class testing::TestResult | qiotoolkit",
    "keywords": "Class testing::TestResult Inheritance testing::TestResult Constructors TestResult() Declaration testing::TestResult::TestResult() TestResult() Declaration testing::TestResult::TestResult() Methods ~TestResult() Declaration testing::TestResult::~TestResult() total_part_count() Declaration int testing::TestResult::total_part_count() const test_property_count() Declaration int testing::TestResult::test_property_count() const Passed() Declaration bool testing::TestResult::Passed() const Skipped() Declaration bool testing::TestResult::Skipped() const Failed() Declaration bool testing::TestResult::Failed() const HasFatalFailure() Declaration bool testing::TestResult::HasFatalFailure() const HasNonfatalFailure() Declaration bool testing::TestResult::HasNonfatalFailure() const elapsed_time() Declaration TimeInMillis testing::TestResult::elapsed_time() const start_timestamp() Declaration TimeInMillis testing::TestResult::start_timestamp() const GetTestPartResult() Declaration const TestPartResult&testing::TestResult::GetTestPartResult(int i) const GetTestProperty() Declaration const TestProperty&testing::TestResult::GetTestProperty(int i) const ~TestResult() Declaration testing::TestResult::~TestResult() total_part_count() Declaration int testing::TestResult::total_part_count() const test_property_count() Declaration int testing::TestResult::test_property_count() const Passed() Declaration bool testing::TestResult::Passed() const Failed() Declaration bool testing::TestResult::Failed() const HasFatalFailure() Declaration bool testing::TestResult::HasFatalFailure() const HasNonfatalFailure() Declaration bool testing::TestResult::HasNonfatalFailure() const elapsed_time() Declaration TimeInMillis testing::TestResult::elapsed_time() const GetTestPartResult() Declaration const TestPartResult&testing::TestResult::GetTestPartResult(int i) const GetTestProperty() Declaration const TestProperty&testing::TestResult::GetTestProperty(int i) const test_part_results() Declaration const std::vector<TestPartResult>&testing::TestResult::test_part_results() const test_properties() Declaration const std::vector<TestProperty>&testing::TestResult::test_properties() const set_start_timestamp() Declaration void testing::TestResult::set_start_timestamp(TimeInMillis start) set_elapsed_time() Declaration void testing::TestResult::set_elapsed_time(TimeInMillis elapsed) RecordProperty() Declaration void testing::TestResult::RecordProperty(const std::string&xml_element, const TestProperty&test_property) AddTestPartResult() Declaration void testing::TestResult::AddTestPartResult(const TestPartResult&test_part_result) death_test_count() Declaration int testing::TestResult::death_test_count() const increment_death_test_count() Declaration int testing::TestResult::increment_death_test_count() ClearTestPartResults() Declaration void testing::TestResult::ClearTestPartResults() Clear() Declaration void testing::TestResult::Clear() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::TestResult::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestResult) test_part_results() Declaration const std::vector<TestPartResult>&testing::TestResult::test_part_results() const test_properties() Declaration const std::vector<TestProperty>&testing::TestResult::test_properties() const set_elapsed_time() Declaration void testing::TestResult::set_elapsed_time(TimeInMillis elapsed) RecordProperty() Declaration void testing::TestResult::RecordProperty(const std::string&xml_element, const TestProperty&test_property) AddTestPartResult() Declaration void testing::TestResult::AddTestPartResult(const TestPartResult&test_part_result) death_test_count() Declaration int testing::TestResult::death_test_count() const increment_death_test_count() Declaration int testing::TestResult::increment_death_test_count() ClearTestPartResults() Declaration void testing::TestResult::ClearTestPartResults() Clear() Declaration void testing::TestResult::Clear() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::TestResult::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestResult) ValidateTestProperty() Declaration bool testing::TestResult::ValidateTestProperty(const std::string&xml_element, const TestProperty&test_property) ValidateTestProperty() Declaration static bool testing::TestResult::ValidateTestProperty(const std::string&xml_element, const TestProperty&test_property)"
  },
  "api/testing/test-suite.html": {
    "href": "api/testing/test-suite.html",
    "title": "Class testing::TestSuite | qiotoolkit",
    "keywords": "Class testing::TestSuite Inheritance testing::TestSuite Constructors TestSuite() Declaration testing::TestSuite::TestSuite(const char *name, const char *a_type_param, internal::SetUpTestSuiteFunc set_up_tc, internal::TearDownTestSuiteFunc tear_down_tc) Methods ~TestSuite() Declaration testing::TestSuite::~TestSuite() name() Declaration const char* testing::TestSuite::name() const type_param() Declaration const char* testing::TestSuite::type_param() const should_run() Declaration bool testing::TestSuite::should_run() const successful_test_count() Declaration int testing::TestSuite::successful_test_count() const skipped_test_count() Declaration int testing::TestSuite::skipped_test_count() const failed_test_count() Declaration int testing::TestSuite::failed_test_count() const reportable_disabled_test_count() Declaration int testing::TestSuite::reportable_disabled_test_count() const disabled_test_count() Declaration int testing::TestSuite::disabled_test_count() const reportable_test_count() Declaration int testing::TestSuite::reportable_test_count() const test_to_run_count() Declaration int testing::TestSuite::test_to_run_count() const total_test_count() Declaration int testing::TestSuite::total_test_count() const Passed() Declaration bool testing::TestSuite::Passed() const Failed() Declaration bool testing::TestSuite::Failed() const elapsed_time() Declaration TimeInMillis testing::TestSuite::elapsed_time() const start_timestamp() Declaration TimeInMillis testing::TestSuite::start_timestamp() const GetTestInfo() Declaration const TestInfo * testing::TestSuite::GetTestInfo(int i) const ad_hoc_test_result() Declaration const TestResult&testing::TestSuite::ad_hoc_test_result() const test_info_list() Declaration std::vector<TestInfo*>&testing::TestSuite::test_info_list() test_info_list() Declaration const std::vector<TestInfo*>&testing::TestSuite::test_info_list() const GetMutableTestInfo() Declaration TestInfo * testing::TestSuite::GetMutableTestInfo(int i) set_should_run() Declaration void testing::TestSuite::set_should_run(bool should) AddTestInfo() Declaration void testing::TestSuite::AddTestInfo(TestInfo *test_info) ClearResult() Declaration void testing::TestSuite::ClearResult() Run() Declaration void testing::TestSuite::Run() RunSetUpTestSuite() Declaration void testing::TestSuite::RunSetUpTestSuite() RunTearDownTestSuite() Declaration void testing::TestSuite::RunTearDownTestSuite() ShuffleTests() Declaration void testing::TestSuite::ShuffleTests(internal::Random *random) UnshuffleTests() Declaration void testing::TestSuite::UnshuffleTests() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::TestSuite::GTEST_DISALLOW_COPY_AND_ASSIGN_(TestSuite) ClearTestSuiteResult() Declaration static void testing::TestSuite::ClearTestSuiteResult(TestSuite *test_suite) TestPassed() Declaration static bool testing::TestSuite::TestPassed(const TestInfo *test_info) TestSkipped() Declaration static bool testing::TestSuite::TestSkipped(const TestInfo *test_info) TestFailed() Declaration static bool testing::TestSuite::TestFailed(const TestInfo *test_info) TestReportableDisabled() Declaration static bool testing::TestSuite::TestReportableDisabled(const TestInfo *test_info) TestDisabled() Declaration static bool testing::TestSuite::TestDisabled(const TestInfo *test_info) TestReportable() Declaration static bool testing::TestSuite::TestReportable(const TestInfo *test_info) ShouldRunTest() Declaration static bool testing::TestSuite::ShouldRunTest(const TestInfo *test_info)"
  },
  "api/testing/test-with-param.html": {
    "href": "api/testing/test-with-param.html",
    "title": "Class testing::TestWithParam | qiotoolkit",
    "keywords": "Class testing::TestWithParam Inheritance testing::Test testing::WithParamInterface testing::TestWithParam Inherited Members HasNonfatalFailure HasFatalFailure TearDown HasNonfatalFailure SetUp SetUpTestCase IsSkipped Test TearDownTestSuite HasFailure RecordProperty SetUp HasFatalFailure TearDown ~Test RecordProperty SetUpTestSuite TearDownTestCase RecordProperty RecordProperty ~Test GetParam ~WithParamInterface GetParam"
  },
  "api/testing/test.html": {
    "href": "api/testing/test.html",
    "title": "Class testing::Test | qiotoolkit",
    "keywords": "Class testing::Test Inheritance testing::Test testing::TestWithParam Constructors Test() Declaration testing::Test::Test() Test() Declaration testing::Test::Test() Methods ~Test() Declaration testing::Test::~Test() ~Test() Declaration virtual testing::Test::~Test() SetUpTestSuite() Declaration static void testing::Test::SetUpTestSuite() TearDownTestSuite() Declaration static void testing::Test::TearDownTestSuite() TearDownTestCase() Declaration static void testing::Test::TearDownTestCase() SetUpTestCase() Declaration static void testing::Test::SetUpTestCase() HasFatalFailure() Declaration bool testing::Test::HasFatalFailure() HasNonfatalFailure() Declaration bool testing::Test::HasNonfatalFailure() IsSkipped() Declaration bool testing::Test::IsSkipped() HasFailure() Declaration static bool testing::Test::HasFailure() RecordProperty() Declaration void testing::Test::RecordProperty(const std::string&key, const std::string&value) RecordProperty() Declaration void testing::Test::RecordProperty(const std::string&key, int value) SetUpTestCase() Declaration static void testing::Test::SetUpTestCase() TearDownTestCase() Declaration static void testing::Test::TearDownTestCase() HasFatalFailure() Declaration static bool testing::Test::HasFatalFailure() HasNonfatalFailure() Declaration static bool testing::Test::HasNonfatalFailure() HasFailure() Declaration static bool testing::Test::HasFailure() RecordProperty() Declaration static void testing::Test::RecordProperty(const std::string&key, const std::string&value) RecordProperty() Declaration static void testing::Test::RecordProperty(const std::string&key, int value) SetUp() Declaration void testing::Test::SetUp() TearDown() Declaration void testing::Test::TearDown() SetUp() Declaration virtual void testing::Test::SetUp() TearDown() Declaration virtual void testing::Test::TearDown() HasSameFixtureClass() Declaration bool testing::Test::HasSameFixtureClass() HasSameFixtureClass() Declaration static bool testing::Test::HasSameFixtureClass() TestBody() Declaration virtual void testing::Test::TestBody()=0 Run() Declaration void testing::Test::Run() DeleteSelf_() Declaration void testing::Test::DeleteSelf_() Setup() Declaration virtual Setup_should_be_spelled_SetUp* testing::Test::Setup() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::Test::GTEST_DISALLOW_COPY_AND_ASSIGN_(Test) TestBody() Declaration virtual void testing::Test::TestBody()=0 Run() Declaration void testing::Test::Run() DeleteSelf_() Declaration void testing::Test::DeleteSelf_() Setup() Declaration virtual Setup_should_be_spelled_SetUp* testing::Test::Setup() GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::Test::GTEST_DISALLOW_COPY_AND_ASSIGN_(Test)"
  },
  "api/testing/test/setup/should/be/spelled/set-up.html": {
    "href": "api/testing/test/setup/should/be/spelled/set-up.html",
    "title": "Struct testing::Test::Setup_should_be_spelled_SetUp | qiotoolkit",
    "keywords": "Struct testing::Test::Setup_should_be_spelled_SetUp"
  },
  "api/testing/unit-test.html": {
    "href": "api/testing/unit-test.html",
    "title": "Class testing::UnitTest | qiotoolkit",
    "keywords": "Class testing::UnitTest Inheritance testing::UnitTest Constructors UnitTest() Declaration testing::UnitTest::UnitTest() UnitTest() Declaration testing::UnitTest::UnitTest() Methods GetInstance() Declaration UnitTest * testing::UnitTest::GetInstance() GetInstance() Declaration static UnitTest* testing::UnitTest::GetInstance() Run() Declaration int testing::UnitTest::Run() GTEST_MUST_USE_RESULT_ original_working_dir() Declaration const char * testing::UnitTest::original_working_dir() const current_test_suite() Declaration const TestSuite * testing::UnitTest::current_test_suite() const GTEST_LOCK_EXCLUDED_(mutex_) current_test_case() Declaration const TestCase * testing::UnitTest::current_test_case() const GTEST_LOCK_EXCLUDED_(mutex_) current_test_info() Declaration const TestInfo * testing::UnitTest::current_test_info() const GTEST_LOCK_EXCLUDED_(mutex_) random_seed() Declaration int testing::UnitTest::random_seed() const parameterized_test_registry() Declaration internal::ParameterizedTestCaseRegistry&testing::UnitTest::parameterized_test_registry() GTEST_LOCK_EXCLUDED_(mutex_) successful_test_suite_count() Declaration int testing::UnitTest::successful_test_suite_count() const failed_test_suite_count() Declaration int testing::UnitTest::failed_test_suite_count() const total_test_suite_count() Declaration int testing::UnitTest::total_test_suite_count() const test_suite_to_run_count() Declaration int testing::UnitTest::test_suite_to_run_count() const successful_test_case_count() Declaration int testing::UnitTest::successful_test_case_count() const failed_test_case_count() Declaration int testing::UnitTest::failed_test_case_count() const total_test_case_count() Declaration int testing::UnitTest::total_test_case_count() const test_case_to_run_count() Declaration int testing::UnitTest::test_case_to_run_count() const successful_test_count() Declaration int testing::UnitTest::successful_test_count() const skipped_test_count() Declaration int testing::UnitTest::skipped_test_count() const failed_test_count() Declaration int testing::UnitTest::failed_test_count() const reportable_disabled_test_count() Declaration int testing::UnitTest::reportable_disabled_test_count() const disabled_test_count() Declaration int testing::UnitTest::disabled_test_count() const reportable_test_count() Declaration int testing::UnitTest::reportable_test_count() const total_test_count() Declaration int testing::UnitTest::total_test_count() const test_to_run_count() Declaration int testing::UnitTest::test_to_run_count() const start_timestamp() Declaration internal::TimeInMillis testing::UnitTest::start_timestamp() const elapsed_time() Declaration internal::TimeInMillis testing::UnitTest::elapsed_time() const Passed() Declaration bool testing::UnitTest::Passed() const Failed() Declaration bool testing::UnitTest::Failed() const GetTestSuite() Declaration const TestSuite * testing::UnitTest::GetTestSuite(int i) const GetTestCase() Declaration const TestCase * testing::UnitTest::GetTestCase(int i) const ad_hoc_test_result() Declaration const TestResult&testing::UnitTest::ad_hoc_test_result() const listeners() Declaration TestEventListeners&testing::UnitTest::listeners() Run() Declaration int testing::UnitTest::Run() GTEST_MUST_USE_RESULT_ original_working_dir() Declaration const char* testing::UnitTest::original_working_dir() const current_test_case() Declaration const TestCase* testing::UnitTest::current_test_case() const GTEST_LOCK_EXCLUDED_(mutex_) current_test_info() Declaration const TestInfo* testing::UnitTest::current_test_info() const GTEST_LOCK_EXCLUDED_(mutex_) random_seed() Declaration int testing::UnitTest::random_seed() const parameterized_test_registry() Declaration internal::ParameterizedTestCaseRegistry&testing::UnitTest::parameterized_test_registry() GTEST_LOCK_EXCLUDED_(mutex_) successful_test_case_count() Declaration int testing::UnitTest::successful_test_case_count() const failed_test_case_count() Declaration int testing::UnitTest::failed_test_case_count() const total_test_case_count() Declaration int testing::UnitTest::total_test_case_count() const test_case_to_run_count() Declaration int testing::UnitTest::test_case_to_run_count() const successful_test_count() Declaration int testing::UnitTest::successful_test_count() const failed_test_count() Declaration int testing::UnitTest::failed_test_count() const reportable_disabled_test_count() Declaration int testing::UnitTest::reportable_disabled_test_count() const disabled_test_count() Declaration int testing::UnitTest::disabled_test_count() const reportable_test_count() Declaration int testing::UnitTest::reportable_test_count() const total_test_count() Declaration int testing::UnitTest::total_test_count() const test_to_run_count() Declaration int testing::UnitTest::test_to_run_count() const start_timestamp() Declaration TimeInMillis testing::UnitTest::start_timestamp() const elapsed_time() Declaration TimeInMillis testing::UnitTest::elapsed_time() const Passed() Declaration bool testing::UnitTest::Passed() const Failed() Declaration bool testing::UnitTest::Failed() const GetTestCase() Declaration const TestCase* testing::UnitTest::GetTestCase(int i) const ad_hoc_test_result() Declaration const TestResult&testing::UnitTest::ad_hoc_test_result() const listeners() Declaration TestEventListeners&testing::UnitTest::listeners() AddEnvironment() Declaration Environment * testing::UnitTest::AddEnvironment(Environment *env) AddTestPartResult() Declaration void testing::UnitTest::AddTestPartResult(TestPartResult::Type result_type, const char *file_name, int line_number, const std::string&message, const std::string&os_stack_trace) GTEST_LOCK_EXCLUDED_(mutex_) RecordProperty() Declaration void testing::UnitTest::RecordProperty(const std::string&key, const std::string&value) GetMutableTestSuite() Declaration TestSuite * testing::UnitTest::GetMutableTestSuite(int i) impl() Declaration internal::UnitTestImpl* testing::UnitTest::impl() impl() Declaration const internal::UnitTestImpl* testing::UnitTest::impl() const ~UnitTest() Declaration testing::UnitTest::~UnitTest() PushGTestTrace() Declaration void testing::UnitTest::PushGTestTrace(const internal::TraceInfo&trace) GTEST_LOCK_EXCLUDED_(mutex_) PopGTestTrace() Declaration void testing::UnitTest::PopGTestTrace() GTEST_LOCK_EXCLUDED_(mutex_) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::UnitTest::GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTest) AddEnvironment() Declaration Environment* testing::UnitTest::AddEnvironment(Environment *env) AddTestPartResult() Declaration void testing::UnitTest::AddTestPartResult(TestPartResult::Type result_type, const char *file_name, int line_number, const std::string&message, const std::string&os_stack_trace) GTEST_LOCK_EXCLUDED_(mutex_) RecordProperty() Declaration void testing::UnitTest::RecordProperty(const std::string&key, const std::string&value) GetMutableTestCase() Declaration TestCase * testing::UnitTest::GetMutableTestCase(int i) impl() Declaration internal::UnitTestImpl* testing::UnitTest::impl() impl() Declaration const internal::UnitTestImpl* testing::UnitTest::impl() const ~UnitTest() Declaration virtual testing::UnitTest::~UnitTest() PushGTestTrace() Declaration void testing::UnitTest::PushGTestTrace(const internal::TraceInfo&trace) GTEST_LOCK_EXCLUDED_(mutex_) PopGTestTrace() Declaration void testing::UnitTest::PopGTestTrace() GTEST_LOCK_EXCLUDED_(mutex_) GTEST_DISALLOW_COPY_AND_ASSIGN_() Declaration testing::UnitTest::GTEST_DISALLOW_COPY_AND_ASSIGN_(UnitTest)"
  },
  "api/testing/with-param-interface.html": {
    "href": "api/testing/with-param-interface.html",
    "title": "Class testing::WithParamInterface | qiotoolkit",
    "keywords": "Class testing::WithParamInterface Inheritance testing::WithParamInterface testing::TestWithParam Methods ~WithParamInterface() Declaration virtual testing::WithParamInterface<T>::~WithParamInterface() ~WithParamInterface() Declaration virtual testing::WithParamInterface<T>::~WithParamInterface() GetParam() Declaration const ParamType&testing::WithParamInterface<T>::GetParam() const GetParam() Declaration static const ParamType&testing::WithParamInterface<T>::GetParam() SetParam() Declaration static void testing::WithParamInterface<T>::SetParam(const ParamType *parameter) SetParam() Declaration static void testing::WithParamInterface<T>::SetParam(const ParamType *parameter)"
  },
  "api/transcoder.html": {
    "href": "api/transcoder.html",
    "title": "Struct Transcoder | qiotoolkit",
    "keywords": "Struct Transcoder Encoding conversion. Methods Transcode() Take one Unicode codepoint from source encoding, convert it to target encoding and put it to the output stream. Declaration static RAPIDJSON_FORCEINLINE bool Transcoder<SourceEncoding, TargetEncoding>::Transcode(InputStream&is, OutputStream&os) TranscodeUnsafe() Declaration static RAPIDJSON_FORCEINLINE bool Transcoder<SourceEncoding, TargetEncoding>::TranscodeUnsafe(InputStream&is, OutputStream&os) Validate() Validate one Unicode codepoint from an encoded stream. Declaration static RAPIDJSON_FORCEINLINE bool Transcoder<SourceEncoding, TargetEncoding>::Validate(InputStream&is, OutputStream&os)"
  },
  "api/transcoder/3/01-encoding/00/01-encoding/01/4.html": {
    "href": "api/transcoder/3/01-encoding/00/01-encoding/01/4.html",
    "title": "Struct > | qiotoolkit",
    "keywords": "Struct > Specialization of Transcoder with same source and target encoding. Methods Transcode() Declaration static RAPIDJSON_FORCEINLINE bool Transcoder<Encoding, Encoding>::Transcode(InputStream&is, OutputStream&os) TranscodeUnsafe() Declaration static RAPIDJSON_FORCEINLINE bool Transcoder<Encoding, Encoding>::TranscodeUnsafe(InputStream&is, OutputStream&os) Validate() Declaration static RAPIDJSON_FORCEINLINE bool Transcoder<Encoding, Encoding>::Validate(InputStream&is, OutputStream&os)"
  },
  "api/upload/abstract-rpc-server.html": {
    "href": "api/upload/abstract-rpc-server.html",
    "title": "Class upload::AbstractRpcServer | qiotoolkit",
    "keywords": "Class upload::AbstractRpcServer Provides a common interface for a simple RPC server. Inheritance upload::AbstractRpcServer upload::HttpRpcServer Methods __init__() Creates a new HttpRpcServer. Args: host: The host to send requests to. auth_function: A function that takes no arguments and returns an (email, password) tuple when called. Will be called if authentication is required. host_override: The host header to send to the server (defaults to host). extra_headers: A dict of extra headers to append to every request. save_cookies: If True, save the authentication cookies to local disk. If False, use an in-memory cookiejar instead. Subclasses must implement this functionality. Defaults to False. Declaration def upload.AbstractRpcServer.__init__(self, host, auth_function, host_override=None, extra_headers={}, save_cookies=False) Send() Sends an RPC and returns the response. Args: request_path: The path to send the request to, eg /api/appversion/create. payload: The body of the request, or None to send an empty request. content_type: The Content-Type header to use. timeout: timeout in seconds; default None i.e. no timeout. (Note: for large requests on OS X, the timeout doesn't work right.) kwargs: Any keyword arguments are converted into query string parameters. Returns: The response body, as a string. Declaration def upload.AbstractRpcServer.Send(self, request_path, payload=None, content_type=\"application/octet-stream\", timeout=None, **kwargs) __init__() Creates a new HttpRpcServer. Args: host: The host to send requests to. auth_function: A function that takes no arguments and returns an (email, password) tuple when called. Will be called if authentication is required. host_override: The host header to send to the server (defaults to host). extra_headers: A dict of extra headers to append to every request. save_cookies: If True, save the authentication cookies to local disk. If False, use an in-memory cookiejar instead. Subclasses must implement this functionality. Defaults to False. Declaration def upload.AbstractRpcServer.__init__(self, host, auth_function, host_override=None, extra_headers={}, save_cookies=False) Send() Sends an RPC and returns the response. Args: request_path: The path to send the request to, eg /api/appversion/create. payload: The body of the request, or None to send an empty request. content_type: The Content-Type header to use. timeout: timeout in seconds; default None i.e. no timeout. (Note: for large requests on OS X, the timeout doesn't work right.) kwargs: Any keyword arguments are converted into query string parameters. Returns: The response body, as a string. Declaration def upload.AbstractRpcServer.Send(self, request_path, payload=None, content_type=\"application/octet-stream\", timeout=None, **kwargs) __init__() Creates a new HttpRpcServer. Args: host: The host to send requests to. auth_function: A function that takes no arguments and returns an (email, password) tuple when called. Will be called if authentication is required. host_override: The host header to send to the server (defaults to host). extra_headers: A dict of extra headers to append to every request. save_cookies: If True, save the authentication cookies to local disk. If False, use an in-memory cookiejar instead. Subclasses must implement this functionality. Defaults to False. Declaration def upload.AbstractRpcServer.__init__(self, host, auth_function, host_override=None, extra_headers={}, save_cookies=False) Send() Sends an RPC and returns the response. Args: request_path: The path to send the request to, eg /api/appversion/create. payload: The body of the request, or None to send an empty request. content_type: The Content-Type header to use. timeout: timeout in seconds; default None i.e. no timeout. (Note: for large requests on OS X, the timeout doesn't work right.) kwargs: Any keyword arguments are converted into query string parameters. Returns: The response body, as a string. Declaration def upload.AbstractRpcServer.Send(self, request_path, payload=None, content_type=\"application/octet-stream\", timeout=None, **kwargs) __init__() Creates a new HttpRpcServer. Args: host: The host to send requests to. auth_function: A function that takes no arguments and returns an (email, password) tuple when called. Will be called if authentication is required. host_override: The host header to send to the server (defaults to host). extra_headers: A dict of extra headers to append to every request. save_cookies: If True, save the authentication cookies to local disk. If False, use an in-memory cookiejar instead. Subclasses must implement this functionality. Defaults to False. Declaration def upload.AbstractRpcServer.__init__(self, host, auth_function, host_override=None, extra_headers={}, save_cookies=False) Send() Sends an RPC and returns the response. Args: request_path: The path to send the request to, eg /api/appversion/create. payload: The body of the request, or None to send an empty request. content_type: The Content-Type header to use. timeout: timeout in seconds; default None i.e. no timeout. (Note: for large requests on OS X, the timeout doesn't work right.) kwargs: Any keyword arguments are converted into query string parameters. Returns: The response body, as a string. Declaration def upload.AbstractRpcServer.Send(self, request_path, payload=None, content_type=\"application/octet-stream\", timeout=None, **kwargs) _GetOpener() Returns an OpenerDirector for making HTTP requests. Returns: A urllib2.OpenerDirector object. Declaration def upload.AbstractRpcServer._GetOpener(self) _CreateRequest() Creates a new urllib request. Declaration def upload.AbstractRpcServer._CreateRequest(self, url, data=None) _GetAuthToken() Uses ClientLogin to authenticate the user, returning an auth token. Args: email: The user's email address password: The user's password Raises: ClientLoginError: If there was an error authenticating with ClientLogin. HTTPError: If there was some other form of HTTP error. Returns: The authentication token returned by ClientLogin. Declaration def upload.AbstractRpcServer._GetAuthToken(self, email, password) _GetAuthCookie() Fetches authentication cookies for an authentication token. Args: auth_token: The authentication token returned by ClientLogin. Raises: HTTPError: If there was an error fetching the authentication cookies. Declaration def upload.AbstractRpcServer._GetAuthCookie(self, auth_token) _Authenticate() Authenticates the user. The authentication process works as follows: We get a username and password from the user We use ClientLogin to obtain an AUTH token for the user (see http://code.google.com/apis/accounts/AuthForInstalledApps.html). We pass the auth token to /_ah/login on the server to obtain an authentication cookie. If login was successful, it tries to redirect us to the URL we provided. If we attempt to access the upload API without first obtaining an authentication cookie, it returns a 401 response and directs us to authenticate ourselves with ClientLogin. Declaration def upload.AbstractRpcServer._Authenticate(self) _GetOpener() Returns an OpenerDirector for making HTTP requests. Returns: A urllib2.OpenerDirector object. Declaration def upload.AbstractRpcServer._GetOpener(self) _CreateRequest() Creates a new urllib request. Declaration def upload.AbstractRpcServer._CreateRequest(self, url, data=None) _GetAuthToken() Uses ClientLogin to authenticate the user, returning an auth token. Args: email: The user's email address password: The user's password Raises: ClientLoginError: If there was an error authenticating with ClientLogin. HTTPError: If there was some other form of HTTP error. Returns: The authentication token returned by ClientLogin. Declaration def upload.AbstractRpcServer._GetAuthToken(self, email, password) _GetAuthCookie() Fetches authentication cookies for an authentication token. Args: auth_token: The authentication token returned by ClientLogin. Raises: HTTPError: If there was an error fetching the authentication cookies. Declaration def upload.AbstractRpcServer._GetAuthCookie(self, auth_token) _Authenticate() Authenticates the user. The authentication process works as follows: We get a username and password from the user We use ClientLogin to obtain an AUTH token for the user (see http://code.google.com/apis/accounts/AuthForInstalledApps.html). We pass the auth token to /_ah/login on the server to obtain an authentication cookie. If login was successful, it tries to redirect us to the URL we provided. If we attempt to access the upload API without first obtaining an authentication cookie, it returns a 401 response and directs us to authenticate ourselves with ClientLogin. Declaration def upload.AbstractRpcServer._Authenticate(self) _GetOpener() Returns an OpenerDirector for making HTTP requests. Returns: A urllib2.OpenerDirector object. Declaration def upload.AbstractRpcServer._GetOpener(self) _CreateRequest() Creates a new urllib request. Declaration def upload.AbstractRpcServer._CreateRequest(self, url, data=None) _GetAuthToken() Uses ClientLogin to authenticate the user, returning an auth token. Args: email: The user's email address password: The user's password Raises: ClientLoginError: If there was an error authenticating with ClientLogin. HTTPError: If there was some other form of HTTP error. Returns: The authentication token returned by ClientLogin. Declaration def upload.AbstractRpcServer._GetAuthToken(self, email, password) _GetAuthCookie() Fetches authentication cookies for an authentication token. Args: auth_token: The authentication token returned by ClientLogin. Raises: HTTPError: If there was an error fetching the authentication cookies. Declaration def upload.AbstractRpcServer._GetAuthCookie(self, auth_token) _Authenticate() Authenticates the user. The authentication process works as follows: We get a username and password from the user We use ClientLogin to obtain an AUTH token for the user (see http://code.google.com/apis/accounts/AuthForInstalledApps.html). We pass the auth token to /_ah/login on the server to obtain an authentication cookie. If login was successful, it tries to redirect us to the URL we provided. If we attempt to access the upload API without first obtaining an authentication cookie, it returns a 401 response and directs us to authenticate ourselves with ClientLogin. Declaration def upload.AbstractRpcServer._Authenticate(self) _GetOpener() Returns an OpenerDirector for making HTTP requests. Returns: A urllib2.OpenerDirector object. Declaration def upload.AbstractRpcServer._GetOpener(self) _CreateRequest() Creates a new urllib request. Declaration def upload.AbstractRpcServer._CreateRequest(self, url, data=None) _GetAuthToken() Uses ClientLogin to authenticate the user, returning an auth token. Args: email: The user's email address password: The user's password Raises: ClientLoginError: If there was an error authenticating with ClientLogin. HTTPError: If there was some other form of HTTP error. Returns: The authentication token returned by ClientLogin. Declaration def upload.AbstractRpcServer._GetAuthToken(self, email, password) _GetAuthCookie() Fetches authentication cookies for an authentication token. Args: auth_token: The authentication token returned by ClientLogin. Raises: HTTPError: If there was an error fetching the authentication cookies. Declaration def upload.AbstractRpcServer._GetAuthCookie(self, auth_token) _Authenticate() Authenticates the user. The authentication process works as follows: We get a username and password from the user We use ClientLogin to obtain an AUTH token for the user (see http://code.google.com/apis/accounts/AuthForInstalledApps.html). We pass the auth token to /_ah/login on the server to obtain an authentication cookie. If login was successful, it tries to redirect us to the URL we provided. If we attempt to access the upload API without first obtaining an authentication cookie, it returns a 401 response and directs us to authenticate ourselves with ClientLogin. Declaration def upload.AbstractRpcServer._Authenticate(self)"
  },
  "api/upload/client-login-error.html": {
    "href": "api/upload/client-login-error.html",
    "title": "Class upload::ClientLoginError | qiotoolkit",
    "keywords": "Class upload::ClientLoginError Raised to indicate there was an error authenticating with ClientLogin. Inheritance upload::ClientLoginError Methods __init__() Declaration def upload.ClientLoginError.__init__(self, url, code, msg, headers, args) __init__() Declaration def upload.ClientLoginError.__init__(self, url, code, msg, headers, args) __init__() Declaration def upload.ClientLoginError.__init__(self, url, code, msg, headers, args) __init__() Declaration def upload.ClientLoginError.__init__(self, url, code, msg, headers, args)"
  },
  "api/upload/git-vcs.html": {
    "href": "api/upload/git-vcs.html",
    "title": "Class upload::GitVCS | qiotoolkit",
    "keywords": "Class upload::GitVCS Implementation of the VersionControlSystem interface for Git. Inheritance upload::VersionControlSystem upload::GitVCS Inherited Members UploadBaseFiles GetBaseFiles IsImage CheckForUnknownFiles Methods __init__() Constructor. Args: options: Command line options. Declaration def upload.GitVCS.__init__(self, options) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.GitVCS.GenerateDiff(self, extra_args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.GitVCS.GetUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.GitVCS.GetBaseFile(self, filename) __init__() Constructor. Args: options: Command line options. Declaration def upload.GitVCS.__init__(self, options) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.GitVCS.GenerateDiff(self, extra_args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.GitVCS.GetUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.GitVCS.GetBaseFile(self, filename) __init__() Constructor. Args: options: Command line options. Declaration def upload.GitVCS.__init__(self, options) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.GitVCS.GenerateDiff(self, extra_args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.GitVCS.GetUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.GitVCS.GetBaseFile(self, filename) __init__() Constructor. Args: options: Command line options. Declaration def upload.GitVCS.__init__(self, options) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.GitVCS.GenerateDiff(self, extra_args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.GitVCS.GetUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.GitVCS.GetBaseFile(self, filename)"
  },
  "api/upload/http-rpc-server.html": {
    "href": "api/upload/http-rpc-server.html",
    "title": "Class upload::HttpRpcServer | qiotoolkit",
    "keywords": "Class upload::HttpRpcServer elif e.code >= 500 and e.code < 600: Server Error - try again. continue Provides a simplified RPC-style interface for HTTP requests. Server Error - try again. continue Provides a simplified RPC-style interface for HTTP requests. Server Error - try again. continue Provides a simplified RPC-style interface for HTTP requests. Server Error - try again. continue Provides a simplified RPC-style interface for HTTP requests. Inheritance upload::AbstractRpcServer upload::HttpRpcServer Inherited Members __init__ Send Methods _Authenticate() Save the cookie jar after authentication. Declaration def upload.HttpRpcServer._Authenticate(self) _GetOpener() Returns an OpenerDirector that supports cookies and ignores redirects. Returns: A urllib2.OpenerDirector object. Declaration def upload.HttpRpcServer._GetOpener(self) _Authenticate() Save the cookie jar after authentication. Declaration def upload.HttpRpcServer._Authenticate(self) _GetOpener() Returns an OpenerDirector that supports cookies and ignores redirects. Returns: A urllib2.OpenerDirector object. Declaration def upload.HttpRpcServer._GetOpener(self) _Authenticate() Save the cookie jar after authentication. Declaration def upload.HttpRpcServer._Authenticate(self) _GetOpener() Returns an OpenerDirector that supports cookies and ignores redirects. Returns: A urllib2.OpenerDirector object. Declaration def upload.HttpRpcServer._GetOpener(self) _Authenticate() Save the cookie jar after authentication. Declaration def upload.HttpRpcServer._Authenticate(self) _GetOpener() Returns an OpenerDirector that supports cookies and ignores redirects. Returns: A urllib2.OpenerDirector object. Declaration def upload.HttpRpcServer._GetOpener(self)"
  },
  "api/upload/mercurial-vcs.html": {
    "href": "api/upload/mercurial-vcs.html",
    "title": "Class upload::MercurialVCS | qiotoolkit",
    "keywords": "Class upload::MercurialVCS Implementation of the VersionControlSystem interface for Mercurial. Inheritance upload::VersionControlSystem upload::MercurialVCS Inherited Members UploadBaseFiles GetBaseFiles IsImage __init__ CheckForUnknownFiles Methods __init__() Declaration def upload.MercurialVCS.__init__(self, options, repo_dir) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.MercurialVCS.GenerateDiff(self, extra_args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.MercurialVCS.GetUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.MercurialVCS.GetBaseFile(self, filename) __init__() Declaration def upload.MercurialVCS.__init__(self, options, repo_dir) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.MercurialVCS.GenerateDiff(self, extra_args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.MercurialVCS.GetUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.MercurialVCS.GetBaseFile(self, filename) __init__() Declaration def upload.MercurialVCS.__init__(self, options, repo_dir) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.MercurialVCS.GenerateDiff(self, extra_args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.MercurialVCS.GetUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.MercurialVCS.GetBaseFile(self, filename) __init__() Declaration def upload.MercurialVCS.__init__(self, options, repo_dir) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.MercurialVCS.GenerateDiff(self, extra_args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.MercurialVCS.GetUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.MercurialVCS.GetBaseFile(self, filename) _GetRelPath() Get relative path of a file according to the current directory, given its logical path in the repo. Declaration def upload.MercurialVCS._GetRelPath(self, filename) _GetRelPath() Get relative path of a file according to the current directory, given its logical path in the repo. Declaration def upload.MercurialVCS._GetRelPath(self, filename) _GetRelPath() Get relative path of a file according to the current directory, given its logical path in the repo. Declaration def upload.MercurialVCS._GetRelPath(self, filename) _GetRelPath() Get relative path of a file according to the current directory, given its logical path in the repo. Declaration def upload.MercurialVCS._GetRelPath(self, filename)"
  },
  "api/upload/subversion-vcs.html": {
    "href": "api/upload/subversion-vcs.html",
    "title": "Class upload::SubversionVCS | qiotoolkit",
    "keywords": "Class upload::SubversionVCS Implementation of the VersionControlSystem interface for Subversion. Inheritance upload::VersionControlSystem upload::SubversionVCS Inherited Members UploadBaseFiles GetBaseFiles IsImage CheckForUnknownFiles Methods __init__() Constructor. Args: options: Command line options. Declaration def upload.SubversionVCS.__init__(self, options) GuessBase() Wrapper for _GuessBase. Declaration def upload.SubversionVCS.GuessBase(self, required) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.SubversionVCS.GenerateDiff(self, args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.SubversionVCS.GetUnknownFiles(self) ReadFile() Returns the contents of a file. Declaration def upload.SubversionVCS.ReadFile(self, filename) GetStatus() Returns the status of a file. Declaration def upload.SubversionVCS.GetStatus(self, filename) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.SubversionVCS.GetBaseFile(self, filename) __init__() Constructor. Args: options: Command line options. Declaration def upload.SubversionVCS.__init__(self, options) GuessBase() Wrapper for _GuessBase. Declaration def upload.SubversionVCS.GuessBase(self, required) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.SubversionVCS.GenerateDiff(self, args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.SubversionVCS.GetUnknownFiles(self) ReadFile() Returns the contents of a file. Declaration def upload.SubversionVCS.ReadFile(self, filename) GetStatus() Returns the status of a file. Declaration def upload.SubversionVCS.GetStatus(self, filename) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.SubversionVCS.GetBaseFile(self, filename) __init__() Constructor. Args: options: Command line options. Declaration def upload.SubversionVCS.__init__(self, options) GuessBase() Wrapper for _GuessBase. Declaration def upload.SubversionVCS.GuessBase(self, required) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.SubversionVCS.GenerateDiff(self, args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.SubversionVCS.GetUnknownFiles(self) ReadFile() Returns the contents of a file. Declaration def upload.SubversionVCS.ReadFile(self, filename) GetStatus() Returns the status of a file. Declaration def upload.SubversionVCS.GetStatus(self, filename) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.SubversionVCS.GetBaseFile(self, filename) __init__() Constructor. Args: options: Command line options. Declaration def upload.SubversionVCS.__init__(self, options) GuessBase() Wrapper for _GuessBase. Declaration def upload.SubversionVCS.GuessBase(self, required) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.SubversionVCS.GenerateDiff(self, args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.SubversionVCS.GetUnknownFiles(self) ReadFile() Returns the contents of a file. Declaration def upload.SubversionVCS.ReadFile(self, filename) GetStatus() Returns the status of a file. Declaration def upload.SubversionVCS.GetStatus(self, filename) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.SubversionVCS.GetBaseFile(self, filename) _GuessBase() Returns the SVN base URL. Args: required: If true, exits if the url can't be guessed, otherwise None is returned. Declaration def upload.SubversionVCS._GuessBase(self, required) _CollapseKeywords() Collapses SVN keywords. Declaration def upload.SubversionVCS._CollapseKeywords(self, content, keyword_str) _GuessBase() Returns the SVN base URL. Args: required: If true, exits if the url can't be guessed, otherwise None is returned. Declaration def upload.SubversionVCS._GuessBase(self, required) _CollapseKeywords() Collapses SVN keywords. Declaration def upload.SubversionVCS._CollapseKeywords(self, content, keyword_str) _GuessBase() Returns the SVN base URL. Args: required: If true, exits if the url can't be guessed, otherwise None is returned. Declaration def upload.SubversionVCS._GuessBase(self, required) _CollapseKeywords() Collapses SVN keywords. Declaration def upload.SubversionVCS._CollapseKeywords(self, content, keyword_str) _GuessBase() Returns the SVN base URL. Args: required: If true, exits if the url can't be guessed, otherwise None is returned. Declaration def upload.SubversionVCS._GuessBase(self, required) _CollapseKeywords() Collapses SVN keywords. Declaration def upload.SubversionVCS._CollapseKeywords(self, content, keyword_str)"
  },
  "api/upload/version-control-system.html": {
    "href": "api/upload/version-control-system.html",
    "title": "Class upload::VersionControlSystem | qiotoolkit",
    "keywords": "Class upload::VersionControlSystem Abstract base class providing an interface to the VCS. Inheritance upload::VersionControlSystem upload::GitVCS upload::MercurialVCS upload::SubversionVCS Methods __init__() Constructor. Args: options: Command line options. Declaration def upload.VersionControlSystem.__init__(self, options) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.VersionControlSystem.GenerateDiff(self, args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.VersionControlSystem.GetUnknownFiles(self) CheckForUnknownFiles() Show an \"are you sure?\" prompt if there are unknown files. Declaration def upload.VersionControlSystem.CheckForUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.VersionControlSystem.GetBaseFile(self, filename) GetBaseFiles() Helper that calls GetBase file for each file in the patch. Returns: A dictionary that maps from filename to GetBaseFile's tuple. Filenames are retrieved based on lines that start with \"Index:\" or \"Property changes on:\". Declaration def upload.VersionControlSystem.GetBaseFiles(self, diff) UploadBaseFiles() Uploads the base files (and if necessary, the current ones as well). Declaration def upload.VersionControlSystem.UploadBaseFiles(self, issue, rpc_server, patch_list, patchset, options, files) IsImage() Returns true if the filename has an image extension. Declaration def upload.VersionControlSystem.IsImage(self, filename) __init__() Constructor. Args: options: Command line options. Declaration def upload.VersionControlSystem.__init__(self, options) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.VersionControlSystem.GenerateDiff(self, args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.VersionControlSystem.GetUnknownFiles(self) CheckForUnknownFiles() Show an \"are you sure?\" prompt if there are unknown files. Declaration def upload.VersionControlSystem.CheckForUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.VersionControlSystem.GetBaseFile(self, filename) GetBaseFiles() Helper that calls GetBase file for each file in the patch. Returns: A dictionary that maps from filename to GetBaseFile's tuple. Filenames are retrieved based on lines that start with \"Index:\" or \"Property changes on:\". Declaration def upload.VersionControlSystem.GetBaseFiles(self, diff) UploadBaseFiles() Uploads the base files (and if necessary, the current ones as well). Declaration def upload.VersionControlSystem.UploadBaseFiles(self, issue, rpc_server, patch_list, patchset, options, files) IsImage() Returns true if the filename has an image extension. Declaration def upload.VersionControlSystem.IsImage(self, filename) __init__() Constructor. Args: options: Command line options. Declaration def upload.VersionControlSystem.__init__(self, options) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.VersionControlSystem.GenerateDiff(self, args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.VersionControlSystem.GetUnknownFiles(self) CheckForUnknownFiles() Show an \"are you sure?\" prompt if there are unknown files. Declaration def upload.VersionControlSystem.CheckForUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.VersionControlSystem.GetBaseFile(self, filename) GetBaseFiles() Helper that calls GetBase file for each file in the patch. Returns: A dictionary that maps from filename to GetBaseFile's tuple. Filenames are retrieved based on lines that start with \"Index:\" or \"Property changes on:\". Declaration def upload.VersionControlSystem.GetBaseFiles(self, diff) UploadBaseFiles() Uploads the base files (and if necessary, the current ones as well). Declaration def upload.VersionControlSystem.UploadBaseFiles(self, issue, rpc_server, patch_list, patchset, options, files) IsImage() Returns true if the filename has an image extension. Declaration def upload.VersionControlSystem.IsImage(self, filename) __init__() Constructor. Args: options: Command line options. Declaration def upload.VersionControlSystem.__init__(self, options) GenerateDiff() Return the current diff as a string. Args: args: Extra arguments to pass to the diff command. Declaration def upload.VersionControlSystem.GenerateDiff(self, args) GetUnknownFiles() Return a list of files unknown to the VCS. Declaration def upload.VersionControlSystem.GetUnknownFiles(self) CheckForUnknownFiles() Show an \"are you sure?\" prompt if there are unknown files. Declaration def upload.VersionControlSystem.CheckForUnknownFiles(self) GetBaseFile() Get the content of the upstream version of a file. Returns: A tuple (base_content, new_content, is_binary, status) base_content: The contents of the base file. new_content: For text files, this is empty. For binary files, this is the contents of the new file, since the diff output won't contain information to reconstruct the current file. is_binary: True iff the file is binary. status: The status of the file. Declaration def upload.VersionControlSystem.GetBaseFile(self, filename) GetBaseFiles() Helper that calls GetBase file for each file in the patch. Returns: A dictionary that maps from filename to GetBaseFile's tuple. Filenames are retrieved based on lines that start with \"Index:\" or \"Property changes on:\". Declaration def upload.VersionControlSystem.GetBaseFiles(self, diff) UploadBaseFiles() Uploads the base files (and if necessary, the current ones as well). Declaration def upload.VersionControlSystem.UploadBaseFiles(self, issue, rpc_server, patch_list, patchset, options, files) IsImage() Returns true if the filename has an image extension. Declaration def upload.VersionControlSystem.IsImage(self, filename)"
  },
  "api/utf16-be.html": {
    "href": "api/utf16-be.html",
    "title": "Struct UTF16BE | qiotoolkit",
    "keywords": "Struct UTF16BE UTF-16 big endian encoding. Inherited Members RAPIDJSON_STATIC_ASSERT Decode Validate Encode EncodeUnsafe Methods TakeBOM() Declaration static CharType UTF16BE<CharType>::TakeBOM(InputByteStream&is) Take() Declaration static CharType UTF16BE<CharType>::Take(InputByteStream&is) PutBOM() Declaration static void UTF16BE<CharType>::PutBOM(OutputByteStream&os) Put() Declaration static void UTF16BE<CharType>::Put(OutputByteStream&os, CharType c)"
  },
  "api/utf16-le.html": {
    "href": "api/utf16-le.html",
    "title": "Struct UTF16LE | qiotoolkit",
    "keywords": "Struct UTF16LE UTF-16 little endian encoding. Inherited Members RAPIDJSON_STATIC_ASSERT Decode Validate Encode EncodeUnsafe Methods TakeBOM() Declaration static CharType UTF16LE<CharType>::TakeBOM(InputByteStream&is) Take() Declaration static CharType UTF16LE<CharType>::Take(InputByteStream&is) PutBOM() Declaration static void UTF16LE<CharType>::PutBOM(OutputByteStream&os) Put() Declaration static void UTF16LE<CharType>::Put(OutputByteStream&os, CharType c)"
  },
  "api/utf16.html": {
    "href": "api/utf16.html",
    "title": "Struct UTF16 | qiotoolkit",
    "keywords": "Struct UTF16 UTF-16 encoding. http://en.wikipedia.org/wiki/UTF-16 http://tools.ietf.org/html/rfc2781 CharType Type for storing 16-bit UTF-16 data. Default is wchar_t. C++11 may use char16_t instead. implements Encoding concept For in-memory access, no need to concern endianness. The code units and code points are represented by CPU's endianness. For streaming, use UTF16LE and UTF16BE, which handle endianness. Methods RAPIDJSON_STATIC_ASSERT() Declaration UTF16<CharType>::RAPIDJSON_STATIC_ASSERT(sizeof(Ch)>=2) Encode() Declaration static void UTF16<CharType>::Encode(OutputStream&os, unsigned codepoint) EncodeUnsafe() Declaration static void UTF16<CharType>::EncodeUnsafe(OutputStream&os, unsigned codepoint) Decode() Declaration static bool UTF16<CharType>::Decode(InputStream&is, unsigned *codepoint) Validate() Declaration static bool UTF16<CharType>::Validate(InputStream&is, OutputStream&os)"
  },
  "api/utf32-be.html": {
    "href": "api/utf32-be.html",
    "title": "Struct UTF32BE | qiotoolkit",
    "keywords": "Struct UTF32BE UTF-32 big endian encoding. Inherited Members Encode Decode Validate RAPIDJSON_STATIC_ASSERT EncodeUnsafe Methods TakeBOM() Declaration static CharType UTF32BE<CharType>::TakeBOM(InputByteStream&is) Take() Declaration static CharType UTF32BE<CharType>::Take(InputByteStream&is) PutBOM() Declaration static void UTF32BE<CharType>::PutBOM(OutputByteStream&os) Put() Declaration static void UTF32BE<CharType>::Put(OutputByteStream&os, CharType c)"
  },
  "api/utf32-le.html": {
    "href": "api/utf32-le.html",
    "title": "Struct UTF32LE | qiotoolkit",
    "keywords": "Struct UTF32LE UTF-32 little endian enocoding. Inherited Members Encode Decode Validate RAPIDJSON_STATIC_ASSERT EncodeUnsafe Methods TakeBOM() Declaration static CharType UTF32LE<CharType>::TakeBOM(InputByteStream&is) Take() Declaration static CharType UTF32LE<CharType>::Take(InputByteStream&is) PutBOM() Declaration static void UTF32LE<CharType>::PutBOM(OutputByteStream&os) Put() Declaration static void UTF32LE<CharType>::Put(OutputByteStream&os, CharType c)"
  },
  "api/utf32.html": {
    "href": "api/utf32.html",
    "title": "Struct UTF32 | qiotoolkit",
    "keywords": "Struct UTF32 UTF-32 encoding. http://en.wikipedia.org/wiki/UTF-32 CharType Type for storing 32-bit UTF-32 data. Default is unsigned. C++11 may use char32_t instead. implements Encoding concept For in-memory access, no need to concern endianness. The code units and code points are represented by CPU's endianness. For streaming, use UTF32LE and UTF32BE, which handle endianness. Methods RAPIDJSON_STATIC_ASSERT() Declaration UTF32<CharType>::RAPIDJSON_STATIC_ASSERT(sizeof(Ch)>=4) Encode() Declaration static void UTF32<CharType>::Encode(OutputStream&os, unsigned codepoint) EncodeUnsafe() Declaration static void UTF32<CharType>::EncodeUnsafe(OutputStream&os, unsigned codepoint) Decode() Declaration static bool UTF32<CharType>::Decode(InputStream&is, unsigned *codepoint) Validate() Declaration static bool UTF32<CharType>::Validate(InputStream&is, OutputStream&os)"
  },
  "api/utf8.html": {
    "href": "api/utf8.html",
    "title": "Struct UTF8 | qiotoolkit",
    "keywords": "Struct UTF8 UTF-8 encoding. http://en.wikipedia.org/wiki/UTF-8 http://tools.ietf.org/html/rfc3629 CharType Code unit for storing 8-bit UTF-8 data. Default is char. implements Encoding concept Methods Encode() Declaration static void UTF8<CharType>::Encode(OutputStream&os, unsigned codepoint) EncodeUnsafe() Declaration static void UTF8<CharType>::EncodeUnsafe(OutputStream&os, unsigned codepoint) Decode() Declaration static bool UTF8<CharType>::Decode(InputStream&is, unsigned *codepoint) Validate() Declaration static bool UTF8<CharType>::Validate(InputStream&is, OutputStream&os) GetRange() Declaration static unsigned char UTF8<CharType>::GetRange(unsigned char c) TakeBOM() Declaration static CharType UTF8<CharType>::TakeBOM(InputByteStream&is) Take() Declaration static Ch UTF8<CharType>::Take(InputByteStream&is) PutBOM() Declaration static void UTF8<CharType>::PutBOM(OutputByteStream&os) Put() Declaration static void UTF8<CharType>::Put(OutputByteStream&os, Ch c)"
  },
  "api/utils/any-key-object-member-stream-handler.html": {
    "href": "api/utils/any-key-object-member-stream-handler.html",
    "title": "Class utils::AnyKeyObjectMemberStreamHandler | qiotoolkit",
    "keywords": "Class utils::AnyKeyObjectMemberStreamHandler AnyKeyMemberStreamHandler. Stream handler for handling extra fields, which are not to be used for configure. These fields could have any key value. Inheritance utils::BaseStreamHandler utils::AnyKeyObjectMemberStreamHandler Inherited Members complete started failed reset error_message error_code BaseStreamHandler Constructors AnyKeyObjectMemberStreamHandler() Declaration utils::AnyKeyObjectMemberStreamHandler<OuterClass>::AnyKeyObjectMemberStreamHandler() Methods Key() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::Key(const std::string&key) Value() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::Value(SignalType signal_value, OuterClass&) StartObject() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::StartObject() EndObject() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::EndObject(size_t elementCount, OuterClass&) StartArray() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::StartArray() EndArray() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::EndArray(size_t elementCount, OuterClass&) complete() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::complete() const reset() Declaration void utils::AnyKeyObjectMemberStreamHandler<OuterClass>::reset(OuterClass&) fail_at_missing_inputs() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::fail_at_missing_inputs() missing_inputs() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::missing_inputs() started() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::started() const fail() Declaration bool utils::AnyKeyObjectMemberStreamHandler<OuterClass>::fail(const std::string&meassage=\"parsing error\", Error error_code=Error::ParsingError)"
  },
  "api/utils/base-stream-handler.html": {
    "href": "api/utils/base-stream-handler.html",
    "title": "Class utils::BaseStreamHandler | qiotoolkit",
    "keywords": "Class utils::BaseStreamHandler Classes for implementation of handlers, which consume the events (via function calls) from the steam readers. These handles configure objects directly from events information. The reader publishes events to the handler sequentially. Example: for JSON string { \"c\" = 2.0 } the following events will be called: StartObject(), Key(\"c\"), Double(2), EndObject(1) from which object of type class { double c; } will be configured. BaseStreamHandler This is a base class for stream handlers. It has default failure handling implementation for unexpected events due to incorrect format of data. Boolean result of operations indicates that parsing can continue. Inheritance utils::BaseStreamHandler utils::BasicTypeStreamHandler utils::ObserverStreamHandler Constructors BaseStreamHandler() Declaration utils::BaseStreamHandler<T>::BaseStreamHandler() Methods Value() Declaration bool utils::BaseStreamHandler<T>::Value(SignalType, T&) StartObject() Declaration bool utils::BaseStreamHandler<T>::StartObject() Key() Declaration bool utils::BaseStreamHandler<T>::Key(const std::string&) EndObject() Declaration bool utils::BaseStreamHandler<T>::EndObject(size_t, T&) StartArray() Declaration bool utils::BaseStreamHandler<T>::StartArray() EndArray() Declaration bool utils::BaseStreamHandler<T>::EndArray(size_t, T&) reset() Declaration void utils::BaseStreamHandler<T>::reset() reset() Declaration void utils::BaseStreamHandler<T>::reset(T&) started() Declaration bool utils::BaseStreamHandler<T>::started() const complete() Declaration bool utils::BaseStreamHandler<T>::complete() const missing_inputs() Declaration bool utils::BaseStreamHandler<T>::missing_inputs() const fail_at_missing_inputs() Declaration bool utils::BaseStreamHandler<T>::fail_at_missing_inputs() const failed() Declaration bool utils::BaseStreamHandler<T>::failed() const error_code() Declaration Error utils::BaseStreamHandler<T>::error_code() const error_message() Declaration std::string utils::BaseStreamHandler<T>::error_message() const fail() Declaration bool utils::BaseStreamHandler<T>::fail(const std::string&meassage=\"parsing error\", Error error_code=Error::ParsingError)"
  },
  "api/utils/basic-type-stream-handler.html": {
    "href": "api/utils/basic-type-stream-handler.html",
    "title": "Class utils::BasicTypeStreamHandler | qiotoolkit",
    "keywords": "Class utils::BasicTypeStreamHandler BasicTypeStreamHandler<..> Particular implementations of stream handlers for values of simple, non class, types like int, double, string... Inheritance utils::BaseStreamHandler utils::BasicTypeStreamHandler Inherited Members StartObject StartArray complete started fail_at_missing_inputs Key missing_inputs EndArray failed reset error_message EndObject Value reset error_code BaseStreamHandler fail"
  },
  "api/utils/basic-type-stream-handler/3/01bool/01/4.html": {
    "href": "api/utils/basic-type-stream-handler/3/01bool/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance utils::BaseStreamHandler > Inherited Members StartObject StartArray complete started fail_at_missing_inputs Key missing_inputs EndArray failed reset error_message EndObject reset error_code BaseStreamHandler fail Methods Value() Declaration bool utils::BasicTypeStreamHandler<bool>::Value(SignalType signal_val, bool&) Value() Declaration bool utils::BasicTypeStreamHandler<bool>::Value(bool b, bool&val)"
  },
  "api/utils/basic-type-stream-handler/3/01double/01/4.html": {
    "href": "api/utils/basic-type-stream-handler/3/01double/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance utils::BaseStreamHandler > Inherited Members StartObject StartArray complete started fail_at_missing_inputs Key missing_inputs EndArray failed reset error_message EndObject reset error_code BaseStreamHandler fail Methods Value() Declaration bool utils::BasicTypeStreamHandler<double>::Value(SignalType signal_val, double&) Value() Declaration bool utils::BasicTypeStreamHandler<double>::Value(int64_t i, double&val) Value() Declaration bool utils::BasicTypeStreamHandler<double>::Value(double d, double&val)"
  },
  "api/utils/basic-type-stream-handler/3/01int/01/4.html": {
    "href": "api/utils/basic-type-stream-handler/3/01int/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance utils::BaseStreamHandler > Inherited Members StartObject StartArray complete started fail_at_missing_inputs Key missing_inputs EndArray failed reset error_message EndObject reset error_code BaseStreamHandler fail Methods Value() Declaration bool utils::BasicTypeStreamHandler<int>::Value(SignalType signal_val, int&) Value() Declaration bool utils::BasicTypeStreamHandler<int>::Value(int64_t i, int&val)"
  },
  "api/utils/basic-type-stream-handler/3/01size/t/01/4.html": {
    "href": "api/utils/basic-type-stream-handler/3/01size/t/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance utils::BaseStreamHandler > Inherited Members StartObject StartArray complete started fail_at_missing_inputs Key missing_inputs EndArray failed reset error_message EndObject reset error_code BaseStreamHandler fail Methods Value() Declaration bool utils::BasicTypeStreamHandler<size_t>::Value(SignalType signal_val, size_t&) Value() Declaration bool utils::BasicTypeStreamHandler<size_t>::Value(int64_t i, size_t&val)"
  },
  "api/utils/basic-type-stream-handler/3/01std/string/01/4.html": {
    "href": "api/utils/basic-type-stream-handler/3/01std/string/01/4.html",
    "title": "Class > | qiotoolkit",
    "keywords": "Class > Inheritance utils::BaseStreamHandler > Inherited Members StartObject StartArray complete started fail_at_missing_inputs Key missing_inputs EndArray failed reset error_message EndObject reset error_code BaseStreamHandler fail Methods Value() Declaration bool utils::BasicTypeStreamHandler<std::string>::Value(SignalType signal_val, std::string&) Value() Declaration bool utils::BasicTypeStreamHandler<std::string>::Value(std::string str, std::string&val)"
  },
  "api/utils/bit-stream-visitor.html": {
    "href": "api/utils/bit-stream-visitor.html",
    "title": "Class utils::BitStreamVisitor | qiotoolkit",
    "keywords": "Class utils::BitStreamVisitor Class to keep the position information about data to be read/write in BitStream. Inheritance utils::BitStreamVisitor Constructors BitStreamVisitor() Declaration utils::BitStreamVisitor::BitStreamVisitor() Methods reset() Declaration void utils::BitStreamVisitor::reset(uint64_t value)"
  },
  "api/utils/bit-stream.html": {
    "href": "api/utils/bit-stream.html",
    "title": "Class utils::BitStream | qiotoolkit",
    "keywords": "Class utils::BitStream BitStream is used for saving data in a compact format, data are saved in fix sized bits continuouly. To read and write data to and from BitStream, a BitStreamVisitor is required. Currently one sequentially visiting is supported, unless you know how to manually modify position information inside BitStreamVisitor. Inheritance utils::BitStream Constructors BitStream() Declaration utils::BitStream::BitStream() Methods init() Declaration void utils::BitStream::init(size_t num_units, uint32_t unit_bits) read_next() Declaration uint64_t utils::BitStream::read_next(BitStreamVisitor&visitor) const write_next() Declaration void utils::BitStream::write_next(uint64_t value, BitStreamVisitor&visitor) init_reader() Declaration void utils::BitStream::init_reader(BitStreamVisitor&visitor) const update() Declaration void utils::BitStream::update(BitStreamVisitor&position)"
  },
  "api/utils/component-with-output.html": {
    "href": "api/utils/component-with-output.html",
    "title": "Class utils::ComponentWithOutput | qiotoolkit",
    "keywords": "Class utils::ComponentWithOutput Inheritance utils::Component utils::ComponentWithOutput observe::Observer Inherited Members configure render ~Component Component get_status get_class_name Methods param() Assign a parameter from a json field. Declaration ParameterBuilder<utils::ComponentWithOutput, T>utils::ComponentWithOutput::param(const utils::Json&json, const std::string&name, T&parameter) set_output_parameter() Store a key, value pair in the output_parameters (to be returned to the user). Declaration void utils::ComponentWithOutput::set_output_parameter(const std::string&key, const T&value) set_output_parameter() Store the value of an optional in the output_parameters if it is set. Declaration void utils::ComponentWithOutput::set_output_parameter(const std::string&key, const std::optional<T>&value) get_output_parameters() Get a structure containing all output_parameters. Declaration virtual utils::Structure utils::ComponentWithOutput::get_output_parameters() const"
  },
  "api/utils/component.html": {
    "href": "api/utils/component.html",
    "title": "Class utils::Component | qiotoolkit",
    "keywords": "Class utils::Component Component base class. The component base class provides quality-of-life functionality for any class derived from it: It can be initialized from json via its configure() method It is rendered in \"structured\" form via render() when assigned to an utils::Structure. Its class name is accessible via get_class_name() When passed to an ostream (or LOG), it is represented as '<ClassName: status>' where the status is given by get_status() While get_class_name() works out-of-the-box, the appropriate functionality must be implemented by overloading the others accordingly. Inheritance utils::Component graph::CompactGraph graph::Edge graph::Face graph::Graph graph::Node markov::ClusterWalker markov::State markov::Transition markov::Walker model::BaseModel model::Terms model::Terms::Term model::Terms::Variable observe::Observable observe::Windowed::ValueAndWeight schedule::Schedule schedule::ScheduleGenerator solver::EvaluationCounter solver::Population strategy::BaseOpt strategy::GDParameters utils::ComponentWithOutput utils::Dimacs::Clause utils::Range Constructors Component() Declaration utils::Component::Component() Methods ~Component() Declaration virtual utils::Component::~Component() configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void utils::Component::configure(const utils::Json&json) param() Assign a parameter from a json field. Declaration ParameterBuilder<utils::Component, T>utils::Component::param(const utils::Json&json, const std::string&name, T&parameter) render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration utils::Structure utils::Component::render() const get_status() get_status shows a simplified state representation Like render, this produces a structured representation of the object's state. However, it is intended to be simpler in nature with the purpose of rendering the object during stream-output and logging. By default, it will fall back to the full render, but overloading this allows distinguising how the object looks during LOG vs full output. Declaration utils::Structure utils::Component::get_status() const get_class_name() get_class_name shows an identifier of the (derived) class name Its primary use is for type identification during stream output and logging, where a component is rendered as <ClassName: status>. Example: {c++} MyClass : public Component {} // This will render as '<MyClass>' MyClass my_object; std::cout << my_object << std::endl; Note You do not need to overload this method unless you want to change the output of the default implementation. Declaration std::string utils::Component::get_class_name() const"
  },
  "api/utils/configuration-error.html": {
    "href": "api/utils/configuration-error.html",
    "title": "Class utils::ConfigurationError | qiotoolkit",
    "keywords": "Class utils::ConfigurationError Inheritance utils::ConfigurationException utils::ConfigurationError Inherited Members get_error_code get_error_code_message get_error_message ConfigurationException Constructors ConfigurationError() Declaration utils::ConfigurationError<err>::ConfigurationError(std::string message)"
  },
  "api/utils/configuration-exception.html": {
    "href": "api/utils/configuration-exception.html",
    "title": "Class utils::ConfigurationException | qiotoolkit",
    "keywords": "Class utils::ConfigurationException ConfigurationException. A configuration exception is thrown when the input configuration is not valid (either syntactically or according to the requirements of the components which need to be configured). Inheritance utils::ConfigurationException utils::ConfigurationError Constructors ConfigurationException() Declaration utils::ConfigurationException::ConfigurationException(std::string message, Error error_code) Methods get_error_message() Declaration std::string utils::ConfigurationException::get_error_message() const get_error_code_message() Declaration std::string utils::ConfigurationException::get_error_code_message() const get_error_code() Declaration Error utils::ConfigurationException::get_error_code() const"
  },
  "api/utils/dimacs.html": {
    "href": "api/utils/dimacs.html",
    "title": "Class utils::Dimacs | qiotoolkit",
    "keywords": "Class utils::Dimacs Handler for the DIMACS format. Inheritance utils::Dimacs Constructors Dimacs() Constructor: Create an empty Dimacs handler. Declaration utils::Dimacs::Dimacs() Methods read() Parse a string in dimacs format. Declaration void utils::Dimacs::read(const std::string&content) read_file() Read the contents from filename and parse them. Declaration void utils::Dimacs::read_file(const std::string&filename) get_type() Get the type of the parsed problem ('cnf' or 'wcnf') (or empty string if nothing was parsed). Declaration std::string utils::Dimacs::get_type() const get_nvar() Get the number of variables in the problem. Declaration size_t utils::Dimacs::get_nvar() const get_ncl() Get the number of clauses in the problem. Declaration size_t utils::Dimacs::get_ncl() const get_top() Get the value specified as top (minimum weight for a clause to be 'hard') in the input (return 0 if not specified). [!NOTE]: Only type type='wcnfallowstop as an optional 5th element in the problem description line (starting with a 'p). Declaration double utils::Dimacs::get_top() const get_variables() Get the list of variables actually encountered in the description. These are all in their positive (non-negated) form, but they don't need to form a contiguous set of numbers. Declaration const std::vector<int>&utils::Dimacs::get_variables() const get_clauses() Get the list of clauses parsed. Declaration const std::vector<Dimacs::Clause>&utils::Dimacs::get_clauses() const clear() Return the Dimacs parser to its initial state. Declaration void utils::Dimacs::clear() parse() Parse the string pointed to by content_ Declaration void utils::Dimacs::parse() ignore_line() Ignore a full line from the current position p_ Declaration void utils::Dimacs::ignore_line() parse_problem() Parse a problem description line. Declaration void utils::Dimacs::parse_problem() parse_clause() Parse a clause (terminated by 0) Declaration void utils::Dimacs::parse_clause() expect() Check that the next characters are equivalent to s and advance the position p_ past them. Declaration void utils::Dimacs::expect(const std::string&s) to_next_ws() Count the number of characters to the next whitespace. Declaration size_t utils::Dimacs::to_next_ws() read_string() Read the set of characters to the next whitespace and store them in target. Declaration void utils::Dimacs::read_string(std::string *target) read_number() Parse the characters up to the next whitespace as an integer. Declaration void utils::Dimacs::read_number(int *target) read_number() Parse the characters up to the next whitespace as a double. Declaration void utils::Dimacs::read_number(double *target) read_positive_number() Parse the characters up to the next whitespace as an integer and ensure that the number is greater than 0. Declaration void utils::Dimacs::read_positive_number(uint32_t *target) eat_whitespace() Ignore all whitespace from the current position. Declaration void utils::Dimacs::eat_whitespace() on_line() Return a string describing the current line being parsed. Declaration std::string utils::Dimacs::on_line() const at_position() Return a string describing the current line and column (adding offset to the current column). [!NOTE] This does not fix the line if col+offset is on a different line; it is meant solely to get correct positioning after a number has been read successfully but does not meet conditions. Declaration std::string utils::Dimacs::at_position(int offset=0) const"
  },
  "api/utils/dimacs/clause.html": {
    "href": "api/utils/dimacs/clause.html",
    "title": "Class utils::Dimacs::Clause | qiotoolkit",
    "keywords": "Class utils::Dimacs::Clause Representation of a satisfiability clause For unweighted satisfiability problems, the weight will always be 1. Inheritance utils::Component utils::Dimacs::Clause Inherited Members render ~Component Component get_status param get_class_name Methods configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void utils::Dimacs::Clause::configure(const utils::Json&json) check_variable_names() Declaration void utils::Dimacs::Clause::check_variable_names()"
  },
  "api/utils/dimacs/clause/get/variables.html": {
    "href": "api/utils/dimacs/clause/get/variables.html",
    "title": "Struct utils::Dimacs::Clause::Get_Variables | qiotoolkit",
    "keywords": "Struct utils::Dimacs::Clause::Get_Variables Methods get() Declaration static std::vector<int>&utils::Dimacs::Clause::Get_Variables::get(Clause&config) get_key() Declaration static std::string utils::Dimacs::Clause::Get_Variables::get_key()"
  },
  "api/utils/dimacs/clause/get/weight.html": {
    "href": "api/utils/dimacs/clause/get/weight.html",
    "title": "Struct utils::Dimacs::Clause::Get_Weight | qiotoolkit",
    "keywords": "Struct utils::Dimacs::Clause::Get_Weight Methods get() Declaration static double&utils::Dimacs::Clause::Get_Weight::get(Clause&config) get_key() Declaration static std::string utils::Dimacs::Clause::Get_Weight::get_key()"
  },
  "api/utils/enum-stream-handler.html": {
    "href": "api/utils/enum-stream-handler.html",
    "title": "Class utils::EnumStreamHandler | qiotoolkit",
    "keywords": "Class utils::EnumStreamHandler EnumStreamHandler. Implementations of stream handlers for enum expressed as fixed string values Inheritance utils::BaseStreamHandler utils::EnumStreamHandler Inherited Members StartObject StartArray complete started fail_at_missing_inputs Key missing_inputs EndArray failed reset error_message EndObject reset error_code BaseStreamHandler fail Methods Value() Declaration bool utils::EnumStreamHandler<EnumType, StringEnumMap>::Value(SignalType signal_val, EnumType&) Value() Declaration bool utils::EnumStreamHandler<EnumType, StringEnumMap>::Value(std::string str, EnumType&val)"
  },
  "api/utils/feature-configs.html": {
    "href": "api/utils/feature-configs.html",
    "title": "Class utils::FeatureConfigs | qiotoolkit",
    "keywords": "Class utils::FeatureConfigs Inheritance utils::FeatureConfigs Constructors FeatureConfigs() Declaration utils::FeatureConfigs::FeatureConfigs() Methods set_disabled_feature() Declaration void utils::FeatureConfigs::set_disabled_feature(int feature_id) set_enabled_feature() Declaration void utils::FeatureConfigs::set_enabled_feature(int feature_id) feature_disabled() Declaration bool utils::FeatureConfigs::feature_disabled(int feature_id) feature_enabled() Declaration bool utils::FeatureConfigs::feature_enabled(int feature_id)"
  },
  "api/utils/file.html": {
    "href": "api/utils/file.html",
    "title": "Class utils::File | qiotoolkit",
    "keywords": "Class utils::File File Wrapper for using FILE* exception safe way. Inheritance utils::File Constructors File() Declaration utils::File::File() File() Declaration utils::File::File(const std::string&file_name, const std::string&mode) Methods open() Declaration void utils::File::open(const std::string&file_name, const std::string&mode) get() Declaration FILE* utils::File::get() ~File() Declaration utils::File::~File()"
  },
  "api/utils/final-object-member-stream-handler.html": {
    "href": "api/utils/final-object-member-stream-handler.html",
    "title": "Class utils::FinalObjectMemberStreamHandler | qiotoolkit",
    "keywords": "Class utils::FinalObjectMemberStreamHandler Stream handler for object is implemented as nested classes of key value and utility stream handlers: ObjectStreamHandler< ObjectMemberStreamHandler<.., ObjectMemberStreamHandler<.., FinalObjectMemberStreamHandler Each ObjectMemberStreamHandler represents key value entry of object. FinalObjectMemberStreamHandler is the last one in the chain. FinalObjectMemberStreamHandler FinalObjectMemberStreamHandler is the last one in the members stream chain. It is used to simplify ObjectMemberStreamHandler logic. Inheritance utils::BaseStreamHandler utils::FinalObjectMemberStreamHandler utils::ObjectMemberStreamHandler Inherited Members StartObject StartArray complete started Key EndArray failed reset error_message EndObject Value reset error_code BaseStreamHandler fail Methods complete() Declaration bool utils::FinalObjectMemberStreamHandler<OuterClass>::complete() const started() Declaration bool utils::FinalObjectMemberStreamHandler<OuterClass>::started() const fail_at_missing_inputs() Declaration bool utils::FinalObjectMemberStreamHandler<OuterClass>::fail_at_missing_inputs() missing_inputs() Declaration bool utils::FinalObjectMemberStreamHandler<OuterClass>::missing_inputs()"
  },
  "api/utils/index.html": {
    "href": "api/utils/index.html",
    "title": "| qiotoolkit",
    "keywords": ""
  },
  "api/utils/jsonhandler-proxy.html": {
    "href": "api/utils/jsonhandler-proxy.html",
    "title": "Class utils::JSONHandlerProxy | qiotoolkit",
    "keywords": "Class utils::JSONHandlerProxy JSONHandlerProxy. Convert and redirect JSON reader signals into qiotoolkit handler. Inheritance utils::JSONHandlerProxy Constructors JSONHandlerProxy() Declaration utils::JSONHandlerProxy<StreamHandler>::JSONHandlerProxy() Methods Null() Declaration bool utils::JSONHandlerProxy<StreamHandler>::Null() Bool() Declaration bool utils::JSONHandlerProxy<StreamHandler>::Bool(bool b) Int() Declaration bool utils::JSONHandlerProxy<StreamHandler>::Int(int i) Uint() Declaration bool utils::JSONHandlerProxy<StreamHandler>::Uint(unsigned i) Int64() Declaration bool utils::JSONHandlerProxy<StreamHandler>::Int64(int64_t i) Uint64() Declaration bool utils::JSONHandlerProxy<StreamHandler>::Uint64(uint64_t i) Double() Declaration bool utils::JSONHandlerProxy<StreamHandler>::Double(double d) RawNumber() Declaration bool utils::JSONHandlerProxy<StreamHandler>::RawNumber(const char *, int, bool) String() Declaration bool utils::JSONHandlerProxy<StreamHandler>::String(const char *str, int len, bool) StartObject() Declaration bool utils::JSONHandlerProxy<StreamHandler>::StartObject() Key() Declaration bool utils::JSONHandlerProxy<StreamHandler>::Key(const char *str, int len, bool) EndObject() Declaration bool utils::JSONHandlerProxy<StreamHandler>::EndObject(int elementCount) StartArray() Declaration bool utils::JSONHandlerProxy<StreamHandler>::StartArray() EndArray() Declaration bool utils::JSONHandlerProxy<StreamHandler>::EndArray(int elementCount) get_value() Declaration StreamHandler::Type_T&utils::JSONHandlerProxy<StreamHandler>::get_value() complete() Declaration bool utils::JSONHandlerProxy<StreamHandler>::complete() error_code() Declaration Error utils::JSONHandlerProxy<StreamHandler>::error_code() const error_message() Declaration std::string utils::JSONHandlerProxy<StreamHandler>::error_message() const fail() Declaration bool utils::JSONHandlerProxy<StreamHandler>::fail() const"
  },
  "api/utils/logger.html": {
    "href": "api/utils/logger.html",
    "title": "Class utils::Logger | qiotoolkit",
    "keywords": "Class utils::Logger Logging facilities. Apart from adjusting logging attributes (level, color, output stream), users should use the LOG(LEVEL, ...) macro to produce log output. The macro takes care of including the source context of where information was logged, while passing the content to Logger::log. Inheritance utils::Logger Methods log() Log information to the Logger Declaration static void utils::Logger::log(LogLevel level, Context context, const Args&... args) debug() Declaration static void utils::Logger::debug(Context context, Args... args) set_level() Set the global log level (minimum level for logs to appear) Declaration static void utils::Logger::set_level(LogLevel level) is_default_level() Whether the level is still the default value for that build (used to decide whether to override from input). Declaration static bool utils::Logger::is_default_level() set_level() Set the global log level from string (minimum level for logs to appear) Declaration bool utils::Logger::set_level(std::string str_level) get_level() Get the currently set log level. Declaration static LogLevel utils::Logger::get_level() to_string() Turn a log level into its string representation. Declaration std::string utils::Logger::to_string(LogLevel level) set_color() Set whether logging should use ansi colors. Declaration static void utils::Logger::set_color(bool color) set_stream() Set where logging should be streamed to (default=std::cerr) Declaration static void utils::Logger::set_stream(std::ostream *stream) get_stream() Declaration static std::ostream&utils::Logger::get_stream() use_color() Declaration static bool utils::Logger::use_color() color() Declaration std::string utils::Logger::color(LogLevel level) context_color() Declaration std::string utils::Logger::context_color() normal_color() Declaration std::string utils::Logger::normal_color() get_prefix() Return the prefix that should be at the beginning of each log. Declaration std::string utils::Logger::get_prefix(LogLevel level, const Context&context) get_debug_prefix() Return the prefix that should be at the beginning of each debug output. Declaration std::string utils::Logger::get_debug_prefix(const Context&context) should_log() Decide whether a given call should pass to the output. Declaration bool utils::Logger::should_log(LogLevel level, const Context&_)"
  },
  "api/utils/logger/context.html": {
    "href": "api/utils/logger/context.html",
    "title": "Class utils::Logger::Context | qiotoolkit",
    "keywords": "Class utils::Logger::Context Store the (code) context of where a LOG was invoked (file, line, function). Inheritance utils::Logger::Context Constructors Context() Declaration utils::Logger::Context::Context(const std::string&file, int line, const std::string&function) Methods get_line() Return the source line where the LOG was made. Declaration int utils::Logger::Context::get_line() const get_file() Return the source file path where the LOG was made. Declaration const std::string&utils::Logger::Context::get_file() const get_function() Return the function or method within which the LOG was made. Declaration const std::string&utils::Logger::Context::get_function() const demangle() Translate gcc mangled function name to human-readable form. Declaration std::string utils::Logger::Context::demangle(const char *name)"
  },
  "api/utils/memory-usage-log.html": {
    "href": "api/utils/memory-usage-log.html",
    "title": "Class utils::MemoryUsageLog | qiotoolkit",
    "keywords": "Class utils::MemoryUsageLog Inheritance utils::MemoryUsageLog Methods clear() Declaration void utils::MemoryUsageLog::clear() add() Declaration void utils::MemoryUsageLog::add(const std::string&checkpoint) get() Declaration const std::vector<std::pair<std::string, size_t>>&utils::MemoryUsageLog::get()"
  },
  "api/utils/object-member-stream-handler.html": {
    "href": "api/utils/object-member-stream-handler.html",
    "title": "Class utils::ObjectMemberStreamHandler | qiotoolkit",
    "keywords": "Class utils::ObjectMemberStreamHandler ObjectMemberStreamHandler. Stream handler for key value entry. GetMember::get_key() is the key of object entry. GetMember::get(val) return reference to the member it is streaming to. Inheritance utils::FinalObjectMemberStreamHandler utils::ObjectMemberStreamHandler Inherited Members complete started failed reset error_message error_code BaseStreamHandler started Methods Key() Declaration bool utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::Key(const std::string&key) Value() Declaration bool utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::Value(SignalType signal_value, OuterClass&val) StartObject() Declaration bool utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::StartObject() EndObject() Declaration bool utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::EndObject(size_t elementCount, OuterClass&val) StartArray() Declaration bool utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::StartArray() EndArray() Declaration bool utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::EndArray(size_t elementCount, OuterClass&val) complete() Declaration bool utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::complete() const reset() Declaration void utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::reset(OuterClass&val) fail_at_missing_inputs() Declaration bool utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::fail_at_missing_inputs() missing_inputs() Declaration bool utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::missing_inputs() fail() Declaration bool utils::ObjectMemberStreamHandler<StreamHandler, OuterClass, GetMember, required_, NextObjectMemberStreamHandler>::fail(const std::string&meassage=\"parsing error\", Error error_code=Error::ParsingError)"
  },
  "api/utils/object-stream-handler.html": {
    "href": "api/utils/object-stream-handler.html",
    "title": "Class utils::ObjectStreamHandler | qiotoolkit",
    "keywords": "Class utils::ObjectStreamHandler ObjectStreamHandler. Stream handler for object. .stop_early_ - stop streaming when all required parameters are loaded, to skip streaming of large members. Inheritance utils::ObjectStreamHandler Methods Key() Declaration bool utils::ObjectStreamHandler<MemberStreamHandler, stop_early_, Out_Type>::Key(const std::string&key) StartObject() Declaration bool utils::ObjectStreamHandler<MemberStreamHandler, stop_early_, Out_Type>::StartObject() EndObject() Declaration bool utils::ObjectStreamHandler<MemberStreamHandler, stop_early_, Out_Type>::EndObject(size_t elementCount, typename MemberStreamHandler::Out_Type_T&val) complete() Declaration bool utils::ObjectStreamHandler<MemberStreamHandler, stop_early_, Out_Type>::complete() const started() Declaration bool utils::ObjectStreamHandler<MemberStreamHandler, stop_early_, Out_Type>::started() const reset() Declaration void utils::ObjectStreamHandler<MemberStreamHandler, stop_early_, Out_Type>::reset(Type_T&val)"
  },
  "api/utils/observer-stream-handler.html": {
    "href": "api/utils/observer-stream-handler.html",
    "title": "Class utils::ObserverStreamHandler | qiotoolkit",
    "keywords": "Class utils::ObserverStreamHandler ObserverStreamHandler. This is a stream handler for skipping to load corresponding member, used for configure passes when only part of information is needed. Inheritance utils::BaseStreamHandler utils::ObserverStreamHandler Inherited Members complete fail_at_missing_inputs missing_inputs failed reset error_message error_code BaseStreamHandler fail Constructors ObserverStreamHandler() Declaration utils::ObserverStreamHandler<T>::ObserverStreamHandler() Methods Key() Declaration bool utils::ObserverStreamHandler<T>::Key(const std::string&) Value() Declaration bool utils::ObserverStreamHandler<T>::Value(SignalType, T&) StartObject() Declaration bool utils::ObserverStreamHandler<T>::StartObject() EndObject() Declaration bool utils::ObserverStreamHandler<T>::EndObject(size_t, T&) StartArray() Declaration bool utils::ObserverStreamHandler<T>::StartArray() EndArray() Declaration bool utils::ObserverStreamHandler<T>::EndArray(size_t, T&) reset() Declaration void utils::ObserverStreamHandler<T>::reset(T&val) started() Declaration bool utils::ObserverStreamHandler<T>::started() const state_check() Declaration bool utils::ObserverStreamHandler<T>::state_check()"
  },
  "api/utils/omp-catch.html": {
    "href": "api/utils/omp-catch.html",
    "title": "Class utils::OmpCatch | qiotoolkit",
    "keywords": "Class utils::OmpCatch Catch exceptions in parallel sections. Omp parallel sections must not leave the parallel section via exceptions This allows such exceptions to be caught and later re-thrown after the parallel section: utils::OmpCatch omp_catch; #pragma omp parallel for (int i = 0; i < N; i++) { omp_catch([=]{ // .. code which might throw }); } omp_catch.rethrow(); Inheritance utils::OmpCatch Constructors OmpCatch() Declaration utils::OmpCatch::OmpCatch() Methods ~OmpCatch() Declaration utils::OmpCatch::~OmpCatch() run() Declaration void utils::OmpCatch::run(Function f, Parameters... params) rethrow() Declaration void utils::OmpCatch::rethrow()"
  },
  "api/utils/owner-class-stream-handler.html": {
    "href": "api/utils/owner-class-stream-handler.html",
    "title": "Class utils::OwnerClassStreamHandler | qiotoolkit",
    "keywords": "Class utils::OwnerClassStreamHandler Inheritance utils::OwnerClassStreamHandler Methods Value() Declaration bool utils::OwnerClassStreamHandler<StreamHandler>::Value(SignalType signal_value) EndObject() Declaration bool utils::OwnerClassStreamHandler<StreamHandler>::EndObject(size_t elementCount) EndArray() Declaration bool utils::OwnerClassStreamHandler<StreamHandler>::EndArray(size_t sz) get_value() Declaration StreamHandler::Type_T&utils::OwnerClassStreamHandler<StreamHandler>::get_value() reset() Declaration void utils::OwnerClassStreamHandler<StreamHandler>::reset()"
  },
  "api/utils/pair-vector-stream-handler.html": {
    "href": "api/utils/pair-vector-stream-handler.html",
    "title": "Class utils::PairVectorStreamHandler | qiotoolkit",
    "keywords": "Class utils::PairVectorStreamHandler PairVectorStreamHandler. Implementations of stream handlers for set of values of simple, non class type like bool, int... Inheritance utils::BaseStreamHandler utils::PairVectorStreamHandler Inherited Members StartArray complete started fail_at_missing_inputs missing_inputs EndArray failed reset error_message error_code BaseStreamHandler Methods StartObject() Declaration bool utils::PairVectorStreamHandler<Key_T, T>::StartObject() Key() Declaration bool utils::PairVectorStreamHandler<Key_T, T>::Key(const std::string&key) Value() Declaration bool utils::PairVectorStreamHandler<Key_T, T>::Value(SignalType signal_value, Type_T&vec) EndObject() Declaration bool utils::PairVectorStreamHandler<Key_T, T>::EndObject(size_t elementCount, Type_T&vec) started() Declaration bool utils::PairVectorStreamHandler<Key_T, T>::started() const complete() Declaration bool utils::PairVectorStreamHandler<Key_T, T>::complete() const reset() Declaration void utils::PairVectorStreamHandler<Key_T, T>::reset(Type_T&vec) fail() Declaration bool utils::PairVectorStreamHandler<Key_T, T>::fail(const std::string&meassage=\"parsing error\", Error error_code=Error::ParsingError)"
  },
  "api/utils/parameter-builder.html": {
    "href": "api/utils/parameter-builder.html",
    "title": "Class utils::ParameterBuilder | qiotoolkit",
    "keywords": "Class utils::ParameterBuilder ParameterBuilder. This is the builder object returned by Component::param(). Its initial setup contains the input (json) to read from, the name of the field to read and a reference to the parameter to be filled. Additional details on how to read the parameter can be chained onto the Parameter builder: this->param(json, \"number\", my_number) .alias(\"my_number\") .description(\"some description\") .matches(GreaterEquals(0)) .default_value(1) Note A parameter is considered optional unless required() is specified explicitly as part of the chain. An optional parameter with no default value will leave the parameter reference untouched (except if the parameter is an std::optional , in which case it will be reset). Output Parametes Some parameters are intended to be returned as part of the response (read back). Components with this property should be derived from utils::ComponentWithOutput, in which case the ParameterBuilder has the additional method [.with_output()](xref:classutils_1_1ParameterBuilder_1ae7291d09e04864c1126fff90516d470f) causing the parameter value to be stored in the component's output parameters: this->param(json, \"number\", my_number) .with_output() this->get_output_parameters(); // will contain {\"number\": my_number} Inheritance utils::ParameterBuilder Constructors ParameterBuilder() Assign the parameter from the specified field. Declaration utils::ParameterBuilder<Component_T, Param_T>::ParameterBuilder(Component_T *component, const utils::Json&json, const std::string&name, Param_T&parameter) Methods alias() If not yet assigned try assigning from the alias field. Declaration ParameterBuilder&utils::ParameterBuilder<Component_T, Param_T>::alias(const std::string&name) description() Store the description to be used in error messages. Declaration ParameterBuilder&utils::ParameterBuilder<Component_T, Param_T>::description(const std::string&desc) required() Throw an exception if the parameter has not been assigned (i.e., the field was not present). Declaration ParameterBuilder&utils::ParameterBuilder<Component_T, Param_T>::required() default_value() Assign a default value if the parameter has not ben assigned. Declaration ParameterBuilder&utils::ParameterBuilder<Component_T, Param_T>::default_value(const V&default_value_) with_output() Store the parameters value in the component's output_parameters (to be returned to the user). Declaration std::enable_if<std::is_same<C, utils::ComponentWithOutput>::value, ParameterBuilder&>::type utils::ParameterBuilder<Component_T, Param_T>::with_output() matches() If the parameter was assigned, match its value against the matcher. Declaration ParameterBuilder&utils::ParameterBuilder<Component_T, Param_T>::matches(const M&matcher) try_assign() Declaration bool utils::ParameterBuilder<Component_T, Param_T>::try_assign() reset_if_optional() Declaration static void utils::ParameterBuilder<Component_T, Param_T>::reset_if_optional(T&) reset_if_optional() Declaration static void utils::ParameterBuilder<Component_T, Param_T>::reset_if_optional(std::optional<T>&parameter)"
  },
  "api/utils/pcg.html": {
    "href": "api/utils/pcg.html",
    "title": "Class utils::PCG | qiotoolkit",
    "keywords": "Class utils::PCG Inheritance utils::RandomGenerator utils::PCG Inherited Members min ~RandomGenerator max seed RandomGenerator operator() Constructors PCG() Declaration utils::PCG::PCG() PCG() Declaration utils::PCG::PCG(uint32_t seed) Methods seed() Set the seed to the random_number_generator. Declaration void utils::PCG::seed(uint32_t) override fork() Declaration std::unique_ptr<RandomGenerator>utils::PCG::fork() override uint32() Return a random 32bit integer. Declaration uint32_t utils::PCG::uint32() override uniform() Return a uniformly distributed double in [0,1). Declaration double utils::PCG::uniform() override gaussian() Return a gaussian distributed double. Declaration double utils::PCG::gaussian() override poisson() Return a poisson distributed integer with mean mean. Declaration uint32_t utils::PCG::poisson(double mean) override memory_estimate() Return estimation of memory in bytes. Declaration size_t utils::PCG::memory_estimate() const override"
  },
  "api/utils/proto-reader.html": {
    "href": "api/utils/proto-reader.html",
    "title": "Class utils::ProtoReader | qiotoolkit",
    "keywords": "Class utils::ProtoReader Inheritance utils::ProtoReader Constructors ProtoReader() Declaration utils::ProtoReader::ProtoReader() Methods Parse() Declaration bool utils::ProtoReader::Parse(const std::string&folder_path, utils::PROTOHandlerProxy<StreamHandler>&handler_proxy) Parse() Declaration bool utils::ProtoReader::Parse(const google::protobuf::RepeatedPtrField<QuantumUtil::Problem_Term>&terms, utils::PROTOHandlerProxy<StreamHandler>&handler_proxy, unsigned&num_terms) Parse() Declaration bool utils::ProtoReader::Parse(const QuantumUtil::Problem_Term&term, utils::PROTOHandlerProxy<StreamHandler>&handler_proxy)"
  },
  "api/utils/protohandler-proxy.html": {
    "href": "api/utils/protohandler-proxy.html",
    "title": "Class utils::PROTOHandlerProxy | qiotoolkit",
    "keywords": "Class utils::PROTOHandlerProxy PROTOHandlerProxy. Convert and redirect PROTO reader signals into qiotoolkit handler. Inheritance utils::PROTOHandlerProxy Constructors PROTOHandlerProxy() Declaration utils::PROTOHandlerProxy<StreamHandler>::PROTOHandlerProxy() Methods Null() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::Null() Bool() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::Bool(bool b) Int() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::Int(int i) Uint() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::Uint(unsigned i) Int64() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::Int64(int64_t i) Uint64() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::Uint64(uint64_t i) Double() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::Double(double d) RawNumber() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::RawNumber(const char *, int, bool) String() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::String(std::string str) StartObject() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::StartObject() Key() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::Key(std::string str) EndObject() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::EndObject(int elementCount) StartArray() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::StartArray() EndArray() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::EndArray(int elementCount) get_value() Declaration StreamHandler::Type_T&utils::PROTOHandlerProxy<StreamHandler>::get_value() reset() Declaration void utils::PROTOHandlerProxy<StreamHandler>::reset() complete() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::complete() error_code() Declaration Error utils::PROTOHandlerProxy<StreamHandler>::error_code() const error_message() Declaration std::string utils::PROTOHandlerProxy<StreamHandler>::error_message() const fail() Declaration bool utils::PROTOHandlerProxy<StreamHandler>::fail() const"
  },
  "api/utils/random-generator.html": {
    "href": "api/utils/random-generator.html",
    "title": "Class utils::RandomGenerator | qiotoolkit",
    "keywords": "Class utils::RandomGenerator RandomGenerator. This is a thin wrapper around the STL mersenne twister which provides the convenience function for the uniform = rand \\in [0,1) and poisson(double mean) Inheritance utils::RandomGenerator utils::PCG utils::Twister Constructors RandomGenerator() Declaration utils::RandomGenerator::RandomGenerator() Methods max() Declaration static result_type utils::RandomGenerator::max() min() Declaration static result_type utils::RandomGenerator::min() ~RandomGenerator() Declaration virtual utils::RandomGenerator::~RandomGenerator() operator()() Declaration uint32_t utils::RandomGenerator::operator()() seed() Allow seeding from signed integer. Declaration void utils::RandomGenerator::seed(int32_t seed) fork() Declaration virtual std::unique_ptr<RandomGenerator>utils::RandomGenerator::fork()=0 seed() Set the seed to the random_number_generator. Declaration virtual void utils::RandomGenerator::seed(uint32_t seed)=0 uint32() Return a random 32bit integer. Declaration virtual uint32_t utils::RandomGenerator::uint32()=0 uniform() Return a uniformly distributed double in [0,1). Declaration virtual double utils::RandomGenerator::uniform()=0 gaussian() Return a gaussian distributed double. Declaration virtual double utils::RandomGenerator::gaussian()=0 poisson() Return a poisson distributed integer with mean mean. Declaration virtual uint32_t utils::RandomGenerator::poisson(double mean)=0 memory_estimate() Return estimation of memory in bytes. Declaration virtual size_t utils::RandomGenerator::memory_estimate() const =0"
  },
  "api/utils/random-selector.html": {
    "href": "api/utils/random-selector.html",
    "title": "Class utils::RandomSelector | qiotoolkit",
    "keywords": "Class utils::RandomSelector Inheritance utils::RandomSelector Constructors RandomSelector() Declaration utils::RandomSelector::RandomSelector() Methods reset() Declaration void utils::RandomSelector::reset() insert() Declaration void utils::RandomSelector::insert(size_t id, double weight) select() Declaration size_t utils::RandomSelector::select(double uniform) const select_and_remove() Declaration size_t utils::RandomSelector::select_and_remove(double uniform) get_weight() Declaration double utils::RandomSelector::get_weight(size_t position) const get_cumulative_weight() Declaration double utils::RandomSelector::get_cumulative_weight(size_t position) const select_position() Declaration size_t utils::RandomSelector::select_position(double uniform) const remove_position() Declaration void utils::RandomSelector::remove_position(size_t position) add_weight() Declaration void utils::RandomSelector::add_weight(size_t position, double weight)"
  },
  "api/utils/range.html": {
    "href": "api/utils/range.html",
    "title": "Class utils::Range | qiotoolkit",
    "keywords": "Class utils::Range Inheritance utils::Component utils::Range Inherited Members ~Component Component get_status param Constructors Range() Declaration utils::Range::Range() Range() Declaration utils::Range::Range(double in_initial, double in_final) Methods ~Range() Declaration utils::Range::~Range() configure() configure the object from input Initialize the object's state from the input utils::Config. This is done by declaring which required and optional parameters are associated with the fields of this object. During initialization, they are checked for their presence, type and any matchers. Example: MyClass : public Component { public: void configure(const utils::Json& json) override { this->param(json, \"number\", my_number) .description(\"some description\") .matches(GreaterEquals(0)) .required(); this->param(json, \"name\", my_name) .description(\"some description\") .matches(SizeIs(GreaterThan(0))) .default_value(\"no_name\"); } private: int my_number; std::string my_name; } MyClass my_object; my_object.configure(utils::json_from_string(R\"( { \"number\": 42, \"name\": \"hello\" } )\")); Note By default, nothing is configured from input. You need to overload this method if you want to use this functionality. Don't forget to call the configure method of the parent class if it also needs to be configured (this is not the case for utils::Component itself). HINT: Parameters are not limited to scalars and strings; Any component can be a parameter; in which case it is initialized using its own configure method. utils::Json Declaration void utils::Range::configure(const utils::Json&json) override render() render the object in structured form Return a structured representation of the object. This is intended for output purposes. For instance, the solution your solver finds should have a render method which allows it to be returned as part of the result. Example: {c++} MySolution : public Component { public: // Represent the internal bool vector as +-1 output. utils::Structure render() const override { utils::Structure rendered; for (bool item : solution_) rendered.push_back(item ? 1 : -1); return rendered; } private: std::vector<bool> solution_; } MySolution solution; std::cout << solution.render().to_string() << std::endl; utils::Structure Declaration Structure utils::Range::render() const override get_class_name() get_class_name shows an identifier of the (derived) class name Its primary use is for type identification during stream output and logging, where a component is rendered as <ClassName: status>. Example: {c++} MyClass : public Component {} // This will render as '<MyClass>' MyClass my_object; std::cout << my_object << std::endl; Note You do not need to overload this method unless you want to change the output of the default implementation. Declaration std::string utils::Range::get_class_name() const override"
  },
  "api/utils/runtime-error.html": {
    "href": "api/utils/runtime-error.html",
    "title": "Class utils::RuntimeError | qiotoolkit",
    "keywords": "Class utils::RuntimeError Inheritance utils::RuntimeException utils::RuntimeError Inherited Members RuntimeException get_error_code_message get_error_code Constructors RuntimeError() Declaration utils::RuntimeError<err>::RuntimeError(std::string message)"
  },
  "api/utils/runtime-exception.html": {
    "href": "api/utils/runtime-exception.html",
    "title": "Class utils::RuntimeException | qiotoolkit",
    "keywords": "Class utils::RuntimeException RuntimeException. A runtime exception is thrown when an unexpected state is encountered during the simulation, which cannot be handled gracefully (i.e., a bug). Inheritance utils::RuntimeException utils::RuntimeError Constructors RuntimeException() Declaration utils::RuntimeException::RuntimeException(std::string message, Error error_code) Methods get_error_code_message() Declaration std::string utils::RuntimeException::get_error_code_message() const get_error_code() Declaration Error utils::RuntimeException::get_error_code() const"
  },
  "api/utils/scoped-timer.html": {
    "href": "api/utils/scoped-timer.html",
    "title": "Class utils::ScopedTimer | qiotoolkit",
    "keywords": "Class utils::ScopedTimer Drop in timer (logs time used to INFO when the object leaves scope) Inheritance utils::ScopedTimer Constructors ScopedTimer() Declaration utils::ScopedTimer::ScopedTimer(std::string title) Methods ~ScopedTimer() Declaration utils::ScopedTimer::~ScopedTimer()"
  },
  "api/utils/set-stream-handler.html": {
    "href": "api/utils/set-stream-handler.html",
    "title": "Class utils::SetStreamHandler | qiotoolkit",
    "keywords": "Class utils::SetStreamHandler SetStreamHandler. Implementations of stream handlers for set of values of simple, non class type like bool, int... Inheritance utils::BaseStreamHandler utils::SetStreamHandler Inherited Members StartObject complete started fail_at_missing_inputs Key missing_inputs failed reset error_message EndObject error_code BaseStreamHandler Methods Value() Declaration bool utils::SetStreamHandler<T>::Value(SignalType signal_value, Type_T&vec) StartArray() Declaration bool utils::SetStreamHandler<T>::StartArray() EndArray() Declaration bool utils::SetStreamHandler<T>::EndArray(size_t elementCount, Type_T&vec) started() Declaration bool utils::SetStreamHandler<T>::started() const complete() Declaration bool utils::SetStreamHandler<T>::complete() const reset() Declaration void utils::SetStreamHandler<T>::reset(Type_T&vec) fail() Declaration bool utils::SetStreamHandler<T>::fail(const std::string&meassage=\"parsing error\", Error error_code=Error::ParsingError)"
  },
  "api/utils/signal.html": {
    "href": "api/utils/signal.html",
    "title": "Class utils::Signal | qiotoolkit",
    "keywords": "Class utils::Signal Inheritance utils::Signal Constructors Signal() Declaration utils::Signal::Signal(Type type) Methods get_type() Declaration Signal::Type utils::Signal::get_type() get_time() Declaration double utils::Signal::get_time() queue() Declaration std::queue<Signal>&utils::Signal::queue()"
  },
  "api/utils/structure.html": {
    "href": "api/utils/structure.html",
    "title": "Class utils::Structure | qiotoolkit",
    "keywords": "Class utils::Structure Inheritance utils::Structure Constructors Structure() Declaration utils::Structure::Structure() Structure() Declaration utils::Structure::Structure(Type type) Structure() Declaration utils::Structure::Structure(const Structure&other) Structure() Declaration utils::Structure::Structure(const T&value) Methods ~Structure() Declaration utils::Structure::~Structure() remove() Declaration void utils::Structure::remove(const std::string&key) operator=() Declaration Structure&utils::Structure::operator=(const Structure&other) check_reset() Declaration void utils::Structure::check_reset(Structure::Type type) reset() Declaration void utils::Structure::reset(Structure::Type type) operator=() Declaration Structure&utils::Structure::operator=(const T&value) operator[]() Declaration Structure&utils::Structure::operator[](size_t index) operator[]() Declaration Structure&utils::Structure::operator[](int32_t index) operator[]() Declaration const Structure&utils::Structure::operator[](size_t index) const check_array() Declaration void utils::Structure::check_array() const operator[]() Declaration const Structure&utils::Structure::operator[](int32_t index) const operator[]() Declaration Structure&utils::Structure::operator[](const std::string&key) check_object() Declaration void utils::Structure::check_object() const operator[]() Declaration const Structure&utils::Structure::operator[](const std::string&key) const get_extension() Declaration Structure&utils::Structure::get_extension(const std::string&name) get_type() Declaration Type utils::Structure::get_type() const is_empty() Declaration bool utils::Structure::is_empty() const has_key() Declaration bool utils::Structure::has_key(const std::string&key) const has_extension() Declaration bool utils::Structure::has_extension(const std::string&name) const get_array_size() Declaration size_t utils::Structure::get_array_size() const get_object_keys() Declaration std::vector<std::string>utils::Structure::get_object_keys() const get_extension_names() Declaration std::vector<std::string>utils::Structure::get_extension_names() const get() Declaration T utils::Structure::get() const clear() Declaration void utils::Structure::clear() push_back() Declaration void utils::Structure::push_back(const T&value) append() Declaration void utils::Structure::append(const std::vector<T>&values) prepend() Declaration void utils::Structure::prepend(const std::vector<T>&values) set_extension() Declaration void utils::Structure::set_extension(const std::string&name, const T&value) to_string() Declaration std::string utils::Structure::to_string(bool pretty=true) const <() Declaration bool utils::Structure::operator<(const Structure&rhs) const <() Declaration bool utils::Structure::operator<(const Structure&rhs) const get() Declaration bool utils::Structure::get() const get() Declaration int32_t utils::Structure::get() const get() Declaration uint32_t utils::Structure::get() const get() Declaration int64_t utils::Structure::get() const get() Declaration uint64_t utils::Structure::get() const get() Declaration double utils::Structure::get() const get() Declaration bool utils::Structure::get() const get() Declaration int32_t utils::Structure::get() const get() Declaration uint32_t utils::Structure::get() const get() Declaration int64_t utils::Structure::get() const get() Declaration uint64_t utils::Structure::get() const get() Declaration double utils::Structure::get() const get() Declaration std::string utils::Structure::get() const find_extension() Declaration const Structure* utils::Structure::find_extension(const std::string&name) const set_value() Declaration void utils::Structure::set_value(bool value) set_value() Declaration void utils::Structure::set_value(int32_t value) set_value() Declaration void utils::Structure::set_value(uint32_t value) set_value() Declaration void utils::Structure::set_value(int64_t value) set_value() Declaration void utils::Structure::set_value(uint64_t value) set_value() Declaration void utils::Structure::set_value(float value) set_value() Declaration void utils::Structure::set_value(double value) set_value() Declaration void utils::Structure::set_value(const char value[]) set_value() Declaration void utils::Structure::set_value(const std::string&value) set_value() Declaration void utils::Structure::set_value(const Structure&value) set_value() Declaration void utils::Structure::set_value(const std::vector<T>&array) set_value() Declaration void utils::Structure::set_value(const std::map<std::string, T>&object) set_value() Declaration void utils::Structure::set_value(const std::unordered_map<std::string, T>&object) set_value() Declaration void utils::Structure::set_value(const T&component) is_simple() Declaration bool utils::Structure::is_simple() const to_string() Declaration std::string utils::Structure::to_string(bool pretty, int level) const type2string() Declaration std::string utils::Structure::type2string(Type type) deep_copy() Declaration void utils::Structure::deep_copy(const Structure&other)"
  },
  "api/utils/twister.html": {
    "href": "api/utils/twister.html",
    "title": "Class utils::Twister | qiotoolkit",
    "keywords": "Class utils::Twister Inheritance utils::RandomGenerator utils::Twister Inherited Members min ~RandomGenerator max seed RandomGenerator operator() Constructors Twister() Declaration utils::Twister::Twister() Twister() Declaration utils::Twister::Twister(uint32_t seed) Methods seed() Set the seed to the random_number_generator. Declaration void utils::Twister::seed(uint32_t) override fork() Declaration std::unique_ptr<RandomGenerator>utils::Twister::fork() override uint32() Return a random 32bit integer. Declaration uint32_t utils::Twister::uint32() override uniform() Return a uniformly distributed double in [0,1). Declaration double utils::Twister::uniform() override gaussian() Return a gaussian distributed double. Declaration double utils::Twister::gaussian() override poisson() Return a poisson distributed integer with mean mean. Declaration uint32_t utils::Twister::poisson(double mean) override memory_estimate() Return estimation of memory in bytes. Declaration size_t utils::Twister::memory_estimate() const override"
  },
  "api/utils/vector-object-stream-handler.html": {
    "href": "api/utils/vector-object-stream-handler.html",
    "title": "Class utils::VectorObjectStreamHandler | qiotoolkit",
    "keywords": "Class utils::VectorObjectStreamHandler Inheritance utils::BaseStreamHandler utils::VectorObjectStreamHandler Inherited Members complete started fail_at_missing_inputs missing_inputs EndArray failed reset error_message EndObject Value reset error_code BaseStreamHandler Methods StartArray() Declaration bool utils::VectorObjectStreamHandler<StreamHandler>::StartArray() Value() Declaration bool utils::VectorObjectStreamHandler<StreamHandler>::Value(SignalType signal_value, Type_T&) StartObject() Declaration bool utils::VectorObjectStreamHandler<StreamHandler>::StartObject() Key() Declaration bool utils::VectorObjectStreamHandler<StreamHandler>::Key(const std::string&key) EndObject() Declaration bool utils::VectorObjectStreamHandler<StreamHandler>::EndObject(size_t elementCount, Type_T&vec) EndArray() Declaration bool utils::VectorObjectStreamHandler<StreamHandler>::EndArray(size_t elementCount, Type_T&vec) complete() Declaration virtual bool utils::VectorObjectStreamHandler<StreamHandler>::complete() const started() Declaration virtual bool utils::VectorObjectStreamHandler<StreamHandler>::started() const reset() Declaration void utils::VectorObjectStreamHandler<StreamHandler>::reset(Type_T&vec) push_back_value() Declaration void utils::VectorObjectStreamHandler<StreamHandler>::push_back_value(Type_T&vec) fail() Declaration bool utils::VectorObjectStreamHandler<StreamHandler>::fail(const std::string&meassage=\"parsing error\", Error error_code=Error::ParsingError)"
  },
  "api/utils/vector-stream-handler.html": {
    "href": "api/utils/vector-stream-handler.html",
    "title": "Class utils::VectorStreamHandler | qiotoolkit",
    "keywords": "Class utils::VectorStreamHandler VectorStreamHandler. Implementations of stream handlers for vector of values of simple, non class type like bool, int... Inheritance utils::BaseStreamHandler utils::VectorStreamHandler Inherited Members StartObject complete started fail_at_missing_inputs Key missing_inputs failed reset error_message EndObject error_code BaseStreamHandler Methods Value() Declaration bool utils::VectorStreamHandler<T>::Value(SignalType signal_value, Type_T&vec) StartArray() Declaration bool utils::VectorStreamHandler<T>::StartArray() EndArray() Declaration bool utils::VectorStreamHandler<T>::EndArray(size_t elementCount, Type_T&vec) complete() Declaration bool utils::VectorStreamHandler<T>::complete() const started() Declaration bool utils::VectorStreamHandler<T>::started() const reset() Declaration void utils::VectorStreamHandler<T>::reset(Type_T&vec) fail() Declaration bool utils::VectorStreamHandler<T>::fail(const std::string&meassage=\"parsing error\", Error error_code=Error::ParsingError)"
  },
  "api/widget.html": {
    "href": "api/widget.html",
    "title": "Class Widget | qiotoolkit",
    "keywords": "Class Widget Inheritance Widget Constructors Widget() Declaration Widget::Widget(int number, const std::string&name) Methods ~Widget() Declaration Widget::~Widget() GetFloatValue() Declaration float Widget::GetFloatValue() const GetIntValue() Declaration int Widget::GetIntValue() const GetStringValue() Declaration std::string Widget::GetStringValue() const GetCharPtrValue() Declaration void Widget::GetCharPtrValue(char *buffer, size_t max_size) const"
  },
  "api/writer.html": {
    "href": "api/writer.html",
    "title": "Class Writer | qiotoolkit",
    "keywords": "Class Writer JSON writer. Writer implements the concept Handler. It generates JSON text by events to an output os. User may programmatically calls the functions of a writer to generate JSON text. On the other side, a writer can also be passed to objects that generates events, for example Reader::Parse() and Document::Accept(). OutputStream Type of output stream. SourceEncoding Encoding of source string. TargetEncoding Encoding of output stream. StackAllocator Type of allocator for allocating memory of stack. implements Handler concept Inheritance Writer Constructors Writer() Declaration Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Writer(const Writer&) Writer() Constructor. os Output stream. stackAllocator User supplied allocator. If it is null, it will create a private one. levelDepth Initial capacity of stack. Declaration Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Writer(OutputStream&os, StackAllocator *stackAllocator=0, size_t levelDepth=kDefaultLevelDepth) Writer() Declaration Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Writer(StackAllocator *allocator=0, size_t levelDepth=kDefaultLevelDepth) Methods Null() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Null() Bool() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Bool(bool b) Int() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Int(int i) Uint() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Uint(unsigned u) Int64() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Int64(int64_t i64) Uint64() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Uint64(uint64_t u64) Double() Writes the given double value to the stream. d The value to be written. Whether it is succeed. Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Double(double d) RawNumber() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::RawNumber(const Ch *str, SizeType length, bool copy=false) String() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::String(const Ch *str, SizeType length, bool copy=false) StartObject() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::StartObject() Key() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Key(const Ch *str, SizeType length, bool copy=false) EndObject() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::EndObject(SizeType memberCount=0) StartArray() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::StartArray() EndArray() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::EndArray(SizeType elementCount=0) String() Simpler but slower overload. Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::String(const Ch *const&str) Key() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Key(const Ch *const&str) RawValue() Write a raw JSON value. For user to write a stringified JSON as a value. json A well-formed JSON value. It should not contain null character within [0, length - 1] range. length Length of the json. type Type of the root of json. Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::RawValue(const Ch *json, size_t length, Type type) Flush() Flush the output stream. Allows the user to flush the output stream immediately. Declaration void Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Flush() WriteNull() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteNull() WriteBool() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteBool(bool b) WriteInt() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteInt(int i) WriteUint() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteUint(unsigned u) WriteInt64() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteInt64(int64_t i64) WriteUint64() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteUint64(uint64_t u64) WriteDouble() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteDouble(double d) WriteString() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteString(const Ch *str, SizeType length) ScanWriteUnescapedString() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::ScanWriteUnescapedString(GenericStringStream<SourceEncoding>&is, size_t length) WriteStartObject() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteStartObject() WriteEndObject() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteEndObject() WriteStartArray() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteStartArray() WriteEndArray() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteEndArray() WriteRawValue() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::WriteRawValue(const Ch *json, size_t length) Prefix() Declaration void Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Prefix(Type type) EndValue() Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::EndValue(bool ret) operator=() Declaration Writer&Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::operator=(const Writer&) Reset() Reset the writer with a new stream. This function reset the writer with a new stream and default settings, in order to make a Writer object reusable for output multiple JSONs. os New output stream. Writer<OutputStream> writer(os1); writer.StartObject(); // ... writer.EndObject(); writer.Reset(os2); writer.StartObject(); // ... writer.EndObject(); Declaration void Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Reset(OutputStream&os) IsComplete() Checks whether the output is a complete JSON. A complete JSON has a complete root object or array. Declaration bool Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::IsComplete() const GetMaxDecimalPlaces() Declaration int Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::GetMaxDecimalPlaces() const SetMaxDecimalPlaces() Sets the maximum number of decimal places for double output. This setting truncates the output with specified number of decimal places. For example, writer.SetMaxDecimalPlaces(3); writer.StartArray(); writer.Double(0.12345); // \"0.123\" writer.Double(0.0001); // \"0.0\" writer.Double(1.234567890123456e30); // \"1.234567890123456e30\" (do not truncate significand for positive exponent) writer.Double(1.23e-4); // \"0.0\" (do truncate significand for negative exponent) writer.EndArray(); The default setting does not truncate any decimal places. You can restore to this setting by calling writer.SetMaxDecimalPlaces(Writer::kDefaultMaxDecimalPlaces); Declaration void Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::SetMaxDecimalPlaces(int maxDecimalPlaces) WriteInt() Declaration bool Writer<StringBuffer>::WriteInt(int i) WriteUint() Declaration bool Writer<StringBuffer>::WriteUint(unsigned u) WriteInt64() Declaration bool Writer<StringBuffer>::WriteInt64(int64_t i64) WriteUint64() Declaration bool Writer<StringBuffer>::WriteUint64(uint64_t u) WriteDouble() Declaration bool Writer<StringBuffer>::WriteDouble(double d)"
  },
  "api/writer/level.html": {
    "href": "api/writer/level.html",
    "title": "Struct Writer::Level | qiotoolkit",
    "keywords": "Struct Writer::Level Information for each nested level. Constructors Level() Declaration Writer<OutputStream, SourceEncoding, TargetEncoding, StackAllocator, writeFlags>::Level::Level(bool inArray_)"
  },
  "CODE_OF_CONDUCT.html": {
    "href": "CODE_OF_CONDUCT.html",
    "title": "Code of Conduct | qiotoolkit",
    "keywords": "Code of Conduct Purpose The primary goal of this project is to foster an open and welcoming environment where everyone who wishes to contribute can do so, regardless of gender, sexual orientation, ability, ethnicity, socioeconomic status, and religion (or lack thereof). We encourage everyone with the necessary skills and a genuine interest in this project to contribute and be a part of our community. This Code of Conduct outlines our expectations for all community members and the principles we adhere to, ensuring a safe and positive experience for everyone. Our Standards We are committed to maintaining a community that acknowledges the value of every individual. We expect all members of our community to: Demonstrate empathy, kindness, and respect towards each other. Respect personal boundaries and personal identities. Give credit where credit is due and acknowledge the contributions of others. Welcome constructive criticism and be open to learning. Show commitment to the wellbeing and success of the community. Examples of unacceptable behavior include: Offensive or derogatory comments, personal or political attacks, or any form of public or private harassment. Publishing others' private information without their explicit permission. Other conduct that could be reasonably considered inappropriate in a professional setting. Responsibilities Project maintainers are responsible for clarifying and enforcing our standards of acceptable behavior and are expected to take appropriate action in response to any instances of unacceptable behavior. Maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the project maintainers responsible for enforcement at dennis.jensen@kpmg.com. All complaints will be reviewed, investigated and responded to. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html Conclusion By choosing to contribute to this project, you commit to upholding this Code of Conduct. Let us all strive to create a productive, welcoming, and inclusive environment where everyone feels valued and can freely contribute their skills and knowledge."
  },
  "CONTRIBUTING.html": {
    "href": "CONTRIBUTING.html",
    "title": "Quantum Inspired Optimization Toolkit Project - Contribution Guidelines | qiotoolkit",
    "keywords": "Quantum Inspired Optimization Toolkit Project - Contribution Guidelines Introduction Thank you for your interest in contributing to the Quantum Inspired Optimization Toolkit project! We're thrilled to welcome you on board. This project is deeply rooted in complex mathematical concepts, implemented in C++, and we greatly value your expertise and dedication. Getting Started Familiarize Yourself with the Project Before making your first contribution, please familiarize yourself with the project. Understand what the project is about, what its objectives are, and how it works. This project requires a strong understanding of quantum-inspired algorithms, mathematical optimization, and C++ programming. Understand the Code of Conduct We maintain a standard Code of Conduct that all contributors must adhere to. Make sure you read and understand this before contributing. A respectful and inclusive environment is critical to the project's success. How to Contribute Fork the Repository To start contributing, fork the repository and then clone it to your local machine. This will give you a copy of the entire codebase on your system, allowing you to make changes. Set Up the Development Environment Ensure your local setup is working perfectly and you can run the project without any issues. If you encounter any problems, reach out to the community for help. Pick an Issue Check out the open issues in the repository. Select one that you are interested in and fits your skills. We encourage newcomers to start with smaller, simpler issues and gradually move on to more complex ones as they get more comfortable. Write Your Code After selecting an issue, start writing your code. Please try and ensure you follow our coding standards and conventions. They help maintain the code's consistency and readability. Write code in modern, idiomatic C++ and adhere to the C++ Core Guidelines Include detailed comments with your code when the logic isn't immediately apparent. Strive for clean, efficient, and optimized code. Avoid unnecessary complexity or over-optimization. Testing Write tests for your code to verify that it behaves as expected. Your tests should cover edge cases and potential errors. This is necessary to actually contribute to the project as we do not currently allow ned code in with under 90% test coverage. Documentation Given the mathematical complexity of this project, robust documentation is critical. Include thorough explanations of your code and the mathematical concepts behind it when necessary. Remember that others in the community may not have the same level of understanding or expertise as you. Submitting Your Contribution Commit Your Changes Before committing your changes, ensure that your code builds correctly and all tests pass. Your commit message should be descriptive and clarify the purpose of the commit. Push to Your Fork Push your commits to your fork. Open a Pull Request From your forked repository, open a pull request against the main project. Include a descriptive title and detailed description of your changes. Link any related issues. Quality gate check We have several automated quality checks. Currently we do not allow any code change without 90% code coverage. We also have a static code analysis tool that checks for any code quality issues. The pull request will automatically run these checks and it won't be possible to contribute until these checks pass. Code Review Maintainers or project members will review your code. They may suggest changes or improvements. This is a normal part of the process, and these reviews ensure the quality and consistency of the code base. Incorporate Feedback Incorporate any feedback or changes requested during the code review. Once all feedback has been addressed, the maintainers will merge your pull request. Conclusion We hope these guidelines help you navigate your contribution journey. Don't hesitate to ask for help when you need it. And most importantly, have fun! Thank you for contributing to the Quantum Inspired Optimization Toolkit project!"
  },
  "design/exceptions.html": {
    "href": "design/exceptions.html",
    "title": "Design: Exceptions | qiotoolkit",
    "keywords": "Design: Exceptions Background: Concise and actionable feedback in exceptions is crucial to allow customers to amend their input. Goal: Provide guidelines on the content and wording of exceptions returned to customers. Non-goals: Design and discussion of logging levels for development. Exceptions vs Logging Exceptions are intended as an early-abort mechanism with feedback to customers (unless caught and handled) Logging is purely for development (we don't surface any log statements to customers). How to throw We provide a THROW macro which takes care of concatenating multiple stream-printable contents into an error message: if (!my_condition(variable)) { THROW(utils::ValueException, \"my_condition must hold for variable. Found variable=\", variable, \".\"); } which is equivalent to throw(utils::ValueException(msg.str())) with a manually crafted msg. Which Exception We recognize [four classes of exceptions]: Insufficient Resources (1-100) Invalid Input Data (101-200) Runtime Errors (201-300) File IO errors (301-400) The list of error codes can be expanded if necessary. Choice of Modal Verb To clarify whether a condition is enforced or merely suggested, we follow the Microsoft Style Guide: the word \"must\" indicates a required condition (the task will abort early if not followed and indicate this condition as the reason), the word \"should\" indicates a suggestion (the task will still run, but we expect results to be inferior). We currently don't have a mechanism to surface warnings to the user, so the second instance will silently accept inputs not following the suggestion. Positive Statement Exceptions should be formulated in the positive (i.e., describe the expected situation), followed by what was encountered (i.e., why the expectation is not met). Ideally with details on where to find the inconsistency. Example a must be greater-equals 0. Found a=-1 in the json input: cost_function.params.a. alpha must be decreasing (i.e., the initial value of alpha must be larger than the final value). Found alpha.initial = 0 < 1 = alpha.final. Note This is in contrast to describing what is wrong (i.e., \"Error: alpha.initial is smaller than alpha.final.\")."
  },
  "index.html": {
    "href": "index.html",
    "title": "qiotoolkit | qiotoolkit",
    "keywords": "Tools for rapid development, analysis and deployment of quantum inspired optimization algorithms. Content This documentation contains: API: Documentation of the C++ interfaces of qiotoolkit components, Specification: Listing of input parameters for models and solvers, Theory: Explanations of commonly used terminology, and a few Tutorials to get up and running."
  },
  "spec/index.html": {
    "href": "spec/index.html",
    "title": "I/O Specifications | qiotoolkit",
    "keywords": "Specifications The interfaces generated for qiotoolkit-based solvers use JSON for both input and output. This documentation section specifies their format as JSON-schemas."
  },
  "spec/model/blume-capel.html": {
    "href": "spec/model/blume-capel.html",
    "title": "Blume-Capel model | qiotoolkit",
    "keywords": "Blume-Capel Model The variables in the BlumeCapel model can take 3 values (spin-\\(`1`\\) as opposed to spin-\\(`\\frac12`\\) in the Ising case). \\mathcal{H} = -\\sum_{ij} J_{ij} s_{i}s_{j}\\,,\\quad s_i \\in \\{-1,0,+1\\} Hypergraph Generalization The generalization is analogous to the Ising spin glass: \\mathcal{H} = -\\sum_e J_e \\prod_{i\\in e} s_i NOTE: Contrary to the Ising model, squared spin variables can be meaningful in the BlumeCapel model: \\(`s_i\\in\\{-1,0,+1\\}`\\), \\(`s_i^2\\in\\{0,1\\}`\\). Example Input Data { \"type\": \"blume-capel\", \"version\": \"0.2\", \"terms\": [ {\"c\": 1.0, \"ids\": [0, 1]}, {\"c\": 1.0, \"ids\": [1, 2]}, {\"c\": 1.0, \"ids\": [2, 3]}, {\"c\": -2.0, \"ids\": [3, 0]} ] }"
  },
  "spec/model/clock.html": {
    "href": "spec/model/clock.html",
    "title": "Clock model | qiotoolkit",
    "keywords": "Clock Spin Glass The clock model (and corresponding clock spin glass) describes interacting spins which can take discrete values on the 2D planar unit circle. \\mathcal{H} = -\\sum_{ij} J_{ij}\\, s_i\\!\\cdot\\!s_j,\\quad s_i=(\\cos\\varphi_i, \\sin\\varphi_i) where \\(`s_i\\!\\cdot\\!s_j`\\) is a scalar product and each \\(`\\varphi_i`\\) can take one of \\(`q`\\) values: \\varphi_i = v_i \\frac{2\\pi}{q},\\quad v_i\\in\\{0,\\ldots,q-1\\} Or, as a visual representation for \\(`q=5`\\): \\begin{tikzpicture} \\draw (0,0) circle(2); \\draw[->,line width=1.5pt] (0,0) -- (30:2); \\draw[->,line width=1.5pt] (0,0) -- (102:2); \\draw[->,line width=1.5pt] (0,0) -- (174:2); \\draw[->,line width=1.5pt] (0,0) -- (246:2); \\draw[->,line width=1.5pt] (0,0) -- (318:2); \\end{tikzpicture} NOTE: For the case discretized to two values, \\(`q=2`\\), this model corresponds to the Ising spin glass. Hypergraph Generalization The scalar product in the standard clock Hamiltonian does not lend itself to a generalization for multi-spin interactions. Instead, the qiotoolkit implementation uses a Hamiltonian based on the normalized sum of vectors \\(`\\vec v_e`\\): \\mathcal{H} = -\\sum_e J_e (2v_e^2-1),\\quad \\vec v_e = \\frac{1}{|e|}\\sum_{i\\in e} \\vec{s_i}\\, where the term in brackets reduces to the scalar product for the case of 2-spin interactions and covers the range \\(`[-1,1]`\\) for any \\(`q`\\): The minimal value is realized when the clock spins \"cancel out\" (i.e., sum up to \\(`\\vec 0`\\)) The maximal value is realized when all spins are aligned (have the same value). Example Input Data { \"type\": \"clock\", \"version\": \"0.1\", \"q\": 5, \"terms\": [ {\"c\": 1.0, \"ids\": [0, 1]}, {\"c\": 1.0, \"ids\": [1, 2]}, {\"c\": 1.0, \"ids\": [2, 3]}, {\"c\": -2.0, \"ids\": [3, 0]} ] }"
  },
  "spec/model/index.html": {
    "href": "spec/model/index.html",
    "title": "Model Specifications | qiotoolkit",
    "keywords": "Built-in Models qiotoolkit has the following built-in models: Model Description ising The Ising model consists of binary variables \\(`\\in\\{\\pm1\\}`\\) with a cost function that is the sum of weighted variable-products. pubo, qubo The PUBO (\"polynomial unconstrained binary optimization\") and QUBO (\"quadratic ...\") models have binary variables \\(`\\in[0,1]`\\) and a cost function that sums terms of 2 (qubo) or more variables (pubo). blume-capel The Blume-Capel model extends the Ising model to Spin-1 (i.e, 3 states, \\(`[-1,0,1]`\\)). potts-model Each variable in the Potts model can have one of \\(`p`\\) values \\(`[0,1,\\ldots,p-1]`\\) and the cost function compares variables for equality. That is, there is no notion of neighboring values clock-model Each clock variable (or \"rotor\") can have on of \\(`p`\\) discrete values which can be interpreted as a discretized angle (periodic boundaries). The cost function compares how similarly aligned interacting variables are. tsp The travelling salesman problem asks to find the shortest tour visiting all nodes in a graph. poly Cost function constructed from nested polynomial terms with mutable parameters. Experimental State Spaces In addition to the built-in models, components for Partition and Permutation are provided as pre-defined state-spaces."
  },
  "spec/model/ising.html": {
    "href": "spec/model/ising.html",
    "title": "Ising model | qiotoolkit",
    "keywords": "Ising Spin Glass The Ising spin glass Hamiltonian has the form: \\mathcal{H} = \\sum_{ij} c_{ij} s_i s_j\\,, where the sum is over interacting pairs \\(`ij`\\) and the spins take the values \\(`s_i\\in\\{\\pm1\\}`\\). The \\(`c_{ij}`\\)'s are interaction constants which are specified as part of the problem description. Caution This definition differs from the canonical version used in statistical mechanics by a global minus sign! As a result, positive interaction constants \\(`c_{ij}\\gt0`\\) give rise to anti-ferromagnetic interaction. Graph Interpretation We consider each of the spins \\(`s_i`\\) to reside on the node \\(`i`\\) of a weighted graph and the interactions \\(`c_{ij}`\\) to represent edge weights between the respective nodes \\(`i`\\) and \\(`j`\\). For instance, the Hamiltonian \\mathcal{H}(\\vec s) = - (s_0s_1 + s_1s_2 + s_2s_3 - 2s_3s_0) would correspond to the graph \\begin{tikzpicture} \\draw[line width=1pt] (0,3) -- (3,3) -- (3,0) -- (0,0); \\draw[line width=3pt,color=red] (0,0) -- (0,3); \\draw[fill=white] (0,3) circle(0.5); \\draw[fill=white] (3,3) circle(0.5); \\draw[fill=white] (3,0) circle(0.5); \\draw[fill=white] (0,0) circle(0.5); \\node at (0,3) {\\(0\\)}; \\node at (3,3) {\\(1\\)}; \\node at (3,0) {\\(2\\)}; \\node at (0,0) {\\(3\\)}; \\node[color=red] at (0.5,1.5) {\\(-2\\)}; \\node at (1.5,2.5) {\\(+1\\)}; \\node at (2.5,1.5) {\\(+1\\)}; \\node at (1.5,0.5) {\\(+1\\)}; \\end{tikzpicture} Hypergraph Generalization The above interpretation holds for Hamiltonians with terms consisting of exactly two spins. For optimization problems, we are interested in a more general Hamiltonian of the form \\mathcal{H} = -\\sum_e c_e \\prod_{i\\in e} s_i where the sum is over all edges \\(`e`\\) in the list of terms and the product is over the ids \\(`i`\\) participating in this term. In this case, any number of spins can interact in a given term -- akin to a \"hyper edge\" in the graph. Example Input Data A configuration for the general Ising spin glass Hamiltonian must carry the label \"ising\" and corresponding version \"1.0\" specify a non-empty array of terms in the Hamiltonian (or, equally, the hyper edges of the graph): each edge must have a cost c (denoted \\(`c_e`\\) in the Hamiltonian). each edge must have an array ids of the nodes participating in the interaction. the ids in each term must be unique (no repetition within a given term) the ids mentioned in all terms must form a consecutive set [0..N-1]. Example: { \"type\": \"ising\", \"version\": \"1.0\", \"terms\": [ {\"c\": 1.0, \"ids\": [0, 1]}, {\"c\": 1.0, \"ids\": [1, 2]}, {\"c\": 1.0, \"ids\": [2, 3]}, {\"c\": -2.0, \"ids\": [3, 0]} ] } NOTES: The list of ids can be empty, which is interpreted as a constant term in the Hamiltonian. If there is only a single number in ids, this corresponds to a local field. Repetitions are not allowed since any odd number is equivalent to a single occurence (and any even number can be dropped). The number of spins \\(`N`\\) is inferred from the highest number found in ids of any term (which is presumed to represent \\(`N-1`\\))."
  },
  "spec/model/poly.html": {
    "href": "spec/model/poly.html",
    "title": "Polynomial Cost Function | qiotoolkit",
    "keywords": "Polynomial Cost Function (Poly) Example Input Data"
  },
  "spec/model/potts.html": {
    "href": "spec/model/potts.html",
    "title": "Potts Model | qiotoolkit",
    "keywords": "Potts Spin Glass The Potts Hamiltonian has the form \\mathcal{H} = -\\sum_{ij} \\delta_{s_i,s_j}\\,, where the sum is over interacting spin pairs \\(`i`\\), \\(`j`\\) and \\(`\\delta`\\) is the Kronecker delta: \\delta_{a,b} = \\begin{cases} 1 & a=b\\\\ 0 & a\\neq b \\end{cases} Example Input Data { \"type\": \"potts\", \"version\": \"0.1\", \"q\": 5, \"terms\": [ {\"c\": 1.0, \"ids\": [0, 1]}, {\"c\": 1.0, \"ids\": [1, 2]}, {\"c\": 1.0, \"ids\": [2, 3]}, {\"c\": -2.0, \"ids\": [3, 0]} ] }"
  },
  "spec/model/pubo.html": {
    "href": "spec/model/pubo.html",
    "title": "PUBO model | qiotoolkit",
    "keywords": "PUBO The partially unconstrained binary optimization problem consists of variables \\(`s_i`\\) which take the values \\(`\\in\\{0,1\\}`\\): \\mathcal{H} = \\sum_{ij} J_{ij} s_is_j Example Input Data"
  },
  "spec/model/tsp.html": {
    "href": "spec/model/tsp.html",
    "title": "Traveling Salesman Problem | qiotoolkit",
    "keywords": "Travelling Salesman Problem (TSP) \\mathcal{H} = \\sum_{j\\in\\Pi_i} \\text{dist}(j, j+1)\\,, where \\(`\\Pi_i`\\) is a permutation of the numbers \\(`\\{0,\\ldots,N-1\\}`\\) and \\(`\\text{dist}(j, j+1)`\\) is the distance between a consecutive pair of nodes in the parmutation (we equate the nodes 0 and N, i.e., the \"route\" forms a loop). Example InputData { \"type\": \"tsp\", \"version\": \"0.1\", \"q\": 5, \"terms\": [ {\"c\": 1.0, \"ids\": [0, 1]}, {\"c\": 1.0, \"ids\": [1, 2]}, {\"c\": 1.0, \"ids\": [2, 3]}, {\"c\": -2.0, \"ids\": [3, 0]} ] }"
  },
  "spec/schedule/constant.html": {
    "href": "spec/schedule/constant.html",
    "title": "Constant Schedule | qiotoolkit",
    "keywords": "Constant Schedule { \"$id\": \"schedule/constant.schema\", \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Constant Schedule Generator\", \"oneOf\": [ { \"type\": \"number\", \"description\": \"The constant value of this generator\", }, { \"type\": \"object\", \"description\": \"Generator for a sequence of values in the range [initial, final] (inclusive).\", \"required\": [\"type\", \"value\"], \"properties\": { \"type\": { \"type\": \"string\", \"description\": \"Constant generator identifier.\", \"const\": \"constant\" }, \"value\": { \"type\": \"number\", \"description\": \"The constant value of the generator.\" } } } ] }"
  },
  "spec/schedule/geometric.html": {
    "href": "spec/schedule/geometric.html",
    "title": "Constant Schedule | qiotoolkit",
    "keywords": "Constant Schedule { \"$id\": \"schedule/geometric.schema\", \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Geometric Schedule Generator\", \"type\": \"object\", \"description\": \"Generator for a geometric interpolation of values from `initial` to `final` (inclusive).\", \"required\": [\"type\", \"initial\", \"final\"], \"properties\": { \"type\": { \"type\": \"string\", \"description\": \"GeometricGenerator identifier.\", \"const\": \"geometric\" } \"initial\": { \"type\": \"number\", \"description\": \"The initial value in the schedule (e.g., initial annealing temperature).\", \"minimum\": 1e-9 }, \"final\": { \"type\": \"number\", \"description\": \"The final value in the schedule (e.g., final annealing temperature).\", \"minimum\": 1e-9 } } }"
  },
  "spec/schedule/index.html": {
    "href": "spec/schedule/index.html",
    "title": "Schedule Specifications | qiotoolkit",
    "keywords": "Schedule { \"$id\": \"schedule/schedule.schema\", \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Schedule\", \"allOf\": [ \"oneOf\": [ {\"$ref\": \"constant.schema#\"}, {\"$ref\": \"linear.schema#\"}, {\"$ref\": \"geometric.schema#\"}, {\"$ref\": \"segments.schema#\"}, ], \"oneOf\": [ { \"type\": \"number\", \"description\": \"Shorthand notation for a constant generator.\" }, { \"type\": \"array\", \"description\": \"Shorthand notation for a segments generator.\" \"items\": {\"$ref\": \"schedule.schema#\"}, }, { \"type\": \"object\", \"required\": [\"type\"], \"properties\": { \"type\": { \"type\": \"string\", \"description\": \"identifier for the type of schedule generator\", \"enum\": [\"constant\", \"linear\", \"geometric\", \"segments\"] }, \"start\": { \"type\": \"number\", \"description\": \"start of the input value interval\", \"defaut\": 0.0 }, \"stop\": { \"type\": \"number\" \"description\": \"stop of the input value interval\", \"default\": 1.0 }, \"count\": { \"type\": \"integer\", \"description\": \"number of values when discretizing this generator to a set\", \"default\": 1, \"minimum\": 1 }, \"repeat\": { \"type\": \"bool\", \"description\": \"whether to repeat the schedule outside of the input interval.\", \"default\": false } } } ] ] }"
  },
  "spec/schedule/linear.html": {
    "href": "spec/schedule/linear.html",
    "title": "Linear Schedule | qiotoolkit",
    "keywords": "Linear Schedule { \"$id\": \"schedule/linear.schema\", \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Linear Schedule Generator\", \"type\": \"object\", \"description\": \"Generator for a linear interpolation of values from `initial` to `final` (inclusive).\", \"required\": [\"type\", \"initial\", \"final\"], \"properties\": { \"type\": { \"type\": \"string\", \"description\": \"LinearGenerator identifier.\", \"const\": \"linear\" } \"initial\": { \"type\": \"number\", \"description\": \"The initial value in the schedule (e.g., initial annealing temperature).\" }, \"final\": { \"type\": \"number\", \"description\": \"The final value in the schedule (e.g., final annealing temperature).\" } } }"
  },
  "spec/schedule/segments.html": {
    "href": "spec/schedule/segments.html",
    "title": "Segments Schedule | qiotoolkit",
    "keywords": "Segments Schedule { \"$id\": \"schedule/segments.schema\", \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Segments Schedule Generator\", \"oneOf\": [ { \"type\": \"array\", \"description\": \"An array describing the segments.\", \"items\": {\"$ref\": \"schedule.schema#\"} }, { \"type\": \"object\", \"description\": \"Generator consisting of concatenated segments.\", \"required\": [\"type\", \"segments\"], \"properties\": { \"type\": { \"type\": \"string\", \"description\": \"SegmentsGenerator identifier\", \"const\": \"segments\" } \"segments\": { \"type\": \"array\", \"description\": \"An array describing the segments.\", \"items\": {\"$ref\": \"schedule.schema#\"} } } } ] }"
  },
  "spec/solver/index.html": {
    "href": "spec/solver/index.html",
    "title": "Solvers | qiotoolkit",
    "keywords": "Built-in Solvers Solver Description Simulated Annealing Simulates independent replicas with metropolis dynamics while gradually cooling the system. Parallel Tempering A chain of metropolis replicas from a low to high temperature regime with exchange dynamics. Population Annealing A population of metropolis walkers with resampling. Substochastic Monte Carlo A population of random walkers with resampling Multi Objective Replica Exchange (MUREX) A network of metropolis nodes in temperature + parameter space with exchange dynamics"
  },
  "spec/solver/multi-objective-replica-exchange.html": {
    "href": "spec/solver/multi-objective-replica-exchange.html",
    "title": "Multi-Objective Replica Exchange | qiotoolkit",
    "keywords": "Multiobjective Replica Exchange (MUREX) Caution This solver is experimental; it is still subject to development which may alter its API and performance attributes. MUREX simulates replicas at different temperature AND parameter values concurrently. This is currently only supported by the Poly model which has parameters which can be adjusted during the simulation. This is achieved by defining a graph of nodes, each associated with different parameter values and a temperature. Replica exchanges are performed between nearby nodes according to the graph's edges. Note The current implementation has a grid arrangement of nodes hard-coded into the setup routine. This will be adjusted to be more configurable in upcoming versions."
  },
  "spec/solver/parallel-tempering.html": {
    "href": "spec/solver/parallel-tempering.html",
    "title": "Parallel Tempering | qiotoolkit",
    "keywords": "Parallel Tempering qiotoolkit's parallel tempering implementation does not currently adjust the set of temperatures automatically to the model (upcoming feature). As of now, the set of temperatures needs to be specified as an input parameter. For this you can either use an explicit array or a schedule generator. Alternatively, you may specify the set of inverse temperatures via all_betas. Example { \"target\": \"parallel-tempering.qiotoolkit\", \"version\": \"1.0\", \"input_params\": { \"seed\": 42, \"temperatures\": { \"type\": \"geometric\", \"initial_value\": 3.0, \"final_value\": 0.2, \"count\": 32 } }, \"input_data_uri\": \"...\" } This example uses a generator to create a geometric series of temperatures ranging from 3.0 to 0.2 with 32 steps. This means that the simulation will use 32 replicas spaced such that a_i = c*a_{i+1} with a constant c selected to match the initial and final value requested. Parameters Specification List Schema param required/default description seed default: time-based temperatures required How the temperature should be changed over time. all_betas required How the inverse temperature should be changed over time. { \"$id\": \"solver/paralleltempering.qiotoolkit.schema\", \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Parallel Tempering with qiotoolkit\", \"type\": \"object\", \"properties\": { \"target\": { \"type\": \"string\", \"const\": \"paralleltempering.qiotoolkit\" }, \"input_params\": { \"type\": \"object\", \"oneOf\": [ { \"required\": [\"temperatures\"] }, { \"required\": [\"all_betas\"] } ], \"properties\": { \"temperatures\": { \"type\": \"object\", \"$ref\": \"schedule.schema#\", \"description\": \"How the temperature should be changed over time.\" }, \"all_betas\": { \"type\": \"object\", \"$ref\": \"schedule.schema#\", \"description\": \"How the inverse temperature should be changed over time.\" } } } } }"
  },
  "spec/solver/population-annealing.html": {
    "href": "spec/solver/population-annealing.html",
    "title": "Population Annealing | qiotoolkit",
    "keywords": "Population Annealing Simulates a population of metropolis walkers with birth-death process resampling. The qiotoolkit implementation uses variable setpping in temperatures according to one of 4 available resampling strategies: linear_schedule: Change the temperature according to a fixed schedule (non-adaptive). friction_tensor: Estimate the next temperature step such that the friction tensor remains stable with a constant of friction_tensor_constant energy_variance: Adjust culling such that the energy variance remains stable, using initial_culling_constant for the first step. constant_culling: Adjust stepping such that a constant portion culling_fraction of the population is replaced each resampling step. The initial number of replicas can be specified via initial_population_size. The solver will double the population size whenever There is no remaining cost variance (all replicas are in an equal-cost state) The ratio of families remaining in the population drops below alpha (indicating that one family dominates the population). Additionally, you may increase the number of sweeps between resamplings using the sweeps_per_replica parameter. Example { \"target\": \"population-annealing.cpu\", \"version\": \"1.0\", \"input_params\": { \"seed\": 42, \"population\": 100 }, \"input_data_uri\": \"...\" } Parameters Specification List Schema param type required/default description seed integer time-based population integer >1 number of threads population size. constant_population bool false whether to keep the population constant between restarts resampling_strategy string linear_schedule resample by linear_schedule, friction_tensor, energy_variance or constant_culling. beta Schedule linear 0..5 The schedule by which to anneal the system. beta_start float >0 0.0 initial beta for the linear_schedule. beta_stop float >beta_start 5.0 final beta for the linear_schedule. friction_tensor_constant float >0.0 1.0 friction tensor constant (required for friction_tensor initial_culling_fraction float [0,1] 0.5 initial culling rate (for energy_variance) culling_fraction float [0,1] 0.2 constant culling rate (for constant_culling) alpha float >1.0 2.0 ratio to trigger a restart { \"$id\": \"solver/populationannealing.qiotoolkit.schema\", \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"qiotoolkit Population Annealing\", \"type\": \"object\", \"required\": [\"target\", \"input_params\"], \"properties\": { \"target\": { \"type\": \"string\", \"const\": \"populationannealing.qiotoolkit\" }, \"input_params\": { \"type\": \"object\", \"required\": [\"resampling_strategy\"], \"properties\": { \"alpha\": { \"type\": \"number\", \"minimum\": 1.0, \"default\": 2.0, \"description\": \"ratio to trigger a restart\" }, \"population\": { \"type\": \"number\", \"minimum\": 2, \"description\": \"desired population size (defaults to the number of threads)\" }, \"constant_population\": { \"type\": \"boolean\", \"default\": \"false\", \"description\": \"whether to keep the population constant between restarts\" }, \"beta\": { \"type\": \"object\", \"$ref\": \"../schedule/schedule.schema\", \"description\": \"How the temperature should be changed over time.\" }, \"beta_start\": { \"type\": \"number\", \"description\": \"float specifying the starting inverse temperature.\" \"minimum\": 0, }, \"beta_stop\": { \"type\": \"number\", \"description\": \"float specifying the stopping inverse temperature.\" \"minimum\": 0, }, \"resampling_strategy\": { \"type\": \"string\", \"enum\": [\"linear_schedule\", \"friction_tensor\", \"energy_variance\", \"constant_culling\"], \"default\": 'linear_schedule', \"description\": \"resample by 'linear_schedule', 'friction_tensor', 'energy_variance' or 'constant_culling'.\" }, \"friction_tensor_constant\": { \"type\": \"number\", \"minimum\": 0.0, \"default\": 1.0, \"description\": \"friction tensor constant\" }, \"initial_culling_fraction\": { \"type\": \"number\", \"minimum\": 0.0, \"maximum\": 1.0, \"default\": 0.5, \"description\": \"initial culling rate\" }, \"culling_fraction\": { \"type\": \"number\", \"minimum\": 0.0, \"maximum\": 1.0, \"default\": 0.2, \"description\": \"constant culling rate\" }, \"sweeps_per_replica\" { \"type\": \"number\", \"minimum\": 1, \"multipleOf\": 1, \"default\": 1, \"sweeps per replica between resampling.\" } } } } }"
  },
  "spec/solver/simulated-annealing.html": {
    "href": "spec/solver/simulated-annealing.html",
    "title": "Simulated Annealing | qiotoolkit",
    "keywords": "Simulated Annealing Performs metropolis dynamics on the model while gratually lowering (\"annealing\") the simulation temperature. As a result, the system settles in a low-cost state while still being allowed to escape local minima as the simulation progresses. qiotoolkit's simulated annealing implementation allows the specification of an annealing schedule either as an explicit array of values or as a schedule-generator. This (explicit or schedule-generated) list of numbers can be interpreted as inverse temperatures by specifying use_inverse_temperature = true. Multiple restarts can be performed using the restarts parameter. These restarts are mutually independent. Note If you use the QIOtoolkit-comptaible parameters beta_start and beta_stop, the solver will attempt to infer the number of annealing steps from step_limit or its Qiotoolkit-alias sweeps. Example { \"target\": \"simulated-annealing.qiotoolkit\", \"version\": \"1.0\", \"input_params\": { \"seed\": 42, \"schedule\": { \"type\": \"geometric\", \"initial_value\": 3.0, \"final_value\": 0.2, \"count\": 128 } \"restarts\": 8 }, \"input_data_uri\": \"...\" } This will perform 8 restarts of cooling the system from T=3.0 to T=0.2 in 128 steps spaced geometrically. Parameters Specification List Schema param type required/default description seed integer default: time-based schedule Schedule required How the temperature should be changed over time. use_inverse_temperature boolean default: false Whether to interpret schedule as inverse temperature. beta_start float >0 (QIO compatibility) Float specifying the starting inverse temperature. beta_stop float >beta_start (QIO compatibility) Float specifying the stopping inverse temperature. restarts integer > 0 default: 1 How many restarts to perform. { \"$id\": \"solver/simulatedannealing.qiotoolkit.schema\", \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Simulated Annealing on CPU\", \"type\": \"object\", \"required\": [\"target\", \"input_params\"], \"properties\": { \"target\": { \"type\": \"string\", \"const\": \"simulatedannealing.qiotoolkit\" }, \"input_params\": { \"type\": \"object\", \"oneOf\": [ {\"requried\": [\"schedule\"]}, {\"required\": [\"beta_start\", \"beta_stop\"]}, ], \"properties\": { \"schedule\": { \"type\": \"object\", \"$ref\": \"../schedule/schedule.schema\", \"description\": \"How the temperature should be changed over time.\" }, \"use_inverse_temperature\": { \"type\": \"bool\", \"description\": \"Whether to interpret `schedule` as inverse temperature\", \"default\": false }, \"beta_start\": { \"type\": \"number\", \"description\": \"float specifying the starting inverse temperature.\" \"minimum\": 0, }, \"beta_stop\": { \"type\": \"number\", \"description\": \"float specifying the stopping inverse temperature.\" \"minimum\": 0, }, \"restarts\": { \"type\": \"number\", \"description\": \"how many restarts to perform\", \"minimum\": 1, \"multipleOf\": 1, \"default\": 1 } }, } } }"
  },
  "spec/solver/substochastic-monte-carlo.html": {
    "href": "spec/solver/substochastic-monte-carlo.html",
    "title": "Substochastic Monte Carlo | qiotoolkit",
    "keywords": "Substochastic Monte Carlo Simulates a population of random walkers with birth-death resampling. qiotoolkit's implementation allows both the stepping probability alpha and the resampling factor beta to be specified as a schedule (over simulation steps). Additionaly, you may specify the target_population and the number of steps_per_walker as input parametes. Example { \"target\": \"substochastic-monte-carlo.qiotoolkit\", \"version\": \"1.0\", \"input_params\": { \"seed\": 42, \"alpha\": { \"initial_value\": 0.8, \"final_value\": 0.2, \"count\": 1e3 } \"beta\": { \"initial_value\": 0.2, \"final_value\": 0.8, \"count\": 1e3 } \"target_population\": 800 }, \"model\": {...} } This simulates a population of 800 random walkers over the course of 200 steps. It starts out with an emphasis on stepping (alpha=0.8) and gradually changes to a resampling regime. Note Substochastic Monte-Carlo does currently NOT adjust the energy scale of your model. Therefore the magnitude of beta may need to be adjusted for your needs. Parameters Specification List Schema param type required/default description seed integer default: time-based target_population integer required The desired population size (throughout the simulation). alpha Schedule required How the stepping probability alpha should be changed over time. beta Schedule required How the resampling factor beta should be changed over time. steps_per_walker float >0 Number of steps to attempt for each walker. { \"$id\": \"solver/substochasticmontecarlo.qiotoolkit.schema\", \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"qiotoolkit Substochastic Monte Carlo\", \"type\": \"object\", \"required\": [\"target\", \"input_params\"], \"properties\": { \"target\": { \"type\": \"string\", \"const\": \"substochasticmontecarlo.qiotoolkit\" }, \"input_params\": { \"type\": \"object\", \"required\": [\"target_population\", \"alpha\", \"beta\"], \"properties\": { \"target_population\": { \"type\": \"number\", \"minimum\": 0, \"multipleOf\": 1 \"description\": \"The desired population size (throughout the simulation).\" }, \"alpha\": { \"$ref\": \"../schedule/schedule.schema\", \"description\": \"How the stepping probability `alpha` should be changed over time.\" }, \"beta\": { \"$ref\": \"../schedule/schedule.schema\", \"description\": \"How the resampling factor `beta` should be changed over time.\" }, \"steps_per_walker\" { \"type\": \"integer\", \"description\": \"Number of steps to attempt for each walker.\", \"minimum\": 1 } } } } }"
  },
  "theory/graph-cost.html": {
    "href": "theory/graph-cost.html",
    "title": "Graph Correspondency | qiotoolkit",
    "keywords": "Graph Cost Functions For models with a polynomial cost function of the form \\mathcal{H} = \\sum_i c_i \\prod_{j\\in i} s_j such as the Ising or PUBO models, we define the following hyper-graph correspondency: Each variable of the model is associated with a node of the graph. Each term in the cost function gives rise to an interaction between the variables in this term. This is interpreted as a \"hyper-edge\" connecting these nodes. The interaction constant \\(`c_i`\\) is taken to be the weight of this edge. Note For the QUBO model (or an Ising model where no term has more then two variables interacting), this correspondency resolves to a regular graph where nodes are connected in pairs. As such we can describe each cost function of the above form as a hyper-graph. Implementation qiotoolkit provies a model::GraphModel base class which implements the input and access of a graph in the edge-list representation used by the QIO solvers in Qiotoolkit. Namely: \"terms\": [ {\"c\": 2, \"ids\": [0,1,2]}, {\"c\": -3, \"ids\": [3,4,5]} ... ] Where the listed terms describe An edge with weight \\(`+2`\\) connecting spins 0..2, and An edge with weight \\(`-3`\\) connecting spins 3,4,5 This would result in a cost function of the form \\mathcal{H} = +2s_0s_1s_2 -3s_3s_4s_5 + \\cdots The corresponding interfaces to access these nodes() and edges() can be found in the API section."
  },
  "theory/index.html": {
    "href": "theory/index.html",
    "title": "Theory | qiotoolkit",
    "keywords": "Theory The following articles aim to define some of the commonly used termininology: Graphs graph-cost.md correspondency for Ising, PUBO models Markov Dynamics Metropolis Walker Random Walker"
  },
  "theory/metropolis-walker.html": {
    "href": "theory/metropolis-walker.html",
    "title": "Metropolis Walker | qiotoolkit",
    "keywords": "Metropolis Walker The Boltzmann weight describes the likelyhood of finding a physical system in a state \\(`s`\\) at a given temperature \\(`T`\\): p(s) \\propto e^{-E(s)/k_B T} where \\(`E(s)`\\) is the energy of the system in state \\(`s`\\) (in the context of optimization, this is often referred to as the \"cost function\"). The actual value of \\(`p(s)`\\) could be obtained via normalization: p(s) = \\frac{e^{-E(s)/k_BT}}{Z},\\quad Z = \\sum_{s'} e^{-E(s')/k_B T} where the normalizing denominator \\(`Z`\\) is called the \"partition function\" and the sum is over all possible states of the system. For configuration spaces of interesting optimization problems, \\(`Z`\\) is typically intractable (that is, the number of possible configurations is too large to compute it). NOTE: The lower the temperature \\(`T`\\), the highter the weight-discrepancy between \"low energy\" and \"high energy\" states. In the limit \\(`T \\to 0`\\), the weight of all but the lowest energy state vanishes and we find the system in this \"ground state\" with probability \\(`1`\\). Randomized Sampling The metropolis algorithm describes a markov chain approach for randomized sampling of a system's states with their sampling probability converging to the Boltzmann weight. To extend the markov chain, a random next state is proposed and accepted with probability p(s\\to s') = \\begin{cases} e^{-(E(s')-E(s))/k_BT},& \\text{if } E(s') > E(s)\\\\ 1, & \\text{otherwise.} \\end{cases} That is, we always accept a move to a lower-energy state, but only allow increases depending on the energy difference \\(`\\Delta_E`\\) and temperature \\(`T`\\). This sampling approach can be proven to converge to the Boltzmann distribution in the long-term limit. Implementation Metropolis sampling is implemented as a specialization of the Walker base class: :::cpp linenums=False template <class Model> class Metropolis : public Walker<Model> { public: /// Decide whether to accept a given cost increase. bool accept(double cost_diff) override { return cost_diff <= 0 || Walker<Model>::random_number_generator_->uniform() < exp(-cost_diff * beta_); } /// Set the sampling temperature (also updates beta_). void set_temperature(double temperature); }; where the selection of a random next state and conditional application of the proposed transition is implemented in the Walker base class. NOTE: For optimization problems it is customary to set the Boltzmann constant to \\(`k_B\\equiv 1`\\) and work with the inverse temperature \\(`\\beta=1/T`\\). Usage The Metropolis class is used by solvers which rely on Boltzmann sampling, such as ParallelTempering, SimulatedAnnealing and PopulationAnnealing. Instantiation: The class of the model to be sampled is specified as a template argument to the Metropolis class. This defines both the model used for cost function evaluation and the type of state (Model::State_T) in the markov chain. Preparation: Metropolis instance initialization requires the following steps prior to calls to the make_step() method (inherited from Walker): set_model(&your_model) must be called with a pointer to an instance of the model to use (not owned). set_random_number_generator(&your_rng) must be called with a pointer to the random number generator to use (now owned). set_temperature(double) must be called with the desired sampling temperature (the default value is \\(`T=1`\\)). init() must be invoked after the model and rng have been assigned (and before make_step() is called). Both your_model and your_rng are \"not owned\", meaning they must be instantiated by the caller and must outlive the last call to make_step() NOTE: This delegation of ownership for the Model and RandomNumberGenerator allows the caller to manage the number of instances for each (e.g., avoid multiple models; rng's as needed for multi-threading). Introspection: As a Walker, each metropolis instance keeps track of the last state in the markov chain and caches its current energy. In particular, the calls to state() and cost() are \\(`O(1)`\\). Example #!cpp #include \"random/generator.h\" #include \"markov/metropolis.h #include \"solver/test/test_model.h\" int main() { // Prepare objects not owned by metropolis. TestModel model; common::RandomNumberGenerator rng; rng.seed(42); // Initialize the metropolis instance. Metropolis<TestModel> metropolis; metropolis.set_model(&model); metropolis.set_rng(&rng) metropolis.set_temperature(0.1); metropolis.init(); // Attempt 50 metropolis steps for (int i = 0; i < 50; i++) { metropolis.make_step(); std::cout << metropolis.state() << \" \" << metropolis.cost() << std::endl; } return 0; }"
  },
  "theory/random-walker.html": {
    "href": "theory/random-walker.html",
    "title": "Random Walker | qiotoolkit",
    "keywords": "Random Walker"
  },
  "tutorial/dev/configuration.html": {
    "href": "tutorial/dev/configuration.html",
    "title": "Configuration | qiotoolkit",
    "keywords": "Configuration qiotoolkit includes boiler plate to initialize C++ objects from json. For this, the class should be derived from utils::Component and override the virtual void configure(const utils::Json& json) {...} method inherited from the base class. Required Parameters A Parameter can be used to read a variable value from configuration. The chained call to required() signals that an exception should be thrown if the specified field name is not found: #include \"utils/component.h\" class MyModel : public utils::Component { public: void configure(const utils::Json& json) { this->param(json, \"my_param\", my_param_).required(); } private: int my_param_; }; This will read an integer from the JSON field my_param (see sample input below) and store its value in the class field my_param_. It throws a ConfigurationException if the field is not set or cannot be parsed as an integer: { \"my_param\": 42 } Matchers Depending on the meaning of my_param, not all integer values might make sense as input. For this reason, you maybe specify additional requirements to be checked on a ParameterBuilder using matches(): this->param(json, \"my_param\", my_param_) .matches(::matchers::GreaterThan(0)) .required(); This will throw a configuration exception if my_param is not specified, not an integer OR if its value is not greater than 0. Optional Parameters Parameters are implicitly optional (if required() is not specifeid). In this case, you can decide how to handle the absence of the parameter in the input: this->param(json, \"my_param\", my_param_); This does not throw a ConfigurationException if my_param is not set and does not change value of my_param_ (unless my_param_ is of std::optional<T> type, in which case it is reset). Specifying a default value: this->param(json, \"my_param\", my_param_) .default_value(3); assigns a specific default value (3) instead. For optional Parameters, you can also combine a matches() and default_value(): this->param(json, \"my_param\", my_param_) .matches(::matcher::GreaterThan(0)) .default_value(3); which tells the program to read from the configuration if the value is set (and check that it is greater than 0), or assign 3 otherwise. Note The default value is only checked against the matcher if it is chained before. Vector Parameters Configuration works for certain container data types in the same way as it does for primitive types. For instance, you can denote a std::vector<int> as an expected input parameter: #include \"../utils/component.h\" class MyComponent : public utils::Component { public: void configure(const utils::Json& json) { this->param(json, \"numbers\", numbers).required(); } private: std::vector<int> numbers_; }; Expects the input to have an array-type field numbers, the contents of which must all be integers. During configure(...), these numbers are filled into the std::vector: { \"numbers\": [1,2,3] } Complex Parameters Configuration works for any utils::Component (by invoking its configure method). This means that you can use components as parameter types: class MyParamType : public utils::Component { public: void configure(const utils::Json& json) override { this->param(json, \"a\", a_).required(); this->param(json, \"b\", b_).required(); } private: int a_, b_; }; class MyModel : public utils::Component { public: void configure(utils::Config& config) override { this->param(json, \"my_param\", my_param_).required(); } private: MyParamType my_param_; } The json input for MyModel is expected to have a field which contains the input for a MyParamType: { \"my_param\": { \"a\": 13, \"b\": 42 } }"
  },
  "tutorial/dev/dynamics.html": {
    "href": "tutorial/dev/dynamics.html",
    "title": "Model Dynamics | qiotoolkit",
    "keywords": "Model Dynamics"
  },
  "tutorial/dev/index.html": {
    "href": "tutorial/dev/index.html",
    "title": "Development | qiotoolkit",
    "keywords": "Development"
  },
  "tutorial/dev/log.html": {
    "href": "tutorial/dev/log.html",
    "title": "Logging | qiotoolkit",
    "keywords": "Logging The utils/log.h header file provides logging functionality in the form of the LOG() macro: ... LOG(INFO, \"The value of x is \", x) ... You can log any number of elements as an argument to LOG. Each of them must support printing to a stream (operator<<). Note All qiotoolkit classes which are derived from utils::Component have this capability. Levels Level Description DEBUG Surfaced in Debug builds only. INFO Hidden in Release unless -v is specified. WARN Unexpected state with predefined recovery. ERROR Problematic state, continuation possible. FATAL Recovery not possible. Debug builds will surface all log levels, while Release builds only show WARN level or higher (unless verbosity is set with -v). DEBUG logs are never shown in a Release build."
  },
  "tutorial/dev/model.html": {
    "href": "tutorial/dev/model.html",
    "title": "Model Development | qiotoolkit",
    "keywords": "Model Development A new model is created by inheriting from the markov::Model class. This base class defines the virtual pure methods which the new model must implement: method purpose get_identifier() string identifying the model -- this will be the type='...' value in the input. get_version() string identifying the version -- this will be the version='...' value in the input. configure(...) method telling qiotoolkit how to read model configuration from input. calculate_cost(state) Implements the (parametrized) cost function calculate_cost_difference(state, transition) Calculates how much the cost will change if transition is applied. get_random_state(rng) Creates a new random starting state get_random_transition(state, rng) Proposes a random change to the state apply_transition(transition, state) Modifies the state as dictated by the transition These methods entail the essence of the model: They define the state space and how one can move within it, as well as the association of a cost with each sate. The dynamics of whether to accept or reject a transition are left to the user. Self consistency The implementation of calculate_cost_difference() and calculate_cost() must be consistent. That is, \\text{costdiff}(\\text{before}, \\text{transition}) \\equiv \\text{cost}(\\text{transition}(\\text{before})) - \\text{cost}(\\text{before}) You can use the SelfConsistency Build to verify this holds. Note calculate_cost_difference() could be based on a call to calculate_cost() with a modified state, but this is less efficient for models where individual changes affect only a small number of terms. State and Transition In some situations it is sufficient to use a base type to represent the transition (or even the state); in others you need to define your own class to hold this information. You may extend markov::State and markov::Transition, respectively, to get the right interfaces. Whichever route you opt for, you need to template the base class of your new model with this two pieces of information: class MyModel : public ::markov::Model<MyState, MyTransition> { public: using State_T = MyState; using Transition_T = MyTransition; ... }; Note I find it convenient to typedef these two to State_T and Transition_T to homogenize the interfaces which need to be overloaded. Graph Model The special base class ::model::GraphModel makes use of the Graph-Cost correspondency and provides the appropriate interfaces to access the graph structure. If your cost function has the appropriate shape, this can simplify writing the cost function logic substantially. Example The following is an example implementation of the above interfaces for a soft-spin Model. It can be found in the cpp/examples/ directoy of the qiotoolkit codebase. #pragma once #include \"utils/config.h\" #include \"markov/state.h\" #include \"markov/transition.h\" #include \"model/graph_model.h\" namespace examples { class SoftSpinState : public ::markov::State { public: std::vector<double> spin; utils::Structure render() const override { return spin; } utils::Structure get_status() const override { return spin; } std::string get_class_name() const override { return \"SoftSpinState\"; } static size_t memory_estimate(size_t N) { return sizeof(SoftSpinState) + utils::vector_values_memory_estimate<double>(N); } static size_t state_only_memory_estimate(size_t N) { return memory_estimate(N); } }; class SoftSpinTransition : public ::markov::Transition { public: SoftSpinTransition() : spin_id(0), new_value(0) {} int spin_id; double new_value; bool operator<(const SoftSpinTransition& trans) const { if (spin_id == trans.spin_id) { return new_value < trans.new_value; } else { return spin_id < trans.spin_id; } } }; class SoftSpin : public ::model::GraphModel<SoftSpinState, SoftSpinTransition> { public: using State_T = SoftSpinState; using Transition_T = SoftSpinTransition; using Graph = ::model::GraphModel<State_T, Transition_T>; std::string get_identifier() const override { return \"softspin\"; } std::string get_version() const override { return \"0.1\"; } void configure(const utils::Json& json) override { Graph::configure(json); } void configure(Configuration_T& configuration) { Graph::configure(configuration); } double calculate_cost(const State_T& state) const override { double cost = 0; for (auto e : edges()) { double term = e.cost(); for (auto spin_id : e.node_ids()) { term *= state.spin[spin_id]; } cost += term; } return cost; } double calculate_cost_difference( const State_T& state, const Transition_T& transition) const override { double diff = 0; for (auto edge_id : node(transition.spin_id).edge_ids()) { const auto& e = edge(edge_id); double term_before = e.cost(); double term_after = e.cost(); for (auto spin_id : e.node_ids()) { term_before *= state.spin[spin_id]; if (spin_id == transition.spin_id) { term_after *= transition.new_value; } else { term_after *= state.spin[spin_id]; } } diff += term_after - term_before; } return diff; } State_T get_random_state(utils::RandomGenerator& rng) const override { State_T state; state.spin.resize(nodes().size()); for (size_t i = 0; i < nodes().size(); i++) { state.spin[i] = rng.uniform() * 2.0 - 1; } return state; } Transition_T get_random_transition(const State_T&, utils::RandomGenerator& rng) const override { Transition_T transition; transition.spin_id = (size_t)floor(rng.uniform() * static_cast<double>(nodes().size())); transition.new_value = rng.uniform() * 2.0 - 1; return transition; } void apply_transition(const Transition_T& transition, State_T& state) const override { state.spin[transition.spin_id] = transition.new_value; } size_t state_memory_estimate() const override { return State_T::memory_estimate(nodes().size()); } size_t state_only_memory_estimate() const override { return State_T::state_only_memory_estimate(nodes().size()); } }; } // namespace examples template <> struct std::hash<examples::SoftSpinTransition> { std::size_t operator()( const examples::SoftSpinTransition& trans) const noexcept { return utils::get_combined_hash(trans.spin_id, trans.new_value); } };"
  },
  "tutorial/dev/observer.html": {
    "href": "tutorial/dev/observer.html",
    "title": "Observer | qiotoolkit",
    "keywords": "Observer"
  },
  "tutorial/dev/solver.html": {
    "href": "tutorial/dev/solver.html",
    "title": "Solver Development | qiotoolkit",
    "keywords": "Solver Development A new solver is created by extending solver::AbstractSolver or solver::SteppingSolver. The latter has stepping logic already implemented and is currently used for all the built-in solvers. It is customary to template your solver for Model_T -- the class of the model to be simulated. The base class defines which methods must be implemented for the solver to work. For a SteppingSolver, they are: method purpose get_identifier() string identifying the solver -- this will be the target='...' value in the input. configure(...) method telling qiotoolkit how to read model configuration from input. init() called after configure(), allowing you to initialize based on configuration. make_step(step) perform the next step in the simulation. get_model_sweep_size() should return the sweep size of the model being simulated* get_lowest_cost() should return the lowest cost found so far (used for limit_cost condition) get_solutions() should render the best solution(s) found. Implementation The solver should rely on the interfaces provided by a markov::Model to perform its work. They are sufficient to build a markov chain, but might not cater to the need of more sophisticated solvers. For instance, the MUREX solver can currently only simulate the Poly model, because it relies on the additional parameter interfaces it provides. Example The following shows an implementation of a \"steep descent\" algorithm. Its deliberately not called \"steepest\" because the ::markov::Model interfaces do not allow us to enumerate all possible transitions from a given starting point. (And, depending on the model, this might be infeasible). Instead we settle for sampling a number of different candidates and picking the best choice (or none) at each step: #pragma once #include \"utils/random_generator.h\" #include \"solver/stepping_solver.h\" namespace examples { template <class Model_T> class Descent : public ::solver::SteppingSolver<Model_T> { public: using Base_T = ::solver::SteppingSolver<Model_T>; using State_T = typename Model_T::State_T; using Transition_T = typename Model_T::Transition_T; std::string get_identifier() const override { return \"descent.qiotoolkit\"; } void configure(const utils::Json& json) override { Base_T::configure(json); this->param(json[utils::kParams], \"samples\", samples_) .description(\"number of samples to take for the gradient\") .default_value(10) .matches(matcher::GreaterThan(0)) .with_output(); } std::string init_memory_check_error_message() const override { return ( \"Input problem is too large.\" \"Expected to exceed machine's current available memory.\"); } size_t target_number_of_states() const override { return 1; } void init() override { this->init_memory_check(); state_ = this->model_->get_random_state(*this->rng_); cost_ = this->model_->calculate_cost(state_); } void make_step(uint64_t) override { Transition_T transition; double best = 1.0; for (int i = 0; i < samples_; i++) { Transition_T candidate = this->model_->get_random_transition(state_, *this->rng_); double diff = this->model_->calculate_cost_difference(state_, candidate); if (diff < best) { best = diff; transition = candidate; } } if (best <= 0.0) { this->model_->apply_transition(transition, state_); cost_ += best; DEBUG(\"new best: \", cost_, \" \", state_); this->update_lowest_cost(cost_, state_); } } void finalize() override { this->update_lowest_cost(cost_, state_); } protected: int samples_; double cost_; State_T state_; }; } // namespace examples"
  },
  "tutorial/index.html": {
    "href": "tutorial/index.html",
    "title": "Tutorials | qiotoolkit",
    "keywords": "Tutorials Getting Started If this is your first time working with the qiotoolkit , here's a good place to start; build the binary and run your first simulation: Build the QIOToolkit Run your first simulation Usage Once you have a running binary (see previous section), this section explains how to run configure a request to run a specific solver on a particular model: Anatomy of a request Make it stop! Choosing a solver Choosing a model Multithreading Anatomy of a response Benchmarking Development Beyond the built-in functionality, you may also opt to modify a model to use custom simulation dynamics (types of steps), create a new model or even roll your own solver. Besides these tutorials, the API section provides machine-generated interface descriptions. Configuration Logging from qiotoolkit Writing a custom model Adding a solver"
  },
  "tutorial/setup/build.html": {
    "href": "tutorial/setup/build.html",
    "title": "Building the application | qiotoolkit",
    "keywords": "Building the QIOToolkit The QIOToolkit build environment supported is targeted for linux systems. The dockerfile located in the repo is the main build environment which the CI also runs in. If you want to build natively, you can follow the dockerfile for setting up your native environment. We do however recommend to stick with the dockerfile for the build process for building the x86-64 binary application. Running the two commands below should provide you with the build environment: qio-toolkit$ docker build -t qio-toolkit . qio-toolkit$ docker run -it --rm -v $(pwd):/qio-toolkit qio-toolkit Build and Test Once you have the docker environment up and running and have attached the repostiory inside of your docker environment you are ready to build the application and run tests. We have a single entrypoint for operating and building the application which is the root makefile. This file will provide you with all the necessary targets to do development on the QIOToolkit. The following targets are available: build - Builds the application in debug mode build-release - Builds the application in release mode build-coverage - Builds the application in debug mode with coverage test - Runs the unit tests test-coverage - Runs the unit tests with coverage clean - Cleans the build directory build-documentation - Builds the documentation static-code-analysis - Runs the static code analysis Building the application Building the application in debug mode can be done with the following command within your build environment: qio-toolkit$ make build Testing Testing the application can be done with the following command within your build environment: qio-toolkit$ make test Getting test coverage Getting the test coverage can be done with the following command within your build environment: qio-toolkit$ make test-coverage"
  },
  "tutorial/setup/cmake.html": {
    "href": "tutorial/setup/cmake.html",
    "title": "Build with CMake | qiotoolkit",
    "keywords": "Build with CMake qiotoolkit uses cmake as its build system. There are multiple build configurations available to choose from. Debug (default): During development, you may want to rely on a non-optimized build with debug symbols. Release: Uses optimization flags, strips debug symbols and all asserts from the code. SelfConsistency: Within walkers, check each calculate_cost_difference() against a full invocation of calculate_cost() (VERY SLOW). cmake is typically invoked in a new folder, e.g., path/to/qiotoolkit/cpp/YOUR_BUILD. The first time, cmake .. needs to be invoked with the selected build type. thereafter, you can simply make in that folder (even when modifying CMakeLists.txt files). Note The build type is also denoted in the build extensions found in each JSON response generated by the binary. Debug Build (default) $ cd path/to/qiotoolkit/cpp $ mkdir debug_build $ cd debug_build $ cmake .. $ make -j8 Release Build $ cd path/to/qiotoolkit/cpp $ mkdir release_build $ cd release_build $ cmake .. -DCMAKE_BUILD_TYPE=Release $ make -j8 SelfConsistency Build $ cd path/to/qiotoolkit/cpp $ mkdir consistency_build $ cd consistency_build $ cmake .. -DCMAKE_BUILD_TYPE=SelfConsistency $ make -j8 Once built, you can continue to running your first simulation."
  },
  "tutorial/setup/prerequisites.html": {
    "href": "tutorial/setup/prerequisites.html",
    "title": "Prerequisites | qiotoolkit",
    "keywords": "Prerequisites qiotoolkit uses the cmake build system and your compiler of choice (g++ being used in the example below). libomp-dev is required for multi-threading swig and python3-dev are used to generate python bindings (optional) In Linux, you can install these dependencies with sudo apt install cmake g++ libomp-dev swig python3-dev sudo apt-get install -y autoconf automake libtool curl make g++ unzip git clone https://github.com/protocolbuffers/protobuf.git cd protobuf git reset --hard 2514f0bd7da7e2af1bed4c5d1b84f031c4d12c10 cd cmake sudo cmake -Dprotobuf_BUILD_TESTS=OFF -DCMAKE_POSITION_INDEPENDENT_CODE=ON . sudo make sudo make install sudo ldconfig You can find the script in src/Tools of this repo. After installing the prerequisites, you can build qiotoolkit with cmake. Troubleshooting A note about installing the latest cmake The command sudo apt install cmake You may not get the latest version. In such a scenario please follow the steps below. sudo apt-get purge cmake sudo apt-get update sudo apt-get install apt-transport-https ca-certificates gnupg software-properties-common wget wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2>/dev/null | sudo apt-key add - sudo apt-add-repository 'deb https://apt.kitware.com/ubuntu/ bionic main' sudo apt-get update sudo apt-get install cmake You may get an error saying that boost is not available Please try the following steps sudo apt-get install libboost-all-dev"
  },
  "tutorial/setup/run.html": {
    "href": "tutorial/setup/run.html",
    "title": "First Simulation | qiotoolkit",
    "keywords": "First Simulation The first simulation we are going to simulate a simple Ising model. For this we need 2 inputs: The input parameters for the solver we want to run. The description of the Ising cost function (\"input data\"). A set of examples for these can be found in the cpp/examples/ directory: Input Params { \"type\": \"simulated-annealing.qiotoolkit\", \"version\": \"1.0\", \"params\": { \"step_limit\": 100, \"seed\": 42, \"restarts\": 4, \"schedule\": { \"type\": \"linear\", \"initial\": 2.0, \"final\": 1.0, \"count\": 100 } } } Input Data { \"cost_function\": { \"type\": \"ising\", \"version\": \"1.0\", \"terms\": [ {\"c\": 1, \"ids\": [0, 1]}, {\"c\": 1, \"ids\": [1, 2]}, {\"c\": 1, \"ids\": [2, 3]}, {\"c\": 1, \"ids\": [3, 4]}, {\"c\": 1, \"ids\": [4, 5]}, {\"c\": 1, \"ids\": [5, 6]}, {\"c\": 1, \"ids\": [6, 7]}, {\"c\": 1, \"ids\": [7, 8]}, {\"c\": 1, \"ids\": [8, 9]}, {\"c\": 1, \"ids\": [9, 0]} ] } } Running the Solver Additionally, the CLI command must specify the solver to use: $ cd path/to/qiotoolkit/cpp $ mkdir release_build $ cd release_build $ cmake .. -DCMAKE_BUILD_TYPE=Release $ make -j8 $ ./app/qiotoolkit --user --log_level=WARN \\ --solver simulatedannealing.qiotoolkit \\ --parameters ../data/params1.json \\ --input ../data/ising1.json Runtime Output [INFO] app/runner.cc:41: Reading file: ../data/params1.json [INFO] app/qiotoolkit.cc:191: Running solver simulatedannealing.qiotoolkit [DEBUG] solver/simulated_annealing.h:116: recorded cost:10.000000 [DEBUG] solver/simulated_annealing.h:117: calculated_cost:10.000000 [INFO] solver/stepping_solver.h:228: Stop due to step limit: 999, steps:999 [DEBUG] solver/simulated_annealing.h:116: recorded cost:-10.000000 [DEBUG] solver/simulated_annealing.h:117: calculated_cost:-10.000000 [INFO] app/qiotoolkit.cc:201: Writing Response to stdout Results { \"benchmark\": { \"accumulated_dependent_vars\": 0, \"avg_locality\": 1.000000, \"cost_difference_evaluation_count\": 0, \"cost_function_evaluation_count\": 99, \"cpu_time_ms\": 195.635000, \"disk_io_read_bytes\": 0, \"disk_io_write_bytes\": 2746, \"end2end_cputime_ms\": 241.409071, \"end2end_time_ms\": 39.701056, \"extensions\": [ { \"name\": \"counters\", \"value\": {\"accepted_transitions\": 0, \"difference_evaluations\": 0, \"function_evaluations\": 99} }, { \"name\": \"solver\", \"value\": { \"cost_milestones\": [ {\"cost\": 10.000000, \"step\": 1.000000} ], \"exit_reason\": \"Stop due to step limit: 999, steps:999\", \"last_step\": 999, \"step_limit\": 999 } }, { \"name\": \"model\", \"value\": { \"graph\": { \"size\": { \"accumulated_dependent_vars\": 0, \"avg_locality\": 1.000000, \"edges\": 3, \"locality\": 1, \"max_coupling_magnitude\": 4.000000, \"min_coupling_magnitude\": 2.000000, \"min_locality\": 1, \"nodes\": 3, \"sum_coefficient_degrees_total\": 3 } } } }, { \"name\": \"build\", \"value\": { \"branch\": \"\", \"build_type\": \"Debug\", \"commit_hash\": \"cc7d716\", \"compiler\": \"g++ 9.4\", \"qiotoolkit_version\": \"0.0.208\" } }, { \"name\": \"invocation\", \"value\": { \"datetime\": \"2023-05-10 11:44:04\", \"directory\": \"/QIOToolkitV1/cpp\", \"host\": \"\", \"user\": \"\" } } ], \"locality\": 1, \"max_coupling_magnitude\": 4.000000, \"max_mem_bytes\": 10448896, \"min_coupling_magnitude\": 2.000000, \"min_locality\": 1, \"num_terms\": 3, \"num_variables\": 3, \"postprocessing_time_ms\": 6.697893, \"preprocessing_time_ms\": 13.180017, \"solver_time_ms\": 5.856991, \"sum_coefficient_degrees_total\": 3, \"threads\": 20 }, \"solutions\": { \"version\": \"1.0\", \"configuration\": {\"0\": -1, \"2\": -1, \"3\": -1}, \"cost\": -10.000000, \"parameters\": { \"beta_start\": 0.990000, \"beta_stop\": 1.990000, \"restarts\": 99, \"seed\": 111, \"sweeps\": 999 }, \"solutions\": [ { \"configuration\": {\"0\": 1, \"2\": 1, \"3\": 1}, \"cost\": 10.000000, \"stage\": \"init\", \"time_in_stage_ms\": 13.180017 }, { \"configuration\": {\"0\": -1, \"2\": -1, \"3\": -1}, \"cost\": -10.000000, \"stage\": \"simulatedannealing.qiotoolkit\", \"time_in_stage_ms\": 5.856991 } ] } } Arguments --solver or -s (required): The name of the qiotoolkit solver target. --parameters or -p (required): The parameter file containing the input parameters for how the solver should be run. --input or -i (required): The data file containing the input data that specifies the problem. --output or -o (optional): The data file to which the result will be written. If this is not provided, the results will be written to stdout. --user (optional): Render output in human-readable form. -n (optional): No benchmarking output is displayed when this flag is set. -v (optional): Shows the qiotoolkit build version info."
  },
  "tutorial/usage/benchmark.html": {
    "href": "tutorial/usage/benchmark.html",
    "title": "Benchmark | qiotoolkit",
    "keywords": "Benchmark Caution Always ensure you are using a binary built with a Release configuration; there is a substantial difference in performance. If in doubt, you can check the build extension of the response.benchmark. Usage Details on how to run qiotoolkit can be found here. To display the benchmarking logging data, ensure that you run the qiotoolkit executable without the -n flag: $ cd path/to/qiotoolkit/cpp $ mkdir release_build $ cd release_build $ cmake .. -DCMAKE_BUILD_TYPE=Release $ make -j8 $ ./app/qiotoolkit --user --log_level=WARN --solver simulatedannealing.qiotoolkit \\ --parameters ../examples/params-sa.json \\ --input ../examples/ising.json Wall time of a run The wall clock duration of a simulation can be gathered from the benchmark.end2end_time_ms in the qiotoolkit Response. For this to be meaningful, the simulation should be run with a step_limit or (alternatively) eval_limit. When a timeout is set and reached, this will only show how precise qiotoolkit's stop timing was... Note For multi-threaded simulations, you can also compare this value to brenchmark.end2end_cputime_ms to evaluate how efficient the multi-threading was. Ideally the latter should approach threads times the former. Memory Usage Memory usage is returned as part of the response in the field benchmark.max_memory_usage_bytes. Time to Solution By setting a params.cost_limit you can tell qiotoolkit to stop the simulation once the expected lowest energy (or an even lower one...) is found. Use this limiting condition in conjunction with the wall clock duration mentioned above, keeping an eye on the number of benchmark.threads used when comparing results."
  },
  "tutorial/usage/limits.html": {
    "href": "tutorial/usage/limits.html",
    "title": "Limits | qiotoolkit",
    "keywords": "Make it Stop There are several options to define how long your simulation should run. Limit Parameters You should denote at least one of the following stopping conditions. If multiple are given, qiotoolkit will stop when the first one is reached. name description limit_time How many wall-clock seconds the simulation should run. qiotoolkit aims for a 1-s heartbeat (can be changed using tick_every) and will adjust the steps aiming to stop just before the limit_time is reached. This does not consider time spend in multiple vs single threads. step_limit How many steps the solver should take. The final step denoted is inclusive. eval_limit How many times the cost function should be evaluated. qiotoolkit will stop at the end of the step during which the eval_limit is surpassed. This treats full and partial cost function evaluations equivalently. cost_limit Stop when a cost equal or lower to cost_limit is reached. Will stop at the end of the step during which the requested cost is matched. This allows benchmarking time-to-solution. timeout Alias of time_limit for QIO compatibility sweeps Alias of step_limit for QIO compatibility Signals While the process is running, you can send the following signals to the process: signal effect SIG_USR1 show current status on stderr SIG_USR2 stop at the end of the current step SIG_TERM terminate immediately SIG_INT (Ctrl-C) 1st: show status, 2nd: stop after step, 3rd: terminate immediately Note To trigger the 2nd and 3rd option of SIG_INT, signals must be received within 2.0 wall clock seconds from each other (otherwise the counter resets to 0)."
  },
  "tutorial/usage/models.html": {
    "href": "tutorial/usage/models.html",
    "title": "Models | qiotoolkit",
    "keywords": "Built-in Models qiotoolkit has the following built-in models: Model Description ising The Ising model consists of binary variables \\(`\\in\\{\\pm1\\}`\\) with a cost function that is the sum of weighted variable-products. pubo, qubo The PUBO (\"polynomial unconstrained binary optimization\") and QUBO (\"quadratic ...\") models have binary variables \\(`\\in[0,1]`\\) and a cost function that sums terms of 2 (qubo) or more variables (pubo). blume-capel The Blume-Capel model extends the Ising model to Spin-1 (i.e, 3 states, \\(`[-1,0,1]`\\)). potts-model Each variable in the Potts model can have one of \\(`p`\\) values \\(`[0,1,\\ldots,p-1]`\\) and the cost function compares variables for equality. That is, there is no notion of neighboring values clock-model Each clock variable (or \"rotor\") can have on of \\(`p`\\) discrete values which can be interpreted as a discretized angle (periodic boundaries). The cost function compares how similarly aligned interacting variables are. tsp The travelling salesman problem asks to find the shortest tour visiting all nodes in a graph. poly Cost function constructed from nested polynomial terms with mutable parameters. Experimental State Spaces In addition to the built-in models, components for Partition and Permutation are provided as pre-defined state-spaces."
  },
  "tutorial/usage/multithread.html": {
    "href": "tutorial/usage/multithread.html",
    "title": "Multi-threading | qiotoolkit",
    "keywords": "Multi-threading Warning This feature is currently being reworked. Its parameters and functionality are subject to change. By default, solvers will try to use multiple threads to speed up the simulation (using OpenMP). You can override this behavior by setting a maximum number of threads in the input_params: { \"target\": \"paralleltempering.qiotoolkit\", \"input_params\": { \"threads\": 1, ... } } In any case, you can see the number of threads used denoted in the benchmark section of the output: { \"benchmark\": { ... \"threads\": 1, ... }, \"solutions\": [...] } If the \"threads\" is larger than the number of CPU cores on the machine or the value is not positive, the parameter \"threads\" will be ignored."
  },
  "tutorial/usage/request.html": {
    "href": "tutorial/usage/request.html",
    "title": "Anatomy of a Request | qiotoolkit",
    "keywords": "Anatomy of a Request The default qiotoolkit input format is JSON, although it would be possible to handle other formats with different input handlers. A minimal request for qiotoolkit has the following shape: { \"target\": \"SOLVER_IDENTIFIER\", \"input_params\": { ... } } \"cost_function\": { \"type\": \"MODEL_IDENTIFIER\", \"version\": \"MODEL_VERSION\", ... } } Where the SOLVER_IDENTIFIER must exactly match the value returned by AbstractSolver::get_identifier(). Likewise, MODEL_IDENTIFIER and MODEL_VERSION must match those return by markov::Model::get_identifier() and markov::Model::get_version(). Note These identifiers and version numbers not only tell qiotoolkit what to simulate but ensure there is no mismatch in versioning (i.e., you're trying to run old input with a substantially modified newer version of the code or vice-versa. Input Parameters Additional configuration for the solver should be denoted in the input_params section of the request. While some parameters are shared between all solvers (e.g., time_limit), others are specific to the solver. For instance, the Parallel Tempering solver can be configured with: ... \"input_params\": { \"max_steps\": 10, \"seed\": 42, \"temperature_set\": { \"type\": \"geometric\", \"low\": 0.5, \"high\": 3, \"steps\": 32 } }, ... Note For the exact set of parameters understood by a solver, refer to the solver specifications. Input Data The model is configured from additional parameters in the input_data section. These input parameters determine which cost function will be optimized. For instance, the Ising model expects a term entry describing the terms of the polynomial in the Ising cost function: ... \"input_data\": { \"type\": \"ising\", \"version\": \"1.0\", \"terms\": [ {\"c\": -1, \"ids\": [0,1]}, {\"c\": 2, \"ids\": [0,2]}, {\"c\": 1, \"ids\": [1,2]}, ... ] }, ... Which, in this case, describes a cost function of the form \\mathcal{H} = -s_0s_1 + 2s_0s_2 + s_1s_2 + \\cdots Note For the exact set of parameters required by each model, refer to the model specifications."
  },
  "tutorial/usage/response.html": {
    "href": "tutorial/usage/response.html",
    "title": "Anatomy of a Response | qiotoolkit",
    "keywords": "Anatomy of a Response A qiotoolkit response is in JSON format. It contains: The configuration (both explicit and inferred parameters) Telemetry including basic benchmarking attributes and qiotoolkit/solver-specific extensions The best solution(s) found { \"target\": \"parallel-tempering.qiotoolkit\", \"input_params\": {...} \"input_data\": {...} \"benchmark\": { \"execution_time_ms\": 19.98242, ... \"extensions\": [...] }, \"solutions\": [ ] } Configuration Telemetry The benchmark field contains basic benchmarking measures as defined in conjunction with the QIO service solvers. This denotes the resources consumed by the simulation (wall time, threads, memory usage, cost function evaluations). Benchmark Extensions Additionally, qiotoolkit will populate a number of extensions to this shared format to indicate provenance metadata and solver properties. Build information The build information extension ensures data provenance w.r.t. the version of the code which was used to generate a specific response. It contains the build type, branch and git hash of the code that was compiled. \"extensions\": [ ... { \"name\": \"build\", \"value\" { \"build_type\": \"RELEASE\", \"branch\": \"master\", \"hash\": \"a892de1\" } }, ... ] Note Ensure you always manually enable the RELEASE build type when running large scale simulations. There is a notable overhead for running in DEBUG mode (default). Solver properties The AbstractSolver base class inherits from utils::Observer, allowing it to take measurements during the course of the simulation. These measurements are summarized in the solver extension. Solutions Solutions will always be an array containing one or multiple solutions found by the solver. As these are stochastic methods, there is no guarantee that they are optimal."
  },
  "tutorial/usage/solvers.html": {
    "href": "tutorial/usage/solvers.html",
    "title": "Solvers | qiotoolkit",
    "keywords": "Built-in Solvers Solver Description Simulated Annealing Simulates independent replicas with metropolis dynamics while gradually cooling the system. Parallel Tempering A chain of metropolis replicas from a low to high temperature regime with exchange dynamics. Population Annealing A population of metropolis walkers with resampling. Substochastic Monte Carlo A population of random walkers with resampling Multi Objective Replica Exchange (MUREX) A network of metropolis nodes in temperature + parameter space with exchange dynamics"
  }
}